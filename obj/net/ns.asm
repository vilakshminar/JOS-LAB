
obj/net/ns:     file format elf64-x86-64


Disassembly of section .text:

0000000000800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	movabs $USTACKTOP, %rax
  800020:	48 b8 00 e0 7f ef 00 	movabs $0xef7fe000,%rax
  800027:	00 00 00 
	cmpq %rax,%rsp
  80002a:	48 39 c4             	cmp    %rax,%rsp
	jne args_exist
  80002d:	75 04                	jne    800033 <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushq $0
  80002f:	6a 00                	pushq  $0x0
	pushq $0
  800031:	6a 00                	pushq  $0x0

0000000000800033 <args_exist>:

args_exist:
	movq 8(%rsp), %rsi
  800033:	48 8b 74 24 08       	mov    0x8(%rsp),%rsi
	movq (%rsp), %rdi
  800038:	48 8b 3c 24          	mov    (%rsp),%rdi
	call libmain
  80003c:	e8 c3 0f 00 00       	callq  801004 <libmain>
1:	jmp 1b
  800041:	eb fe                	jmp    800041 <args_exist+0xe>
	...

0000000000800044 <next_i>:
static envid_t timer_envid;
static envid_t input_envid;
static envid_t output_envid;

static bool buse[QUEUE_SIZE];
static int next_i(int i) { return (i+1) % QUEUE_SIZE; }
  800044:	55                   	push   %rbp
  800045:	48 89 e5             	mov    %rsp,%rbp
  800048:	48 83 ec 08          	sub    $0x8,%rsp
  80004c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80004f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800052:	8d 48 01             	lea    0x1(%rax),%ecx
  800055:	ba 67 66 66 66       	mov    $0x66666667,%edx
  80005a:	89 c8                	mov    %ecx,%eax
  80005c:	f7 ea                	imul   %edx
  80005e:	c1 fa 03             	sar    $0x3,%edx
  800061:	89 c8                	mov    %ecx,%eax
  800063:	c1 f8 1f             	sar    $0x1f,%eax
  800066:	29 c2                	sub    %eax,%edx
  800068:	89 d0                	mov    %edx,%eax
  80006a:	c1 e0 02             	shl    $0x2,%eax
  80006d:	01 d0                	add    %edx,%eax
  80006f:	c1 e0 02             	shl    $0x2,%eax
  800072:	89 ca                	mov    %ecx,%edx
  800074:	29 c2                	sub    %eax,%edx
  800076:	89 d0                	mov    %edx,%eax
  800078:	c9                   	leaveq 
  800079:	c3                   	retq   

000000000080007a <prev_i>:
static int prev_i(int i) { return (i ? i-1 : QUEUE_SIZE-1); }
  80007a:	55                   	push   %rbp
  80007b:	48 89 e5             	mov    %rsp,%rbp
  80007e:	48 83 ec 08          	sub    $0x8,%rsp
  800082:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800085:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800089:	74 08                	je     800093 <prev_i+0x19>
  80008b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80008e:	83 e8 01             	sub    $0x1,%eax
  800091:	eb 05                	jmp    800098 <prev_i+0x1e>
  800093:	b8 13 00 00 00       	mov    $0x13,%eax
  800098:	c9                   	leaveq 
  800099:	c3                   	retq   

000000000080009a <get_buffer>:

static void *
get_buffer(void) {
  80009a:	55                   	push   %rbp
  80009b:	48 89 e5             	mov    %rsp,%rbp
  80009e:	48 83 ec 10          	sub    $0x10,%rsp
	void *va;

	int64_t i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8000a2:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8000a9:	00 
  8000aa:	eb 20                	jmp    8000cc <get_buffer+0x32>
		if (!buse[i]) break;
  8000ac:	48 ba 80 90 82 00 00 	movabs $0x829080,%rdx
  8000b3:	00 00 00 
  8000b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8000ba:	48 01 d0             	add    %rdx,%rax
  8000bd:	0f b6 00             	movzbl (%rax),%eax
  8000c0:	83 f0 01             	xor    $0x1,%eax
  8000c3:	84 c0                	test   %al,%al
  8000c5:	75 0e                	jne    8000d5 <get_buffer+0x3b>
static void *
get_buffer(void) {
	void *va;

	int64_t i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8000c7:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8000cc:	48 83 7d f8 13       	cmpq   $0x13,-0x8(%rbp)
  8000d1:	7e d9                	jle    8000ac <get_buffer+0x12>
  8000d3:	eb 01                	jmp    8000d6 <get_buffer+0x3c>
		if (!buse[i]) break;
  8000d5:	90                   	nop

	if (i == QUEUE_SIZE) {
  8000d6:	48 83 7d f8 14       	cmpq   $0x14,-0x8(%rbp)
  8000db:	75 2a                	jne    800107 <get_buffer+0x6d>
		panic("NS: buffer overflow");
  8000dd:	48 ba 00 07 82 00 00 	movabs $0x820700,%rdx
  8000e4:	00 00 00 
  8000e7:	be 3f 00 00 00       	mov    $0x3f,%esi
  8000ec:	48 bf 14 07 82 00 00 	movabs $0x820714,%rdi
  8000f3:	00 00 00 
  8000f6:	b8 00 00 00 00       	mov    $0x0,%eax
  8000fb:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  800102:	00 00 00 
  800105:	ff d1                	callq  *%rcx
		return 0;
	}

	va = (void *)(REQVA + i * PGSIZE);
  800107:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80010b:	48 05 eb ff 00 00    	add    $0xffeb,%rax
  800111:	48 c1 e0 0c          	shl    $0xc,%rax
  800115:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	buse[i] = 1;
  800119:	48 ba 80 90 82 00 00 	movabs $0x829080,%rdx
  800120:	00 00 00 
  800123:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800127:	48 01 d0             	add    %rdx,%rax
  80012a:	c6 00 01             	movb   $0x1,(%rax)

	return va;
  80012d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800131:	c9                   	leaveq 
  800132:	c3                   	retq   

0000000000800133 <put_buffer>:

static void
put_buffer(void *va) {
  800133:	55                   	push   %rbp
  800134:	48 89 e5             	mov    %rsp,%rbp
  800137:	48 83 ec 18          	sub    $0x18,%rsp
  80013b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int64_t i = ((uint64_t)va - REQVA) / PGSIZE;
  80013f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800143:	48 2d 00 b0 fe 0f    	sub    $0xffeb000,%rax
  800149:	48 c1 e8 0c          	shr    $0xc,%rax
  80014d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	buse[i] = 0;
  800151:	48 ba 80 90 82 00 00 	movabs $0x829080,%rdx
  800158:	00 00 00 
  80015b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80015f:	48 01 d0             	add    %rdx,%rax
  800162:	c6 00 00             	movb   $0x0,(%rax)
}
  800165:	c9                   	leaveq 
  800166:	c3                   	retq   

0000000000800167 <lwip_init>:

static void
lwip_init(struct netif *nif, void *if_state,
	  uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
  800167:	55                   	push   %rbp
  800168:	48 89 e5             	mov    %rsp,%rbp
  80016b:	53                   	push   %rbx
  80016c:	48 83 ec 68          	sub    $0x68,%rsp
  800170:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800174:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800178:	89 55 ac             	mov    %edx,-0x54(%rbp)
  80017b:	89 4d a8             	mov    %ecx,-0x58(%rbp)
  80017e:	44 89 45 a4          	mov    %r8d,-0x5c(%rbp)
	struct ip_addr ipaddr, netmask, gateway;
	ipaddr.addr  = init_addr;
  800182:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800185:	89 45 e0             	mov    %eax,-0x20(%rbp)
	netmask.addr = init_mask;
  800188:	8b 45 a8             	mov    -0x58(%rbp),%eax
  80018b:	89 45 d0             	mov    %eax,-0x30(%rbp)
	gateway.addr = init_gw;
  80018e:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  800191:	89 45 c0             	mov    %eax,-0x40(%rbp)

	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  800194:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
  800198:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  80019c:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8001a0:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8001a4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8001a8:	48 bb d2 0a 81 00 00 	movabs $0x810ad2,%rbx
  8001af:	00 00 00 
  8001b2:	48 89 1c 24          	mov    %rbx,(%rsp)
  8001b6:	49 b9 30 95 81 00 00 	movabs $0x819530,%r9
  8001bd:	00 00 00 
  8001c0:	49 89 f8             	mov    %rdi,%r8
  8001c3:	48 89 c7             	mov    %rax,%rdi
  8001c6:	48 b8 74 cb 80 00 00 	movabs $0x80cb74,%rax
  8001cd:	00 00 00 
  8001d0:	ff d0                	callq  *%rax
  8001d2:	48 85 c0             	test   %rax,%rax
  8001d5:	75 2a                	jne    800201 <lwip_init+0x9a>
			   if_state,
			   jif_init,
			   ip_input))
		panic("lwip_init: error in netif_add\n");
  8001d7:	48 ba 20 07 82 00 00 	movabs $0x820720,%rdx
  8001de:	00 00 00 
  8001e1:	be 5c 00 00 00       	mov    $0x5c,%esi
  8001e6:	48 bf 14 07 82 00 00 	movabs $0x820714,%rdi
  8001ed:	00 00 00 
  8001f0:	b8 00 00 00 00       	mov    $0x0,%eax
  8001f5:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8001fc:	00 00 00 
  8001ff:	ff d1                	callq  *%rcx

	netif_set_default(nif);
  800201:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800205:	48 89 c7             	mov    %rax,%rdi
  800208:	48 b8 77 cf 80 00 00 	movabs $0x80cf77,%rax
  80020f:	00 00 00 
  800212:	ff d0                	callq  *%rax
	netif_set_up(nif);
  800214:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800218:	48 89 c7             	mov    %rax,%rdi
  80021b:	48 b8 96 cf 80 00 00 	movabs $0x80cf96,%rax
  800222:	00 00 00 
  800225:	ff d0                	callq  *%rax
}
  800227:	48 83 c4 68          	add    $0x68,%rsp
  80022b:	5b                   	pop    %rbx
  80022c:	5d                   	pop    %rbp
  80022d:	c3                   	retq   

000000000080022e <net_timer>:

static void __attribute__((noreturn))
net_timer(uint64_t arg)
{
  80022e:	55                   	push   %rbp
  80022f:	48 89 e5             	mov    %rsp,%rbp
  800232:	48 83 ec 20          	sub    $0x20,%rsp
  800236:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	struct timer_thread *t = (struct timer_thread *) arg;
  80023a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80023e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	for (;;) {
		uint32_t cur = sys_time_msec();
  800242:	48 b8 69 2a 80 00 00 	movabs $0x802a69,%rax
  800249:	00 00 00 
  80024c:	ff d0                	callq  *%rax
  80024e:	89 45 f4             	mov    %eax,-0xc(%rbp)

		lwip_core_lock();
  800251:	48 b8 a4 86 81 00 00 	movabs $0x8186a4,%rax
  800258:	00 00 00 
  80025b:	ff d0                	callq  *%rax
		t->func();
  80025d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800261:	48 8b 40 08          	mov    0x8(%rax),%rax
  800265:	ff d0                	callq  *%rax
		lwip_core_unlock();
  800267:	48 b8 aa 86 81 00 00 	movabs $0x8186aa,%rax
  80026e:	00 00 00 
  800271:	ff d0                	callq  *%rax

		thread_wait(0, 0, cur + t->msec);
  800273:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800277:	8b 00                	mov    (%rax),%eax
  800279:	03 45 f4             	add    -0xc(%rbp),%eax
  80027c:	89 c2                	mov    %eax,%edx
  80027e:	be 00 00 00 00       	mov    $0x0,%esi
  800283:	bf 00 00 00 00       	mov    $0x0,%edi
  800288:	48 b8 1f 88 81 00 00 	movabs $0x81881f,%rax
  80028f:	00 00 00 
  800292:	ff d0                	callq  *%rax
	}
  800294:	eb ac                	jmp    800242 <net_timer+0x14>

0000000000800296 <start_timer>:
}

static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  800296:	55                   	push   %rbp
  800297:	48 89 e5             	mov    %rsp,%rbp
  80029a:	48 83 ec 30          	sub    $0x30,%rsp
  80029e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8002a2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8002a6:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8002aa:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
	t->msec = msec;
  8002ad:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8002b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002b4:	89 10                	mov    %edx,(%rax)
	t->func = func;
  8002b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002ba:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8002be:	48 89 50 08          	mov    %rdx,0x8(%rax)
	t->name = name;
  8002c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8002c6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8002ca:	48 89 50 10          	mov    %rdx,0x10(%rax)
	int r = thread_create(0, name, &net_timer, (uint64_t)t);
  8002ce:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8002d2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8002d6:	48 89 d1             	mov    %rdx,%rcx
  8002d9:	48 ba 2e 02 80 00 00 	movabs $0x80022e,%rdx
  8002e0:	00 00 00 
  8002e3:	48 89 c6             	mov    %rax,%rsi
  8002e6:	bf 00 00 00 00       	mov    $0x0,%edi
  8002eb:	48 b8 97 8a 81 00 00 	movabs $0x818a97,%rax
  8002f2:	00 00 00 
  8002f5:	ff d0                	callq  *%rax
  8002f7:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (r < 0)
  8002fa:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8002fe:	79 3f                	jns    80033f <start_timer+0xa9>
		panic("cannot create timer thread: %s", e2s(r));
  800300:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800303:	89 c7                	mov    %eax,%edi
  800305:	48 b8 27 91 81 00 00 	movabs $0x819127,%rax
  80030c:	00 00 00 
  80030f:	ff d0                	callq  *%rax
  800311:	48 89 c1             	mov    %rax,%rcx
  800314:	48 ba 40 07 82 00 00 	movabs $0x820740,%rdx
  80031b:	00 00 00 
  80031e:	be 7a 00 00 00       	mov    $0x7a,%esi
  800323:	48 bf 14 07 82 00 00 	movabs $0x820714,%rdi
  80032a:	00 00 00 
  80032d:	b8 00 00 00 00       	mov    $0x0,%eax
  800332:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  800339:	00 00 00 
  80033c:	41 ff d0             	callq  *%r8
}
  80033f:	c9                   	leaveq 
  800340:	c3                   	retq   

0000000000800341 <tcpip_init_done>:

static void
tcpip_init_done(void *arg)
{
  800341:	55                   	push   %rbp
  800342:	48 89 e5             	mov    %rsp,%rbp
  800345:	48 83 ec 20          	sub    $0x20,%rsp
  800349:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	uint32_t *done = arg;
  80034d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800351:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	*done = 1;
  800355:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800359:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	thread_wakeup(done);
  80035f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800363:	48 89 c7             	mov    %rax,%rdi
  800366:	48 b8 cc 87 81 00 00 	movabs $0x8187cc,%rax
  80036d:	00 00 00 
  800370:	ff d0                	callq  *%rax
}
  800372:	c9                   	leaveq 
  800373:	c3                   	retq   

0000000000800374 <serve_init>:

void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  800374:	55                   	push   %rbp
  800375:	48 89 e5             	mov    %rsp,%rbp
  800378:	48 83 ec 30          	sub    $0x30,%rsp
  80037c:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80037f:	89 75 e8             	mov    %esi,-0x18(%rbp)
  800382:	89 55 e4             	mov    %edx,-0x1c(%rbp)
	int r;
	lwip_core_lock();
  800385:	48 b8 a4 86 81 00 00 	movabs $0x8186a4,%rax
  80038c:	00 00 00 
  80038f:	ff d0                	callq  *%rax

	uint32_t done = 0;
  800391:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	tcpip_init(&tcpip_init_done, &done);
  800398:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  80039c:	48 89 c6             	mov    %rax,%rsi
  80039f:	48 bf 41 03 80 00 00 	movabs $0x800341,%rdi
  8003a6:	00 00 00 
  8003a9:	48 b8 30 89 80 00 00 	movabs $0x808930,%rax
  8003b0:	00 00 00 
  8003b3:	ff d0                	callq  *%rax
	lwip_core_unlock();
  8003b5:	48 b8 aa 86 81 00 00 	movabs $0x8186aa,%rax
  8003bc:	00 00 00 
  8003bf:	ff d0                	callq  *%rax
	thread_wait(&done, 0, (uint32_t)~0);
  8003c1:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8003c5:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8003ca:	be 00 00 00 00       	mov    $0x0,%esi
  8003cf:	48 89 c7             	mov    %rax,%rdi
  8003d2:	48 b8 1f 88 81 00 00 	movabs $0x81881f,%rax
  8003d9:	00 00 00 
  8003dc:	ff d0                	callq  *%rax
	lwip_core_lock();
  8003de:	48 b8 a4 86 81 00 00 	movabs $0x8186a4,%rax
  8003e5:	00 00 00 
  8003e8:	ff d0                	callq  *%rax

	lwip_init(&nif, &output_envid, ipaddr, netmask, gw);
  8003ea:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8003ed:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8003f0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8003f3:	41 89 c8             	mov    %ecx,%r8d
  8003f6:	89 d1                	mov    %edx,%ecx
  8003f8:	89 c2                	mov    %eax,%edx
  8003fa:	48 be 70 90 82 00 00 	movabs $0x829070,%rsi
  800401:	00 00 00 
  800404:	48 bf c0 75 b5 00 00 	movabs $0xb575c0,%rdi
  80040b:	00 00 00 
  80040e:	48 b8 67 01 80 00 00 	movabs $0x800167,%rax
  800415:	00 00 00 
  800418:	ff d0                	callq  *%rax

	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  80041a:	b9 88 13 00 00       	mov    $0x1388,%ecx
  80041f:	48 ba 5f 07 82 00 00 	movabs $0x82075f,%rdx
  800426:	00 00 00 
  800429:	48 be 32 57 81 00 00 	movabs $0x815732,%rsi
  800430:	00 00 00 
  800433:	48 bf 10 90 82 00 00 	movabs $0x829010,%rdi
  80043a:	00 00 00 
  80043d:	48 b8 96 02 80 00 00 	movabs $0x800296,%rax
  800444:	00 00 00 
  800447:	ff d0                	callq  *%rax
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  800449:	b9 fa 00 00 00       	mov    $0xfa,%ecx
  80044e:	48 ba 69 07 82 00 00 	movabs $0x820769,%rdx
  800455:	00 00 00 
  800458:	48 be 4e ff 80 00 00 	movabs $0x80ff4e,%rsi
  80045f:	00 00 00 
  800462:	48 bf 30 90 82 00 00 	movabs $0x829030,%rdi
  800469:	00 00 00 
  80046c:	48 b8 96 02 80 00 00 	movabs $0x800296,%rax
  800473:	00 00 00 
  800476:	ff d0                	callq  *%rax
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800478:	b9 f4 01 00 00       	mov    $0x1f4,%ecx
  80047d:	48 ba 75 07 82 00 00 	movabs $0x820775,%rdx
  800484:	00 00 00 
  800487:	48 be ee f6 80 00 00 	movabs $0x80f6ee,%rsi
  80048e:	00 00 00 
  800491:	48 bf 50 90 82 00 00 	movabs $0x829050,%rdi
  800498:	00 00 00 
  80049b:	48 b8 96 02 80 00 00 	movabs $0x800296,%rax
  8004a2:	00 00 00 
  8004a5:	ff d0                	callq  *%rax

	struct in_addr ia = {ipaddr};
  8004a7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004aa:	89 45 f0             	mov    %eax,-0x10(%rbp)
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004ad:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004b0:	89 c7                	mov    %eax,%edi
  8004b2:	48 b8 61 2b 81 00 00 	movabs $0x812b61,%rax
  8004b9:	00 00 00 
  8004bc:	ff d0                	callq  *%rax
		" bound to static IP %s\n",
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
		nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004be:	48 ba c0 75 b5 00 00 	movabs $0xb575c0,%rdx
  8004c5:	00 00 00 
  8004c8:	0f b6 52 46          	movzbl 0x46(%rdx),%edx
	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004cc:	0f b6 fa             	movzbl %dl,%edi
		" bound to static IP %s\n",
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
		nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004cf:	48 ba c0 75 b5 00 00 	movabs $0xb575c0,%rdx
  8004d6:	00 00 00 
  8004d9:	0f b6 52 45          	movzbl 0x45(%rdx),%edx
	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004dd:	44 0f b6 ca          	movzbl %dl,%r9d
		" bound to static IP %s\n",
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
		nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
  8004e1:	48 ba c0 75 b5 00 00 	movabs $0xb575c0,%rdx
  8004e8:	00 00 00 
  8004eb:	0f b6 52 44          	movzbl 0x44(%rdx),%edx
	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8004ef:	44 0f b6 c2          	movzbl %dl,%r8d
		" bound to static IP %s\n",
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  8004f3:	48 ba c0 75 b5 00 00 	movabs $0xb575c0,%rdx
  8004fa:	00 00 00 
  8004fd:	0f b6 52 43          	movzbl 0x43(%rdx),%edx
	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800501:	0f b6 ca             	movzbl %dl,%ecx
		" bound to static IP %s\n",
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  800504:	48 ba c0 75 b5 00 00 	movabs $0xb575c0,%rdx
  80050b:	00 00 00 
  80050e:	0f b6 52 42          	movzbl 0x42(%rdx),%edx
	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800512:	0f b6 d2             	movzbl %dl,%edx
		" bound to static IP %s\n",
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
  800515:	48 be c0 75 b5 00 00 	movabs $0xb575c0,%rsi
  80051c:	00 00 00 
  80051f:	0f b6 76 41          	movzbl 0x41(%rsi),%esi
	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);

	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  800523:	40 0f b6 f6          	movzbl %sil,%esi
  800527:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  80052c:	89 3c 24             	mov    %edi,(%rsp)
  80052f:	48 bf 88 07 82 00 00 	movabs $0x820788,%rdi
  800536:	00 00 00 
  800539:	b8 00 00 00 00       	mov    $0x0,%eax
  80053e:	49 ba 07 13 80 00 00 	movabs $0x801307,%r10
  800545:	00 00 00 
  800548:	41 ff d2             	callq  *%r10
		" bound to static IP %s\n",
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
		nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
		inet_ntoa(ia));

	lwip_core_unlock();
  80054b:	48 b8 aa 86 81 00 00 	movabs $0x8186aa,%rax
  800552:	00 00 00 
  800555:	ff d0                	callq  *%rax

	cprintf("NS: TCP/IP initialized.\n");
  800557:	48 bf c1 07 82 00 00 	movabs $0x8207c1,%rdi
  80055e:	00 00 00 
  800561:	b8 00 00 00 00       	mov    $0x0,%eax
  800566:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  80056d:	00 00 00 
  800570:	ff d2                	callq  *%rdx
}
  800572:	c9                   	leaveq 
  800573:	c3                   	retq   

0000000000800574 <process_timer>:

static void
process_timer(envid_t envid) {
  800574:	55                   	push   %rbp
  800575:	48 89 e5             	mov    %rsp,%rbp
  800578:	48 83 ec 20          	sub    $0x20,%rsp
  80057c:	89 7d ec             	mov    %edi,-0x14(%rbp)
	uint32_t start, now, to;

	if (envid != timer_envid) {
  80057f:	48 b8 68 90 82 00 00 	movabs $0x829068,%rax
  800586:	00 00 00 
  800589:	8b 00                	mov    (%rax),%eax
  80058b:	39 45 ec             	cmp    %eax,-0x14(%rbp)
  80058e:	74 22                	je     8005b2 <process_timer+0x3e>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  800590:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800593:	89 c6                	mov    %eax,%esi
  800595:	48 bf e0 07 82 00 00 	movabs $0x8207e0,%rdi
  80059c:	00 00 00 
  80059f:	b8 00 00 00 00       	mov    $0x0,%eax
  8005a4:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  8005ab:	00 00 00 
  8005ae:	ff d2                	callq  *%rdx
		return;
  8005b0:	eb 5c                	jmp    80060e <process_timer+0x9a>
	}

	start = sys_time_msec();
  8005b2:	48 b8 69 2a 80 00 00 	movabs $0x802a69,%rax
  8005b9:	00 00 00 
  8005bc:	ff d0                	callq  *%rax
  8005be:	89 45 fc             	mov    %eax,-0x4(%rbp)
	thread_yield();
  8005c1:	48 b8 18 8d 81 00 00 	movabs $0x818d18,%rax
  8005c8:	00 00 00 
  8005cb:	ff d0                	callq  *%rax
	now = sys_time_msec();
  8005cd:	48 b8 69 2a 80 00 00 	movabs $0x802a69,%rax
  8005d4:	00 00 00 
  8005d7:	ff d0                	callq  *%rax
  8005d9:	89 45 f8             	mov    %eax,-0x8(%rbp)

	to = TIMER_INTERVAL - (now - start);
  8005dc:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8005df:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8005e2:	89 d1                	mov    %edx,%ecx
  8005e4:	29 c1                	sub    %eax,%ecx
  8005e6:	89 c8                	mov    %ecx,%eax
  8005e8:	05 fa 00 00 00       	add    $0xfa,%eax
  8005ed:	89 45 f4             	mov    %eax,-0xc(%rbp)
	ipc_send(envid, to, 0, 0);
  8005f0:	8b 75 f4             	mov    -0xc(%rbp),%esi
  8005f3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8005f6:	b9 00 00 00 00       	mov    $0x0,%ecx
  8005fb:	ba 00 00 00 00       	mov    $0x0,%edx
  800600:	89 c7                	mov    %eax,%edi
  800602:	48 b8 c0 32 80 00 00 	movabs $0x8032c0,%rax
  800609:	00 00 00 
  80060c:	ff d0                	callq  *%rax
}
  80060e:	c9                   	leaveq 
  80060f:	c3                   	retq   

0000000000800610 <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint64_t a) {
  800610:	55                   	push   %rbp
  800611:	48 89 e5             	mov    %rsp,%rbp
  800614:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  80061b:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
	struct st_args *args = (struct st_args *)a;
  800622:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800629:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	union Nsipc *req = args->req;
  80062d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800631:	48 8b 40 08          	mov    0x8(%rax),%rax
  800635:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	int r;

	switch (args->reqno) {
  800639:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80063d:	8b 00                	mov    (%rax),%eax
  80063f:	83 f8 0a             	cmp    $0xa,%eax
  800642:	0f 87 d7 01 00 00    	ja     80081f <serve_thread+0x20f>
  800648:	89 c0                	mov    %eax,%eax
  80064a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800651:	00 
  800652:	48 b8 58 08 82 00 00 	movabs $0x820858,%rax
  800659:	00 00 00 
  80065c:	48 01 d0             	add    %rdx,%rax
  80065f:	48 8b 00             	mov    (%rax),%rax
  800662:	ff e0                	jmpq   *%rax
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  800664:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800668:	8b 00                	mov    (%rax),%eax
  80066a:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80066e:	48 83 c2 10          	add    $0x10,%rdx
  800672:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800676:	48 89 ce             	mov    %rcx,%rsi
  800679:	89 c7                	mov    %eax,%edi
  80067b:	48 b8 39 5b 80 00 00 	movabs $0x805b39,%rax
  800682:	00 00 00 
  800685:	ff d0                	callq  *%rax
  800687:	89 45 fc             	mov    %eax,-0x4(%rbp)
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  80068a:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80068e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800692:	ba 14 00 00 00       	mov    $0x14,%edx
  800697:	48 89 ce             	mov    %rcx,%rsi
  80069a:	48 89 c7             	mov    %rax,%rdi
  80069d:	48 b8 e6 21 80 00 00 	movabs $0x8021e6,%rax
  8006a4:	00 00 00 
  8006a7:	ff d0                	callq  *%rax
		break;
  8006a9:	e9 a5 01 00 00       	jmpq   800853 <serve_thread+0x243>
	}
	case NSREQ_BIND:
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
			      req->bind.req_namelen);
  8006ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
		break;
	}
	case NSREQ_BIND:
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  8006b2:	8b 50 14             	mov    0x14(%rax),%edx
  8006b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006b9:	48 8d 48 04          	lea    0x4(%rax),%rcx
  8006bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006c1:	8b 00                	mov    (%rax),%eax
  8006c3:	48 89 ce             	mov    %rcx,%rsi
  8006c6:	89 c7                	mov    %eax,%edi
  8006c8:	48 b8 63 5e 80 00 00 	movabs $0x805e63,%rax
  8006cf:	00 00 00 
  8006d2:	ff d0                	callq  *%rax
  8006d4:	89 45 fc             	mov    %eax,-0x4(%rbp)
			      req->bind.req_namelen);
		break;
  8006d7:	e9 77 01 00 00       	jmpq   800853 <serve_thread+0x243>
	case NSREQ_SHUTDOWN:
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  8006dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006e0:	8b 50 04             	mov    0x4(%rax),%edx
  8006e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8006e7:	8b 00                	mov    (%rax),%eax
  8006e9:	89 d6                	mov    %edx,%esi
  8006eb:	89 c7                	mov    %eax,%edi
  8006ed:	48 b8 e6 75 80 00 00 	movabs $0x8075e6,%rax
  8006f4:	00 00 00 
  8006f7:	ff d0                	callq  *%rax
  8006f9:	89 45 fc             	mov    %eax,-0x4(%rbp)
		break;
  8006fc:	e9 52 01 00 00       	jmpq   800853 <serve_thread+0x243>
	case NSREQ_CLOSE:
		r = lwip_close(req->close.req_s);
  800701:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800705:	8b 00                	mov    (%rax),%eax
  800707:	89 c7                	mov    %eax,%edi
  800709:	48 b8 98 5f 80 00 00 	movabs $0x805f98,%rax
  800710:	00 00 00 
  800713:	ff d0                	callq  *%rax
  800715:	89 45 fc             	mov    %eax,-0x4(%rbp)
		break;
  800718:	e9 36 01 00 00       	jmpq   800853 <serve_thread+0x243>
	case NSREQ_CONNECT:
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
				 req->connect.req_namelen);
  80071d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
		break;
	case NSREQ_CLOSE:
		r = lwip_close(req->close.req_s);
		break;
	case NSREQ_CONNECT:
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  800721:	8b 50 14             	mov    0x14(%rax),%edx
  800724:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800728:	48 8d 48 04          	lea    0x4(%rax),%rcx
  80072c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800730:	8b 00                	mov    (%rax),%eax
  800732:	48 89 ce             	mov    %rcx,%rsi
  800735:	89 c7                	mov    %eax,%edi
  800737:	48 b8 7d 60 80 00 00 	movabs $0x80607d,%rax
  80073e:	00 00 00 
  800741:	ff d0                	callq  *%rax
  800743:	89 45 fc             	mov    %eax,-0x4(%rbp)
				 req->connect.req_namelen);
		break;
  800746:	e9 08 01 00 00       	jmpq   800853 <serve_thread+0x243>
	case NSREQ_LISTEN:
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  80074b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80074f:	8b 50 04             	mov    0x4(%rax),%edx
  800752:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800756:	8b 00                	mov    (%rax),%eax
  800758:	89 d6                	mov    %edx,%esi
  80075a:	89 c7                	mov    %eax,%edi
  80075c:	48 b8 d9 61 80 00 00 	movabs $0x8061d9,%rax
  800763:	00 00 00 
  800766:	ff d0                	callq  *%rax
  800768:	89 45 fc             	mov    %eax,-0x4(%rbp)
		break;
  80076b:	e9 e3 00 00 00       	jmpq   800853 <serve_thread+0x243>
	case NSREQ_RECV:
		// Note that we read the request fields before we
		// overwrite it with the response data.
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
			      req->recv.req_len, req->recv.req_flags);
  800770:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
		break;
	case NSREQ_RECV:
		// Note that we read the request fields before we
		// overwrite it with the response data.
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  800774:	8b 48 08             	mov    0x8(%rax),%ecx
			      req->recv.req_len, req->recv.req_flags);
  800777:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
		break;
	case NSREQ_RECV:
		// Note that we read the request fields before we
		// overwrite it with the response data.
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  80077b:	8b 50 04             	mov    0x4(%rax),%edx
  80077e:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800782:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800786:	8b 00                	mov    (%rax),%eax
  800788:	89 c7                	mov    %eax,%edi
  80078a:	48 b8 da 66 80 00 00 	movabs $0x8066da,%rax
  800791:	00 00 00 
  800794:	ff d0                	callq  *%rax
  800796:	89 45 fc             	mov    %eax,-0x4(%rbp)
			      req->recv.req_len, req->recv.req_flags);
		break;
  800799:	e9 b5 00 00 00       	jmpq   800853 <serve_thread+0x243>
	case NSREQ_SEND:
		r = lwip_send(req->send.req_s, &req->send.req_buf,
			      req->send.req_size, req->send.req_flags);
  80079e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
		// overwrite it with the response data.
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
			      req->recv.req_len, req->recv.req_flags);
		break;
	case NSREQ_SEND:
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8007a2:	8b 48 08             	mov    0x8(%rax),%ecx
			      req->send.req_size, req->send.req_flags);
  8007a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
		// overwrite it with the response data.
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
			      req->recv.req_len, req->recv.req_flags);
		break;
	case NSREQ_SEND:
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8007a9:	8b 50 04             	mov    0x4(%rax),%edx
  8007ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007b0:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  8007b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007b8:	8b 00                	mov    (%rax),%eax
  8007ba:	89 c7                	mov    %eax,%edi
  8007bc:	48 b8 18 67 80 00 00 	movabs $0x806718,%rax
  8007c3:	00 00 00 
  8007c6:	ff d0                	callq  *%rax
  8007c8:	89 45 fc             	mov    %eax,-0x4(%rbp)
			      req->send.req_size, req->send.req_flags);
		break;
  8007cb:	e9 83 00 00 00       	jmpq   800853 <serve_thread+0x243>
	case NSREQ_SOCKET:
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
				req->socket.req_protocol);
  8007d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
	case NSREQ_SEND:
		r = lwip_send(req->send.req_s, &req->send.req_buf,
			      req->send.req_size, req->send.req_flags);
		break;
	case NSREQ_SOCKET:
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  8007d4:	8b 50 08             	mov    0x8(%rax),%edx
  8007d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007db:	8b 48 04             	mov    0x4(%rax),%ecx
  8007de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007e2:	8b 00                	mov    (%rax),%eax
  8007e4:	89 ce                	mov    %ecx,%esi
  8007e6:	89 c7                	mov    %eax,%edi
  8007e8:	48 b8 35 6a 80 00 00 	movabs $0x806a35,%rax
  8007ef:	00 00 00 
  8007f2:	ff d0                	callq  *%rax
  8007f4:	89 45 fc             	mov    %eax,-0x4(%rbp)
				req->socket.req_protocol);
		break;
  8007f7:	eb 5a                	jmp    800853 <serve_thread+0x243>
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
  8007f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8007fd:	48 89 c6             	mov    %rax,%rsi
  800800:	48 bf c0 75 b5 00 00 	movabs $0xb575c0,%rdi
  800807:	00 00 00 
  80080a:	48 b8 33 94 81 00 00 	movabs $0x819433,%rax
  800811:	00 00 00 
  800814:	ff d0                	callq  *%rax
		r = 0;
  800816:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
		break;
  80081d:	eb 34                	jmp    800853 <serve_thread+0x243>
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  80081f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800823:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800827:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80082b:	8b 40 04             	mov    0x4(%rax),%eax
  80082e:	89 c6                	mov    %eax,%esi
  800830:	48 bf 20 08 82 00 00 	movabs $0x820820,%rdi
  800837:	00 00 00 
  80083a:	b8 00 00 00 00       	mov    $0x0,%eax
  80083f:	48 b9 07 13 80 00 00 	movabs $0x801307,%rcx
  800846:	00 00 00 
  800849:	ff d1                	callq  *%rcx
		r = -E_INVAL;
  80084b:	c7 45 fc fd ff ff ff 	movl   $0xfffffffd,-0x4(%rbp)
		break;
  800852:	90                   	nop
	}

	if (r == -1) {
  800853:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  800857:	75 49                	jne    8008a2 <serve_thread+0x292>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  800859:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80085d:	8b 10                	mov    (%rax),%edx
  80085f:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
  800866:	89 d1                	mov    %edx,%ecx
  800868:	48 ba 43 08 82 00 00 	movabs $0x820843,%rdx
  80086f:	00 00 00 
  800872:	be 64 00 00 00       	mov    $0x64,%esi
  800877:	48 89 c7             	mov    %rax,%rdi
  80087a:	b8 00 00 00 00       	mov    $0x0,%eax
  80087f:	49 b8 76 1d 80 00 00 	movabs $0x801d76,%r8
  800886:	00 00 00 
  800889:	41 ff d0             	callq  *%r8
		perror(buf);
  80088c:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
  800893:	48 89 c7             	mov    %rax,%rdi
  800896:	48 b8 d4 90 81 00 00 	movabs $0x8190d4,%rax
  80089d:	00 00 00 
  8008a0:	ff d0                	callq  *%rax
	}

	if (args->reqno != NSREQ_INPUT)
  8008a2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008a6:	8b 00                	mov    (%rax),%eax
  8008a8:	83 f8 0a             	cmp    $0xa,%eax
  8008ab:	74 22                	je     8008cf <serve_thread+0x2bf>
		ipc_send(args->whom, r, 0, 0);
  8008ad:	8b 75 fc             	mov    -0x4(%rbp),%esi
  8008b0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008b4:	8b 40 04             	mov    0x4(%rax),%eax
  8008b7:	b9 00 00 00 00       	mov    $0x0,%ecx
  8008bc:	ba 00 00 00 00       	mov    $0x0,%edx
  8008c1:	89 c7                	mov    %eax,%edi
  8008c3:	48 b8 c0 32 80 00 00 	movabs $0x8032c0,%rax
  8008ca:	00 00 00 
  8008cd:	ff d0                	callq  *%rax

	put_buffer(args->req);
  8008cf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008d3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8008d7:	48 89 c7             	mov    %rax,%rdi
  8008da:	48 b8 33 01 80 00 00 	movabs $0x800133,%rax
  8008e1:	00 00 00 
  8008e4:	ff d0                	callq  *%rax
	sys_page_unmap(0, (void*) args->req);
  8008e6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8008ea:	48 8b 40 08          	mov    0x8(%rax),%rax
  8008ee:	48 89 c6             	mov    %rax,%rsi
  8008f1:	bf 00 00 00 00       	mov    $0x0,%edi
  8008f6:	48 b8 a7 28 80 00 00 	movabs $0x8028a7,%rax
  8008fd:	00 00 00 
  800900:	ff d0                	callq  *%rax
	free(args);
  800902:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800906:	48 89 c7             	mov    %rax,%rdi
  800909:	48 b8 35 4d 80 00 00 	movabs $0x804d35,%rax
  800910:	00 00 00 
  800913:	ff d0                	callq  *%rax
}
  800915:	c9                   	leaveq 
  800916:	c3                   	retq   

0000000000800917 <serve>:

void
serve(void) {
  800917:	55                   	push   %rbp
  800918:	48 89 e5             	mov    %rsp,%rbp
  80091b:	48 83 ec 30          	sub    $0x30,%rsp

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  80091f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800926:	eb 10                	jmp    800938 <serve+0x21>
			thread_yield();
  800928:	48 b8 18 8d 81 00 00 	movabs $0x818d18,%rax
  80092f:	00 00 00 
  800932:	ff d0                	callq  *%rax

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800934:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800938:	48 b8 00 89 81 00 00 	movabs $0x818900,%rax
  80093f:	00 00 00 
  800942:	ff d0                	callq  *%rax
  800944:	85 c0                	test   %eax,%eax
  800946:	74 06                	je     80094e <serve+0x37>
  800948:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  80094c:	7e da                	jle    800928 <serve+0x11>
			thread_yield();

		perm = 0;
  80094e:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
		va = get_buffer();
  800955:	48 b8 9a 00 80 00 00 	movabs $0x80009a,%rax
  80095c:	00 00 00 
  80095f:	ff d0                	callq  *%rax
  800961:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  800965:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  800969:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  80096d:	48 8d 45 dc          	lea    -0x24(%rbp),%rax
  800971:	48 89 ce             	mov    %rcx,%rsi
  800974:	48 89 c7             	mov    %rax,%rdi
  800977:	48 b8 00 32 80 00 00 	movabs $0x803200,%rax
  80097e:	00 00 00 
  800981:	ff d0                	callq  *%rax
  800983:	89 45 ec             	mov    %eax,-0x14(%rbp)
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  800986:	83 7d ec 0c          	cmpl   $0xc,-0x14(%rbp)
  80098a:	75 29                	jne    8009b5 <serve+0x9e>
			process_timer(whom);
  80098c:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80098f:	89 c7                	mov    %eax,%edi
  800991:	48 b8 74 05 80 00 00 	movabs $0x800574,%rax
  800998:	00 00 00 
  80099b:	ff d0                	callq  *%rax
			put_buffer(va);
  80099d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8009a1:	48 89 c7             	mov    %rax,%rdi
  8009a4:	48 b8 33 01 80 00 00 	movabs $0x800133,%rax
  8009ab:	00 00 00 
  8009ae:	ff d0                	callq  *%rax
			continue;
  8009b0:	e9 d1 00 00 00       	jmpq   800a86 <serve+0x16f>
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  8009b5:	8b 45 d8             	mov    -0x28(%rbp),%eax
  8009b8:	83 e0 01             	and    $0x1,%eax
  8009bb:	85 c0                	test   %eax,%eax
  8009bd:	75 25                	jne    8009e4 <serve+0xcd>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  8009bf:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8009c2:	89 c6                	mov    %eax,%esi
  8009c4:	48 bf b0 08 82 00 00 	movabs $0x8208b0,%rdi
  8009cb:	00 00 00 
  8009ce:	b8 00 00 00 00       	mov    $0x0,%eax
  8009d3:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  8009da:	00 00 00 
  8009dd:	ff d2                	callq  *%rdx
			continue; // just leave it hanging...
  8009df:	e9 a2 00 00 00       	jmpq   800a86 <serve+0x16f>
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  8009e4:	bf 10 00 00 00       	mov    $0x10,%edi
  8009e9:	48 b8 b5 49 80 00 00 	movabs $0x8049b5,%rax
  8009f0:	00 00 00 
  8009f3:	ff d0                	callq  *%rax
  8009f5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		if (!args)
  8009f9:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8009fe:	75 2a                	jne    800a2a <serve+0x113>
			panic("could not allocate thread args structure");
  800a00:	48 ba e0 08 82 00 00 	movabs $0x8208e0,%rdx
  800a07:	00 00 00 
  800a0a:	be 26 01 00 00       	mov    $0x126,%esi
  800a0f:	48 bf 14 07 82 00 00 	movabs $0x820714,%rdi
  800a16:	00 00 00 
  800a19:	b8 00 00 00 00       	mov    $0x0,%eax
  800a1e:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  800a25:	00 00 00 
  800a28:	ff d1                	callq  *%rcx

		args->reqno = reqno;
  800a2a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a2e:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800a31:	89 10                	mov    %edx,(%rax)
		args->whom = whom;
  800a33:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800a36:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a3a:	89 50 04             	mov    %edx,0x4(%rax)
		args->req = va;
  800a3d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a41:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800a45:	48 89 50 08          	mov    %rdx,0x8(%rax)

		thread_create(0, "serve_thread", serve_thread, (uint64_t)args);
  800a49:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800a4d:	48 89 c1             	mov    %rax,%rcx
  800a50:	48 ba 10 06 80 00 00 	movabs $0x800610,%rdx
  800a57:	00 00 00 
  800a5a:	48 be 09 09 82 00 00 	movabs $0x820909,%rsi
  800a61:	00 00 00 
  800a64:	bf 00 00 00 00       	mov    $0x0,%edi
  800a69:	48 b8 97 8a 81 00 00 	movabs $0x818a97,%rax
  800a70:	00 00 00 
  800a73:	ff d0                	callq  *%rax
		thread_yield(); // let the thread created run
  800a75:	48 b8 18 8d 81 00 00 	movabs $0x818d18,%rax
  800a7c:	00 00 00 
  800a7f:	ff d0                	callq  *%rax
	}
  800a81:	e9 99 fe ff ff       	jmpq   80091f <serve+0x8>
  800a86:	e9 94 fe ff ff       	jmpq   80091f <serve+0x8>

0000000000800a8b <tmain>:
}

static void
tmain(uint64_t arg) {
  800a8b:	55                   	push   %rbp
  800a8c:	48 89 e5             	mov    %rsp,%rbp
  800a8f:	41 54                	push   %r12
  800a91:	53                   	push   %rbx
  800a92:	48 83 ec 10          	sub    $0x10,%rsp
  800a96:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	serve_init(inet_addr(IP),
  800a9a:	48 bf 16 09 82 00 00 	movabs $0x820916,%rdi
  800aa1:	00 00 00 
  800aa4:	48 b8 7c 28 81 00 00 	movabs $0x81287c,%rax
  800aab:	00 00 00 
  800aae:	ff d0                	callq  *%rax
  800ab0:	41 89 c4             	mov    %eax,%r12d
  800ab3:	48 bf 1f 09 82 00 00 	movabs $0x82091f,%rdi
  800aba:	00 00 00 
  800abd:	48 b8 7c 28 81 00 00 	movabs $0x81287c,%rax
  800ac4:	00 00 00 
  800ac7:	ff d0                	callq  *%rax
  800ac9:	89 c3                	mov    %eax,%ebx
  800acb:	48 bf 2d 09 82 00 00 	movabs $0x82092d,%rdi
  800ad2:	00 00 00 
  800ad5:	48 b8 7c 28 81 00 00 	movabs $0x81287c,%rax
  800adc:	00 00 00 
  800adf:	ff d0                	callq  *%rax
  800ae1:	44 89 e2             	mov    %r12d,%edx
  800ae4:	89 de                	mov    %ebx,%esi
  800ae6:	89 c7                	mov    %eax,%edi
  800ae8:	48 b8 74 03 80 00 00 	movabs $0x800374,%rax
  800aef:	00 00 00 
  800af2:	ff d0                	callq  *%rax
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  800af4:	48 b8 17 09 80 00 00 	movabs $0x800917,%rax
  800afb:	00 00 00 
  800afe:	ff d0                	callq  *%rax
}
  800b00:	48 83 c4 10          	add    $0x10,%rsp
  800b04:	5b                   	pop    %rbx
  800b05:	41 5c                	pop    %r12
  800b07:	5d                   	pop    %rbp
  800b08:	c3                   	retq   

0000000000800b09 <umain>:

void
umain(int argc, char **argv)
{
  800b09:	55                   	push   %rbp
  800b0a:	48 89 e5             	mov    %rsp,%rbp
  800b0d:	48 83 ec 20          	sub    $0x20,%rsp
  800b11:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800b14:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	envid_t ns_envid = sys_getenvid();
  800b18:	48 b8 80 27 80 00 00 	movabs $0x802780,%rax
  800b1f:	00 00 00 
  800b22:	ff d0                	callq  *%rax
  800b24:	89 45 fc             	mov    %eax,-0x4(%rbp)

	binaryname = "ns";
  800b27:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800b2e:	00 00 00 
  800b31:	48 ba 37 09 82 00 00 	movabs $0x820937,%rdx
  800b38:	00 00 00 
  800b3b:	48 89 10             	mov    %rdx,(%rax)

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  800b3e:	48 b8 d3 2e 80 00 00 	movabs $0x802ed3,%rax
  800b45:	00 00 00 
  800b48:	ff d0                	callq  *%rax
  800b4a:	48 ba 68 90 82 00 00 	movabs $0x829068,%rdx
  800b51:	00 00 00 
  800b54:	89 02                	mov    %eax,(%rdx)
	if (timer_envid < 0)
  800b56:	48 b8 68 90 82 00 00 	movabs $0x829068,%rax
  800b5d:	00 00 00 
  800b60:	8b 00                	mov    (%rax),%eax
  800b62:	85 c0                	test   %eax,%eax
  800b64:	79 2a                	jns    800b90 <umain+0x87>
		panic("error forking");
  800b66:	48 ba 3a 09 82 00 00 	movabs $0x82093a,%rdx
  800b6d:	00 00 00 
  800b70:	be 43 01 00 00       	mov    $0x143,%esi
  800b75:	48 bf 14 07 82 00 00 	movabs $0x820714,%rdi
  800b7c:	00 00 00 
  800b7f:	b8 00 00 00 00       	mov    $0x0,%eax
  800b84:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  800b8b:	00 00 00 
  800b8e:	ff d1                	callq  *%rcx
	else if (timer_envid == 0) {
  800b90:	48 b8 68 90 82 00 00 	movabs $0x829068,%rax
  800b97:	00 00 00 
  800b9a:	8b 00                	mov    (%rax),%eax
  800b9c:	85 c0                	test   %eax,%eax
  800b9e:	75 1b                	jne    800bbb <umain+0xb2>
		timer(ns_envid, TIMER_INTERVAL);
  800ba0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800ba3:	be fa 00 00 00       	mov    $0xfa,%esi
  800ba8:	89 c7                	mov    %eax,%edi
  800baa:	48 b8 ec 0c 80 00 00 	movabs $0x800cec,%rax
  800bb1:	00 00 00 
  800bb4:	ff d0                	callq  *%rax
		return;
  800bb6:	e9 2f 01 00 00       	jmpq   800cea <umain+0x1e1>
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  800bbb:	48 b8 d3 2e 80 00 00 	movabs $0x802ed3,%rax
  800bc2:	00 00 00 
  800bc5:	ff d0                	callq  *%rax
  800bc7:	48 ba 6c 90 82 00 00 	movabs $0x82906c,%rdx
  800bce:	00 00 00 
  800bd1:	89 02                	mov    %eax,(%rdx)
	if (input_envid < 0)
  800bd3:	48 b8 6c 90 82 00 00 	movabs $0x82906c,%rax
  800bda:	00 00 00 
  800bdd:	8b 00                	mov    (%rax),%eax
  800bdf:	85 c0                	test   %eax,%eax
  800be1:	79 2a                	jns    800c0d <umain+0x104>
		panic("error forking");
  800be3:	48 ba 3a 09 82 00 00 	movabs $0x82093a,%rdx
  800bea:	00 00 00 
  800bed:	be 4d 01 00 00       	mov    $0x14d,%esi
  800bf2:	48 bf 14 07 82 00 00 	movabs $0x820714,%rdi
  800bf9:	00 00 00 
  800bfc:	b8 00 00 00 00       	mov    $0x0,%eax
  800c01:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  800c08:	00 00 00 
  800c0b:	ff d1                	callq  *%rcx
	else if (input_envid == 0) {
  800c0d:	48 b8 6c 90 82 00 00 	movabs $0x82906c,%rax
  800c14:	00 00 00 
  800c17:	8b 00                	mov    (%rax),%eax
  800c19:	85 c0                	test   %eax,%eax
  800c1b:	75 16                	jne    800c33 <umain+0x12a>
		input(ns_envid);
  800c1d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800c20:	89 c7                	mov    %eax,%edi
  800c22:	48 b8 0c 0e 80 00 00 	movabs $0x800e0c,%rax
  800c29:	00 00 00 
  800c2c:	ff d0                	callq  *%rax
		return;
  800c2e:	e9 b7 00 00 00       	jmpq   800cea <umain+0x1e1>
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  800c33:	48 b8 d3 2e 80 00 00 	movabs $0x802ed3,%rax
  800c3a:	00 00 00 
  800c3d:	ff d0                	callq  *%rax
  800c3f:	48 ba 70 90 82 00 00 	movabs $0x829070,%rdx
  800c46:	00 00 00 
  800c49:	89 02                	mov    %eax,(%rdx)
	if (output_envid < 0)
  800c4b:	48 b8 70 90 82 00 00 	movabs $0x829070,%rax
  800c52:	00 00 00 
  800c55:	8b 00                	mov    (%rax),%eax
  800c57:	85 c0                	test   %eax,%eax
  800c59:	79 2a                	jns    800c85 <umain+0x17c>
		panic("error forking");
  800c5b:	48 ba 3a 09 82 00 00 	movabs $0x82093a,%rdx
  800c62:	00 00 00 
  800c65:	be 57 01 00 00       	mov    $0x157,%esi
  800c6a:	48 bf 14 07 82 00 00 	movabs $0x820714,%rdi
  800c71:	00 00 00 
  800c74:	b8 00 00 00 00       	mov    $0x0,%eax
  800c79:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  800c80:	00 00 00 
  800c83:	ff d1                	callq  *%rcx
	else if (output_envid == 0) {
  800c85:	48 b8 70 90 82 00 00 	movabs $0x829070,%rax
  800c8c:	00 00 00 
  800c8f:	8b 00                	mov    (%rax),%eax
  800c91:	85 c0                	test   %eax,%eax
  800c93:	75 13                	jne    800ca8 <umain+0x19f>
		output(ns_envid);
  800c95:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800c98:	89 c7                	mov    %eax,%edi
  800c9a:	48 b8 1c 0f 80 00 00 	movabs $0x800f1c,%rax
  800ca1:	00 00 00 
  800ca4:	ff d0                	callq  *%rax
		return;
  800ca6:	eb 42                	jmp    800cea <umain+0x1e1>
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  800ca8:	48 b8 8b 87 81 00 00 	movabs $0x81878b,%rax
  800caf:	00 00 00 
  800cb2:	ff d0                	callq  *%rax
	thread_create(0, "main", tmain, 0);
  800cb4:	b9 00 00 00 00       	mov    $0x0,%ecx
  800cb9:	48 ba 8b 0a 80 00 00 	movabs $0x800a8b,%rdx
  800cc0:	00 00 00 
  800cc3:	48 be 48 09 82 00 00 	movabs $0x820948,%rsi
  800cca:	00 00 00 
  800ccd:	bf 00 00 00 00       	mov    $0x0,%edi
  800cd2:	48 b8 97 8a 81 00 00 	movabs $0x818a97,%rax
  800cd9:	00 00 00 
  800cdc:	ff d0                	callq  *%rax
	thread_yield();
  800cde:	48 b8 18 8d 81 00 00 	movabs $0x818d18,%rax
  800ce5:	00 00 00 
  800ce8:	ff d0                	callq  *%rax
	// never coming here!
}
  800cea:	c9                   	leaveq 
  800ceb:	c3                   	retq   

0000000000800cec <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800cec:	55                   	push   %rbp
  800ced:	48 89 e5             	mov    %rsp,%rbp
  800cf0:	48 83 ec 20          	sub    $0x20,%rsp
  800cf4:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800cf7:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  800cfa:	48 b8 69 2a 80 00 00 	movabs $0x802a69,%rax
  800d01:	00 00 00 
  800d04:	ff d0                	callq  *%rax
  800d06:	03 45 e8             	add    -0x18(%rbp),%eax
  800d09:	89 45 fc             	mov    %eax,-0x4(%rbp)

	binaryname = "ns_timer";
  800d0c:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800d13:	00 00 00 
  800d16:	48 ba 50 09 82 00 00 	movabs $0x820950,%rdx
  800d1d:	00 00 00 
  800d20:	48 89 10             	mov    %rdx,(%rax)

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
  800d23:	eb 0c                	jmp    800d31 <timer+0x45>
			sys_yield();
  800d25:	48 b8 be 27 80 00 00 	movabs $0x8027be,%rax
  800d2c:	00 00 00 
  800d2f:	ff d0                	callq  *%rax
	uint32_t stop = sys_time_msec() + initial_to;

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
  800d31:	48 b8 69 2a 80 00 00 	movabs $0x802a69,%rax
  800d38:	00 00 00 
  800d3b:	ff d0                	callq  *%rax
  800d3d:	89 45 f8             	mov    %eax,-0x8(%rbp)
  800d40:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800d43:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800d46:	73 06                	jae    800d4e <timer+0x62>
  800d48:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800d4c:	79 d7                	jns    800d25 <timer+0x39>
			sys_yield();
		}
		if (r < 0)
  800d4e:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800d52:	79 30                	jns    800d84 <timer+0x98>
			panic("sys_time_msec: %e", r);
  800d54:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800d57:	89 c1                	mov    %eax,%ecx
  800d59:	48 ba 59 09 82 00 00 	movabs $0x820959,%rdx
  800d60:	00 00 00 
  800d63:	be 0f 00 00 00       	mov    $0xf,%esi
  800d68:	48 bf 6b 09 82 00 00 	movabs $0x82096b,%rdi
  800d6f:	00 00 00 
  800d72:	b8 00 00 00 00       	mov    $0x0,%eax
  800d77:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  800d7e:	00 00 00 
  800d81:	41 ff d0             	callq  *%r8

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  800d84:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800d87:	b9 00 00 00 00       	mov    $0x0,%ecx
  800d8c:	ba 00 00 00 00       	mov    $0x0,%edx
  800d91:	be 0c 00 00 00       	mov    $0xc,%esi
  800d96:	89 c7                	mov    %eax,%edi
  800d98:	48 b8 c0 32 80 00 00 	movabs $0x8032c0,%rax
  800d9f:	00 00 00 
  800da2:	ff d0                	callq  *%rax

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  800da4:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  800da8:	ba 00 00 00 00       	mov    $0x0,%edx
  800dad:	be 00 00 00 00       	mov    $0x0,%esi
  800db2:	48 89 c7             	mov    %rax,%rdi
  800db5:	48 b8 00 32 80 00 00 	movabs $0x803200,%rax
  800dbc:	00 00 00 
  800dbf:	ff d0                	callq  *%rax
  800dc1:	89 45 f4             	mov    %eax,-0xc(%rbp)

			if (whom != ns_envid) {
  800dc4:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800dc7:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800dca:	39 c2                	cmp    %eax,%edx
  800dcc:	74 22                	je     800df0 <timer+0x104>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  800dce:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800dd1:	89 c6                	mov    %eax,%esi
  800dd3:	48 bf 78 09 82 00 00 	movabs $0x820978,%rdi
  800dda:	00 00 00 
  800ddd:	b8 00 00 00 00       	mov    $0x0,%eax
  800de2:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  800de9:	00 00 00 
  800dec:	ff d2                	callq  *%rdx
				continue;
			}

			stop = sys_time_msec() + to;
			break;
		}
  800dee:	eb b4                	jmp    800da4 <timer+0xb8>
			if (whom != ns_envid) {
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
				continue;
			}

			stop = sys_time_msec() + to;
  800df0:	48 b8 69 2a 80 00 00 	movabs $0x802a69,%rax
  800df7:	00 00 00 
  800dfa:	ff d0                	callq  *%rax
  800dfc:	03 45 f4             	add    -0xc(%rbp),%eax
  800dff:	89 45 fc             	mov    %eax,-0x4(%rbp)
			break;
  800e02:	90                   	nop
		}
	}
  800e03:	90                   	nop
	uint32_t stop = sys_time_msec() + initial_to;

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
  800e04:	e9 28 ff ff ff       	jmpq   800d31 <timer+0x45>
  800e09:	00 00                	add    %al,(%rax)
	...

0000000000800e0c <input>:
extern union Nsipc nsipcbuf;


void
input(envid_t ns_envid)
{
  800e0c:	55                   	push   %rbp
  800e0d:	48 89 e5             	mov    %rsp,%rbp
  800e10:	48 83 ec 40          	sub    $0x40,%rsp
  800e14:	89 7d cc             	mov    %edi,-0x34(%rbp)
	binaryname = "ns_input";
  800e17:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800e1e:	00 00 00 
  800e21:	48 ba b8 09 82 00 00 	movabs $0x8209b8,%rdx
  800e28:	00 00 00 
  800e2b:	48 89 10             	mov    %rdx,(%rax)
	// reading from it for a while, so don't immediately receive
	// another packet in to the same physical page.
	struct jif_pkt *packet;
	uintptr_t addr;
	size_t len;
	uint32_t reqType = NSREQ_INPUT;
  800e2e:	c7 45 fc 0a 00 00 00 	movl   $0xa,-0x4(%rbp)
	int r, recvBuffLen=0;
  800e35:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	packet = (struct jif_pkt *)&(nsipcbuf);
  800e3c:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  800e43:	00 00 00 
  800e46:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	//Allocate a page for receiving the packet data
        if ((r = sys_page_alloc(0,(void *)((uintptr_t)packet), PTE_P|PTE_U|PTE_W)) < 0)
  800e4a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800e4e:	ba 07 00 00 00       	mov    $0x7,%edx
  800e53:	48 89 c6             	mov    %rax,%rsi
  800e56:	bf 00 00 00 00       	mov    $0x0,%edi
  800e5b:	48 b8 fc 27 80 00 00 	movabs $0x8027fc,%rax
  800e62:	00 00 00 
  800e65:	ff d0                	callq  *%rax
  800e67:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800e6a:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800e6e:	79 30                	jns    800ea0 <input+0x94>
        	panic("panic in input environment:sys_page_alloc: %e\n", r);
  800e70:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800e73:	89 c1                	mov    %eax,%ecx
  800e75:	48 ba c8 09 82 00 00 	movabs $0x8209c8,%rdx
  800e7c:	00 00 00 
  800e7f:	be 19 00 00 00       	mov    $0x19,%esi
  800e84:	48 bf f7 09 82 00 00 	movabs $0x8209f7,%rdi
  800e8b:	00 00 00 
  800e8e:	b8 00 00 00 00       	mov    $0x0,%eax
  800e93:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  800e9a:	00 00 00 
  800e9d:	41 ff d0             	callq  *%r8
        while(1)
        {
		//Receive the packet from the device driver into the page allocated
		addr = (uintptr_t)packet + sizeof(packet->jp_len);
  800ea0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800ea4:	48 83 c0 04          	add    $0x4,%rax
  800ea8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		len = (size_t)(PGSIZE - sizeof(packet->jp_len));
  800eac:	48 c7 45 d8 fc 0f 00 	movq   $0xffc,-0x28(%rbp)
  800eb3:	00 
		while((recvBuffLen = sys_receive_packet((void *)addr,len)) < 0)
  800eb4:	eb 0c                	jmp    800ec2 <input+0xb6>
                	sys_yield();
  800eb6:	48 b8 be 27 80 00 00 	movabs $0x8027be,%rax
  800ebd:	00 00 00 
  800ec0:	ff d0                	callq  *%rax
        while(1)
        {
		//Receive the packet from the device driver into the page allocated
		addr = (uintptr_t)packet + sizeof(packet->jp_len);
		len = (size_t)(PGSIZE - sizeof(packet->jp_len));
		while((recvBuffLen = sys_receive_packet((void *)addr,len)) < 0)
  800ec2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800ec6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800eca:	48 89 d6             	mov    %rdx,%rsi
  800ecd:	48 89 c7             	mov    %rax,%rdi
  800ed0:	48 b8 f1 2a 80 00 00 	movabs $0x802af1,%rax
  800ed7:	00 00 00 
  800eda:	ff d0                	callq  *%rax
  800edc:	89 45 f8             	mov    %eax,-0x8(%rbp)
  800edf:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800ee3:	78 d1                	js     800eb6 <input+0xaa>
                	sys_yield();
                packet->jp_len = recvBuffLen;
  800ee5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800ee9:	8b 55 f8             	mov    -0x8(%rbp),%edx
  800eec:	89 10                	mov    %edx,(%rax)
		//Send the NSREQ_INPUT IPC message to ns with packet in page
                ipc_send(ns_envid, reqType, packet, PTE_P|PTE_U);
  800eee:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800ef2:	8b 75 fc             	mov    -0x4(%rbp),%esi
  800ef5:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800ef8:	b9 05 00 00 00       	mov    $0x5,%ecx
  800efd:	89 c7                	mov    %eax,%edi
  800eff:	48 b8 c0 32 80 00 00 	movabs $0x8032c0,%rax
  800f06:	00 00 00 
  800f09:	ff d0                	callq  *%rax
                sys_yield();
  800f0b:	48 b8 be 27 80 00 00 	movabs $0x8027be,%rax
  800f12:	00 00 00 
  800f15:	ff d0                	callq  *%rax
        }
  800f17:	eb 87                	jmp    800ea0 <input+0x94>
  800f19:	00 00                	add    %al,(%rax)
	...

0000000000800f1c <output>:
#include "ns.h"
extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  800f1c:	55                   	push   %rbp
  800f1d:	48 89 e5             	mov    %rsp,%rbp
  800f20:	48 83 ec 20          	sub    $0x20,%rsp
  800f24:	89 7d ec             	mov    %edi,-0x14(%rbp)
	binaryname = "ns_output";
  800f27:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  800f2e:	00 00 00 
  800f31:	48 ba 08 0a 82 00 00 	movabs $0x820a08,%rdx
  800f38:	00 00 00 
  800f3b:	48 89 10             	mov    %rdx,(%rax)
	// LAB 6: Your code here:
	// 	- read a packet from the network server
	//	- send the packet to the device driver
	while(1)
	{
		perm = 0;
  800f3e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
		//Read a packet from ns
		reqType = ipc_recv(&envid_sender, &nsipcbuf, &perm);
  800f45:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  800f49:	48 8d 45 f4          	lea    -0xc(%rbp),%rax
  800f4d:	48 be 00 a0 b5 00 00 	movabs $0xb5a000,%rsi
  800f54:	00 00 00 
  800f57:	48 89 c7             	mov    %rax,%rdi
  800f5a:	48 b8 00 32 80 00 00 	movabs $0x803200,%rax
  800f61:	00 00 00 
  800f64:	ff d0                	callq  *%rax
  800f66:	89 45 fc             	mov    %eax,-0x4(%rbp)
		//Check if ipc_recv has received correctly
		if(!(perm & PTE_P))
  800f69:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800f6c:	83 e0 01             	and    $0x1,%eax
  800f6f:	85 c0                	test   %eax,%eax
  800f71:	75 22                	jne    800f95 <output+0x79>
		{
			cprintf("Invalid request from network server[%08x]:no page",envid_sender);
  800f73:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800f76:	89 c6                	mov    %eax,%esi
  800f78:	48 bf 18 0a 82 00 00 	movabs $0x820a18,%rdi
  800f7f:	00 00 00 
  800f82:	b8 00 00 00 00       	mov    $0x0,%eax
  800f87:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  800f8e:	00 00 00 
  800f91:	ff d2                	callq  *%rdx
			continue; 
  800f93:	eb 67                	jmp    800ffc <output+0xe0>
		}
		if(reqType != NSREQ_OUTPUT)
  800f95:	83 7d fc 0b          	cmpl   $0xb,-0x4(%rbp)
  800f99:	74 30                	je     800fcb <output+0xaf>
		{
			cprintf("Invalid request from network server[%08x]:not a NSREQ_OUTPUT message",envid_sender);
  800f9b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800f9e:	89 c6                	mov    %eax,%esi
  800fa0:	48 bf 50 0a 82 00 00 	movabs $0x820a50,%rdi
  800fa7:	00 00 00 
  800faa:	b8 00 00 00 00       	mov    $0x0,%eax
  800faf:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  800fb6:	00 00 00 
  800fb9:	ff d2                	callq  *%rdx
			continue;
  800fbb:	eb 3f                	jmp    800ffc <output+0xe0>
		}
		//Send packet to device driver.If packet send fails, give up CPU
		while(sys_send_packet(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len) < 0)
			sys_yield();
  800fbd:	48 b8 be 27 80 00 00 	movabs $0x8027be,%rax
  800fc4:	00 00 00 
  800fc7:	ff d0                	callq  *%rax
  800fc9:	eb 01                	jmp    800fcc <output+0xb0>
		{
			cprintf("Invalid request from network server[%08x]:not a NSREQ_OUTPUT message",envid_sender);
			continue;
		}
		//Send packet to device driver.If packet send fails, give up CPU
		while(sys_send_packet(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len) < 0)
  800fcb:	90                   	nop
  800fcc:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  800fd3:	00 00 00 
  800fd6:	8b 00                	mov    (%rax),%eax
  800fd8:	48 98                	cltq   
  800fda:	48 89 c6             	mov    %rax,%rsi
  800fdd:	48 bf 04 a0 b5 00 00 	movabs $0xb5a004,%rdi
  800fe4:	00 00 00 
  800fe7:	48 b8 a7 2a 80 00 00 	movabs $0x802aa7,%rax
  800fee:	00 00 00 
  800ff1:	ff d0                	callq  *%rax
  800ff3:	85 c0                	test   %eax,%eax
  800ff5:	78 c6                	js     800fbd <output+0xa1>
			sys_yield();
	}
  800ff7:	e9 42 ff ff ff       	jmpq   800f3e <output+0x22>
  800ffc:	e9 3d ff ff ff       	jmpq   800f3e <output+0x22>
  801001:	00 00                	add    %al,(%rax)
	...

0000000000801004 <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  801004:	55                   	push   %rbp
  801005:	48 89 e5             	mov    %rsp,%rbp
  801008:	48 83 ec 10          	sub    $0x10,%rsp
  80100c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80100f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
	thisenv = 0;
  801013:	48 b8 10 76 b5 00 00 	movabs $0xb57610,%rax
  80101a:	00 00 00 
  80101d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	thisenv= &envs[ENVX(sys_getenvid())];
  801024:	48 b8 80 27 80 00 00 	movabs $0x802780,%rax
  80102b:	00 00 00 
  80102e:	ff d0                	callq  *%rax
  801030:	48 98                	cltq   
  801032:	48 89 c2             	mov    %rax,%rdx
  801035:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
  80103b:	48 89 d0             	mov    %rdx,%rax
  80103e:	48 c1 e0 03          	shl    $0x3,%rax
  801042:	48 01 d0             	add    %rdx,%rax
  801045:	48 c1 e0 05          	shl    $0x5,%rax
  801049:	48 89 c2             	mov    %rax,%rdx
  80104c:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  801053:	00 00 00 
  801056:	48 01 c2             	add    %rax,%rdx
  801059:	48 b8 10 76 b5 00 00 	movabs $0xb57610,%rax
  801060:	00 00 00 
  801063:	48 89 10             	mov    %rdx,(%rax)
	// save the name of the program so that panic() can use it
	if (argc > 0)
  801066:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80106a:	7e 14                	jle    801080 <libmain+0x7c>
		binaryname = argv[0];
  80106c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801070:	48 8b 10             	mov    (%rax),%rdx
  801073:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  80107a:	00 00 00 
  80107d:	48 89 10             	mov    %rdx,(%rax)

	// call user main routine
	umain(argc, argv);
  801080:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  801084:	8b 45 fc             	mov    -0x4(%rbp),%eax
  801087:	48 89 d6             	mov    %rdx,%rsi
  80108a:	89 c7                	mov    %eax,%edi
  80108c:	48 b8 09 0b 80 00 00 	movabs $0x800b09,%rax
  801093:	00 00 00 
  801096:	ff d0                	callq  *%rax

	// exit gracefully
	exit();
  801098:	48 b8 a8 10 80 00 00 	movabs $0x8010a8,%rax
  80109f:	00 00 00 
  8010a2:	ff d0                	callq  *%rax
}
  8010a4:	c9                   	leaveq 
  8010a5:	c3                   	retq   
	...

00000000008010a8 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  8010a8:	55                   	push   %rbp
  8010a9:	48 89 e5             	mov    %rsp,%rbp
	close_all();
  8010ac:	48 b8 49 37 80 00 00 	movabs $0x803749,%rax
  8010b3:	00 00 00 
  8010b6:	ff d0                	callq  *%rax
	sys_env_destroy(0);
  8010b8:	bf 00 00 00 00       	mov    $0x0,%edi
  8010bd:	48 b8 3c 27 80 00 00 	movabs $0x80273c,%rax
  8010c4:	00 00 00 
  8010c7:	ff d0                	callq  *%rax
}
  8010c9:	5d                   	pop    %rbp
  8010ca:	c3                   	retq   
	...

00000000008010cc <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  8010cc:	55                   	push   %rbp
  8010cd:	48 89 e5             	mov    %rsp,%rbp
  8010d0:	53                   	push   %rbx
  8010d1:	48 81 ec f8 00 00 00 	sub    $0xf8,%rsp
  8010d8:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  8010df:	89 b5 14 ff ff ff    	mov    %esi,-0xec(%rbp)
  8010e5:	48 89 8d 58 ff ff ff 	mov    %rcx,-0xa8(%rbp)
  8010ec:	4c 89 85 60 ff ff ff 	mov    %r8,-0xa0(%rbp)
  8010f3:	4c 89 8d 68 ff ff ff 	mov    %r9,-0x98(%rbp)
  8010fa:	84 c0                	test   %al,%al
  8010fc:	74 23                	je     801121 <_panic+0x55>
  8010fe:	0f 29 85 70 ff ff ff 	movaps %xmm0,-0x90(%rbp)
  801105:	0f 29 4d 80          	movaps %xmm1,-0x80(%rbp)
  801109:	0f 29 55 90          	movaps %xmm2,-0x70(%rbp)
  80110d:	0f 29 5d a0          	movaps %xmm3,-0x60(%rbp)
  801111:	0f 29 65 b0          	movaps %xmm4,-0x50(%rbp)
  801115:	0f 29 6d c0          	movaps %xmm5,-0x40(%rbp)
  801119:	0f 29 75 d0          	movaps %xmm6,-0x30(%rbp)
  80111d:	0f 29 7d e0          	movaps %xmm7,-0x20(%rbp)
  801121:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  801128:	c7 85 28 ff ff ff 18 	movl   $0x18,-0xd8(%rbp)
  80112f:	00 00 00 
  801132:	c7 85 2c ff ff ff 30 	movl   $0x30,-0xd4(%rbp)
  801139:	00 00 00 
  80113c:	48 8d 45 10          	lea    0x10(%rbp),%rax
  801140:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  801147:	48 8d 85 40 ff ff ff 	lea    -0xc0(%rbp),%rax
  80114e:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  801155:	48 b8 00 80 82 00 00 	movabs $0x828000,%rax
  80115c:	00 00 00 
  80115f:	48 8b 18             	mov    (%rax),%rbx
  801162:	48 b8 80 27 80 00 00 	movabs $0x802780,%rax
  801169:	00 00 00 
  80116c:	ff d0                	callq  *%rax
  80116e:	8b 8d 14 ff ff ff    	mov    -0xec(%rbp),%ecx
  801174:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  80117b:	41 89 c8             	mov    %ecx,%r8d
  80117e:	48 89 d1             	mov    %rdx,%rcx
  801181:	48 89 da             	mov    %rbx,%rdx
  801184:	89 c6                	mov    %eax,%esi
  801186:	48 bf a0 0a 82 00 00 	movabs $0x820aa0,%rdi
  80118d:	00 00 00 
  801190:	b8 00 00 00 00       	mov    $0x0,%eax
  801195:	49 b9 07 13 80 00 00 	movabs $0x801307,%r9
  80119c:	00 00 00 
  80119f:	41 ff d1             	callq  *%r9
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  8011a2:	48 8d 95 28 ff ff ff 	lea    -0xd8(%rbp),%rdx
  8011a9:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8011b0:	48 89 d6             	mov    %rdx,%rsi
  8011b3:	48 89 c7             	mov    %rax,%rdi
  8011b6:	48 b8 5b 12 80 00 00 	movabs $0x80125b,%rax
  8011bd:	00 00 00 
  8011c0:	ff d0                	callq  *%rax
	cprintf("\n");
  8011c2:	48 bf c3 0a 82 00 00 	movabs $0x820ac3,%rdi
  8011c9:	00 00 00 
  8011cc:	b8 00 00 00 00       	mov    $0x0,%eax
  8011d1:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  8011d8:	00 00 00 
  8011db:	ff d2                	callq  *%rdx

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  8011dd:	cc                   	int3   
  8011de:	eb fd                	jmp    8011dd <_panic+0x111>

00000000008011e0 <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  8011e0:	55                   	push   %rbp
  8011e1:	48 89 e5             	mov    %rsp,%rbp
  8011e4:	48 83 ec 10          	sub    $0x10,%rsp
  8011e8:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8011eb:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->buf[b->idx++] = ch;
  8011ef:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8011f3:	8b 00                	mov    (%rax),%eax
  8011f5:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8011f8:	89 d6                	mov    %edx,%esi
  8011fa:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8011fe:	48 63 d0             	movslq %eax,%rdx
  801201:	40 88 74 11 08       	mov    %sil,0x8(%rcx,%rdx,1)
  801206:	8d 50 01             	lea    0x1(%rax),%edx
  801209:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80120d:	89 10                	mov    %edx,(%rax)
	if (b->idx == 256-1) {
  80120f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801213:	8b 00                	mov    (%rax),%eax
  801215:	3d ff 00 00 00       	cmp    $0xff,%eax
  80121a:	75 2c                	jne    801248 <putch+0x68>
		sys_cputs(b->buf, b->idx);
  80121c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801220:	8b 00                	mov    (%rax),%eax
  801222:	48 98                	cltq   
  801224:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  801228:	48 83 c2 08          	add    $0x8,%rdx
  80122c:	48 89 c6             	mov    %rax,%rsi
  80122f:	48 89 d7             	mov    %rdx,%rdi
  801232:	48 b8 b4 26 80 00 00 	movabs $0x8026b4,%rax
  801239:	00 00 00 
  80123c:	ff d0                	callq  *%rax
		b->idx = 0;
  80123e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801242:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	}
	b->cnt++;
  801248:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80124c:	8b 40 04             	mov    0x4(%rax),%eax
  80124f:	8d 50 01             	lea    0x1(%rax),%edx
  801252:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801256:	89 50 04             	mov    %edx,0x4(%rax)
}
  801259:	c9                   	leaveq 
  80125a:	c3                   	retq   

000000000080125b <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80125b:	55                   	push   %rbp
  80125c:	48 89 e5             	mov    %rsp,%rbp
  80125f:	48 81 ec 40 01 00 00 	sub    $0x140,%rsp
  801266:	48 89 bd c8 fe ff ff 	mov    %rdi,-0x138(%rbp)
  80126d:	48 89 b5 c0 fe ff ff 	mov    %rsi,-0x140(%rbp)
	struct printbuf b;
	va_list aq;
	va_copy(aq,ap);
  801274:	48 8d 85 d8 fe ff ff 	lea    -0x128(%rbp),%rax
  80127b:	48 8b 95 c0 fe ff ff 	mov    -0x140(%rbp),%rdx
  801282:	48 8b 0a             	mov    (%rdx),%rcx
  801285:	48 89 08             	mov    %rcx,(%rax)
  801288:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80128c:	48 89 48 08          	mov    %rcx,0x8(%rax)
  801290:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801294:	48 89 50 10          	mov    %rdx,0x10(%rax)
	b.idx = 0;
  801298:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%rbp)
  80129f:	00 00 00 
	b.cnt = 0;
  8012a2:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%rbp)
  8012a9:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, aq);
  8012ac:	48 8d 8d d8 fe ff ff 	lea    -0x128(%rbp),%rcx
  8012b3:	48 8b 95 c8 fe ff ff 	mov    -0x138(%rbp),%rdx
  8012ba:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  8012c1:	48 89 c6             	mov    %rax,%rsi
  8012c4:	48 bf e0 11 80 00 00 	movabs $0x8011e0,%rdi
  8012cb:	00 00 00 
  8012ce:	48 b8 b8 16 80 00 00 	movabs $0x8016b8,%rax
  8012d5:	00 00 00 
  8012d8:	ff d0                	callq  *%rax
	sys_cputs(b.buf, b.idx);
  8012da:	8b 85 f0 fe ff ff    	mov    -0x110(%rbp),%eax
  8012e0:	48 98                	cltq   
  8012e2:	48 8d 95 f0 fe ff ff 	lea    -0x110(%rbp),%rdx
  8012e9:	48 83 c2 08          	add    $0x8,%rdx
  8012ed:	48 89 c6             	mov    %rax,%rsi
  8012f0:	48 89 d7             	mov    %rdx,%rdi
  8012f3:	48 b8 b4 26 80 00 00 	movabs $0x8026b4,%rax
  8012fa:	00 00 00 
  8012fd:	ff d0                	callq  *%rax
	va_end(aq);

	return b.cnt;
  8012ff:	8b 85 f4 fe ff ff    	mov    -0x10c(%rbp),%eax
}
  801305:	c9                   	leaveq 
  801306:	c3                   	retq   

0000000000801307 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  801307:	55                   	push   %rbp
  801308:	48 89 e5             	mov    %rsp,%rbp
  80130b:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  801312:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  801319:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  801320:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  801327:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  80132e:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  801335:	84 c0                	test   %al,%al
  801337:	74 20                	je     801359 <cprintf+0x52>
  801339:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  80133d:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  801341:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  801345:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  801349:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  80134d:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  801351:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  801355:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  801359:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
	va_list ap;
	int cnt;
	va_list aq;
	va_start(ap, fmt);
  801360:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  801367:	00 00 00 
  80136a:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  801371:	00 00 00 
  801374:	48 8d 45 10          	lea    0x10(%rbp),%rax
  801378:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  80137f:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  801386:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  80138d:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  801394:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  80139b:	48 8b 0a             	mov    (%rdx),%rcx
  80139e:	48 89 08             	mov    %rcx,(%rax)
  8013a1:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8013a5:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8013a9:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8013ad:	48 89 50 10          	mov    %rdx,0x10(%rax)
	cnt = vcprintf(fmt, aq);
  8013b1:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  8013b8:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8013bf:	48 89 d6             	mov    %rdx,%rsi
  8013c2:	48 89 c7             	mov    %rax,%rdi
  8013c5:	48 b8 5b 12 80 00 00 	movabs $0x80125b,%rax
  8013cc:	00 00 00 
  8013cf:	ff d0                	callq  *%rax
  8013d1:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return cnt;
  8013d7:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  8013dd:	c9                   	leaveq 
  8013de:	c3                   	retq   
	...

00000000008013e0 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  8013e0:	55                   	push   %rbp
  8013e1:	48 89 e5             	mov    %rsp,%rbp
  8013e4:	48 83 ec 30          	sub    $0x30,%rsp
  8013e8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8013ec:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8013f0:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8013f4:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
  8013f7:	44 89 45 e0          	mov    %r8d,-0x20(%rbp)
  8013fb:	44 89 4d dc          	mov    %r9d,-0x24(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  8013ff:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  801402:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  801406:	77 52                	ja     80145a <printnum+0x7a>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  801408:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80140b:	44 8d 40 ff          	lea    -0x1(%rax),%r8d
  80140f:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  801412:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  801416:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80141a:	ba 00 00 00 00       	mov    $0x0,%edx
  80141f:	48 f7 75 d0          	divq   -0x30(%rbp)
  801423:	48 89 c2             	mov    %rax,%rdx
  801426:	8b 7d dc             	mov    -0x24(%rbp),%edi
  801429:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  80142c:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  801430:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801434:	41 89 f9             	mov    %edi,%r9d
  801437:	48 89 c7             	mov    %rax,%rdi
  80143a:	48 b8 e0 13 80 00 00 	movabs $0x8013e0,%rax
  801441:	00 00 00 
  801444:	ff d0                	callq  *%rax
  801446:	eb 1c                	jmp    801464 <printnum+0x84>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  801448:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80144c:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80144f:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  801453:	48 89 d6             	mov    %rdx,%rsi
  801456:	89 c7                	mov    %eax,%edi
  801458:	ff d1                	callq  *%rcx
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  80145a:	83 6d e0 01          	subl   $0x1,-0x20(%rbp)
  80145e:	83 7d e0 00          	cmpl   $0x0,-0x20(%rbp)
  801462:	7f e4                	jg     801448 <printnum+0x68>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  801464:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  801467:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80146b:	ba 00 00 00 00       	mov    $0x0,%edx
  801470:	48 f7 f1             	div    %rcx
  801473:	48 89 d0             	mov    %rdx,%rax
  801476:	48 ba a8 0c 82 00 00 	movabs $0x820ca8,%rdx
  80147d:	00 00 00 
  801480:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  801484:	0f be c0             	movsbl %al,%eax
  801487:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80148b:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80148f:	48 89 d6             	mov    %rdx,%rsi
  801492:	89 c7                	mov    %eax,%edi
  801494:	ff d1                	callq  *%rcx
}
  801496:	c9                   	leaveq 
  801497:	c3                   	retq   

0000000000801498 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  801498:	55                   	push   %rbp
  801499:	48 89 e5             	mov    %rsp,%rbp
  80149c:	48 83 ec 20          	sub    $0x20,%rsp
  8014a0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8014a4:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  8014a7:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  8014ab:	7e 52                	jle    8014ff <getuint+0x67>
		x= va_arg(*ap, unsigned long long);
  8014ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014b1:	8b 00                	mov    (%rax),%eax
  8014b3:	83 f8 30             	cmp    $0x30,%eax
  8014b6:	73 24                	jae    8014dc <getuint+0x44>
  8014b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014bc:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8014c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014c4:	8b 00                	mov    (%rax),%eax
  8014c6:	89 c0                	mov    %eax,%eax
  8014c8:	48 01 d0             	add    %rdx,%rax
  8014cb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8014cf:	8b 12                	mov    (%rdx),%edx
  8014d1:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8014d4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8014d8:	89 0a                	mov    %ecx,(%rdx)
  8014da:	eb 17                	jmp    8014f3 <getuint+0x5b>
  8014dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8014e0:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8014e4:	48 89 d0             	mov    %rdx,%rax
  8014e7:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  8014eb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8014ef:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  8014f3:	48 8b 00             	mov    (%rax),%rax
  8014f6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8014fa:	e9 a3 00 00 00       	jmpq   8015a2 <getuint+0x10a>
	else if (lflag)
  8014ff:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  801503:	74 4f                	je     801554 <getuint+0xbc>
		x= va_arg(*ap, unsigned long);
  801505:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801509:	8b 00                	mov    (%rax),%eax
  80150b:	83 f8 30             	cmp    $0x30,%eax
  80150e:	73 24                	jae    801534 <getuint+0x9c>
  801510:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801514:	48 8b 50 10          	mov    0x10(%rax),%rdx
  801518:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80151c:	8b 00                	mov    (%rax),%eax
  80151e:	89 c0                	mov    %eax,%eax
  801520:	48 01 d0             	add    %rdx,%rax
  801523:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801527:	8b 12                	mov    (%rdx),%edx
  801529:	8d 4a 08             	lea    0x8(%rdx),%ecx
  80152c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801530:	89 0a                	mov    %ecx,(%rdx)
  801532:	eb 17                	jmp    80154b <getuint+0xb3>
  801534:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801538:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80153c:	48 89 d0             	mov    %rdx,%rax
  80153f:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  801543:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801547:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  80154b:	48 8b 00             	mov    (%rax),%rax
  80154e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  801552:	eb 4e                	jmp    8015a2 <getuint+0x10a>
	else
		x= va_arg(*ap, unsigned int);
  801554:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801558:	8b 00                	mov    (%rax),%eax
  80155a:	83 f8 30             	cmp    $0x30,%eax
  80155d:	73 24                	jae    801583 <getuint+0xeb>
  80155f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801563:	48 8b 50 10          	mov    0x10(%rax),%rdx
  801567:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80156b:	8b 00                	mov    (%rax),%eax
  80156d:	89 c0                	mov    %eax,%eax
  80156f:	48 01 d0             	add    %rdx,%rax
  801572:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801576:	8b 12                	mov    (%rdx),%edx
  801578:	8d 4a 08             	lea    0x8(%rdx),%ecx
  80157b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80157f:	89 0a                	mov    %ecx,(%rdx)
  801581:	eb 17                	jmp    80159a <getuint+0x102>
  801583:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801587:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80158b:	48 89 d0             	mov    %rdx,%rax
  80158e:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  801592:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801596:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  80159a:	8b 00                	mov    (%rax),%eax
  80159c:	89 c0                	mov    %eax,%eax
  80159e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  8015a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8015a6:	c9                   	leaveq 
  8015a7:	c3                   	retq   

00000000008015a8 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  8015a8:	55                   	push   %rbp
  8015a9:	48 89 e5             	mov    %rsp,%rbp
  8015ac:	48 83 ec 20          	sub    $0x20,%rsp
  8015b0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8015b4:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  8015b7:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  8015bb:	7e 52                	jle    80160f <getint+0x67>
		x=va_arg(*ap, long long);
  8015bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8015c1:	8b 00                	mov    (%rax),%eax
  8015c3:	83 f8 30             	cmp    $0x30,%eax
  8015c6:	73 24                	jae    8015ec <getint+0x44>
  8015c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8015cc:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8015d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8015d4:	8b 00                	mov    (%rax),%eax
  8015d6:	89 c0                	mov    %eax,%eax
  8015d8:	48 01 d0             	add    %rdx,%rax
  8015db:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8015df:	8b 12                	mov    (%rdx),%edx
  8015e1:	8d 4a 08             	lea    0x8(%rdx),%ecx
  8015e4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8015e8:	89 0a                	mov    %ecx,(%rdx)
  8015ea:	eb 17                	jmp    801603 <getint+0x5b>
  8015ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8015f0:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8015f4:	48 89 d0             	mov    %rdx,%rax
  8015f7:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  8015fb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8015ff:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  801603:	48 8b 00             	mov    (%rax),%rax
  801606:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80160a:	e9 a3 00 00 00       	jmpq   8016b2 <getint+0x10a>
	else if (lflag)
  80160f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  801613:	74 4f                	je     801664 <getint+0xbc>
		x=va_arg(*ap, long);
  801615:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801619:	8b 00                	mov    (%rax),%eax
  80161b:	83 f8 30             	cmp    $0x30,%eax
  80161e:	73 24                	jae    801644 <getint+0x9c>
  801620:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801624:	48 8b 50 10          	mov    0x10(%rax),%rdx
  801628:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80162c:	8b 00                	mov    (%rax),%eax
  80162e:	89 c0                	mov    %eax,%eax
  801630:	48 01 d0             	add    %rdx,%rax
  801633:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801637:	8b 12                	mov    (%rdx),%edx
  801639:	8d 4a 08             	lea    0x8(%rdx),%ecx
  80163c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801640:	89 0a                	mov    %ecx,(%rdx)
  801642:	eb 17                	jmp    80165b <getint+0xb3>
  801644:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801648:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80164c:	48 89 d0             	mov    %rdx,%rax
  80164f:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  801653:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801657:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  80165b:	48 8b 00             	mov    (%rax),%rax
  80165e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  801662:	eb 4e                	jmp    8016b2 <getint+0x10a>
	else
		x=va_arg(*ap, int);
  801664:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801668:	8b 00                	mov    (%rax),%eax
  80166a:	83 f8 30             	cmp    $0x30,%eax
  80166d:	73 24                	jae    801693 <getint+0xeb>
  80166f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801673:	48 8b 50 10          	mov    0x10(%rax),%rdx
  801677:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80167b:	8b 00                	mov    (%rax),%eax
  80167d:	89 c0                	mov    %eax,%eax
  80167f:	48 01 d0             	add    %rdx,%rax
  801682:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801686:	8b 12                	mov    (%rdx),%edx
  801688:	8d 4a 08             	lea    0x8(%rdx),%ecx
  80168b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80168f:	89 0a                	mov    %ecx,(%rdx)
  801691:	eb 17                	jmp    8016aa <getint+0x102>
  801693:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801697:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80169b:	48 89 d0             	mov    %rdx,%rax
  80169e:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  8016a2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8016a6:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  8016aa:	8b 00                	mov    (%rax),%eax
  8016ac:	48 98                	cltq   
  8016ae:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  8016b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8016b6:	c9                   	leaveq 
  8016b7:	c3                   	retq   

00000000008016b8 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  8016b8:	55                   	push   %rbp
  8016b9:	48 89 e5             	mov    %rsp,%rbp
  8016bc:	41 54                	push   %r12
  8016be:	53                   	push   %rbx
  8016bf:	48 83 ec 60          	sub    $0x60,%rsp
  8016c3:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8016c7:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8016cb:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  8016cf:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  8016d3:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  8016d7:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8016db:	48 8b 0a             	mov    (%rdx),%rcx
  8016de:	48 89 08             	mov    %rcx,(%rax)
  8016e1:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8016e5:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8016e9:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8016ed:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  8016f1:	eb 17                	jmp    80170a <vprintfmt+0x52>
			if (ch == '\0')
  8016f3:	85 db                	test   %ebx,%ebx
  8016f5:	0f 84 d7 04 00 00    	je     801bd2 <vprintfmt+0x51a>
				return;
			putch(ch, putdat);
  8016fb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8016ff:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  801703:	48 89 c6             	mov    %rax,%rsi
  801706:	89 df                	mov    %ebx,%edi
  801708:	ff d2                	callq  *%rdx
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80170a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80170e:	0f b6 00             	movzbl (%rax),%eax
  801711:	0f b6 d8             	movzbl %al,%ebx
  801714:	83 fb 25             	cmp    $0x25,%ebx
  801717:	0f 95 c0             	setne  %al
  80171a:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
  80171f:	84 c0                	test   %al,%al
  801721:	75 d0                	jne    8016f3 <vprintfmt+0x3b>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
  801723:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  801727:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  80172e:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  801735:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  80173c:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  801743:	eb 04                	jmp    801749 <vprintfmt+0x91>
			goto process_precision;

		case '.':
			if (width < 0)
				width = 0;
			goto reswitch;
  801745:	90                   	nop
  801746:	eb 01                	jmp    801749 <vprintfmt+0x91>
			goto reswitch;

		process_precision:
			if (width < 0)
				width = precision, precision = -1;
			goto reswitch;
  801748:	90                   	nop
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  801749:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80174d:	0f b6 00             	movzbl (%rax),%eax
  801750:	0f b6 d8             	movzbl %al,%ebx
  801753:	89 d8                	mov    %ebx,%eax
  801755:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
  80175a:	83 e8 23             	sub    $0x23,%eax
  80175d:	83 f8 55             	cmp    $0x55,%eax
  801760:	0f 87 38 04 00 00    	ja     801b9e <vprintfmt+0x4e6>
  801766:	89 c0                	mov    %eax,%eax
  801768:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80176f:	00 
  801770:	48 b8 d0 0c 82 00 00 	movabs $0x820cd0,%rax
  801777:	00 00 00 
  80177a:	48 01 d0             	add    %rdx,%rax
  80177d:	48 8b 00             	mov    (%rax),%rax
  801780:	ff e0                	jmpq   *%rax

		// flag to pad on the right
		case '-':
			padc = '-';
  801782:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  801786:	eb c1                	jmp    801749 <vprintfmt+0x91>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  801788:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  80178c:	eb bb                	jmp    801749 <vprintfmt+0x91>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  80178e:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  801795:	8b 55 d8             	mov    -0x28(%rbp),%edx
  801798:	89 d0                	mov    %edx,%eax
  80179a:	c1 e0 02             	shl    $0x2,%eax
  80179d:	01 d0                	add    %edx,%eax
  80179f:	01 c0                	add    %eax,%eax
  8017a1:	01 d8                	add    %ebx,%eax
  8017a3:	83 e8 30             	sub    $0x30,%eax
  8017a6:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  8017a9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8017ad:	0f b6 00             	movzbl (%rax),%eax
  8017b0:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  8017b3:	83 fb 2f             	cmp    $0x2f,%ebx
  8017b6:	7e 63                	jle    80181b <vprintfmt+0x163>
  8017b8:	83 fb 39             	cmp    $0x39,%ebx
  8017bb:	7f 5e                	jg     80181b <vprintfmt+0x163>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  8017bd:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  8017c2:	eb d1                	jmp    801795 <vprintfmt+0xdd>
			goto process_precision;

		case '*':
			precision = va_arg(aq, int);
  8017c4:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8017c7:	83 f8 30             	cmp    $0x30,%eax
  8017ca:	73 17                	jae    8017e3 <vprintfmt+0x12b>
  8017cc:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8017d0:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8017d3:	89 c0                	mov    %eax,%eax
  8017d5:	48 01 d0             	add    %rdx,%rax
  8017d8:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8017db:	83 c2 08             	add    $0x8,%edx
  8017de:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8017e1:	eb 0f                	jmp    8017f2 <vprintfmt+0x13a>
  8017e3:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8017e7:	48 89 d0             	mov    %rdx,%rax
  8017ea:	48 83 c2 08          	add    $0x8,%rdx
  8017ee:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  8017f2:	8b 00                	mov    (%rax),%eax
  8017f4:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  8017f7:	eb 23                	jmp    80181c <vprintfmt+0x164>

		case '.':
			if (width < 0)
  8017f9:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8017fd:	0f 89 42 ff ff ff    	jns    801745 <vprintfmt+0x8d>
				width = 0;
  801803:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  80180a:	e9 36 ff ff ff       	jmpq   801745 <vprintfmt+0x8d>

		case '#':
			altflag = 1;
  80180f:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  801816:	e9 2e ff ff ff       	jmpq   801749 <vprintfmt+0x91>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
  80181b:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
  80181c:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  801820:	0f 89 22 ff ff ff    	jns    801748 <vprintfmt+0x90>
				width = precision, precision = -1;
  801826:	8b 45 d8             	mov    -0x28(%rbp),%eax
  801829:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80182c:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  801833:	e9 10 ff ff ff       	jmpq   801748 <vprintfmt+0x90>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  801838:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  80183c:	e9 08 ff ff ff       	jmpq   801749 <vprintfmt+0x91>

		// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  801841:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801844:	83 f8 30             	cmp    $0x30,%eax
  801847:	73 17                	jae    801860 <vprintfmt+0x1a8>
  801849:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80184d:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801850:	89 c0                	mov    %eax,%eax
  801852:	48 01 d0             	add    %rdx,%rax
  801855:	8b 55 b8             	mov    -0x48(%rbp),%edx
  801858:	83 c2 08             	add    $0x8,%edx
  80185b:	89 55 b8             	mov    %edx,-0x48(%rbp)
  80185e:	eb 0f                	jmp    80186f <vprintfmt+0x1b7>
  801860:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  801864:	48 89 d0             	mov    %rdx,%rax
  801867:	48 83 c2 08          	add    $0x8,%rdx
  80186b:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  80186f:	8b 00                	mov    (%rax),%eax
  801871:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  801875:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  801879:	48 89 d6             	mov    %rdx,%rsi
  80187c:	89 c7                	mov    %eax,%edi
  80187e:	ff d1                	callq  *%rcx
			break;
  801880:	e9 47 03 00 00       	jmpq   801bcc <vprintfmt+0x514>

		// error message
		case 'e':
			err = va_arg(aq, int);
  801885:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801888:	83 f8 30             	cmp    $0x30,%eax
  80188b:	73 17                	jae    8018a4 <vprintfmt+0x1ec>
  80188d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  801891:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801894:	89 c0                	mov    %eax,%eax
  801896:	48 01 d0             	add    %rdx,%rax
  801899:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80189c:	83 c2 08             	add    $0x8,%edx
  80189f:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8018a2:	eb 0f                	jmp    8018b3 <vprintfmt+0x1fb>
  8018a4:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8018a8:	48 89 d0             	mov    %rdx,%rax
  8018ab:	48 83 c2 08          	add    $0x8,%rdx
  8018af:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  8018b3:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  8018b5:	85 db                	test   %ebx,%ebx
  8018b7:	79 02                	jns    8018bb <vprintfmt+0x203>
				err = -err;
  8018b9:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  8018bb:	83 fb 10             	cmp    $0x10,%ebx
  8018be:	7f 16                	jg     8018d6 <vprintfmt+0x21e>
  8018c0:	48 b8 20 0c 82 00 00 	movabs $0x820c20,%rax
  8018c7:	00 00 00 
  8018ca:	48 63 d3             	movslq %ebx,%rdx
  8018cd:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  8018d1:	4d 85 e4             	test   %r12,%r12
  8018d4:	75 2e                	jne    801904 <vprintfmt+0x24c>
				printfmt(putch, putdat, "error %d", err);
  8018d6:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  8018da:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8018de:	89 d9                	mov    %ebx,%ecx
  8018e0:	48 ba b9 0c 82 00 00 	movabs $0x820cb9,%rdx
  8018e7:	00 00 00 
  8018ea:	48 89 c7             	mov    %rax,%rdi
  8018ed:	b8 00 00 00 00       	mov    $0x0,%eax
  8018f2:	49 b8 dc 1b 80 00 00 	movabs $0x801bdc,%r8
  8018f9:	00 00 00 
  8018fc:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  8018ff:	e9 c8 02 00 00       	jmpq   801bcc <vprintfmt+0x514>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  801904:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  801908:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80190c:	4c 89 e1             	mov    %r12,%rcx
  80190f:	48 ba c2 0c 82 00 00 	movabs $0x820cc2,%rdx
  801916:	00 00 00 
  801919:	48 89 c7             	mov    %rax,%rdi
  80191c:	b8 00 00 00 00       	mov    $0x0,%eax
  801921:	49 b8 dc 1b 80 00 00 	movabs $0x801bdc,%r8
  801928:	00 00 00 
  80192b:	41 ff d0             	callq  *%r8
			break;
  80192e:	e9 99 02 00 00       	jmpq   801bcc <vprintfmt+0x514>

		// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  801933:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801936:	83 f8 30             	cmp    $0x30,%eax
  801939:	73 17                	jae    801952 <vprintfmt+0x29a>
  80193b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80193f:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801942:	89 c0                	mov    %eax,%eax
  801944:	48 01 d0             	add    %rdx,%rax
  801947:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80194a:	83 c2 08             	add    $0x8,%edx
  80194d:	89 55 b8             	mov    %edx,-0x48(%rbp)
  801950:	eb 0f                	jmp    801961 <vprintfmt+0x2a9>
  801952:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  801956:	48 89 d0             	mov    %rdx,%rax
  801959:	48 83 c2 08          	add    $0x8,%rdx
  80195d:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  801961:	4c 8b 20             	mov    (%rax),%r12
  801964:	4d 85 e4             	test   %r12,%r12
  801967:	75 0a                	jne    801973 <vprintfmt+0x2bb>
				p = "(null)";
  801969:	49 bc c5 0c 82 00 00 	movabs $0x820cc5,%r12
  801970:	00 00 00 
			if (width > 0 && padc != '-')
  801973:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  801977:	7e 7a                	jle    8019f3 <vprintfmt+0x33b>
  801979:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  80197d:	74 74                	je     8019f3 <vprintfmt+0x33b>
				for (width -= strnlen(p, precision); width > 0; width--)
  80197f:	8b 45 d8             	mov    -0x28(%rbp),%eax
  801982:	48 98                	cltq   
  801984:	48 89 c6             	mov    %rax,%rsi
  801987:	4c 89 e7             	mov    %r12,%rdi
  80198a:	48 b8 86 1e 80 00 00 	movabs $0x801e86,%rax
  801991:	00 00 00 
  801994:	ff d0                	callq  *%rax
  801996:	29 45 dc             	sub    %eax,-0x24(%rbp)
  801999:	eb 17                	jmp    8019b2 <vprintfmt+0x2fa>
					putch(padc, putdat);
  80199b:	0f be 45 d3          	movsbl -0x2d(%rbp),%eax
  80199f:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8019a3:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8019a7:	48 89 d6             	mov    %rdx,%rsi
  8019aa:	89 c7                	mov    %eax,%edi
  8019ac:	ff d1                	callq  *%rcx
		// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  8019ae:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  8019b2:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8019b6:	7f e3                	jg     80199b <vprintfmt+0x2e3>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  8019b8:	eb 39                	jmp    8019f3 <vprintfmt+0x33b>
				if (altflag && (ch < ' ' || ch > '~'))
  8019ba:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  8019be:	74 1e                	je     8019de <vprintfmt+0x326>
  8019c0:	83 fb 1f             	cmp    $0x1f,%ebx
  8019c3:	7e 05                	jle    8019ca <vprintfmt+0x312>
  8019c5:	83 fb 7e             	cmp    $0x7e,%ebx
  8019c8:	7e 14                	jle    8019de <vprintfmt+0x326>
					putch('?', putdat);
  8019ca:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8019ce:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8019d2:	48 89 c6             	mov    %rax,%rsi
  8019d5:	bf 3f 00 00 00       	mov    $0x3f,%edi
  8019da:	ff d2                	callq  *%rdx
  8019dc:	eb 0f                	jmp    8019ed <vprintfmt+0x335>
				else
					putch(ch, putdat);
  8019de:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8019e2:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8019e6:	48 89 c6             	mov    %rax,%rsi
  8019e9:	89 df                	mov    %ebx,%edi
  8019eb:	ff d2                	callq  *%rdx
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  8019ed:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  8019f1:	eb 01                	jmp    8019f4 <vprintfmt+0x33c>
  8019f3:	90                   	nop
  8019f4:	41 0f b6 04 24       	movzbl (%r12),%eax
  8019f9:	0f be d8             	movsbl %al,%ebx
  8019fc:	85 db                	test   %ebx,%ebx
  8019fe:	0f 95 c0             	setne  %al
  801a01:	49 83 c4 01          	add    $0x1,%r12
  801a05:	84 c0                	test   %al,%al
  801a07:	74 28                	je     801a31 <vprintfmt+0x379>
  801a09:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  801a0d:	78 ab                	js     8019ba <vprintfmt+0x302>
  801a0f:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  801a13:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  801a17:	79 a1                	jns    8019ba <vprintfmt+0x302>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  801a19:	eb 16                	jmp    801a31 <vprintfmt+0x379>
				putch(' ', putdat);
  801a1b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  801a1f:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  801a23:	48 89 c6             	mov    %rax,%rsi
  801a26:	bf 20 00 00 00       	mov    $0x20,%edi
  801a2b:	ff d2                	callq  *%rdx
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  801a2d:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  801a31:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  801a35:	7f e4                	jg     801a1b <vprintfmt+0x363>
				putch(' ', putdat);
			break;
  801a37:	e9 90 01 00 00       	jmpq   801bcc <vprintfmt+0x514>

		// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  801a3c:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  801a40:	be 03 00 00 00       	mov    $0x3,%esi
  801a45:	48 89 c7             	mov    %rax,%rdi
  801a48:	48 b8 a8 15 80 00 00 	movabs $0x8015a8,%rax
  801a4f:	00 00 00 
  801a52:	ff d0                	callq  *%rax
  801a54:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  801a58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801a5c:	48 85 c0             	test   %rax,%rax
  801a5f:	79 1d                	jns    801a7e <vprintfmt+0x3c6>
				putch('-', putdat);
  801a61:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  801a65:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  801a69:	48 89 c6             	mov    %rax,%rsi
  801a6c:	bf 2d 00 00 00       	mov    $0x2d,%edi
  801a71:	ff d2                	callq  *%rdx
				num = -(long long) num;
  801a73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801a77:	48 f7 d8             	neg    %rax
  801a7a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  801a7e:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  801a85:	e9 d5 00 00 00       	jmpq   801b5f <vprintfmt+0x4a7>
                        
			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  801a8a:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  801a8e:	be 03 00 00 00       	mov    $0x3,%esi
  801a93:	48 89 c7             	mov    %rax,%rdi
  801a96:	48 b8 98 14 80 00 00 	movabs $0x801498,%rax
  801a9d:	00 00 00 
  801aa0:	ff d0                	callq  *%rax
  801aa2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  801aa6:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  801aad:	e9 ad 00 00 00       	jmpq   801b5f <vprintfmt+0x4a7>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			num = getuint(&aq, 3);
  801ab2:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  801ab6:	be 03 00 00 00       	mov    $0x3,%esi
  801abb:	48 89 c7             	mov    %rax,%rdi
  801abe:	48 b8 98 14 80 00 00 	movabs $0x801498,%rax
  801ac5:	00 00 00 
  801ac8:	ff d0                	callq  *%rax
  801aca:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                        base = 8;
  801ace:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
			goto number;
  801ad5:	e9 85 00 00 00       	jmpq   801b5f <vprintfmt+0x4a7>
			putch('X', putdat);
		*/	break;

		// pointer
		case 'p':
			putch('0', putdat);
  801ada:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  801ade:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  801ae2:	48 89 c6             	mov    %rax,%rsi
  801ae5:	bf 30 00 00 00       	mov    $0x30,%edi
  801aea:	ff d2                	callq  *%rdx
			putch('x', putdat);
  801aec:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  801af0:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  801af4:	48 89 c6             	mov    %rax,%rsi
  801af7:	bf 78 00 00 00       	mov    $0x78,%edi
  801afc:	ff d2                	callq  *%rdx
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  801afe:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801b01:	83 f8 30             	cmp    $0x30,%eax
  801b04:	73 17                	jae    801b1d <vprintfmt+0x465>
  801b06:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  801b0a:	8b 45 b8             	mov    -0x48(%rbp),%eax
  801b0d:	89 c0                	mov    %eax,%eax
  801b0f:	48 01 d0             	add    %rdx,%rax
  801b12:	8b 55 b8             	mov    -0x48(%rbp),%edx
  801b15:	83 c2 08             	add    $0x8,%edx
  801b18:	89 55 b8             	mov    %edx,-0x48(%rbp)

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  801b1b:	eb 0f                	jmp    801b2c <vprintfmt+0x474>
				(uintptr_t) va_arg(aq, void *);
  801b1d:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  801b21:	48 89 d0             	mov    %rdx,%rax
  801b24:	48 83 c2 08          	add    $0x8,%rdx
  801b28:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  801b2c:	48 8b 00             	mov    (%rax),%rax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  801b2f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  801b33:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  801b3a:	eb 23                	jmp    801b5f <vprintfmt+0x4a7>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  801b3c:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  801b40:	be 03 00 00 00       	mov    $0x3,%esi
  801b45:	48 89 c7             	mov    %rax,%rdi
  801b48:	48 b8 98 14 80 00 00 	movabs $0x801498,%rax
  801b4f:	00 00 00 
  801b52:	ff d0                	callq  *%rax
  801b54:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  801b58:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  801b5f:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  801b64:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  801b67:	8b 7d dc             	mov    -0x24(%rbp),%edi
  801b6a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  801b6e:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  801b72:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  801b76:	45 89 c1             	mov    %r8d,%r9d
  801b79:	41 89 f8             	mov    %edi,%r8d
  801b7c:	48 89 c7             	mov    %rax,%rdi
  801b7f:	48 b8 e0 13 80 00 00 	movabs $0x8013e0,%rax
  801b86:	00 00 00 
  801b89:	ff d0                	callq  *%rax
			break;
  801b8b:	eb 3f                	jmp    801bcc <vprintfmt+0x514>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
  801b8d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  801b91:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  801b95:	48 89 c6             	mov    %rax,%rsi
  801b98:	89 df                	mov    %ebx,%edi
  801b9a:	ff d2                	callq  *%rdx
			break;
  801b9c:	eb 2e                	jmp    801bcc <vprintfmt+0x514>

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  801b9e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  801ba2:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  801ba6:	48 89 c6             	mov    %rax,%rsi
  801ba9:	bf 25 00 00 00       	mov    $0x25,%edi
  801bae:	ff d2                	callq  *%rdx
			for (fmt--; fmt[-1] != '%'; fmt--)
  801bb0:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  801bb5:	eb 05                	jmp    801bbc <vprintfmt+0x504>
  801bb7:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  801bbc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  801bc0:	48 83 e8 01          	sub    $0x1,%rax
  801bc4:	0f b6 00             	movzbl (%rax),%eax
  801bc7:	3c 25                	cmp    $0x25,%al
  801bc9:	75 ec                	jne    801bb7 <vprintfmt+0x4ff>
				/* do nothing */;
			break;
  801bcb:	90                   	nop
		}
	}
  801bcc:	90                   	nop
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  801bcd:	e9 38 fb ff ff       	jmpq   80170a <vprintfmt+0x52>
			if (ch == '\0')
				return;
  801bd2:	90                   	nop
				/* do nothing */;
			break;
		}
	}
    va_end(aq);
}
  801bd3:	48 83 c4 60          	add    $0x60,%rsp
  801bd7:	5b                   	pop    %rbx
  801bd8:	41 5c                	pop    %r12
  801bda:	5d                   	pop    %rbp
  801bdb:	c3                   	retq   

0000000000801bdc <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  801bdc:	55                   	push   %rbp
  801bdd:	48 89 e5             	mov    %rsp,%rbp
  801be0:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  801be7:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  801bee:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  801bf5:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  801bfc:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  801c03:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  801c0a:	84 c0                	test   %al,%al
  801c0c:	74 20                	je     801c2e <printfmt+0x52>
  801c0e:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  801c12:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  801c16:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  801c1a:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  801c1e:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  801c22:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  801c26:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  801c2a:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  801c2e:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  801c35:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  801c3c:	00 00 00 
  801c3f:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  801c46:	00 00 00 
  801c49:	48 8d 45 10          	lea    0x10(%rbp),%rax
  801c4d:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  801c54:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  801c5b:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  801c62:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  801c69:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  801c70:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  801c77:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  801c7e:	48 89 c7             	mov    %rax,%rdi
  801c81:	48 b8 b8 16 80 00 00 	movabs $0x8016b8,%rax
  801c88:	00 00 00 
  801c8b:	ff d0                	callq  *%rax
	va_end(ap);
}
  801c8d:	c9                   	leaveq 
  801c8e:	c3                   	retq   

0000000000801c8f <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  801c8f:	55                   	push   %rbp
  801c90:	48 89 e5             	mov    %rsp,%rbp
  801c93:	48 83 ec 10          	sub    $0x10,%rsp
  801c97:	89 7d fc             	mov    %edi,-0x4(%rbp)
  801c9a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  801c9e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801ca2:	8b 40 10             	mov    0x10(%rax),%eax
  801ca5:	8d 50 01             	lea    0x1(%rax),%edx
  801ca8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801cac:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  801caf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801cb3:	48 8b 10             	mov    (%rax),%rdx
  801cb6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801cba:	48 8b 40 08          	mov    0x8(%rax),%rax
  801cbe:	48 39 c2             	cmp    %rax,%rdx
  801cc1:	73 17                	jae    801cda <sprintputch+0x4b>
		*b->buf++ = ch;
  801cc3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801cc7:	48 8b 00             	mov    (%rax),%rax
  801cca:	8b 55 fc             	mov    -0x4(%rbp),%edx
  801ccd:	88 10                	mov    %dl,(%rax)
  801ccf:	48 8d 50 01          	lea    0x1(%rax),%rdx
  801cd3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  801cd7:	48 89 10             	mov    %rdx,(%rax)
}
  801cda:	c9                   	leaveq 
  801cdb:	c3                   	retq   

0000000000801cdc <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  801cdc:	55                   	push   %rbp
  801cdd:	48 89 e5             	mov    %rsp,%rbp
  801ce0:	48 83 ec 50          	sub    $0x50,%rsp
  801ce4:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  801ce8:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  801ceb:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  801cef:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  801cf3:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  801cf7:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  801cfb:	48 8b 0a             	mov    (%rdx),%rcx
  801cfe:	48 89 08             	mov    %rcx,(%rax)
  801d01:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  801d05:	48 89 48 08          	mov    %rcx,0x8(%rax)
  801d09:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801d0d:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  801d11:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  801d15:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  801d19:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  801d1c:	48 98                	cltq   
  801d1e:	48 83 e8 01          	sub    $0x1,%rax
  801d22:	48 03 45 c8          	add    -0x38(%rbp),%rax
  801d26:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  801d2a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  801d31:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  801d36:	74 06                	je     801d3e <vsnprintf+0x62>
  801d38:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  801d3c:	7f 07                	jg     801d45 <vsnprintf+0x69>
		return -E_INVAL;
  801d3e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  801d43:	eb 2f                	jmp    801d74 <vsnprintf+0x98>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  801d45:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  801d49:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  801d4d:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  801d51:	48 89 c6             	mov    %rax,%rsi
  801d54:	48 bf 8f 1c 80 00 00 	movabs $0x801c8f,%rdi
  801d5b:	00 00 00 
  801d5e:	48 b8 b8 16 80 00 00 	movabs $0x8016b8,%rax
  801d65:	00 00 00 
  801d68:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  801d6a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  801d6e:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  801d71:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  801d74:	c9                   	leaveq 
  801d75:	c3                   	retq   

0000000000801d76 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  801d76:	55                   	push   %rbp
  801d77:	48 89 e5             	mov    %rsp,%rbp
  801d7a:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  801d81:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  801d88:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  801d8e:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  801d95:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  801d9c:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  801da3:	84 c0                	test   %al,%al
  801da5:	74 20                	je     801dc7 <snprintf+0x51>
  801da7:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  801dab:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  801daf:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  801db3:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  801db7:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  801dbb:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  801dbf:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  801dc3:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  801dc7:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  801dce:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  801dd5:	00 00 00 
  801dd8:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  801ddf:	00 00 00 
  801de2:	48 8d 45 10          	lea    0x10(%rbp),%rax
  801de6:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  801ded:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  801df4:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  801dfb:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  801e02:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  801e09:	48 8b 0a             	mov    (%rdx),%rcx
  801e0c:	48 89 08             	mov    %rcx,(%rax)
  801e0f:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  801e13:	48 89 48 08          	mov    %rcx,0x8(%rax)
  801e17:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  801e1b:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  801e1f:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  801e26:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  801e2d:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  801e33:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  801e3a:	48 89 c7             	mov    %rax,%rdi
  801e3d:	48 b8 dc 1c 80 00 00 	movabs $0x801cdc,%rax
  801e44:	00 00 00 
  801e47:	ff d0                	callq  *%rax
  801e49:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  801e4f:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  801e55:	c9                   	leaveq 
  801e56:	c3                   	retq   
	...

0000000000801e58 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  801e58:	55                   	push   %rbp
  801e59:	48 89 e5             	mov    %rsp,%rbp
  801e5c:	48 83 ec 18          	sub    $0x18,%rsp
  801e60:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  801e64:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  801e6b:	eb 09                	jmp    801e76 <strlen+0x1e>
		n++;
  801e6d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  801e71:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  801e76:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801e7a:	0f b6 00             	movzbl (%rax),%eax
  801e7d:	84 c0                	test   %al,%al
  801e7f:	75 ec                	jne    801e6d <strlen+0x15>
		n++;
	return n;
  801e81:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  801e84:	c9                   	leaveq 
  801e85:	c3                   	retq   

0000000000801e86 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  801e86:	55                   	push   %rbp
  801e87:	48 89 e5             	mov    %rsp,%rbp
  801e8a:	48 83 ec 20          	sub    $0x20,%rsp
  801e8e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801e92:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  801e96:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  801e9d:	eb 0e                	jmp    801ead <strnlen+0x27>
		n++;
  801e9f:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  801ea3:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  801ea8:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  801ead:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  801eb2:	74 0b                	je     801ebf <strnlen+0x39>
  801eb4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801eb8:	0f b6 00             	movzbl (%rax),%eax
  801ebb:	84 c0                	test   %al,%al
  801ebd:	75 e0                	jne    801e9f <strnlen+0x19>
		n++;
	return n;
  801ebf:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  801ec2:	c9                   	leaveq 
  801ec3:	c3                   	retq   

0000000000801ec4 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  801ec4:	55                   	push   %rbp
  801ec5:	48 89 e5             	mov    %rsp,%rbp
  801ec8:	48 83 ec 20          	sub    $0x20,%rsp
  801ecc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801ed0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  801ed4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801ed8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  801edc:	90                   	nop
  801edd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801ee1:	0f b6 10             	movzbl (%rax),%edx
  801ee4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801ee8:	88 10                	mov    %dl,(%rax)
  801eea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801eee:	0f b6 00             	movzbl (%rax),%eax
  801ef1:	84 c0                	test   %al,%al
  801ef3:	0f 95 c0             	setne  %al
  801ef6:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  801efb:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
  801f00:	84 c0                	test   %al,%al
  801f02:	75 d9                	jne    801edd <strcpy+0x19>
		/* do nothing */;
	return ret;
  801f04:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  801f08:	c9                   	leaveq 
  801f09:	c3                   	retq   

0000000000801f0a <strcat>:

char *
strcat(char *dst, const char *src)
{
  801f0a:	55                   	push   %rbp
  801f0b:	48 89 e5             	mov    %rsp,%rbp
  801f0e:	48 83 ec 20          	sub    $0x20,%rsp
  801f12:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801f16:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  801f1a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801f1e:	48 89 c7             	mov    %rax,%rdi
  801f21:	48 b8 58 1e 80 00 00 	movabs $0x801e58,%rax
  801f28:	00 00 00 
  801f2b:	ff d0                	callq  *%rax
  801f2d:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  801f30:	8b 45 fc             	mov    -0x4(%rbp),%eax
  801f33:	48 98                	cltq   
  801f35:	48 03 45 e8          	add    -0x18(%rbp),%rax
  801f39:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  801f3d:	48 89 d6             	mov    %rdx,%rsi
  801f40:	48 89 c7             	mov    %rax,%rdi
  801f43:	48 b8 c4 1e 80 00 00 	movabs $0x801ec4,%rax
  801f4a:	00 00 00 
  801f4d:	ff d0                	callq  *%rax
	return dst;
  801f4f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  801f53:	c9                   	leaveq 
  801f54:	c3                   	retq   

0000000000801f55 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  801f55:	55                   	push   %rbp
  801f56:	48 89 e5             	mov    %rsp,%rbp
  801f59:	48 83 ec 28          	sub    $0x28,%rsp
  801f5d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801f61:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  801f65:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  801f69:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801f6d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  801f71:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  801f78:	00 
  801f79:	eb 27                	jmp    801fa2 <strncpy+0x4d>
		*dst++ = *src;
  801f7b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801f7f:	0f b6 10             	movzbl (%rax),%edx
  801f82:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801f86:	88 10                	mov    %dl,(%rax)
  801f88:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  801f8d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801f91:	0f b6 00             	movzbl (%rax),%eax
  801f94:	84 c0                	test   %al,%al
  801f96:	74 05                	je     801f9d <strncpy+0x48>
			src++;
  801f98:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  801f9d:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  801fa2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  801fa6:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  801faa:	72 cf                	jb     801f7b <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  801fac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  801fb0:	c9                   	leaveq 
  801fb1:	c3                   	retq   

0000000000801fb2 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  801fb2:	55                   	push   %rbp
  801fb3:	48 89 e5             	mov    %rsp,%rbp
  801fb6:	48 83 ec 28          	sub    $0x28,%rsp
  801fba:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  801fbe:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  801fc2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  801fc6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801fca:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  801fce:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  801fd3:	74 37                	je     80200c <strlcpy+0x5a>
		while (--size > 0 && *src != '\0')
  801fd5:	eb 17                	jmp    801fee <strlcpy+0x3c>
			*dst++ = *src++;
  801fd7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801fdb:	0f b6 10             	movzbl (%rax),%edx
  801fde:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  801fe2:	88 10                	mov    %dl,(%rax)
  801fe4:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  801fe9:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  801fee:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  801ff3:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  801ff8:	74 0b                	je     802005 <strlcpy+0x53>
  801ffa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  801ffe:	0f b6 00             	movzbl (%rax),%eax
  802001:	84 c0                	test   %al,%al
  802003:	75 d2                	jne    801fd7 <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  802005:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802009:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  80200c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  802010:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802014:	48 89 d1             	mov    %rdx,%rcx
  802017:	48 29 c1             	sub    %rax,%rcx
  80201a:	48 89 c8             	mov    %rcx,%rax
}
  80201d:	c9                   	leaveq 
  80201e:	c3                   	retq   

000000000080201f <strcmp>:

int
strcmp(const char *p, const char *q)
{
  80201f:	55                   	push   %rbp
  802020:	48 89 e5             	mov    %rsp,%rbp
  802023:	48 83 ec 10          	sub    $0x10,%rsp
  802027:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80202b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  80202f:	eb 0a                	jmp    80203b <strcmp+0x1c>
		p++, q++;
  802031:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  802036:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  80203b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80203f:	0f b6 00             	movzbl (%rax),%eax
  802042:	84 c0                	test   %al,%al
  802044:	74 12                	je     802058 <strcmp+0x39>
  802046:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80204a:	0f b6 10             	movzbl (%rax),%edx
  80204d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802051:	0f b6 00             	movzbl (%rax),%eax
  802054:	38 c2                	cmp    %al,%dl
  802056:	74 d9                	je     802031 <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  802058:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80205c:	0f b6 00             	movzbl (%rax),%eax
  80205f:	0f b6 d0             	movzbl %al,%edx
  802062:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802066:	0f b6 00             	movzbl (%rax),%eax
  802069:	0f b6 c0             	movzbl %al,%eax
  80206c:	89 d1                	mov    %edx,%ecx
  80206e:	29 c1                	sub    %eax,%ecx
  802070:	89 c8                	mov    %ecx,%eax
}
  802072:	c9                   	leaveq 
  802073:	c3                   	retq   

0000000000802074 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  802074:	55                   	push   %rbp
  802075:	48 89 e5             	mov    %rsp,%rbp
  802078:	48 83 ec 18          	sub    $0x18,%rsp
  80207c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802080:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  802084:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  802088:	eb 0f                	jmp    802099 <strncmp+0x25>
		n--, p++, q++;
  80208a:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  80208f:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  802094:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  802099:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80209e:	74 1d                	je     8020bd <strncmp+0x49>
  8020a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8020a4:	0f b6 00             	movzbl (%rax),%eax
  8020a7:	84 c0                	test   %al,%al
  8020a9:	74 12                	je     8020bd <strncmp+0x49>
  8020ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8020af:	0f b6 10             	movzbl (%rax),%edx
  8020b2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8020b6:	0f b6 00             	movzbl (%rax),%eax
  8020b9:	38 c2                	cmp    %al,%dl
  8020bb:	74 cd                	je     80208a <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  8020bd:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8020c2:	75 07                	jne    8020cb <strncmp+0x57>
		return 0;
  8020c4:	b8 00 00 00 00       	mov    $0x0,%eax
  8020c9:	eb 1a                	jmp    8020e5 <strncmp+0x71>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  8020cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8020cf:	0f b6 00             	movzbl (%rax),%eax
  8020d2:	0f b6 d0             	movzbl %al,%edx
  8020d5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8020d9:	0f b6 00             	movzbl (%rax),%eax
  8020dc:	0f b6 c0             	movzbl %al,%eax
  8020df:	89 d1                	mov    %edx,%ecx
  8020e1:	29 c1                	sub    %eax,%ecx
  8020e3:	89 c8                	mov    %ecx,%eax
}
  8020e5:	c9                   	leaveq 
  8020e6:	c3                   	retq   

00000000008020e7 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  8020e7:	55                   	push   %rbp
  8020e8:	48 89 e5             	mov    %rsp,%rbp
  8020eb:	48 83 ec 10          	sub    $0x10,%rsp
  8020ef:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8020f3:	89 f0                	mov    %esi,%eax
  8020f5:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  8020f8:	eb 17                	jmp    802111 <strchr+0x2a>
		if (*s == c)
  8020fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8020fe:	0f b6 00             	movzbl (%rax),%eax
  802101:	3a 45 f4             	cmp    -0xc(%rbp),%al
  802104:	75 06                	jne    80210c <strchr+0x25>
			return (char *) s;
  802106:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80210a:	eb 15                	jmp    802121 <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  80210c:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  802111:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802115:	0f b6 00             	movzbl (%rax),%eax
  802118:	84 c0                	test   %al,%al
  80211a:	75 de                	jne    8020fa <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  80211c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802121:	c9                   	leaveq 
  802122:	c3                   	retq   

0000000000802123 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  802123:	55                   	push   %rbp
  802124:	48 89 e5             	mov    %rsp,%rbp
  802127:	48 83 ec 10          	sub    $0x10,%rsp
  80212b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80212f:	89 f0                	mov    %esi,%eax
  802131:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  802134:	eb 11                	jmp    802147 <strfind+0x24>
		if (*s == c)
  802136:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80213a:	0f b6 00             	movzbl (%rax),%eax
  80213d:	3a 45 f4             	cmp    -0xc(%rbp),%al
  802140:	74 12                	je     802154 <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  802142:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  802147:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80214b:	0f b6 00             	movzbl (%rax),%eax
  80214e:	84 c0                	test   %al,%al
  802150:	75 e4                	jne    802136 <strfind+0x13>
  802152:	eb 01                	jmp    802155 <strfind+0x32>
		if (*s == c)
			break;
  802154:	90                   	nop
	return (char *) s;
  802155:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  802159:	c9                   	leaveq 
  80215a:	c3                   	retq   

000000000080215b <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80215b:	55                   	push   %rbp
  80215c:	48 89 e5             	mov    %rsp,%rbp
  80215f:	48 83 ec 18          	sub    $0x18,%rsp
  802163:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802167:	89 75 f4             	mov    %esi,-0xc(%rbp)
  80216a:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  80216e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  802173:	75 06                	jne    80217b <memset+0x20>
		return v;
  802175:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802179:	eb 69                	jmp    8021e4 <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  80217b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80217f:	83 e0 03             	and    $0x3,%eax
  802182:	48 85 c0             	test   %rax,%rax
  802185:	75 48                	jne    8021cf <memset+0x74>
  802187:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80218b:	83 e0 03             	and    $0x3,%eax
  80218e:	48 85 c0             	test   %rax,%rax
  802191:	75 3c                	jne    8021cf <memset+0x74>
		c &= 0xFF;
  802193:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80219a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80219d:	89 c2                	mov    %eax,%edx
  80219f:	c1 e2 18             	shl    $0x18,%edx
  8021a2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8021a5:	c1 e0 10             	shl    $0x10,%eax
  8021a8:	09 c2                	or     %eax,%edx
  8021aa:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8021ad:	c1 e0 08             	shl    $0x8,%eax
  8021b0:	09 d0                	or     %edx,%eax
  8021b2:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
  8021b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8021b9:	48 89 c1             	mov    %rax,%rcx
  8021bc:	48 c1 e9 02          	shr    $0x2,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  8021c0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8021c4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8021c7:	48 89 d7             	mov    %rdx,%rdi
  8021ca:	fc                   	cld    
  8021cb:	f3 ab                	rep stos %eax,%es:(%rdi)
  8021cd:	eb 11                	jmp    8021e0 <memset+0x85>
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  8021cf:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8021d3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8021d6:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8021da:	48 89 d7             	mov    %rdx,%rdi
  8021dd:	fc                   	cld    
  8021de:	f3 aa                	rep stos %al,%es:(%rdi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
  8021e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8021e4:	c9                   	leaveq 
  8021e5:	c3                   	retq   

00000000008021e6 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  8021e6:	55                   	push   %rbp
  8021e7:	48 89 e5             	mov    %rsp,%rbp
  8021ea:	48 83 ec 28          	sub    $0x28,%rsp
  8021ee:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8021f2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8021f6:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  8021fa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8021fe:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  802202:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802206:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  80220a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80220e:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  802212:	0f 83 88 00 00 00    	jae    8022a0 <memmove+0xba>
  802218:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80221c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  802220:	48 01 d0             	add    %rdx,%rax
  802223:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  802227:	76 77                	jbe    8022a0 <memmove+0xba>
		s += n;
  802229:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80222d:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  802231:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802235:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  802239:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80223d:	83 e0 03             	and    $0x3,%eax
  802240:	48 85 c0             	test   %rax,%rax
  802243:	75 3b                	jne    802280 <memmove+0x9a>
  802245:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802249:	83 e0 03             	and    $0x3,%eax
  80224c:	48 85 c0             	test   %rax,%rax
  80224f:	75 2f                	jne    802280 <memmove+0x9a>
  802251:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802255:	83 e0 03             	and    $0x3,%eax
  802258:	48 85 c0             	test   %rax,%rax
  80225b:	75 23                	jne    802280 <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  80225d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802261:	48 83 e8 04          	sub    $0x4,%rax
  802265:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  802269:	48 83 ea 04          	sub    $0x4,%rdx
  80226d:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  802271:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  802275:	48 89 c7             	mov    %rax,%rdi
  802278:	48 89 d6             	mov    %rdx,%rsi
  80227b:	fd                   	std    
  80227c:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  80227e:	eb 1d                	jmp    80229d <memmove+0xb7>
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  802280:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802284:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  802288:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80228c:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  802290:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802294:	48 89 d7             	mov    %rdx,%rdi
  802297:	48 89 c1             	mov    %rax,%rcx
  80229a:	fd                   	std    
  80229b:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80229d:	fc                   	cld    
  80229e:	eb 57                	jmp    8022f7 <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  8022a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8022a4:	83 e0 03             	and    $0x3,%eax
  8022a7:	48 85 c0             	test   %rax,%rax
  8022aa:	75 36                	jne    8022e2 <memmove+0xfc>
  8022ac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8022b0:	83 e0 03             	and    $0x3,%eax
  8022b3:	48 85 c0             	test   %rax,%rax
  8022b6:	75 2a                	jne    8022e2 <memmove+0xfc>
  8022b8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022bc:	83 e0 03             	and    $0x3,%eax
  8022bf:	48 85 c0             	test   %rax,%rax
  8022c2:	75 1e                	jne    8022e2 <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  8022c4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8022c8:	48 89 c1             	mov    %rax,%rcx
  8022cb:	48 c1 e9 02          	shr    $0x2,%rcx
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  8022cf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8022d3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8022d7:	48 89 c7             	mov    %rax,%rdi
  8022da:	48 89 d6             	mov    %rdx,%rsi
  8022dd:	fc                   	cld    
  8022de:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  8022e0:	eb 15                	jmp    8022f7 <memmove+0x111>
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  8022e2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8022e6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8022ea:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8022ee:	48 89 c7             	mov    %rax,%rdi
  8022f1:	48 89 d6             	mov    %rdx,%rsi
  8022f4:	fc                   	cld    
  8022f5:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  8022f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8022fb:	c9                   	leaveq 
  8022fc:	c3                   	retq   

00000000008022fd <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  8022fd:	55                   	push   %rbp
  8022fe:	48 89 e5             	mov    %rsp,%rbp
  802301:	48 83 ec 18          	sub    $0x18,%rsp
  802305:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802309:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80230d:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  802311:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  802315:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  802319:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80231d:	48 89 ce             	mov    %rcx,%rsi
  802320:	48 89 c7             	mov    %rax,%rdi
  802323:	48 b8 e6 21 80 00 00 	movabs $0x8021e6,%rax
  80232a:	00 00 00 
  80232d:	ff d0                	callq  *%rax
}
  80232f:	c9                   	leaveq 
  802330:	c3                   	retq   

0000000000802331 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  802331:	55                   	push   %rbp
  802332:	48 89 e5             	mov    %rsp,%rbp
  802335:	48 83 ec 28          	sub    $0x28,%rsp
  802339:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80233d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  802341:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  802345:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802349:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  80234d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802351:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  802355:	eb 38                	jmp    80238f <memcmp+0x5e>
		if (*s1 != *s2)
  802357:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80235b:	0f b6 10             	movzbl (%rax),%edx
  80235e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802362:	0f b6 00             	movzbl (%rax),%eax
  802365:	38 c2                	cmp    %al,%dl
  802367:	74 1c                	je     802385 <memcmp+0x54>
			return (int) *s1 - (int) *s2;
  802369:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80236d:	0f b6 00             	movzbl (%rax),%eax
  802370:	0f b6 d0             	movzbl %al,%edx
  802373:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802377:	0f b6 00             	movzbl (%rax),%eax
  80237a:	0f b6 c0             	movzbl %al,%eax
  80237d:	89 d1                	mov    %edx,%ecx
  80237f:	29 c1                	sub    %eax,%ecx
  802381:	89 c8                	mov    %ecx,%eax
  802383:	eb 20                	jmp    8023a5 <memcmp+0x74>
		s1++, s2++;
  802385:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  80238a:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80238f:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  802394:	0f 95 c0             	setne  %al
  802397:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  80239c:	84 c0                	test   %al,%al
  80239e:	75 b7                	jne    802357 <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  8023a0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8023a5:	c9                   	leaveq 
  8023a6:	c3                   	retq   

00000000008023a7 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  8023a7:	55                   	push   %rbp
  8023a8:	48 89 e5             	mov    %rsp,%rbp
  8023ab:	48 83 ec 28          	sub    $0x28,%rsp
  8023af:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8023b3:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  8023b6:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  8023ba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8023be:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8023c2:	48 01 d0             	add    %rdx,%rax
  8023c5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  8023c9:	eb 13                	jmp    8023de <memfind+0x37>
		if (*(const unsigned char *) s == (unsigned char) c)
  8023cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8023cf:	0f b6 10             	movzbl (%rax),%edx
  8023d2:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8023d5:	38 c2                	cmp    %al,%dl
  8023d7:	74 11                	je     8023ea <memfind+0x43>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  8023d9:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8023de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8023e2:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8023e6:	72 e3                	jb     8023cb <memfind+0x24>
  8023e8:	eb 01                	jmp    8023eb <memfind+0x44>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
  8023ea:	90                   	nop
	return (void *) s;
  8023eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8023ef:	c9                   	leaveq 
  8023f0:	c3                   	retq   

00000000008023f1 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  8023f1:	55                   	push   %rbp
  8023f2:	48 89 e5             	mov    %rsp,%rbp
  8023f5:	48 83 ec 38          	sub    $0x38,%rsp
  8023f9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8023fd:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  802401:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  802404:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  80240b:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  802412:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  802413:	eb 05                	jmp    80241a <strtol+0x29>
		s++;
  802415:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80241a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80241e:	0f b6 00             	movzbl (%rax),%eax
  802421:	3c 20                	cmp    $0x20,%al
  802423:	74 f0                	je     802415 <strtol+0x24>
  802425:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802429:	0f b6 00             	movzbl (%rax),%eax
  80242c:	3c 09                	cmp    $0x9,%al
  80242e:	74 e5                	je     802415 <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  802430:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802434:	0f b6 00             	movzbl (%rax),%eax
  802437:	3c 2b                	cmp    $0x2b,%al
  802439:	75 07                	jne    802442 <strtol+0x51>
		s++;
  80243b:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  802440:	eb 17                	jmp    802459 <strtol+0x68>
	else if (*s == '-')
  802442:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802446:	0f b6 00             	movzbl (%rax),%eax
  802449:	3c 2d                	cmp    $0x2d,%al
  80244b:	75 0c                	jne    802459 <strtol+0x68>
		s++, neg = 1;
  80244d:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  802452:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  802459:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  80245d:	74 06                	je     802465 <strtol+0x74>
  80245f:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  802463:	75 28                	jne    80248d <strtol+0x9c>
  802465:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802469:	0f b6 00             	movzbl (%rax),%eax
  80246c:	3c 30                	cmp    $0x30,%al
  80246e:	75 1d                	jne    80248d <strtol+0x9c>
  802470:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802474:	48 83 c0 01          	add    $0x1,%rax
  802478:	0f b6 00             	movzbl (%rax),%eax
  80247b:	3c 78                	cmp    $0x78,%al
  80247d:	75 0e                	jne    80248d <strtol+0x9c>
		s += 2, base = 16;
  80247f:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  802484:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  80248b:	eb 2c                	jmp    8024b9 <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  80248d:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  802491:	75 19                	jne    8024ac <strtol+0xbb>
  802493:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802497:	0f b6 00             	movzbl (%rax),%eax
  80249a:	3c 30                	cmp    $0x30,%al
  80249c:	75 0e                	jne    8024ac <strtol+0xbb>
		s++, base = 8;
  80249e:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8024a3:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  8024aa:	eb 0d                	jmp    8024b9 <strtol+0xc8>
	else if (base == 0)
  8024ac:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8024b0:	75 07                	jne    8024b9 <strtol+0xc8>
		base = 10;
  8024b2:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  8024b9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024bd:	0f b6 00             	movzbl (%rax),%eax
  8024c0:	3c 2f                	cmp    $0x2f,%al
  8024c2:	7e 1d                	jle    8024e1 <strtol+0xf0>
  8024c4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024c8:	0f b6 00             	movzbl (%rax),%eax
  8024cb:	3c 39                	cmp    $0x39,%al
  8024cd:	7f 12                	jg     8024e1 <strtol+0xf0>
			dig = *s - '0';
  8024cf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024d3:	0f b6 00             	movzbl (%rax),%eax
  8024d6:	0f be c0             	movsbl %al,%eax
  8024d9:	83 e8 30             	sub    $0x30,%eax
  8024dc:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8024df:	eb 4e                	jmp    80252f <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  8024e1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024e5:	0f b6 00             	movzbl (%rax),%eax
  8024e8:	3c 60                	cmp    $0x60,%al
  8024ea:	7e 1d                	jle    802509 <strtol+0x118>
  8024ec:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024f0:	0f b6 00             	movzbl (%rax),%eax
  8024f3:	3c 7a                	cmp    $0x7a,%al
  8024f5:	7f 12                	jg     802509 <strtol+0x118>
			dig = *s - 'a' + 10;
  8024f7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8024fb:	0f b6 00             	movzbl (%rax),%eax
  8024fe:	0f be c0             	movsbl %al,%eax
  802501:	83 e8 57             	sub    $0x57,%eax
  802504:	89 45 ec             	mov    %eax,-0x14(%rbp)
  802507:	eb 26                	jmp    80252f <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  802509:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80250d:	0f b6 00             	movzbl (%rax),%eax
  802510:	3c 40                	cmp    $0x40,%al
  802512:	7e 47                	jle    80255b <strtol+0x16a>
  802514:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802518:	0f b6 00             	movzbl (%rax),%eax
  80251b:	3c 5a                	cmp    $0x5a,%al
  80251d:	7f 3c                	jg     80255b <strtol+0x16a>
			dig = *s - 'A' + 10;
  80251f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802523:	0f b6 00             	movzbl (%rax),%eax
  802526:	0f be c0             	movsbl %al,%eax
  802529:	83 e8 37             	sub    $0x37,%eax
  80252c:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  80252f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  802532:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  802535:	7d 23                	jge    80255a <strtol+0x169>
			break;
		s++, val = (val * base) + dig;
  802537:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  80253c:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80253f:	48 98                	cltq   
  802541:	48 89 c2             	mov    %rax,%rdx
  802544:	48 0f af 55 f0       	imul   -0x10(%rbp),%rdx
  802549:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80254c:	48 98                	cltq   
  80254e:	48 01 d0             	add    %rdx,%rax
  802551:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  802555:	e9 5f ff ff ff       	jmpq   8024b9 <strtol+0xc8>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
  80255a:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
  80255b:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  802560:	74 0b                	je     80256d <strtol+0x17c>
		*endptr = (char *) s;
  802562:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  802566:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80256a:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  80256d:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  802571:	74 09                	je     80257c <strtol+0x18b>
  802573:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  802577:	48 f7 d8             	neg    %rax
  80257a:	eb 04                	jmp    802580 <strtol+0x18f>
  80257c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  802580:	c9                   	leaveq 
  802581:	c3                   	retq   

0000000000802582 <strstr>:

char * strstr(const char *in, const char *str)
{
  802582:	55                   	push   %rbp
  802583:	48 89 e5             	mov    %rsp,%rbp
  802586:	48 83 ec 30          	sub    $0x30,%rsp
  80258a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80258e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    char c;
    size_t len;

    c = *str++;
  802592:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  802596:	0f b6 00             	movzbl (%rax),%eax
  802599:	88 45 ff             	mov    %al,-0x1(%rbp)
  80259c:	48 83 45 d0 01       	addq   $0x1,-0x30(%rbp)
    if (!c)
  8025a1:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  8025a5:	75 06                	jne    8025ad <strstr+0x2b>
        return (char *) in;	// Trivial empty string case
  8025a7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8025ab:	eb 68                	jmp    802615 <strstr+0x93>

    len = strlen(str);
  8025ad:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8025b1:	48 89 c7             	mov    %rax,%rdi
  8025b4:	48 b8 58 1e 80 00 00 	movabs $0x801e58,%rax
  8025bb:	00 00 00 
  8025be:	ff d0                	callq  *%rax
  8025c0:	48 98                	cltq   
  8025c2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    do {
        char sc;

        do {
            sc = *in++;
  8025c6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8025ca:	0f b6 00             	movzbl (%rax),%eax
  8025cd:	88 45 ef             	mov    %al,-0x11(%rbp)
  8025d0:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
            if (!sc)
  8025d5:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  8025d9:	75 07                	jne    8025e2 <strstr+0x60>
                return (char *) 0;
  8025db:	b8 00 00 00 00       	mov    $0x0,%eax
  8025e0:	eb 33                	jmp    802615 <strstr+0x93>
        } while (sc != c);
  8025e2:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8025e6:	3a 45 ff             	cmp    -0x1(%rbp),%al
  8025e9:	75 db                	jne    8025c6 <strstr+0x44>
    } while (strncmp(in, str, len) != 0);
  8025eb:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8025ef:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8025f3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8025f7:	48 89 ce             	mov    %rcx,%rsi
  8025fa:	48 89 c7             	mov    %rax,%rdi
  8025fd:	48 b8 74 20 80 00 00 	movabs $0x802074,%rax
  802604:	00 00 00 
  802607:	ff d0                	callq  *%rax
  802609:	85 c0                	test   %eax,%eax
  80260b:	75 b9                	jne    8025c6 <strstr+0x44>

    return (char *) (in - 1);
  80260d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802611:	48 83 e8 01          	sub    $0x1,%rax
}
  802615:	c9                   	leaveq 
  802616:	c3                   	retq   
	...

0000000000802618 <syscall>:
#include <inc/syscall.h>
#include <inc/lib.h>

static inline int64_t
syscall(int num, int check, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  802618:	55                   	push   %rbp
  802619:	48 89 e5             	mov    %rsp,%rbp
  80261c:	53                   	push   %rbx
  80261d:	48 83 ec 58          	sub    $0x58,%rsp
  802621:	89 7d dc             	mov    %edi,-0x24(%rbp)
  802624:	89 75 d8             	mov    %esi,-0x28(%rbp)
  802627:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  80262b:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  80262f:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
  802633:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  802637:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80263a:	89 45 ac             	mov    %eax,-0x54(%rbp)
  80263d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  802641:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  802645:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
  802649:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80264d:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  802651:	8b 45 ac             	mov    -0x54(%rbp),%eax
  802654:	4c 89 c3             	mov    %r8,%rbx
  802657:	cd 30                	int    $0x30
  802659:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  80265d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  802661:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");

	if(check && ret > 0)
  802665:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  802669:	74 3e                	je     8026a9 <syscall+0x91>
  80266b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  802670:	7e 37                	jle    8026a9 <syscall+0x91>
		panic("syscall %d returned %d (> 0)", num, ret);
  802672:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  802676:	8b 45 dc             	mov    -0x24(%rbp),%eax
  802679:	49 89 d0             	mov    %rdx,%r8
  80267c:	89 c1                	mov    %eax,%ecx
  80267e:	48 ba 80 0f 82 00 00 	movabs $0x820f80,%rdx
  802685:	00 00 00 
  802688:	be 23 00 00 00       	mov    $0x23,%esi
  80268d:	48 bf 9d 0f 82 00 00 	movabs $0x820f9d,%rdi
  802694:	00 00 00 
  802697:	b8 00 00 00 00       	mov    $0x0,%eax
  80269c:	49 b9 cc 10 80 00 00 	movabs $0x8010cc,%r9
  8026a3:	00 00 00 
  8026a6:	41 ff d1             	callq  *%r9

	return ret;
  8026a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8026ad:	48 83 c4 58          	add    $0x58,%rsp
  8026b1:	5b                   	pop    %rbx
  8026b2:	5d                   	pop    %rbp
  8026b3:	c3                   	retq   

00000000008026b4 <sys_cputs>:

void
sys_cputs(const char *s, size_t len)
{
  8026b4:	55                   	push   %rbp
  8026b5:	48 89 e5             	mov    %rsp,%rbp
  8026b8:	48 83 ec 20          	sub    $0x20,%rsp
  8026bc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8026c0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	syscall(SYS_cputs, 0, (uint64_t)s, len, 0, 0, 0);
  8026c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8026c8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8026cc:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8026d3:	00 
  8026d4:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8026da:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8026e0:	48 89 d1             	mov    %rdx,%rcx
  8026e3:	48 89 c2             	mov    %rax,%rdx
  8026e6:	be 00 00 00 00       	mov    $0x0,%esi
  8026eb:	bf 00 00 00 00       	mov    $0x0,%edi
  8026f0:	48 b8 18 26 80 00 00 	movabs $0x802618,%rax
  8026f7:	00 00 00 
  8026fa:	ff d0                	callq  *%rax
}
  8026fc:	c9                   	leaveq 
  8026fd:	c3                   	retq   

00000000008026fe <sys_cgetc>:

int
sys_cgetc(void)
{
  8026fe:	55                   	push   %rbp
  8026ff:	48 89 e5             	mov    %rsp,%rbp
  802702:	48 83 ec 10          	sub    $0x10,%rsp
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
  802706:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  80270d:	00 
  80270e:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802714:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80271a:	b9 00 00 00 00       	mov    $0x0,%ecx
  80271f:	ba 00 00 00 00       	mov    $0x0,%edx
  802724:	be 00 00 00 00       	mov    $0x0,%esi
  802729:	bf 01 00 00 00       	mov    $0x1,%edi
  80272e:	48 b8 18 26 80 00 00 	movabs $0x802618,%rax
  802735:	00 00 00 
  802738:	ff d0                	callq  *%rax
}
  80273a:	c9                   	leaveq 
  80273b:	c3                   	retq   

000000000080273c <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  80273c:	55                   	push   %rbp
  80273d:	48 89 e5             	mov    %rsp,%rbp
  802740:	48 83 ec 20          	sub    $0x20,%rsp
  802744:	89 7d fc             	mov    %edi,-0x4(%rbp)
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
  802747:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80274a:	48 98                	cltq   
  80274c:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802753:	00 
  802754:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80275a:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802760:	b9 00 00 00 00       	mov    $0x0,%ecx
  802765:	48 89 c2             	mov    %rax,%rdx
  802768:	be 01 00 00 00       	mov    $0x1,%esi
  80276d:	bf 03 00 00 00       	mov    $0x3,%edi
  802772:	48 b8 18 26 80 00 00 	movabs $0x802618,%rax
  802779:	00 00 00 
  80277c:	ff d0                	callq  *%rax
}
  80277e:	c9                   	leaveq 
  80277f:	c3                   	retq   

0000000000802780 <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  802780:	55                   	push   %rbp
  802781:	48 89 e5             	mov    %rsp,%rbp
  802784:	48 83 ec 10          	sub    $0x10,%rsp
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
  802788:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  80278f:	00 
  802790:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802796:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80279c:	b9 00 00 00 00       	mov    $0x0,%ecx
  8027a1:	ba 00 00 00 00       	mov    $0x0,%edx
  8027a6:	be 00 00 00 00       	mov    $0x0,%esi
  8027ab:	bf 02 00 00 00       	mov    $0x2,%edi
  8027b0:	48 b8 18 26 80 00 00 	movabs $0x802618,%rax
  8027b7:	00 00 00 
  8027ba:	ff d0                	callq  *%rax
}
  8027bc:	c9                   	leaveq 
  8027bd:	c3                   	retq   

00000000008027be <sys_yield>:

void
sys_yield(void)
{
  8027be:	55                   	push   %rbp
  8027bf:	48 89 e5             	mov    %rsp,%rbp
  8027c2:	48 83 ec 10          	sub    $0x10,%rsp
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
  8027c6:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8027cd:	00 
  8027ce:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8027d4:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8027da:	b9 00 00 00 00       	mov    $0x0,%ecx
  8027df:	ba 00 00 00 00       	mov    $0x0,%edx
  8027e4:	be 00 00 00 00       	mov    $0x0,%esi
  8027e9:	bf 0b 00 00 00       	mov    $0xb,%edi
  8027ee:	48 b8 18 26 80 00 00 	movabs $0x802618,%rax
  8027f5:	00 00 00 
  8027f8:	ff d0                	callq  *%rax
}
  8027fa:	c9                   	leaveq 
  8027fb:	c3                   	retq   

00000000008027fc <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  8027fc:	55                   	push   %rbp
  8027fd:	48 89 e5             	mov    %rsp,%rbp
  802800:	48 83 ec 20          	sub    $0x20,%rsp
  802804:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802807:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80280b:	89 55 f8             	mov    %edx,-0x8(%rbp)
	return syscall(SYS_page_alloc, 1, envid, (uint64_t) va, perm, 0, 0);
  80280e:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802811:	48 63 c8             	movslq %eax,%rcx
  802814:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802818:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80281b:	48 98                	cltq   
  80281d:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802824:	00 
  802825:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  80282b:	49 89 c8             	mov    %rcx,%r8
  80282e:	48 89 d1             	mov    %rdx,%rcx
  802831:	48 89 c2             	mov    %rax,%rdx
  802834:	be 01 00 00 00       	mov    $0x1,%esi
  802839:	bf 04 00 00 00       	mov    $0x4,%edi
  80283e:	48 b8 18 26 80 00 00 	movabs $0x802618,%rax
  802845:	00 00 00 
  802848:	ff d0                	callq  *%rax
}
  80284a:	c9                   	leaveq 
  80284b:	c3                   	retq   

000000000080284c <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80284c:	55                   	push   %rbp
  80284d:	48 89 e5             	mov    %rsp,%rbp
  802850:	48 83 ec 30          	sub    $0x30,%rsp
  802854:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802857:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80285b:	89 55 f8             	mov    %edx,-0x8(%rbp)
  80285e:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  802862:	44 89 45 e4          	mov    %r8d,-0x1c(%rbp)
	return syscall(SYS_page_map, 1, srcenv, (uint64_t) srcva, dstenv, (uint64_t) dstva, perm);
  802866:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  802869:	48 63 c8             	movslq %eax,%rcx
  80286c:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  802870:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802873:	48 63 f0             	movslq %eax,%rsi
  802876:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80287a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80287d:	48 98                	cltq   
  80287f:	48 89 0c 24          	mov    %rcx,(%rsp)
  802883:	49 89 f9             	mov    %rdi,%r9
  802886:	49 89 f0             	mov    %rsi,%r8
  802889:	48 89 d1             	mov    %rdx,%rcx
  80288c:	48 89 c2             	mov    %rax,%rdx
  80288f:	be 01 00 00 00       	mov    $0x1,%esi
  802894:	bf 05 00 00 00       	mov    $0x5,%edi
  802899:	48 b8 18 26 80 00 00 	movabs $0x802618,%rax
  8028a0:	00 00 00 
  8028a3:	ff d0                	callq  *%rax
}
  8028a5:	c9                   	leaveq 
  8028a6:	c3                   	retq   

00000000008028a7 <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  8028a7:	55                   	push   %rbp
  8028a8:	48 89 e5             	mov    %rsp,%rbp
  8028ab:	48 83 ec 20          	sub    $0x20,%rsp
  8028af:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8028b2:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_page_unmap, 1, envid, (uint64_t) va, 0, 0, 0);
  8028b6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8028ba:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8028bd:	48 98                	cltq   
  8028bf:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8028c6:	00 
  8028c7:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8028cd:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8028d3:	48 89 d1             	mov    %rdx,%rcx
  8028d6:	48 89 c2             	mov    %rax,%rdx
  8028d9:	be 01 00 00 00       	mov    $0x1,%esi
  8028de:	bf 06 00 00 00       	mov    $0x6,%edi
  8028e3:	48 b8 18 26 80 00 00 	movabs $0x802618,%rax
  8028ea:	00 00 00 
  8028ed:	ff d0                	callq  *%rax
}
  8028ef:	c9                   	leaveq 
  8028f0:	c3                   	retq   

00000000008028f1 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  8028f1:	55                   	push   %rbp
  8028f2:	48 89 e5             	mov    %rsp,%rbp
  8028f5:	48 83 ec 20          	sub    $0x20,%rsp
  8028f9:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8028fc:	89 75 f8             	mov    %esi,-0x8(%rbp)
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
  8028ff:	8b 45 f8             	mov    -0x8(%rbp),%eax
  802902:	48 63 d0             	movslq %eax,%rdx
  802905:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802908:	48 98                	cltq   
  80290a:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802911:	00 
  802912:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802918:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80291e:	48 89 d1             	mov    %rdx,%rcx
  802921:	48 89 c2             	mov    %rax,%rdx
  802924:	be 01 00 00 00       	mov    $0x1,%esi
  802929:	bf 08 00 00 00       	mov    $0x8,%edi
  80292e:	48 b8 18 26 80 00 00 	movabs $0x802618,%rax
  802935:	00 00 00 
  802938:	ff d0                	callq  *%rax
}
  80293a:	c9                   	leaveq 
  80293b:	c3                   	retq   

000000000080293c <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80293c:	55                   	push   %rbp
  80293d:	48 89 e5             	mov    %rsp,%rbp
  802940:	48 83 ec 20          	sub    $0x20,%rsp
  802944:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802947:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_env_set_trapframe, 1, envid, (uint64_t) tf, 0, 0, 0);
  80294b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80294f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  802952:	48 98                	cltq   
  802954:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  80295b:	00 
  80295c:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802962:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802968:	48 89 d1             	mov    %rdx,%rcx
  80296b:	48 89 c2             	mov    %rax,%rdx
  80296e:	be 01 00 00 00       	mov    $0x1,%esi
  802973:	bf 09 00 00 00       	mov    $0x9,%edi
  802978:	48 b8 18 26 80 00 00 	movabs $0x802618,%rax
  80297f:	00 00 00 
  802982:	ff d0                	callq  *%rax
}
  802984:	c9                   	leaveq 
  802985:	c3                   	retq   

0000000000802986 <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  802986:	55                   	push   %rbp
  802987:	48 89 e5             	mov    %rsp,%rbp
  80298a:	48 83 ec 20          	sub    $0x20,%rsp
  80298e:	89 7d fc             	mov    %edi,-0x4(%rbp)
  802991:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint64_t) upcall, 0, 0, 0);
  802995:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802999:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80299c:	48 98                	cltq   
  80299e:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8029a5:	00 
  8029a6:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8029ac:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8029b2:	48 89 d1             	mov    %rdx,%rcx
  8029b5:	48 89 c2             	mov    %rax,%rdx
  8029b8:	be 01 00 00 00       	mov    $0x1,%esi
  8029bd:	bf 0a 00 00 00       	mov    $0xa,%edi
  8029c2:	48 b8 18 26 80 00 00 	movabs $0x802618,%rax
  8029c9:	00 00 00 
  8029cc:	ff d0                	callq  *%rax
}
  8029ce:	c9                   	leaveq 
  8029cf:	c3                   	retq   

00000000008029d0 <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint64_t value, void *srcva, int perm)
{
  8029d0:	55                   	push   %rbp
  8029d1:	48 89 e5             	mov    %rsp,%rbp
  8029d4:	48 83 ec 30          	sub    $0x30,%rsp
  8029d8:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8029db:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8029df:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8029e3:	89 4d f8             	mov    %ecx,-0x8(%rbp)
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint64_t) srcva, perm, 0);
  8029e6:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8029e9:	48 63 f0             	movslq %eax,%rsi
  8029ec:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8029f0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8029f3:	48 98                	cltq   
  8029f5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8029f9:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802a00:	00 
  802a01:	49 89 f1             	mov    %rsi,%r9
  802a04:	49 89 c8             	mov    %rcx,%r8
  802a07:	48 89 d1             	mov    %rdx,%rcx
  802a0a:	48 89 c2             	mov    %rax,%rdx
  802a0d:	be 00 00 00 00       	mov    $0x0,%esi
  802a12:	bf 0c 00 00 00       	mov    $0xc,%edi
  802a17:	48 b8 18 26 80 00 00 	movabs $0x802618,%rax
  802a1e:	00 00 00 
  802a21:	ff d0                	callq  *%rax
}
  802a23:	c9                   	leaveq 
  802a24:	c3                   	retq   

0000000000802a25 <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  802a25:	55                   	push   %rbp
  802a26:	48 89 e5             	mov    %rsp,%rbp
  802a29:	48 83 ec 20          	sub    $0x20,%rsp
  802a2d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return syscall(SYS_ipc_recv, 1, (uint64_t)dstva, 0, 0, 0, 0);
  802a31:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802a35:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802a3c:	00 
  802a3d:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802a43:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802a49:	b9 00 00 00 00       	mov    $0x0,%ecx
  802a4e:	48 89 c2             	mov    %rax,%rdx
  802a51:	be 01 00 00 00       	mov    $0x1,%esi
  802a56:	bf 0d 00 00 00       	mov    $0xd,%edi
  802a5b:	48 b8 18 26 80 00 00 	movabs $0x802618,%rax
  802a62:	00 00 00 
  802a65:	ff d0                	callq  *%rax
}
  802a67:	c9                   	leaveq 
  802a68:	c3                   	retq   

0000000000802a69 <sys_time_msec>:

unsigned int
sys_time_msec(void)
{
  802a69:	55                   	push   %rbp
  802a6a:	48 89 e5             	mov    %rsp,%rbp
  802a6d:	48 83 ec 10          	sub    $0x10,%rsp
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
  802a71:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802a78:	00 
  802a79:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802a7f:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802a85:	b9 00 00 00 00       	mov    $0x0,%ecx
  802a8a:	ba 00 00 00 00       	mov    $0x0,%edx
  802a8f:	be 00 00 00 00       	mov    $0x0,%esi
  802a94:	bf 0e 00 00 00       	mov    $0xe,%edi
  802a99:	48 b8 18 26 80 00 00 	movabs $0x802618,%rax
  802aa0:	00 00 00 
  802aa3:	ff d0                	callq  *%rax
}
  802aa5:	c9                   	leaveq 
  802aa6:	c3                   	retq   

0000000000802aa7 <sys_send_packet>:
int
sys_send_packet(void *addr, size_t len)
{
  802aa7:	55                   	push   %rbp
  802aa8:	48 89 e5             	mov    %rsp,%rbp
  802aab:	48 83 ec 20          	sub    $0x20,%rsp
  802aaf:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802ab3:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_send_packet, 0, (uint64_t)addr, (uint64_t)len, 0, 0, 0);
  802ab7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802abb:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802abf:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802ac6:	00 
  802ac7:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802acd:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802ad3:	48 89 d1             	mov    %rdx,%rcx
  802ad6:	48 89 c2             	mov    %rax,%rdx
  802ad9:	be 00 00 00 00       	mov    $0x0,%esi
  802ade:	bf 0f 00 00 00       	mov    $0xf,%edi
  802ae3:	48 b8 18 26 80 00 00 	movabs $0x802618,%rax
  802aea:	00 00 00 
  802aed:	ff d0                	callq  *%rax
}
  802aef:	c9                   	leaveq 
  802af0:	c3                   	retq   

0000000000802af1 <sys_receive_packet>:
int
sys_receive_packet(void *addr, size_t len)
{
  802af1:	55                   	push   %rbp
  802af2:	48 89 e5             	mov    %rsp,%rbp
  802af5:	48 83 ec 20          	sub    $0x20,%rsp
  802af9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  802afd:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	return syscall(SYS_receive_packet, 0, (uint64_t)addr, (uint64_t)len, 0, 0, 0);
  802b01:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802b05:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  802b09:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  802b10:	00 
  802b11:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  802b17:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  802b1d:	48 89 d1             	mov    %rdx,%rcx
  802b20:	48 89 c2             	mov    %rax,%rdx
  802b23:	be 00 00 00 00       	mov    $0x0,%esi
  802b28:	bf 10 00 00 00       	mov    $0x10,%edi
  802b2d:	48 b8 18 26 80 00 00 	movabs $0x802618,%rax
  802b34:	00 00 00 
  802b37:	ff d0                	callq  *%rax
}
  802b39:	c9                   	leaveq 
  802b3a:	c3                   	retq   
	...

0000000000802b3c <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  802b3c:	55                   	push   %rbp
  802b3d:	48 89 e5             	mov    %rsp,%rbp
  802b40:	48 83 ec 30          	sub    $0x30,%rsp
  802b44:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	void *addr = (void *) utf->utf_fault_va;
  802b48:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802b4c:	48 8b 00             	mov    (%rax),%rax
  802b4f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	uint32_t err = utf->utf_err;
  802b53:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  802b57:	48 8b 40 08          	mov    0x8(%rax),%rax
  802b5b:	89 45 f4             	mov    %eax,-0xc(%rbp)
	// Hint:
	//   Use the read-only page table mappings at vpt
	//   (see <inc/memlayout.h>).

	// LAB 4: Your code here.
	if(!(err & FEC_WR) || !(uvpt[VPN(addr)] & PTE_COW))
  802b5e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802b61:	83 e0 02             	and    $0x2,%eax
  802b64:	85 c0                	test   %eax,%eax
  802b66:	74 23                	je     802b8b <pgfault+0x4f>
  802b68:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802b6c:	48 89 c2             	mov    %rax,%rdx
  802b6f:	48 c1 ea 0c          	shr    $0xc,%rdx
  802b73:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  802b7a:	01 00 00 
  802b7d:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802b81:	25 00 08 00 00       	and    $0x800,%eax
  802b86:	48 85 c0             	test   %rax,%rax
  802b89:	75 2a                	jne    802bb5 <pgfault+0x79>
                panic("faulting access not to a write or copy-on-write page");
  802b8b:	48 ba b0 0f 82 00 00 	movabs $0x820fb0,%rdx
  802b92:	00 00 00 
  802b95:	be 1c 00 00 00       	mov    $0x1c,%esi
  802b9a:	48 bf e5 0f 82 00 00 	movabs $0x820fe5,%rdi
  802ba1:	00 00 00 
  802ba4:	b8 00 00 00 00       	mov    $0x0,%eax
  802ba9:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  802bb0:	00 00 00 
  802bb3:	ff d1                	callq  *%rcx
	// Hint:
	//   You should make three system calls.
	//   No need to explicitly delete the old page's mapping.

	// LAB 4: Your code here.
	if((r = sys_page_alloc(0,(void *)PFTEMP,PTE_P|PTE_U|PTE_W))<0)
  802bb5:	ba 07 00 00 00       	mov    $0x7,%edx
  802bba:	be 00 f0 5f 00       	mov    $0x5ff000,%esi
  802bbf:	bf 00 00 00 00       	mov    $0x0,%edi
  802bc4:	48 b8 fc 27 80 00 00 	movabs $0x8027fc,%rax
  802bcb:	00 00 00 
  802bce:	ff d0                	callq  *%rax
  802bd0:	89 45 f0             	mov    %eax,-0x10(%rbp)
  802bd3:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  802bd7:	79 30                	jns    802c09 <pgfault+0xcd>
                panic("panic in pgfault:sys_page_alloc: %e",r);
  802bd9:	8b 45 f0             	mov    -0x10(%rbp),%eax
  802bdc:	89 c1                	mov    %eax,%ecx
  802bde:	48 ba f0 0f 82 00 00 	movabs $0x820ff0,%rdx
  802be5:	00 00 00 
  802be8:	be 26 00 00 00       	mov    $0x26,%esi
  802bed:	48 bf e5 0f 82 00 00 	movabs $0x820fe5,%rdi
  802bf4:	00 00 00 
  802bf7:	b8 00 00 00 00       	mov    $0x0,%eax
  802bfc:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  802c03:	00 00 00 
  802c06:	41 ff d0             	callq  *%r8
	
	memmove((void *)PFTEMP, (void *)(ROUNDDOWN(addr, PGSIZE)), PGSIZE);
  802c09:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802c0d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  802c11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802c15:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  802c1b:	ba 00 10 00 00       	mov    $0x1000,%edx
  802c20:	48 89 c6             	mov    %rax,%rsi
  802c23:	bf 00 f0 5f 00       	mov    $0x5ff000,%edi
  802c28:	48 b8 e6 21 80 00 00 	movabs $0x8021e6,%rax
  802c2f:	00 00 00 
  802c32:	ff d0                	callq  *%rax
	
	if((r = sys_page_map(0,(void *)PFTEMP,0,ROUNDDOWN(addr,PGSIZE),PTE_P|PTE_U|PTE_W))<0)
  802c34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802c38:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  802c3c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  802c40:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  802c46:	41 b8 07 00 00 00    	mov    $0x7,%r8d
  802c4c:	48 89 c1             	mov    %rax,%rcx
  802c4f:	ba 00 00 00 00       	mov    $0x0,%edx
  802c54:	be 00 f0 5f 00       	mov    $0x5ff000,%esi
  802c59:	bf 00 00 00 00       	mov    $0x0,%edi
  802c5e:	48 b8 4c 28 80 00 00 	movabs $0x80284c,%rax
  802c65:	00 00 00 
  802c68:	ff d0                	callq  *%rax
  802c6a:	89 45 f0             	mov    %eax,-0x10(%rbp)
  802c6d:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  802c71:	79 30                	jns    802ca3 <pgfault+0x167>
                panic("panic in pgfault:sys_page_map:%e",r);
  802c73:	8b 45 f0             	mov    -0x10(%rbp),%eax
  802c76:	89 c1                	mov    %eax,%ecx
  802c78:	48 ba 18 10 82 00 00 	movabs $0x821018,%rdx
  802c7f:	00 00 00 
  802c82:	be 2b 00 00 00       	mov    $0x2b,%esi
  802c87:	48 bf e5 0f 82 00 00 	movabs $0x820fe5,%rdi
  802c8e:	00 00 00 
  802c91:	b8 00 00 00 00       	mov    $0x0,%eax
  802c96:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  802c9d:	00 00 00 
  802ca0:	41 ff d0             	callq  *%r8

	if((r = sys_page_unmap(0,(void *)PFTEMP))<0)
  802ca3:	be 00 f0 5f 00       	mov    $0x5ff000,%esi
  802ca8:	bf 00 00 00 00       	mov    $0x0,%edi
  802cad:	48 b8 a7 28 80 00 00 	movabs $0x8028a7,%rax
  802cb4:	00 00 00 
  802cb7:	ff d0                	callq  *%rax
  802cb9:	89 45 f0             	mov    %eax,-0x10(%rbp)
  802cbc:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  802cc0:	79 30                	jns    802cf2 <pgfault+0x1b6>
                panic("panic in pgfault:sys_page_unmap:%e",r);
  802cc2:	8b 45 f0             	mov    -0x10(%rbp),%eax
  802cc5:	89 c1                	mov    %eax,%ecx
  802cc7:	48 ba 40 10 82 00 00 	movabs $0x821040,%rdx
  802cce:	00 00 00 
  802cd1:	be 2e 00 00 00       	mov    $0x2e,%esi
  802cd6:	48 bf e5 0f 82 00 00 	movabs $0x820fe5,%rdi
  802cdd:	00 00 00 
  802ce0:	b8 00 00 00 00       	mov    $0x0,%eax
  802ce5:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  802cec:	00 00 00 
  802cef:	41 ff d0             	callq  *%r8
	
}
  802cf2:	c9                   	leaveq 
  802cf3:	c3                   	retq   

0000000000802cf4 <duppage>:
// Returns: 0 on success, < 0 on error.
// It is also OK to panic on error.
//
static int
duppage(envid_t envid, unsigned pn)
{
  802cf4:	55                   	push   %rbp
  802cf5:	48 89 e5             	mov    %rsp,%rbp
  802cf8:	48 83 ec 30          	sub    $0x30,%rsp
  802cfc:	89 7d dc             	mov    %edi,-0x24(%rbp)
  802cff:	89 75 d8             	mov    %esi,-0x28(%rbp)
	// LAB 4: Your code here.
	void* addr;
	pte_t pte;
	int r,perm;
	pte = uvpt[pn];
  802d02:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  802d09:	01 00 00 
  802d0c:	8b 55 d8             	mov    -0x28(%rbp),%edx
  802d0f:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  802d13:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	perm  = pte & PTE_SYSCALL;
  802d17:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  802d1b:	25 07 0e 00 00       	and    $0xe07,%eax
  802d20:	89 45 f4             	mov    %eax,-0xc(%rbp)
	addr = (void*)((uintptr_t)pn * PGSIZE);
  802d23:	8b 45 d8             	mov    -0x28(%rbp),%eax
  802d26:	48 c1 e0 0c          	shl    $0xc,%rax
  802d2a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	//cprintf("addr:%08x\tpte:%08x\tPTE_SYSCALL:%08x\tpte&PTE_SYSCALL:%08x\tPTE_SHARE:%08x\n",addr,pte,PTE_SYSCALL,pte&PTE_SYSCALL,PTE_SHARE);
	//shared page
	if(perm & PTE_SHARE)
  802d2e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802d31:	25 00 04 00 00       	and    $0x400,%eax
  802d36:	85 c0                	test   %eax,%eax
  802d38:	74 5c                	je     802d96 <duppage+0xa2>
	{
                r = sys_page_map(0, addr, envid, addr, perm);
  802d3a:	8b 75 f4             	mov    -0xc(%rbp),%esi
  802d3d:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  802d41:	8b 55 dc             	mov    -0x24(%rbp),%edx
  802d44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802d48:	41 89 f0             	mov    %esi,%r8d
  802d4b:	48 89 c6             	mov    %rax,%rsi
  802d4e:	bf 00 00 00 00       	mov    $0x0,%edi
  802d53:	48 b8 4c 28 80 00 00 	movabs $0x80284c,%rax
  802d5a:	00 00 00 
  802d5d:	ff d0                	callq  *%rax
  802d5f:	89 45 e4             	mov    %eax,-0x1c(%rbp)
                if (r<0)
  802d62:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  802d66:	0f 89 60 01 00 00    	jns    802ecc <duppage+0x1d8>
                        panic("panic in duppage:sys_page_map:shared page");
  802d6c:	48 ba 68 10 82 00 00 	movabs $0x821068,%rdx
  802d73:	00 00 00 
  802d76:	be 4d 00 00 00       	mov    $0x4d,%esi
  802d7b:	48 bf e5 0f 82 00 00 	movabs $0x820fe5,%rdi
  802d82:	00 00 00 
  802d85:	b8 00 00 00 00       	mov    $0x0,%eax
  802d8a:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  802d91:	00 00 00 
  802d94:	ff d1                	callq  *%rcx
        }
	//page with PTE_W or PTE_COW set
	else if(((perm & PTE_W) || (perm & PTE_COW))) 
  802d96:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802d99:	83 e0 02             	and    $0x2,%eax
  802d9c:	85 c0                	test   %eax,%eax
  802d9e:	75 10                	jne    802db0 <duppage+0xbc>
  802da0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  802da3:	25 00 08 00 00       	and    $0x800,%eax
  802da8:	85 c0                	test   %eax,%eax
  802daa:	0f 84 c4 00 00 00    	je     802e74 <duppage+0x180>
	{
		perm |= PTE_COW;
  802db0:	81 4d f4 00 08 00 00 	orl    $0x800,-0xc(%rbp)
		perm &= ~PTE_W;
  802db7:	83 65 f4 fd          	andl   $0xfffffffd,-0xc(%rbp)
		r = sys_page_map(0, addr, envid, addr, perm); 
  802dbb:	8b 75 f4             	mov    -0xc(%rbp),%esi
  802dbe:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  802dc2:	8b 55 dc             	mov    -0x24(%rbp),%edx
  802dc5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802dc9:	41 89 f0             	mov    %esi,%r8d
  802dcc:	48 89 c6             	mov    %rax,%rsi
  802dcf:	bf 00 00 00 00       	mov    $0x0,%edi
  802dd4:	48 b8 4c 28 80 00 00 	movabs $0x80284c,%rax
  802ddb:	00 00 00 
  802dde:	ff d0                	callq  *%rax
  802de0:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if(r<0) 
  802de3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  802de7:	79 2a                	jns    802e13 <duppage+0x11f>
	 		panic("panic in duppage:sys_page_map:PTE_W or PTE_COW page"); 
  802de9:	48 ba 98 10 82 00 00 	movabs $0x821098,%rdx
  802df0:	00 00 00 
  802df3:	be 56 00 00 00       	mov    $0x56,%esi
  802df8:	48 bf e5 0f 82 00 00 	movabs $0x820fe5,%rdi
  802dff:	00 00 00 
  802e02:	b8 00 00 00 00       	mov    $0x0,%eax
  802e07:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  802e0e:	00 00 00 
  802e11:	ff d1                	callq  *%rcx
		r = sys_page_map(0, addr, 0, addr, perm);
  802e13:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  802e16:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  802e1a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802e1e:	41 89 c8             	mov    %ecx,%r8d
  802e21:	48 89 d1             	mov    %rdx,%rcx
  802e24:	ba 00 00 00 00       	mov    $0x0,%edx
  802e29:	48 89 c6             	mov    %rax,%rsi
  802e2c:	bf 00 00 00 00       	mov    $0x0,%edi
  802e31:	48 b8 4c 28 80 00 00 	movabs $0x80284c,%rax
  802e38:	00 00 00 
  802e3b:	ff d0                	callq  *%rax
  802e3d:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    		if (r<0) 
  802e40:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  802e44:	0f 89 82 00 00 00    	jns    802ecc <duppage+0x1d8>
      			panic("panic in duppage:sys_page_map:PTE_W or PTE_COW page");
  802e4a:	48 ba 98 10 82 00 00 	movabs $0x821098,%rdx
  802e51:	00 00 00 
  802e54:	be 59 00 00 00       	mov    $0x59,%esi
  802e59:	48 bf e5 0f 82 00 00 	movabs $0x820fe5,%rdi
  802e60:	00 00 00 
  802e63:	b8 00 00 00 00       	mov    $0x0,%eax
  802e68:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  802e6f:	00 00 00 
  802e72:	ff d1                	callq  *%rcx
	}
	//read-only page
	else 
	{
		r = sys_page_map(0, addr, envid, addr, perm);
  802e74:	8b 75 f4             	mov    -0xc(%rbp),%esi
  802e77:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  802e7b:	8b 55 dc             	mov    -0x24(%rbp),%edx
  802e7e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  802e82:	41 89 f0             	mov    %esi,%r8d
  802e85:	48 89 c6             	mov    %rax,%rsi
  802e88:	bf 00 00 00 00       	mov    $0x0,%edi
  802e8d:	48 b8 4c 28 80 00 00 	movabs $0x80284c,%rax
  802e94:	00 00 00 
  802e97:	ff d0                	callq  *%rax
  802e99:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    		if (r<0) 
  802e9c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  802ea0:	79 2a                	jns    802ecc <duppage+0x1d8>
      			panic("duppage:sys_page_map:read-only-page");
  802ea2:	48 ba d0 10 82 00 00 	movabs $0x8210d0,%rdx
  802ea9:	00 00 00 
  802eac:	be 60 00 00 00       	mov    $0x60,%esi
  802eb1:	48 bf e5 0f 82 00 00 	movabs $0x820fe5,%rdi
  802eb8:	00 00 00 
  802ebb:	b8 00 00 00 00       	mov    $0x0,%eax
  802ec0:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  802ec7:	00 00 00 
  802eca:	ff d1                	callq  *%rcx
	}
	return 0;
  802ecc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802ed1:	c9                   	leaveq 
  802ed2:	c3                   	retq   

0000000000802ed3 <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  802ed3:	55                   	push   %rbp
  802ed4:	48 89 e5             	mov    %rsp,%rbp
  802ed7:	53                   	push   %rbx
  802ed8:	48 83 ec 48          	sub    $0x48,%rsp
	// LAB 4: Your code here.
	set_pgfault_handler(pgfault);
  802edc:	48 bf 3c 2b 80 00 00 	movabs $0x802b3c,%rdi
  802ee3:	00 00 00 
  802ee6:	48 b8 24 57 80 00 00 	movabs $0x805724,%rax
  802eed:	00 00 00 
  802ef0:	ff d0                	callq  *%rax
// This must be inlined.  Exercise for reader: why?
static __inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	__asm __volatile("int %2"
  802ef2:	c7 45 bc 07 00 00 00 	movl   $0x7,-0x44(%rbp)
  802ef9:	8b 45 bc             	mov    -0x44(%rbp),%eax
  802efc:	cd 30                	int    $0x30
  802efe:	89 c3                	mov    %eax,%ebx
  802f00:	89 5d c4             	mov    %ebx,-0x3c(%rbp)
		: "=a" (ret)
		: "a" (SYS_exofork),
		  "i" (T_SYSCALL)
	);
	return ret;
  802f03:	8b 45 c4             	mov    -0x3c(%rbp),%eax
	extern void _pgfault_upcall(void);
	envid_t envid; 
	uint64_t addr;
	int r;
	envid = sys_exofork();
  802f06:	89 45 d4             	mov    %eax,-0x2c(%rbp)
   	if (envid < 0)
  802f09:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  802f0d:	79 30                	jns    802f3f <fork+0x6c>
                panic("sys_exofork: %e", envid);
  802f0f:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  802f12:	89 c1                	mov    %eax,%ecx
  802f14:	48 ba f4 10 82 00 00 	movabs $0x8210f4,%rdx
  802f1b:	00 00 00 
  802f1e:	be 7f 00 00 00       	mov    $0x7f,%esi
  802f23:	48 bf e5 0f 82 00 00 	movabs $0x820fe5,%rdi
  802f2a:	00 00 00 
  802f2d:	b8 00 00 00 00       	mov    $0x0,%eax
  802f32:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  802f39:	00 00 00 
  802f3c:	41 ff d0             	callq  *%r8
        if (envid == 0) 
  802f3f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  802f43:	75 4c                	jne    802f91 <fork+0xbe>
	{
                // We're the child.
                // The copied value of the global variable 'thisenv'
                // is no longer valid (it refers to the parent!).
                // Fix it and return 0.
                thisenv = &envs[ENVX(sys_getenvid())];
  802f45:	48 b8 80 27 80 00 00 	movabs $0x802780,%rax
  802f4c:	00 00 00 
  802f4f:	ff d0                	callq  *%rax
  802f51:	48 98                	cltq   
  802f53:	48 89 c2             	mov    %rax,%rdx
  802f56:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
  802f5c:	48 89 d0             	mov    %rdx,%rax
  802f5f:	48 c1 e0 03          	shl    $0x3,%rax
  802f63:	48 01 d0             	add    %rdx,%rax
  802f66:	48 c1 e0 05          	shl    $0x5,%rax
  802f6a:	48 89 c2             	mov    %rax,%rdx
  802f6d:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  802f74:	00 00 00 
  802f77:	48 01 c2             	add    %rax,%rdx
  802f7a:	48 b8 10 76 b5 00 00 	movabs $0xb57610,%rax
  802f81:	00 00 00 
  802f84:	48 89 10             	mov    %rdx,(%rax)
                return 0;
  802f87:	b8 00 00 00 00       	mov    $0x0,%eax
  802f8c:	e9 38 02 00 00       	jmpq   8031c9 <fork+0x2f6>
        }
	r=sys_page_alloc(envid,(void *)(UXSTACKTOP-PGSIZE),PTE_U|PTE_P|PTE_W);
  802f91:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  802f94:	ba 07 00 00 00       	mov    $0x7,%edx
  802f99:	be 00 f0 7f ef       	mov    $0xef7ff000,%esi
  802f9e:	89 c7                	mov    %eax,%edi
  802fa0:	48 b8 fc 27 80 00 00 	movabs $0x8027fc,%rax
  802fa7:	00 00 00 
  802faa:	ff d0                	callq  *%rax
  802fac:	89 45 d0             	mov    %eax,-0x30(%rbp)
	if (r < 0)
  802faf:	83 7d d0 00          	cmpl   $0x0,-0x30(%rbp)
  802fb3:	79 30                	jns    802fe5 <fork+0x112>
    		panic("panic in fork:sys_page_alloc:%e",r);
  802fb5:	8b 45 d0             	mov    -0x30(%rbp),%eax
  802fb8:	89 c1                	mov    %eax,%ecx
  802fba:	48 ba 08 11 82 00 00 	movabs $0x821108,%rdx
  802fc1:	00 00 00 
  802fc4:	be 8b 00 00 00       	mov    $0x8b,%esi
  802fc9:	48 bf e5 0f 82 00 00 	movabs $0x820fe5,%rdi
  802fd0:	00 00 00 
  802fd3:	b8 00 00 00 00       	mov    $0x0,%eax
  802fd8:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  802fdf:	00 00 00 
  802fe2:	41 ff d0             	callq  *%r8
	int vpml4e_entries,vpdpe_entries,a,b,c,d,c1,d1;
	vpml4e_entries = VPML4E(UTOP);
  802fe5:	c7 45 cc 01 00 00 00 	movl   $0x1,-0x34(%rbp)
	vpdpe_entries = VPDPE(UTOP);
  802fec:	c7 45 c8 00 02 00 00 	movl   $0x200,-0x38(%rbp)
	for(c1=0,d1=0,a=0;a<vpml4e_entries;a++)
  802ff3:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
  802ffa:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
  803001:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  803008:	e9 0a 01 00 00       	jmpq   803117 <fork+0x244>
	{
		if(uvpml4e[a] & PTE_P)
  80300d:	48 b8 00 20 40 80 00 	movabs $0x10080402000,%rax
  803014:	01 00 00 
  803017:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80301a:	48 63 d2             	movslq %edx,%rdx
  80301d:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803021:	83 e0 01             	and    $0x1,%eax
  803024:	84 c0                	test   %al,%al
  803026:	0f 84 e7 00 00 00    	je     803113 <fork+0x240>
		{
			for(b=0;b<vpdpe_entries;b++)
  80302c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
  803033:	e9 cf 00 00 00       	jmpq   803107 <fork+0x234>
			{
				if(uvpde[b] & PTE_P)
  803038:	48 b8 00 00 40 80 00 	movabs $0x10080400000,%rax
  80303f:	01 00 00 
  803042:	8b 55 e8             	mov    -0x18(%rbp),%edx
  803045:	48 63 d2             	movslq %edx,%rdx
  803048:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80304c:	83 e0 01             	and    $0x1,%eax
  80304f:	84 c0                	test   %al,%al
  803051:	0f 84 a0 00 00 00    	je     8030f7 <fork+0x224>
				{
					for(c=0;c<NPDENTRIES;c++,c1++)
  803057:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  80305e:	e9 85 00 00 00       	jmpq   8030e8 <fork+0x215>
					{
						if(uvpd[c1] & PTE_P)
  803063:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  80306a:	01 00 00 
  80306d:	8b 55 dc             	mov    -0x24(%rbp),%edx
  803070:	48 63 d2             	movslq %edx,%rdx
  803073:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803077:	83 e0 01             	and    $0x1,%eax
  80307a:	84 c0                	test   %al,%al
  80307c:	74 56                	je     8030d4 <fork+0x201>
						{
							for(d=0;d<NPTENTRIES;d++,d1++)
  80307e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
  803085:	eb 42                	jmp    8030c9 <fork+0x1f6>
							{
								if((uvpt[d1] & PTE_P) && (d1 != VPN(UXSTACKTOP-PGSIZE)))
  803087:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  80308e:	01 00 00 
  803091:	8b 55 d8             	mov    -0x28(%rbp),%edx
  803094:	48 63 d2             	movslq %edx,%rdx
  803097:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80309b:	83 e0 01             	and    $0x1,%eax
  80309e:	84 c0                	test   %al,%al
  8030a0:	74 1f                	je     8030c1 <fork+0x1ee>
  8030a2:	81 7d d8 ff f7 0e 00 	cmpl   $0xef7ff,-0x28(%rbp)
  8030a9:	74 16                	je     8030c1 <fork+0x1ee>
									 duppage(envid,d1);
  8030ab:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8030ae:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8030b1:	89 d6                	mov    %edx,%esi
  8030b3:	89 c7                	mov    %eax,%edi
  8030b5:	48 b8 f4 2c 80 00 00 	movabs $0x802cf4,%rax
  8030bc:	00 00 00 
  8030bf:	ff d0                	callq  *%rax
				{
					for(c=0;c<NPDENTRIES;c++,c1++)
					{
						if(uvpd[c1] & PTE_P)
						{
							for(d=0;d<NPTENTRIES;d++,d1++)
  8030c1:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
  8030c5:	83 45 d8 01          	addl   $0x1,-0x28(%rbp)
  8030c9:	81 7d e0 ff 01 00 00 	cmpl   $0x1ff,-0x20(%rbp)
  8030d0:	7e b5                	jle    803087 <fork+0x1b4>
  8030d2:	eb 0c                	jmp    8030e0 <fork+0x20d>
								if((uvpt[d1] & PTE_P) && (d1 != VPN(UXSTACKTOP-PGSIZE)))
									 duppage(envid,d1);
							}
						}
						else
							d1=(c1+1)*NPTENTRIES;
  8030d4:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8030d7:	83 c0 01             	add    $0x1,%eax
  8030da:	c1 e0 09             	shl    $0x9,%eax
  8030dd:	89 45 d8             	mov    %eax,-0x28(%rbp)
		{
			for(b=0;b<vpdpe_entries;b++)
			{
				if(uvpde[b] & PTE_P)
				{
					for(c=0;c<NPDENTRIES;c++,c1++)
  8030e0:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
  8030e4:	83 45 dc 01          	addl   $0x1,-0x24(%rbp)
  8030e8:	81 7d e4 ff 01 00 00 	cmpl   $0x1ff,-0x1c(%rbp)
  8030ef:	0f 8e 6e ff ff ff    	jle    803063 <fork+0x190>
  8030f5:	eb 0c                	jmp    803103 <fork+0x230>
						else
							d1=(c1+1)*NPTENTRIES;
					}
				}
				else
					c1=(b+1)*NPDENTRIES;
  8030f7:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8030fa:	83 c0 01             	add    $0x1,%eax
  8030fd:	c1 e0 09             	shl    $0x9,%eax
  803100:	89 45 dc             	mov    %eax,-0x24(%rbp)
	vpdpe_entries = VPDPE(UTOP);
	for(c1=0,d1=0,a=0;a<vpml4e_entries;a++)
	{
		if(uvpml4e[a] & PTE_P)
		{
			for(b=0;b<vpdpe_entries;b++)
  803103:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  803107:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80310a:	3b 45 c8             	cmp    -0x38(%rbp),%eax
  80310d:	0f 8c 25 ff ff ff    	jl     803038 <fork+0x165>
	if (r < 0)
    		panic("panic in fork:sys_page_alloc:%e",r);
	int vpml4e_entries,vpdpe_entries,a,b,c,d,c1,d1;
	vpml4e_entries = VPML4E(UTOP);
	vpdpe_entries = VPDPE(UTOP);
	for(c1=0,d1=0,a=0;a<vpml4e_entries;a++)
  803113:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  803117:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80311a:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  80311d:	0f 8c ea fe ff ff    	jl     80300d <fork+0x13a>
					c1=(b+1)*NPDENTRIES;
			}
		}
	}
	
	r=sys_env_set_pgfault_upcall(envid,_pgfault_upcall);
  803123:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  803126:	48 be e8 57 80 00 00 	movabs $0x8057e8,%rsi
  80312d:	00 00 00 
  803130:	89 c7                	mov    %eax,%edi
  803132:	48 b8 86 29 80 00 00 	movabs $0x802986,%rax
  803139:	00 00 00 
  80313c:	ff d0                	callq  *%rax
  80313e:	89 45 d0             	mov    %eax,-0x30(%rbp)
	if(r<0)
  803141:	83 7d d0 00          	cmpl   $0x0,-0x30(%rbp)
  803145:	79 30                	jns    803177 <fork+0x2a4>
		panic("panic in fork:sys_env_set_pgfault_upcall:%e",r);
  803147:	8b 45 d0             	mov    -0x30(%rbp),%eax
  80314a:	89 c1                	mov    %eax,%ecx
  80314c:	48 ba 28 11 82 00 00 	movabs $0x821128,%rdx
  803153:	00 00 00 
  803156:	be ad 00 00 00       	mov    $0xad,%esi
  80315b:	48 bf e5 0f 82 00 00 	movabs $0x820fe5,%rdi
  803162:	00 00 00 
  803165:	b8 00 00 00 00       	mov    $0x0,%eax
  80316a:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  803171:	00 00 00 
  803174:	41 ff d0             	callq  *%r8
	r = sys_env_set_status(envid,ENV_RUNNABLE);
  803177:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80317a:	be 02 00 00 00       	mov    $0x2,%esi
  80317f:	89 c7                	mov    %eax,%edi
  803181:	48 b8 f1 28 80 00 00 	movabs $0x8028f1,%rax
  803188:	00 00 00 
  80318b:	ff d0                	callq  *%rax
  80318d:	89 45 d0             	mov    %eax,-0x30(%rbp)
	if(r<0)
  803190:	83 7d d0 00          	cmpl   $0x0,-0x30(%rbp)
  803194:	79 30                	jns    8031c6 <fork+0x2f3>
                panic("panic in fork:sys_env_set_status:%e",r);
  803196:	8b 45 d0             	mov    -0x30(%rbp),%eax
  803199:	89 c1                	mov    %eax,%ecx
  80319b:	48 ba 58 11 82 00 00 	movabs $0x821158,%rdx
  8031a2:	00 00 00 
  8031a5:	be b0 00 00 00       	mov    $0xb0,%esi
  8031aa:	48 bf e5 0f 82 00 00 	movabs $0x820fe5,%rdi
  8031b1:	00 00 00 
  8031b4:	b8 00 00 00 00       	mov    $0x0,%eax
  8031b9:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  8031c0:	00 00 00 
  8031c3:	41 ff d0             	callq  *%r8
	return envid;
  8031c6:	8b 45 d4             	mov    -0x2c(%rbp),%eax
}
  8031c9:	48 83 c4 48          	add    $0x48,%rsp
  8031cd:	5b                   	pop    %rbx
  8031ce:	5d                   	pop    %rbp
  8031cf:	c3                   	retq   

00000000008031d0 <sfork>:

// Challenge!
int
sfork(void)
{
  8031d0:	55                   	push   %rbp
  8031d1:	48 89 e5             	mov    %rsp,%rbp
	panic("sfork not implemented");
  8031d4:	48 ba 7c 11 82 00 00 	movabs $0x82117c,%rdx
  8031db:	00 00 00 
  8031de:	be b8 00 00 00       	mov    $0xb8,%esi
  8031e3:	48 bf e5 0f 82 00 00 	movabs $0x820fe5,%rdi
  8031ea:	00 00 00 
  8031ed:	b8 00 00 00 00       	mov    $0x0,%eax
  8031f2:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8031f9:	00 00 00 
  8031fc:	ff d1                	callq  *%rcx
	...

0000000000803200 <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  803200:	55                   	push   %rbp
  803201:	48 89 e5             	mov    %rsp,%rbp
  803204:	48 83 ec 30          	sub    $0x30,%rsp
  803208:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80320c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  803210:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// LAB 4: Your code here.
	int r;
	if(pg!=NULL)
  803214:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  803219:	74 18                	je     803233 <ipc_recv+0x33>
		r=sys_ipc_recv(pg);
  80321b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80321f:	48 89 c7             	mov    %rax,%rdi
  803222:	48 b8 25 2a 80 00 00 	movabs $0x802a25,%rax
  803229:	00 00 00 
  80322c:	ff d0                	callq  *%rax
  80322e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803231:	eb 19                	jmp    80324c <ipc_recv+0x4c>
	else 
                r=sys_ipc_recv((void *)UTOP);
  803233:	48 bf 00 00 80 00 80 	movabs $0x8000800000,%rdi
  80323a:	00 00 00 
  80323d:	48 b8 25 2a 80 00 00 	movabs $0x802a25,%rax
  803244:	00 00 00 
  803247:	ff d0                	callq  *%rax
  803249:	89 45 fc             	mov    %eax,-0x4(%rbp)
        if(r<0)
  80324c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803250:	79 19                	jns    80326b <ipc_recv+0x6b>
	{
		*from_env_store=0;
  803252:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803256:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
		*perm_store=0;
  80325c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803260:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
                return r;
  803266:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803269:	eb 53                	jmp    8032be <ipc_recv+0xbe>
	}
	if(from_env_store!=NULL)
  80326b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  803270:	74 19                	je     80328b <ipc_recv+0x8b>
		*from_env_store=thisenv->env_ipc_from;
  803272:	48 b8 10 76 b5 00 00 	movabs $0xb57610,%rax
  803279:	00 00 00 
  80327c:	48 8b 00             	mov    (%rax),%rax
  80327f:	8b 90 0c 01 00 00    	mov    0x10c(%rax),%edx
  803285:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803289:	89 10                	mov    %edx,(%rax)
	if(perm_store!=NULL)
  80328b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  803290:	74 19                	je     8032ab <ipc_recv+0xab>
		*perm_store=thisenv->env_ipc_perm;
  803292:	48 b8 10 76 b5 00 00 	movabs $0xb57610,%rax
  803299:	00 00 00 
  80329c:	48 8b 00             	mov    (%rax),%rax
  80329f:	8b 90 10 01 00 00    	mov    0x110(%rax),%edx
  8032a5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8032a9:	89 10                	mov    %edx,(%rax)
	return thisenv->env_ipc_value;
  8032ab:	48 b8 10 76 b5 00 00 	movabs $0xb57610,%rax
  8032b2:	00 00 00 
  8032b5:	48 8b 00             	mov    (%rax),%rax
  8032b8:	8b 80 08 01 00 00    	mov    0x108(%rax),%eax
}
  8032be:	c9                   	leaveq 
  8032bf:	c3                   	retq   

00000000008032c0 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  8032c0:	55                   	push   %rbp
  8032c1:	48 89 e5             	mov    %rsp,%rbp
  8032c4:	48 83 ec 30          	sub    $0x30,%rsp
  8032c8:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8032cb:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8032ce:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  8032d2:	89 4d dc             	mov    %ecx,-0x24(%rbp)
	int r=1;
  8032d5:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)
	while(r!=0)
  8032dc:	e9 96 00 00 00       	jmpq   803377 <ipc_send+0xb7>
	{
		if(pg!=NULL)
  8032e1:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8032e6:	74 20                	je     803308 <ipc_send+0x48>
			r=sys_ipc_try_send(to_env,val,pg,perm);
  8032e8:	8b 75 e8             	mov    -0x18(%rbp),%esi
  8032eb:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  8032ee:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8032f2:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8032f5:	89 c7                	mov    %eax,%edi
  8032f7:	48 b8 d0 29 80 00 00 	movabs $0x8029d0,%rax
  8032fe:	00 00 00 
  803301:	ff d0                	callq  *%rax
  803303:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803306:	eb 2d                	jmp    803335 <ipc_send+0x75>
		else if(pg==NULL)
  803308:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80330d:	75 26                	jne    803335 <ipc_send+0x75>
			r=sys_ipc_try_send(to_env,val,(void *)UTOP,0);
  80330f:	8b 75 e8             	mov    -0x18(%rbp),%esi
  803312:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803315:	b9 00 00 00 00       	mov    $0x0,%ecx
  80331a:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  803321:	00 00 00 
  803324:	89 c7                	mov    %eax,%edi
  803326:	48 b8 d0 29 80 00 00 	movabs $0x8029d0,%rax
  80332d:	00 00 00 
  803330:	ff d0                	callq  *%rax
  803332:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if(r<0 && r!= -E_IPC_NOT_RECV)
  803335:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803339:	79 30                	jns    80336b <ipc_send+0xab>
  80333b:	83 7d fc f8          	cmpl   $0xfffffff8,-0x4(%rbp)
  80333f:	74 2a                	je     80336b <ipc_send+0xab>
		{
			panic("panic in ipc_send:%e\n,r");
  803341:	48 ba 92 11 82 00 00 	movabs $0x821192,%rdx
  803348:	00 00 00 
  80334b:	be 40 00 00 00       	mov    $0x40,%esi
  803350:	48 bf aa 11 82 00 00 	movabs $0x8211aa,%rdi
  803357:	00 00 00 
  80335a:	b8 00 00 00 00       	mov    $0x0,%eax
  80335f:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  803366:	00 00 00 
  803369:	ff d1                	callq  *%rcx
		}
		sys_yield();
  80336b:	48 b8 be 27 80 00 00 	movabs $0x8027be,%rax
  803372:	00 00 00 
  803375:	ff d0                	callq  *%rax
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
	int r=1;
	while(r!=0)
  803377:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80337b:	0f 85 60 ff ff ff    	jne    8032e1 <ipc_send+0x21>
		{
			panic("panic in ipc_send:%e\n,r");
		}
		sys_yield();
	}
}
  803381:	c9                   	leaveq 
  803382:	c3                   	retq   

0000000000803383 <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  803383:	55                   	push   %rbp
  803384:	48 89 e5             	mov    %rsp,%rbp
  803387:	48 83 ec 18          	sub    $0x18,%rsp
  80338b:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int i;
	for (i = 0; i < NENV; i++)
  80338e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  803395:	eb 5e                	jmp    8033f5 <ipc_find_env+0x72>
		if (envs[i].env_type == type)
  803397:	48 b9 00 00 80 00 80 	movabs $0x8000800000,%rcx
  80339e:	00 00 00 
  8033a1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8033a4:	48 63 d0             	movslq %eax,%rdx
  8033a7:	48 89 d0             	mov    %rdx,%rax
  8033aa:	48 c1 e0 03          	shl    $0x3,%rax
  8033ae:	48 01 d0             	add    %rdx,%rax
  8033b1:	48 c1 e0 05          	shl    $0x5,%rax
  8033b5:	48 01 c8             	add    %rcx,%rax
  8033b8:	48 05 d0 00 00 00    	add    $0xd0,%rax
  8033be:	8b 00                	mov    (%rax),%eax
  8033c0:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8033c3:	75 2c                	jne    8033f1 <ipc_find_env+0x6e>
			return envs[i].env_id;
  8033c5:	48 b9 00 00 80 00 80 	movabs $0x8000800000,%rcx
  8033cc:	00 00 00 
  8033cf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8033d2:	48 63 d0             	movslq %eax,%rdx
  8033d5:	48 89 d0             	mov    %rdx,%rax
  8033d8:	48 c1 e0 03          	shl    $0x3,%rax
  8033dc:	48 01 d0             	add    %rdx,%rax
  8033df:	48 c1 e0 05          	shl    $0x5,%rax
  8033e3:	48 01 c8             	add    %rcx,%rax
  8033e6:	48 05 c0 00 00 00    	add    $0xc0,%rax
  8033ec:	8b 40 08             	mov    0x8(%rax),%eax
  8033ef:	eb 12                	jmp    803403 <ipc_find_env+0x80>
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
	int i;
	for (i = 0; i < NENV; i++)
  8033f1:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8033f5:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  8033fc:	7e 99                	jle    803397 <ipc_find_env+0x14>
		if (envs[i].env_type == type)
			return envs[i].env_id;
	return 0;
  8033fe:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803403:	c9                   	leaveq 
  803404:	c3                   	retq   
  803405:	00 00                	add    %al,(%rax)
	...

0000000000803408 <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

uint64_t
fd2num(struct Fd *fd)
{
  803408:	55                   	push   %rbp
  803409:	48 89 e5             	mov    %rsp,%rbp
  80340c:	48 83 ec 08          	sub    $0x8,%rsp
  803410:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  803414:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  803418:	48 b8 00 00 00 30 ff 	movabs $0xffffffff30000000,%rax
  80341f:	ff ff ff 
  803422:	48 01 d0             	add    %rdx,%rax
  803425:	48 c1 e8 0c          	shr    $0xc,%rax
}
  803429:	c9                   	leaveq 
  80342a:	c3                   	retq   

000000000080342b <fd2data>:

char*
fd2data(struct Fd *fd)
{
  80342b:	55                   	push   %rbp
  80342c:	48 89 e5             	mov    %rsp,%rbp
  80342f:	48 83 ec 08          	sub    $0x8,%rsp
  803433:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return INDEX2DATA(fd2num(fd));
  803437:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80343b:	48 89 c7             	mov    %rax,%rdi
  80343e:	48 b8 08 34 80 00 00 	movabs $0x803408,%rax
  803445:	00 00 00 
  803448:	ff d0                	callq  *%rax
  80344a:	48 05 20 00 0d 00    	add    $0xd0020,%rax
  803450:	48 c1 e0 0c          	shl    $0xc,%rax
}
  803454:	c9                   	leaveq 
  803455:	c3                   	retq   

0000000000803456 <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  803456:	55                   	push   %rbp
  803457:	48 89 e5             	mov    %rsp,%rbp
  80345a:	48 83 ec 18          	sub    $0x18,%rsp
  80345e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  803462:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  803469:	eb 6b                	jmp    8034d6 <fd_alloc+0x80>
		fd = INDEX2FD(i);
  80346b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80346e:	48 98                	cltq   
  803470:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  803476:	48 c1 e0 0c          	shl    $0xc,%rax
  80347a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		if ((uvpd[VPD(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  80347e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803482:	48 89 c2             	mov    %rax,%rdx
  803485:	48 c1 ea 15          	shr    $0x15,%rdx
  803489:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  803490:	01 00 00 
  803493:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803497:	83 e0 01             	and    $0x1,%eax
  80349a:	48 85 c0             	test   %rax,%rax
  80349d:	74 21                	je     8034c0 <fd_alloc+0x6a>
  80349f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8034a3:	48 89 c2             	mov    %rax,%rdx
  8034a6:	48 c1 ea 0c          	shr    $0xc,%rdx
  8034aa:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8034b1:	01 00 00 
  8034b4:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8034b8:	83 e0 01             	and    $0x1,%eax
  8034bb:	48 85 c0             	test   %rax,%rax
  8034be:	75 12                	jne    8034d2 <fd_alloc+0x7c>
			*fd_store = fd;
  8034c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8034c4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8034c8:	48 89 10             	mov    %rdx,(%rax)
			return 0;
  8034cb:	b8 00 00 00 00       	mov    $0x0,%eax
  8034d0:	eb 1a                	jmp    8034ec <fd_alloc+0x96>
fd_alloc(struct Fd **fd_store)
{
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  8034d2:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8034d6:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  8034da:	7e 8f                	jle    80346b <fd_alloc+0x15>
		if ((uvpd[VPD(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  8034dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8034e0:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	return -E_MAX_OPEN;
  8034e7:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  8034ec:	c9                   	leaveq 
  8034ed:	c3                   	retq   

00000000008034ee <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  8034ee:	55                   	push   %rbp
  8034ef:	48 89 e5             	mov    %rsp,%rbp
  8034f2:	48 83 ec 20          	sub    $0x20,%rsp
  8034f6:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8034f9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  8034fd:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  803501:	78 06                	js     803509 <fd_lookup+0x1b>
  803503:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  803507:	7e 07                	jle    803510 <fd_lookup+0x22>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  803509:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80350e:	eb 6c                	jmp    80357c <fd_lookup+0x8e>
	}
	fd = INDEX2FD(fdnum);
  803510:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803513:	48 98                	cltq   
  803515:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  80351b:	48 c1 e0 0c          	shl    $0xc,%rax
  80351f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!(uvpd[VPD(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  803523:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  803527:	48 89 c2             	mov    %rax,%rdx
  80352a:	48 c1 ea 15          	shr    $0x15,%rdx
  80352e:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  803535:	01 00 00 
  803538:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80353c:	83 e0 01             	and    $0x1,%eax
  80353f:	48 85 c0             	test   %rax,%rax
  803542:	74 21                	je     803565 <fd_lookup+0x77>
  803544:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  803548:	48 89 c2             	mov    %rax,%rdx
  80354b:	48 c1 ea 0c          	shr    $0xc,%rdx
  80354f:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803556:	01 00 00 
  803559:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80355d:	83 e0 01             	and    $0x1,%eax
  803560:	48 85 c0             	test   %rax,%rax
  803563:	75 07                	jne    80356c <fd_lookup+0x7e>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  803565:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80356a:	eb 10                	jmp    80357c <fd_lookup+0x8e>
	}
	*fd_store = fd;
  80356c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803570:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  803574:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  803577:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80357c:	c9                   	leaveq 
  80357d:	c3                   	retq   

000000000080357e <fd_close>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  80357e:	55                   	push   %rbp
  80357f:	48 89 e5             	mov    %rsp,%rbp
  803582:	48 83 ec 30          	sub    $0x30,%rsp
  803586:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80358a:	89 f0                	mov    %esi,%eax
  80358c:	88 45 d4             	mov    %al,-0x2c(%rbp)
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  80358f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803593:	48 89 c7             	mov    %rax,%rdi
  803596:	48 b8 08 34 80 00 00 	movabs $0x803408,%rax
  80359d:	00 00 00 
  8035a0:	ff d0                	callq  *%rax
  8035a2:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8035a6:	48 89 d6             	mov    %rdx,%rsi
  8035a9:	89 c7                	mov    %eax,%edi
  8035ab:	48 b8 ee 34 80 00 00 	movabs $0x8034ee,%rax
  8035b2:	00 00 00 
  8035b5:	ff d0                	callq  *%rax
  8035b7:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8035ba:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8035be:	78 0a                	js     8035ca <fd_close+0x4c>
	    || fd != fd2)
  8035c0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8035c4:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8035c8:	74 12                	je     8035dc <fd_close+0x5e>
		return (must_exist ? r : 0);
  8035ca:	80 7d d4 00          	cmpb   $0x0,-0x2c(%rbp)
  8035ce:	74 05                	je     8035d5 <fd_close+0x57>
  8035d0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8035d3:	eb 05                	jmp    8035da <fd_close+0x5c>
  8035d5:	b8 00 00 00 00       	mov    $0x0,%eax
  8035da:	eb 69                	jmp    803645 <fd_close+0xc7>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  8035dc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8035e0:	8b 00                	mov    (%rax),%eax
  8035e2:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  8035e6:	48 89 d6             	mov    %rdx,%rsi
  8035e9:	89 c7                	mov    %eax,%edi
  8035eb:	48 b8 47 36 80 00 00 	movabs $0x803647,%rax
  8035f2:	00 00 00 
  8035f5:	ff d0                	callq  *%rax
  8035f7:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8035fa:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8035fe:	78 2a                	js     80362a <fd_close+0xac>
		if (dev->dev_close)
  803600:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803604:	48 8b 40 20          	mov    0x20(%rax),%rax
  803608:	48 85 c0             	test   %rax,%rax
  80360b:	74 16                	je     803623 <fd_close+0xa5>
			r = (*dev->dev_close)(fd);
  80360d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803611:	48 8b 50 20          	mov    0x20(%rax),%rdx
  803615:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803619:	48 89 c7             	mov    %rax,%rdi
  80361c:	ff d2                	callq  *%rdx
  80361e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803621:	eb 07                	jmp    80362a <fd_close+0xac>
		else
			r = 0;
  803623:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  80362a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80362e:	48 89 c6             	mov    %rax,%rsi
  803631:	bf 00 00 00 00       	mov    $0x0,%edi
  803636:	48 b8 a7 28 80 00 00 	movabs $0x8028a7,%rax
  80363d:	00 00 00 
  803640:	ff d0                	callq  *%rax
	return r;
  803642:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  803645:	c9                   	leaveq 
  803646:	c3                   	retq   

0000000000803647 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  803647:	55                   	push   %rbp
  803648:	48 89 e5             	mov    %rsp,%rbp
  80364b:	48 83 ec 20          	sub    $0x20,%rsp
  80364f:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803652:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int i;
	for (i = 0; devtab[i]; i++)
  803656:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80365d:	eb 41                	jmp    8036a0 <dev_lookup+0x59>
		if (devtab[i]->dev_id == dev_id) {
  80365f:	48 b8 20 80 82 00 00 	movabs $0x828020,%rax
  803666:	00 00 00 
  803669:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80366c:	48 63 d2             	movslq %edx,%rdx
  80366f:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803673:	8b 00                	mov    (%rax),%eax
  803675:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  803678:	75 22                	jne    80369c <dev_lookup+0x55>
			*dev = devtab[i];
  80367a:	48 b8 20 80 82 00 00 	movabs $0x828020,%rax
  803681:	00 00 00 
  803684:	8b 55 fc             	mov    -0x4(%rbp),%edx
  803687:	48 63 d2             	movslq %edx,%rdx
  80368a:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  80368e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803692:	48 89 10             	mov    %rdx,(%rax)
			return 0;
  803695:	b8 00 00 00 00       	mov    $0x0,%eax
  80369a:	eb 60                	jmp    8036fc <dev_lookup+0xb5>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  80369c:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8036a0:	48 b8 20 80 82 00 00 	movabs $0x828020,%rax
  8036a7:	00 00 00 
  8036aa:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8036ad:	48 63 d2             	movslq %edx,%rdx
  8036b0:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8036b4:	48 85 c0             	test   %rax,%rax
  8036b7:	75 a6                	jne    80365f <dev_lookup+0x18>
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  8036b9:	48 b8 10 76 b5 00 00 	movabs $0xb57610,%rax
  8036c0:	00 00 00 
  8036c3:	48 8b 00             	mov    (%rax),%rax
  8036c6:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8036cc:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8036cf:	89 c6                	mov    %eax,%esi
  8036d1:	48 bf b8 11 82 00 00 	movabs $0x8211b8,%rdi
  8036d8:	00 00 00 
  8036db:	b8 00 00 00 00       	mov    $0x0,%eax
  8036e0:	48 b9 07 13 80 00 00 	movabs $0x801307,%rcx
  8036e7:	00 00 00 
  8036ea:	ff d1                	callq  *%rcx
	*dev = 0;
  8036ec:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8036f0:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	return -E_INVAL;
  8036f7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  8036fc:	c9                   	leaveq 
  8036fd:	c3                   	retq   

00000000008036fe <close>:

int
close(int fdnum)
{
  8036fe:	55                   	push   %rbp
  8036ff:	48 89 e5             	mov    %rsp,%rbp
  803702:	48 83 ec 20          	sub    $0x20,%rsp
  803706:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  803709:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80370d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803710:	48 89 d6             	mov    %rdx,%rsi
  803713:	89 c7                	mov    %eax,%edi
  803715:	48 b8 ee 34 80 00 00 	movabs $0x8034ee,%rax
  80371c:	00 00 00 
  80371f:	ff d0                	callq  *%rax
  803721:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803724:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803728:	79 05                	jns    80372f <close+0x31>
		return r;
  80372a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80372d:	eb 18                	jmp    803747 <close+0x49>
	else
		return fd_close(fd, 1);
  80372f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803733:	be 01 00 00 00       	mov    $0x1,%esi
  803738:	48 89 c7             	mov    %rax,%rdi
  80373b:	48 b8 7e 35 80 00 00 	movabs $0x80357e,%rax
  803742:	00 00 00 
  803745:	ff d0                	callq  *%rax
}
  803747:	c9                   	leaveq 
  803748:	c3                   	retq   

0000000000803749 <close_all>:

void
close_all(void)
{
  803749:	55                   	push   %rbp
  80374a:	48 89 e5             	mov    %rsp,%rbp
  80374d:	48 83 ec 10          	sub    $0x10,%rsp
	int i;
	for (i = 0; i < MAXFD; i++)
  803751:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  803758:	eb 15                	jmp    80376f <close_all+0x26>
		close(i);
  80375a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80375d:	89 c7                	mov    %eax,%edi
  80375f:	48 b8 fe 36 80 00 00 	movabs $0x8036fe,%rax
  803766:	00 00 00 
  803769:	ff d0                	callq  *%rax

void
close_all(void)
{
	int i;
	for (i = 0; i < MAXFD; i++)
  80376b:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80376f:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  803773:	7e e5                	jle    80375a <close_all+0x11>
		close(i);
}
  803775:	c9                   	leaveq 
  803776:	c3                   	retq   

0000000000803777 <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  803777:	55                   	push   %rbp
  803778:	48 89 e5             	mov    %rsp,%rbp
  80377b:	48 83 ec 40          	sub    $0x40,%rsp
  80377f:	89 7d cc             	mov    %edi,-0x34(%rbp)
  803782:	89 75 c8             	mov    %esi,-0x38(%rbp)
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  803785:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  803789:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80378c:	48 89 d6             	mov    %rdx,%rsi
  80378f:	89 c7                	mov    %eax,%edi
  803791:	48 b8 ee 34 80 00 00 	movabs $0x8034ee,%rax
  803798:	00 00 00 
  80379b:	ff d0                	callq  *%rax
  80379d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8037a0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8037a4:	79 08                	jns    8037ae <dup+0x37>
		return r;
  8037a6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8037a9:	e9 70 01 00 00       	jmpq   80391e <dup+0x1a7>
	close(newfdnum);
  8037ae:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8037b1:	89 c7                	mov    %eax,%edi
  8037b3:	48 b8 fe 36 80 00 00 	movabs $0x8036fe,%rax
  8037ba:	00 00 00 
  8037bd:	ff d0                	callq  *%rax

	newfd = INDEX2FD(newfdnum);
  8037bf:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8037c2:	48 98                	cltq   
  8037c4:	48 05 00 00 0d 00    	add    $0xd0000,%rax
  8037ca:	48 c1 e0 0c          	shl    $0xc,%rax
  8037ce:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	ova = fd2data(oldfd);
  8037d2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8037d6:	48 89 c7             	mov    %rax,%rdi
  8037d9:	48 b8 2b 34 80 00 00 	movabs $0x80342b,%rax
  8037e0:	00 00 00 
  8037e3:	ff d0                	callq  *%rax
  8037e5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	nva = fd2data(newfd);
  8037e9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8037ed:	48 89 c7             	mov    %rax,%rdi
  8037f0:	48 b8 2b 34 80 00 00 	movabs $0x80342b,%rax
  8037f7:	00 00 00 
  8037fa:	ff d0                	callq  *%rax
  8037fc:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	if ((uvpd[VPD(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  803800:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803804:	48 89 c2             	mov    %rax,%rdx
  803807:	48 c1 ea 15          	shr    $0x15,%rdx
  80380b:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  803812:	01 00 00 
  803815:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803819:	83 e0 01             	and    $0x1,%eax
  80381c:	84 c0                	test   %al,%al
  80381e:	74 71                	je     803891 <dup+0x11a>
  803820:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803824:	48 89 c2             	mov    %rax,%rdx
  803827:	48 c1 ea 0c          	shr    $0xc,%rdx
  80382b:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803832:	01 00 00 
  803835:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803839:	83 e0 01             	and    $0x1,%eax
  80383c:	84 c0                	test   %al,%al
  80383e:	74 51                	je     803891 <dup+0x11a>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  803840:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803844:	48 89 c2             	mov    %rax,%rdx
  803847:	48 c1 ea 0c          	shr    $0xc,%rdx
  80384b:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  803852:	01 00 00 
  803855:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  803859:	89 c1                	mov    %eax,%ecx
  80385b:	81 e1 07 0e 00 00    	and    $0xe07,%ecx
  803861:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  803865:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803869:	41 89 c8             	mov    %ecx,%r8d
  80386c:	48 89 d1             	mov    %rdx,%rcx
  80386f:	ba 00 00 00 00       	mov    $0x0,%edx
  803874:	48 89 c6             	mov    %rax,%rsi
  803877:	bf 00 00 00 00       	mov    $0x0,%edi
  80387c:	48 b8 4c 28 80 00 00 	movabs $0x80284c,%rax
  803883:	00 00 00 
  803886:	ff d0                	callq  *%rax
  803888:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80388b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80388f:	78 56                	js     8038e7 <dup+0x170>
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  803891:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  803895:	48 89 c2             	mov    %rax,%rdx
  803898:	48 c1 ea 0c          	shr    $0xc,%rdx
  80389c:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8038a3:	01 00 00 
  8038a6:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8038aa:	89 c1                	mov    %eax,%ecx
  8038ac:	81 e1 07 0e 00 00    	and    $0xe07,%ecx
  8038b2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8038b6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8038ba:	41 89 c8             	mov    %ecx,%r8d
  8038bd:	48 89 d1             	mov    %rdx,%rcx
  8038c0:	ba 00 00 00 00       	mov    $0x0,%edx
  8038c5:	48 89 c6             	mov    %rax,%rsi
  8038c8:	bf 00 00 00 00       	mov    $0x0,%edi
  8038cd:	48 b8 4c 28 80 00 00 	movabs $0x80284c,%rax
  8038d4:	00 00 00 
  8038d7:	ff d0                	callq  *%rax
  8038d9:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8038dc:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8038e0:	78 08                	js     8038ea <dup+0x173>
		goto err;

	return newfdnum;
  8038e2:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8038e5:	eb 37                	jmp    80391e <dup+0x1a7>
	ova = fd2data(oldfd);
	nva = fd2data(newfd);

	if ((uvpd[VPD(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
  8038e7:	90                   	nop
  8038e8:	eb 01                	jmp    8038eb <dup+0x174>
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
		goto err;
  8038ea:	90                   	nop

	return newfdnum;

err:
	sys_page_unmap(0, newfd);
  8038eb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8038ef:	48 89 c6             	mov    %rax,%rsi
  8038f2:	bf 00 00 00 00       	mov    $0x0,%edi
  8038f7:	48 b8 a7 28 80 00 00 	movabs $0x8028a7,%rax
  8038fe:	00 00 00 
  803901:	ff d0                	callq  *%rax
	sys_page_unmap(0, nva);
  803903:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803907:	48 89 c6             	mov    %rax,%rsi
  80390a:	bf 00 00 00 00       	mov    $0x0,%edi
  80390f:	48 b8 a7 28 80 00 00 	movabs $0x8028a7,%rax
  803916:	00 00 00 
  803919:	ff d0                	callq  *%rax
	return r;
  80391b:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80391e:	c9                   	leaveq 
  80391f:	c3                   	retq   

0000000000803920 <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  803920:	55                   	push   %rbp
  803921:	48 89 e5             	mov    %rsp,%rbp
  803924:	48 83 ec 40          	sub    $0x40,%rsp
  803928:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80392b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80392f:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  803933:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803937:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80393a:	48 89 d6             	mov    %rdx,%rsi
  80393d:	89 c7                	mov    %eax,%edi
  80393f:	48 b8 ee 34 80 00 00 	movabs $0x8034ee,%rax
  803946:	00 00 00 
  803949:	ff d0                	callq  *%rax
  80394b:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80394e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803952:	78 24                	js     803978 <read+0x58>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803954:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803958:	8b 00                	mov    (%rax),%eax
  80395a:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80395e:	48 89 d6             	mov    %rdx,%rsi
  803961:	89 c7                	mov    %eax,%edi
  803963:	48 b8 47 36 80 00 00 	movabs $0x803647,%rax
  80396a:	00 00 00 
  80396d:	ff d0                	callq  *%rax
  80396f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803972:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803976:	79 05                	jns    80397d <read+0x5d>
		return r;
  803978:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80397b:	eb 7a                	jmp    8039f7 <read+0xd7>
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  80397d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803981:	8b 40 08             	mov    0x8(%rax),%eax
  803984:	83 e0 03             	and    $0x3,%eax
  803987:	83 f8 01             	cmp    $0x1,%eax
  80398a:	75 3a                	jne    8039c6 <read+0xa6>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  80398c:	48 b8 10 76 b5 00 00 	movabs $0xb57610,%rax
  803993:	00 00 00 
  803996:	48 8b 00             	mov    (%rax),%rax
  803999:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  80399f:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8039a2:	89 c6                	mov    %eax,%esi
  8039a4:	48 bf d7 11 82 00 00 	movabs $0x8211d7,%rdi
  8039ab:	00 00 00 
  8039ae:	b8 00 00 00 00       	mov    $0x0,%eax
  8039b3:	48 b9 07 13 80 00 00 	movabs $0x801307,%rcx
  8039ba:	00 00 00 
  8039bd:	ff d1                	callq  *%rcx
		return -E_INVAL;
  8039bf:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8039c4:	eb 31                	jmp    8039f7 <read+0xd7>
	}
	if (!dev->dev_read)
  8039c6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8039ca:	48 8b 40 10          	mov    0x10(%rax),%rax
  8039ce:	48 85 c0             	test   %rax,%rax
  8039d1:	75 07                	jne    8039da <read+0xba>
		return -E_NOT_SUPP;
  8039d3:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  8039d8:	eb 1d                	jmp    8039f7 <read+0xd7>
	return (*dev->dev_read)(fd, buf, n);
  8039da:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8039de:	4c 8b 40 10          	mov    0x10(%rax),%r8
  8039e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8039e6:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8039ea:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8039ee:	48 89 ce             	mov    %rcx,%rsi
  8039f1:	48 89 c7             	mov    %rax,%rdi
  8039f4:	41 ff d0             	callq  *%r8
}
  8039f7:	c9                   	leaveq 
  8039f8:	c3                   	retq   

00000000008039f9 <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  8039f9:	55                   	push   %rbp
  8039fa:	48 89 e5             	mov    %rsp,%rbp
  8039fd:	48 83 ec 30          	sub    $0x30,%rsp
  803a01:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803a04:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  803a08:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  803a0c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  803a13:	eb 46                	jmp    803a5b <readn+0x62>
		m = read(fdnum, (char*)buf + tot, n - tot);
  803a15:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803a18:	48 98                	cltq   
  803a1a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  803a1e:	48 29 c2             	sub    %rax,%rdx
  803a21:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803a24:	48 98                	cltq   
  803a26:	48 89 c1             	mov    %rax,%rcx
  803a29:	48 03 4d e0          	add    -0x20(%rbp),%rcx
  803a2d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803a30:	48 89 ce             	mov    %rcx,%rsi
  803a33:	89 c7                	mov    %eax,%edi
  803a35:	48 b8 20 39 80 00 00 	movabs $0x803920,%rax
  803a3c:	00 00 00 
  803a3f:	ff d0                	callq  *%rax
  803a41:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (m < 0)
  803a44:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  803a48:	79 05                	jns    803a4f <readn+0x56>
			return m;
  803a4a:	8b 45 f8             	mov    -0x8(%rbp),%eax
  803a4d:	eb 1d                	jmp    803a6c <readn+0x73>
		if (m == 0)
  803a4f:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  803a53:	74 13                	je     803a68 <readn+0x6f>
ssize_t
readn(int fdnum, void *buf, size_t n)
{
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  803a55:	8b 45 f8             	mov    -0x8(%rbp),%eax
  803a58:	01 45 fc             	add    %eax,-0x4(%rbp)
  803a5b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803a5e:	48 98                	cltq   
  803a60:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  803a64:	72 af                	jb     803a15 <readn+0x1c>
  803a66:	eb 01                	jmp    803a69 <readn+0x70>
		m = read(fdnum, (char*)buf + tot, n - tot);
		if (m < 0)
			return m;
		if (m == 0)
			break;
  803a68:	90                   	nop
	}
	return tot;
  803a69:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  803a6c:	c9                   	leaveq 
  803a6d:	c3                   	retq   

0000000000803a6e <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  803a6e:	55                   	push   %rbp
  803a6f:	48 89 e5             	mov    %rsp,%rbp
  803a72:	48 83 ec 40          	sub    $0x40,%rsp
  803a76:	89 7d dc             	mov    %edi,-0x24(%rbp)
  803a79:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  803a7d:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  803a81:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803a85:	8b 45 dc             	mov    -0x24(%rbp),%eax
  803a88:	48 89 d6             	mov    %rdx,%rsi
  803a8b:	89 c7                	mov    %eax,%edi
  803a8d:	48 b8 ee 34 80 00 00 	movabs $0x8034ee,%rax
  803a94:	00 00 00 
  803a97:	ff d0                	callq  *%rax
  803a99:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803a9c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803aa0:	78 24                	js     803ac6 <write+0x58>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803aa2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803aa6:	8b 00                	mov    (%rax),%eax
  803aa8:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803aac:	48 89 d6             	mov    %rdx,%rsi
  803aaf:	89 c7                	mov    %eax,%edi
  803ab1:	48 b8 47 36 80 00 00 	movabs $0x803647,%rax
  803ab8:	00 00 00 
  803abb:	ff d0                	callq  *%rax
  803abd:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803ac0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803ac4:	79 05                	jns    803acb <write+0x5d>
		return r;
  803ac6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803ac9:	eb 79                	jmp    803b44 <write+0xd6>
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  803acb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803acf:	8b 40 08             	mov    0x8(%rax),%eax
  803ad2:	83 e0 03             	and    $0x3,%eax
  803ad5:	85 c0                	test   %eax,%eax
  803ad7:	75 3a                	jne    803b13 <write+0xa5>
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  803ad9:	48 b8 10 76 b5 00 00 	movabs $0xb57610,%rax
  803ae0:	00 00 00 
  803ae3:	48 8b 00             	mov    (%rax),%rax
  803ae6:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  803aec:	8b 55 dc             	mov    -0x24(%rbp),%edx
  803aef:	89 c6                	mov    %eax,%esi
  803af1:	48 bf f3 11 82 00 00 	movabs $0x8211f3,%rdi
  803af8:	00 00 00 
  803afb:	b8 00 00 00 00       	mov    $0x0,%eax
  803b00:	48 b9 07 13 80 00 00 	movabs $0x801307,%rcx
  803b07:	00 00 00 
  803b0a:	ff d1                	callq  *%rcx
		return -E_INVAL;
  803b0c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803b11:	eb 31                	jmp    803b44 <write+0xd6>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  803b13:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803b17:	48 8b 40 18          	mov    0x18(%rax),%rax
  803b1b:	48 85 c0             	test   %rax,%rax
  803b1e:	75 07                	jne    803b27 <write+0xb9>
		return -E_NOT_SUPP;
  803b20:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803b25:	eb 1d                	jmp    803b44 <write+0xd6>
	return (*dev->dev_write)(fd, buf, n);
  803b27:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803b2b:	4c 8b 40 18          	mov    0x18(%rax),%r8
  803b2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803b33:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  803b37:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  803b3b:	48 89 ce             	mov    %rcx,%rsi
  803b3e:	48 89 c7             	mov    %rax,%rdi
  803b41:	41 ff d0             	callq  *%r8
}
  803b44:	c9                   	leaveq 
  803b45:	c3                   	retq   

0000000000803b46 <seek>:

int
seek(int fdnum, off_t offset)
{
  803b46:	55                   	push   %rbp
  803b47:	48 89 e5             	mov    %rsp,%rbp
  803b4a:	48 83 ec 18          	sub    $0x18,%rsp
  803b4e:	89 7d ec             	mov    %edi,-0x14(%rbp)
  803b51:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  803b54:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803b58:	8b 45 ec             	mov    -0x14(%rbp),%eax
  803b5b:	48 89 d6             	mov    %rdx,%rsi
  803b5e:	89 c7                	mov    %eax,%edi
  803b60:	48 b8 ee 34 80 00 00 	movabs $0x8034ee,%rax
  803b67:	00 00 00 
  803b6a:	ff d0                	callq  *%rax
  803b6c:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803b6f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803b73:	79 05                	jns    803b7a <seek+0x34>
		return r;
  803b75:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803b78:	eb 0f                	jmp    803b89 <seek+0x43>
	fd->fd_offset = offset;
  803b7a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803b7e:	8b 55 e8             	mov    -0x18(%rbp),%edx
  803b81:	89 50 04             	mov    %edx,0x4(%rax)
	return 0;
  803b84:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803b89:	c9                   	leaveq 
  803b8a:	c3                   	retq   

0000000000803b8b <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  803b8b:	55                   	push   %rbp
  803b8c:	48 89 e5             	mov    %rsp,%rbp
  803b8f:	48 83 ec 30          	sub    $0x30,%rsp
  803b93:	89 7d dc             	mov    %edi,-0x24(%rbp)
  803b96:	89 75 d8             	mov    %esi,-0x28(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  803b99:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803b9d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  803ba0:	48 89 d6             	mov    %rdx,%rsi
  803ba3:	89 c7                	mov    %eax,%edi
  803ba5:	48 b8 ee 34 80 00 00 	movabs $0x8034ee,%rax
  803bac:	00 00 00 
  803baf:	ff d0                	callq  *%rax
  803bb1:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803bb4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803bb8:	78 24                	js     803bde <ftruncate+0x53>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803bba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803bbe:	8b 00                	mov    (%rax),%eax
  803bc0:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803bc4:	48 89 d6             	mov    %rdx,%rsi
  803bc7:	89 c7                	mov    %eax,%edi
  803bc9:	48 b8 47 36 80 00 00 	movabs $0x803647,%rax
  803bd0:	00 00 00 
  803bd3:	ff d0                	callq  *%rax
  803bd5:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803bd8:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803bdc:	79 05                	jns    803be3 <ftruncate+0x58>
		return r;
  803bde:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803be1:	eb 72                	jmp    803c55 <ftruncate+0xca>
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  803be3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803be7:	8b 40 08             	mov    0x8(%rax),%eax
  803bea:	83 e0 03             	and    $0x3,%eax
  803bed:	85 c0                	test   %eax,%eax
  803bef:	75 3a                	jne    803c2b <ftruncate+0xa0>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
  803bf1:	48 b8 10 76 b5 00 00 	movabs $0xb57610,%rax
  803bf8:	00 00 00 
  803bfb:	48 8b 00             	mov    (%rax),%rax
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  803bfe:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  803c04:	8b 55 dc             	mov    -0x24(%rbp),%edx
  803c07:	89 c6                	mov    %eax,%esi
  803c09:	48 bf 10 12 82 00 00 	movabs $0x821210,%rdi
  803c10:	00 00 00 
  803c13:	b8 00 00 00 00       	mov    $0x0,%eax
  803c18:	48 b9 07 13 80 00 00 	movabs $0x801307,%rcx
  803c1f:	00 00 00 
  803c22:	ff d1                	callq  *%rcx
			thisenv->env_id, fdnum);
		return -E_INVAL;
  803c24:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  803c29:	eb 2a                	jmp    803c55 <ftruncate+0xca>
	}
	if (!dev->dev_trunc)
  803c2b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803c2f:	48 8b 40 30          	mov    0x30(%rax),%rax
  803c33:	48 85 c0             	test   %rax,%rax
  803c36:	75 07                	jne    803c3f <ftruncate+0xb4>
		return -E_NOT_SUPP;
  803c38:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803c3d:	eb 16                	jmp    803c55 <ftruncate+0xca>
	return (*dev->dev_trunc)(fd, newsize);
  803c3f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803c43:	48 8b 48 30          	mov    0x30(%rax),%rcx
  803c47:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803c4b:	8b 55 d8             	mov    -0x28(%rbp),%edx
  803c4e:	89 d6                	mov    %edx,%esi
  803c50:	48 89 c7             	mov    %rax,%rdi
  803c53:	ff d1                	callq  *%rcx
}
  803c55:	c9                   	leaveq 
  803c56:	c3                   	retq   

0000000000803c57 <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  803c57:	55                   	push   %rbp
  803c58:	48 89 e5             	mov    %rsp,%rbp
  803c5b:	48 83 ec 30          	sub    $0x30,%rsp
  803c5f:	89 7d dc             	mov    %edi,-0x24(%rbp)
  803c62:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  803c66:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  803c6a:	8b 45 dc             	mov    -0x24(%rbp),%eax
  803c6d:	48 89 d6             	mov    %rdx,%rsi
  803c70:	89 c7                	mov    %eax,%edi
  803c72:	48 b8 ee 34 80 00 00 	movabs $0x8034ee,%rax
  803c79:	00 00 00 
  803c7c:	ff d0                	callq  *%rax
  803c7e:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803c81:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803c85:	78 24                	js     803cab <fstat+0x54>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  803c87:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803c8b:	8b 00                	mov    (%rax),%eax
  803c8d:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  803c91:	48 89 d6             	mov    %rdx,%rsi
  803c94:	89 c7                	mov    %eax,%edi
  803c96:	48 b8 47 36 80 00 00 	movabs $0x803647,%rax
  803c9d:	00 00 00 
  803ca0:	ff d0                	callq  *%rax
  803ca2:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803ca5:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803ca9:	79 05                	jns    803cb0 <fstat+0x59>
		return r;
  803cab:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803cae:	eb 5e                	jmp    803d0e <fstat+0xb7>
	if (!dev->dev_stat)
  803cb0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803cb4:	48 8b 40 28          	mov    0x28(%rax),%rax
  803cb8:	48 85 c0             	test   %rax,%rax
  803cbb:	75 07                	jne    803cc4 <fstat+0x6d>
		return -E_NOT_SUPP;
  803cbd:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  803cc2:	eb 4a                	jmp    803d0e <fstat+0xb7>
	stat->st_name[0] = 0;
  803cc4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803cc8:	c6 00 00             	movb   $0x0,(%rax)
	stat->st_size = 0;
  803ccb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803ccf:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%rax)
  803cd6:	00 00 00 
	stat->st_isdir = 0;
  803cd9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803cdd:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%rax)
  803ce4:	00 00 00 
	stat->st_dev = dev;
  803ce7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  803ceb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  803cef:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
	return (*dev->dev_stat)(fd, stat);
  803cf6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803cfa:	48 8b 48 28          	mov    0x28(%rax),%rcx
  803cfe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803d02:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  803d06:	48 89 d6             	mov    %rdx,%rsi
  803d09:	48 89 c7             	mov    %rax,%rdi
  803d0c:	ff d1                	callq  *%rcx
}
  803d0e:	c9                   	leaveq 
  803d0f:	c3                   	retq   

0000000000803d10 <stat>:

int
stat(const char *path, struct Stat *stat)
{
  803d10:	55                   	push   %rbp
  803d11:	48 89 e5             	mov    %rsp,%rbp
  803d14:	48 83 ec 20          	sub    $0x20,%rsp
  803d18:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803d1c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  803d20:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803d24:	be 00 00 00 00       	mov    $0x0,%esi
  803d29:	48 89 c7             	mov    %rax,%rdi
  803d2c:	48 b8 ff 3d 80 00 00 	movabs $0x803dff,%rax
  803d33:	00 00 00 
  803d36:	ff d0                	callq  *%rax
  803d38:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803d3b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803d3f:	79 05                	jns    803d46 <stat+0x36>
		return fd;
  803d41:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803d44:	eb 2f                	jmp    803d75 <stat+0x65>
	r = fstat(fd, stat);
  803d46:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  803d4a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803d4d:	48 89 d6             	mov    %rdx,%rsi
  803d50:	89 c7                	mov    %eax,%edi
  803d52:	48 b8 57 3c 80 00 00 	movabs $0x803c57,%rax
  803d59:	00 00 00 
  803d5c:	ff d0                	callq  *%rax
  803d5e:	89 45 f8             	mov    %eax,-0x8(%rbp)
	close(fd);
  803d61:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803d64:	89 c7                	mov    %eax,%edi
  803d66:	48 b8 fe 36 80 00 00 	movabs $0x8036fe,%rax
  803d6d:	00 00 00 
  803d70:	ff d0                	callq  *%rax
	return r;
  803d72:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  803d75:	c9                   	leaveq 
  803d76:	c3                   	retq   
	...

0000000000803d78 <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  803d78:	55                   	push   %rbp
  803d79:	48 89 e5             	mov    %rsp,%rbp
  803d7c:	48 83 ec 10          	sub    $0x10,%rsp
  803d80:	89 7d fc             	mov    %edi,-0x4(%rbp)
  803d83:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	static envid_t fsenv;
	if (fsenv == 0)
  803d87:	48 b8 c4 90 82 00 00 	movabs $0x8290c4,%rax
  803d8e:	00 00 00 
  803d91:	8b 00                	mov    (%rax),%eax
  803d93:	85 c0                	test   %eax,%eax
  803d95:	75 1d                	jne    803db4 <fsipc+0x3c>
		fsenv = ipc_find_env(ENV_TYPE_FS);
  803d97:	bf 01 00 00 00       	mov    $0x1,%edi
  803d9c:	48 b8 83 33 80 00 00 	movabs $0x803383,%rax
  803da3:	00 00 00 
  803da6:	ff d0                	callq  *%rax
  803da8:	48 ba c4 90 82 00 00 	movabs $0x8290c4,%rdx
  803daf:	00 00 00 
  803db2:	89 02                	mov    %eax,(%rdx)
	//static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  803db4:	48 b8 c4 90 82 00 00 	movabs $0x8290c4,%rax
  803dbb:	00 00 00 
  803dbe:	8b 00                	mov    (%rax),%eax
  803dc0:	8b 75 fc             	mov    -0x4(%rbp),%esi
  803dc3:	b9 07 00 00 00       	mov    $0x7,%ecx
  803dc8:	48 ba 00 80 b5 00 00 	movabs $0xb58000,%rdx
  803dcf:	00 00 00 
  803dd2:	89 c7                	mov    %eax,%edi
  803dd4:	48 b8 c0 32 80 00 00 	movabs $0x8032c0,%rax
  803ddb:	00 00 00 
  803dde:	ff d0                	callq  *%rax
	return ipc_recv(NULL, dstva, NULL);
  803de0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803de4:	ba 00 00 00 00       	mov    $0x0,%edx
  803de9:	48 89 c6             	mov    %rax,%rsi
  803dec:	bf 00 00 00 00       	mov    $0x0,%edi
  803df1:	48 b8 00 32 80 00 00 	movabs $0x803200,%rax
  803df8:	00 00 00 
  803dfb:	ff d0                	callq  *%rax
}
  803dfd:	c9                   	leaveq 
  803dfe:	c3                   	retq   

0000000000803dff <open>:
// 	The file descriptor index on success
// 	-E_BAD_PATH if the path is too long (>= MAXPATHLEN)
// 	< 0 for other errors.
int
open(const char *path, int mode)
{
  803dff:	55                   	push   %rbp
  803e00:	48 89 e5             	mov    %rsp,%rbp
  803e03:	48 83 ec 20          	sub    $0x20,%rsp
  803e07:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803e0b:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	// LAB 5: Your code here
	
	struct Fd *fd;
	int r;
	
	if(strlen(path)>= MAXPATHLEN)
  803e0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803e12:	48 89 c7             	mov    %rax,%rdi
  803e15:	48 b8 58 1e 80 00 00 	movabs $0x801e58,%rax
  803e1c:	00 00 00 
  803e1f:	ff d0                	callq  *%rax
  803e21:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  803e26:	7e 0a                	jle    803e32 <open+0x33>
                return -E_BAD_PATH;
  803e28:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
  803e2d:	e9 a5 00 00 00       	jmpq   803ed7 <open+0xd8>
	if((r=fd_alloc(&fd))<0)
  803e32:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  803e36:	48 89 c7             	mov    %rax,%rdi
  803e39:	48 b8 56 34 80 00 00 	movabs $0x803456,%rax
  803e40:	00 00 00 
  803e43:	ff d0                	callq  *%rax
  803e45:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803e48:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803e4c:	79 08                	jns    803e56 <open+0x57>
		return r;
  803e4e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803e51:	e9 81 00 00 00       	jmpq   803ed7 <open+0xd8>
	strcpy(fsipcbuf.open.req_path,path);
  803e56:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803e5a:	48 89 c6             	mov    %rax,%rsi
  803e5d:	48 bf 00 80 b5 00 00 	movabs $0xb58000,%rdi
  803e64:	00 00 00 
  803e67:	48 b8 c4 1e 80 00 00 	movabs $0x801ec4,%rax
  803e6e:	00 00 00 
  803e71:	ff d0                	callq  *%rax
	fsipcbuf.open.req_omode=mode;
  803e73:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803e7a:	00 00 00 
  803e7d:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  803e80:	89 90 00 04 00 00    	mov    %edx,0x400(%rax)
	r=fsipc(FSREQ_OPEN, fd);
  803e86:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803e8a:	48 89 c6             	mov    %rax,%rsi
  803e8d:	bf 01 00 00 00       	mov    $0x1,%edi
  803e92:	48 b8 78 3d 80 00 00 	movabs $0x803d78,%rax
  803e99:	00 00 00 
  803e9c:	ff d0                	callq  *%rax
  803e9e:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(r<0)
  803ea1:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803ea5:	79 1d                	jns    803ec4 <open+0xc5>
	{
		fd_close(fd,0);
  803ea7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803eab:	be 00 00 00 00       	mov    $0x0,%esi
  803eb0:	48 89 c7             	mov    %rax,%rdi
  803eb3:	48 b8 7e 35 80 00 00 	movabs $0x80357e,%rax
  803eba:	00 00 00 
  803ebd:	ff d0                	callq  *%rax
		return r;
  803ebf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803ec2:	eb 13                	jmp    803ed7 <open+0xd8>
	}
	return fd2num(fd);
  803ec4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  803ec8:	48 89 c7             	mov    %rax,%rdi
  803ecb:	48 b8 08 34 80 00 00 	movabs $0x803408,%rax
  803ed2:	00 00 00 
  803ed5:	ff d0                	callq  *%rax
	


}
  803ed7:	c9                   	leaveq 
  803ed8:	c3                   	retq   

0000000000803ed9 <devfile_flush>:
// open, unmapping it is enough to free up server-side resources.
// Other than that, we just have to make sure our changes are flushed
// to disk.
static int
devfile_flush(struct Fd *fd)
{
  803ed9:	55                   	push   %rbp
  803eda:	48 89 e5             	mov    %rsp,%rbp
  803edd:	48 83 ec 10          	sub    $0x10,%rsp
  803ee1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  803ee5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  803ee9:	8b 50 0c             	mov    0xc(%rax),%edx
  803eec:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803ef3:	00 00 00 
  803ef6:	89 10                	mov    %edx,(%rax)
	return fsipc(FSREQ_FLUSH, NULL);
  803ef8:	be 00 00 00 00       	mov    $0x0,%esi
  803efd:	bf 06 00 00 00       	mov    $0x6,%edi
  803f02:	48 b8 78 3d 80 00 00 	movabs $0x803d78,%rax
  803f09:	00 00 00 
  803f0c:	ff d0                	callq  *%rax
}
  803f0e:	c9                   	leaveq 
  803f0f:	c3                   	retq   

0000000000803f10 <devfile_read>:
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  803f10:	55                   	push   %rbp
  803f11:	48 89 e5             	mov    %rsp,%rbp
  803f14:	48 83 ec 30          	sub    $0x30,%rsp
  803f18:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803f1c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  803f20:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// bytes read will be written back to fsipcbuf by the file
	// system server.
	// LAB 5: Your code here
	ssize_t r;
	
	fsipcbuf.read.req_fileid = fd->fd_file.id;
  803f24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803f28:	8b 50 0c             	mov    0xc(%rax),%edx
  803f2b:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803f32:	00 00 00 
  803f35:	89 10                	mov    %edx,(%rax)
	fsipcbuf.read.req_n = n;
  803f37:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803f3e:	00 00 00 
  803f41:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  803f45:	48 89 50 08          	mov    %rdx,0x8(%rax)
	if ((r = fsipc(FSREQ_READ, NULL)) < 0)
  803f49:	be 00 00 00 00       	mov    $0x0,%esi
  803f4e:	bf 03 00 00 00       	mov    $0x3,%edi
  803f53:	48 b8 78 3d 80 00 00 	movabs $0x803d78,%rax
  803f5a:	00 00 00 
  803f5d:	ff d0                	callq  *%rax
  803f5f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  803f62:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803f66:	79 05                	jns    803f6d <devfile_read+0x5d>
	{
		return r;
  803f68:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803f6b:	eb 2c                	jmp    803f99 <devfile_read+0x89>
	}
	if(r > 0)
  803f6d:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  803f71:	7e 23                	jle    803f96 <devfile_read+0x86>
		memmove(buf, (void *)&fsipcbuf.readRet.ret_buf, r);
  803f73:	8b 45 fc             	mov    -0x4(%rbp),%eax
  803f76:	48 63 d0             	movslq %eax,%rdx
  803f79:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803f7d:	48 be 00 80 b5 00 00 	movabs $0xb58000,%rsi
  803f84:	00 00 00 
  803f87:	48 89 c7             	mov    %rax,%rdi
  803f8a:	48 b8 e6 21 80 00 00 	movabs $0x8021e6,%rax
  803f91:	00 00 00 
  803f94:	ff d0                	callq  *%rax
	return r;
  803f96:	8b 45 fc             	mov    -0x4(%rbp),%eax



}
  803f99:	c9                   	leaveq 
  803f9a:	c3                   	retq   

0000000000803f9b <devfile_write>:


static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
  803f9b:	55                   	push   %rbp
  803f9c:	48 89 e5             	mov    %rsp,%rbp
  803f9f:	48 83 ec 30          	sub    $0x30,%rsp
  803fa3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  803fa7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  803fab:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

	ssize_t r,status;
	fsipcbuf.write.req_fileid = fd -> fd_file.id;
  803faf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  803fb3:	8b 50 0c             	mov    0xc(%rax),%edx
  803fb6:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803fbd:	00 00 00 
  803fc0:	89 10                	mov    %edx,(%rax)
	//fsipcbuf.write.req_n=n;
	if(n > (PGSIZE - (sizeof(int) + sizeof(size_t)))) 
  803fc2:	48 81 7d d8 f4 0f 00 	cmpq   $0xff4,-0x28(%rbp)
  803fc9:	00 
  803fca:	76 08                	jbe    803fd4 <devfile_write+0x39>
		n = (PGSIZE - (sizeof(int) + (sizeof(size_t))));
  803fcc:	48 c7 45 d8 f4 0f 00 	movq   $0xff4,-0x28(%rbp)
  803fd3:	00 
	fsipcbuf.write.req_n=n;
  803fd4:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  803fdb:	00 00 00 
  803fde:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  803fe2:	48 89 50 08          	mov    %rdx,0x8(%rax)
	memmove(fsipcbuf.write.req_buf, buf, n);
  803fe6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  803fea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  803fee:	48 89 c6             	mov    %rax,%rsi
  803ff1:	48 bf 10 80 b5 00 00 	movabs $0xb58010,%rdi
  803ff8:	00 00 00 
  803ffb:	48 b8 e6 21 80 00 00 	movabs $0x8021e6,%rax
  804002:	00 00 00 
  804005:	ff d0                	callq  *%rax
	r = fsipc(FSREQ_WRITE, NULL);
  804007:	be 00 00 00 00       	mov    $0x0,%esi
  80400c:	bf 04 00 00 00       	mov    $0x4,%edi
  804011:	48 b8 78 3d 80 00 00 	movabs $0x803d78,%rax
  804018:	00 00 00 
  80401b:	ff d0                	callq  *%rax
  80401d:	89 45 fc             	mov    %eax,-0x4(%rbp)
	return r;
  804020:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  804023:	c9                   	leaveq 
  804024:	c3                   	retq   

0000000000804025 <devfile_trunc>:



static int
devfile_trunc(struct Fd *fd, off_t size)
{
  804025:	55                   	push   %rbp
  804026:	48 89 e5             	mov    %rsp,%rbp
  804029:	48 83 ec 10          	sub    $0x10,%rsp
  80402d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  804031:	89 75 f4             	mov    %esi,-0xc(%rbp)
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  804034:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804038:	8b 50 0c             	mov    0xc(%rax),%edx
  80403b:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  804042:	00 00 00 
  804045:	89 10                	mov    %edx,(%rax)
	fsipcbuf.set_size.req_size = size;
  804047:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  80404e:	00 00 00 
  804051:	8b 55 f4             	mov    -0xc(%rbp),%edx
  804054:	89 50 04             	mov    %edx,0x4(%rax)
	return fsipc(FSREQ_SET_SIZE, NULL);
  804057:	be 00 00 00 00       	mov    $0x0,%esi
  80405c:	bf 02 00 00 00       	mov    $0x2,%edi
  804061:	48 b8 78 3d 80 00 00 	movabs $0x803d78,%rax
  804068:	00 00 00 
  80406b:	ff d0                	callq  *%rax
}
  80406d:	c9                   	leaveq 
  80406e:	c3                   	retq   

000000000080406f <devfile_stat>:

static int
devfile_stat(struct Fd *fd, struct Stat *st)
{
  80406f:	55                   	push   %rbp
  804070:	48 89 e5             	mov    %rsp,%rbp
  804073:	48 83 ec 20          	sub    $0x20,%rsp
  804077:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80407b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int r;

	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  80407f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804083:	8b 50 0c             	mov    0xc(%rax),%edx
  804086:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  80408d:	00 00 00 
  804090:	89 10                	mov    %edx,(%rax)
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  804092:	be 00 00 00 00       	mov    $0x0,%esi
  804097:	bf 05 00 00 00       	mov    $0x5,%edi
  80409c:	48 b8 78 3d 80 00 00 	movabs $0x803d78,%rax
  8040a3:	00 00 00 
  8040a6:	ff d0                	callq  *%rax
  8040a8:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8040ab:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8040af:	79 05                	jns    8040b6 <devfile_stat+0x47>
		return r;
  8040b1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8040b4:	eb 56                	jmp    80410c <devfile_stat+0x9d>
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  8040b6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8040ba:	48 be 00 80 b5 00 00 	movabs $0xb58000,%rsi
  8040c1:	00 00 00 
  8040c4:	48 89 c7             	mov    %rax,%rdi
  8040c7:	48 b8 c4 1e 80 00 00 	movabs $0x801ec4,%rax
  8040ce:	00 00 00 
  8040d1:	ff d0                	callq  *%rax
	st->st_size = fsipcbuf.statRet.ret_size;
  8040d3:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  8040da:	00 00 00 
  8040dd:	8b 90 80 00 00 00    	mov    0x80(%rax),%edx
  8040e3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8040e7:	89 90 80 00 00 00    	mov    %edx,0x80(%rax)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  8040ed:	48 b8 00 80 b5 00 00 	movabs $0xb58000,%rax
  8040f4:	00 00 00 
  8040f7:	8b 90 84 00 00 00    	mov    0x84(%rax),%edx
  8040fd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804101:	89 90 84 00 00 00    	mov    %edx,0x84(%rax)
	return 0;
  804107:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80410c:	c9                   	leaveq 
  80410d:	c3                   	retq   
	...

0000000000804110 <fd2sockid>:
	.dev_stat =	devsock_stat,
};

static int
fd2sockid(int fd)
{
  804110:	55                   	push   %rbp
  804111:	48 89 e5             	mov    %rsp,%rbp
  804114:	48 83 ec 20          	sub    $0x20,%rsp
  804118:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
  80411b:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80411f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  804122:	48 89 d6             	mov    %rdx,%rsi
  804125:	89 c7                	mov    %eax,%edi
  804127:	48 b8 ee 34 80 00 00 	movabs $0x8034ee,%rax
  80412e:	00 00 00 
  804131:	ff d0                	callq  *%rax
  804133:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804136:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80413a:	79 05                	jns    804141 <fd2sockid+0x31>
		return r;
  80413c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80413f:	eb 24                	jmp    804165 <fd2sockid+0x55>
	if (sfd->fd_dev_id != devsock.dev_id)
  804141:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804145:	8b 10                	mov    (%rax),%edx
  804147:	48 b8 a0 80 82 00 00 	movabs $0x8280a0,%rax
  80414e:	00 00 00 
  804151:	8b 00                	mov    (%rax),%eax
  804153:	39 c2                	cmp    %eax,%edx
  804155:	74 07                	je     80415e <fd2sockid+0x4e>
		return -E_NOT_SUPP;
  804157:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
  80415c:	eb 07                	jmp    804165 <fd2sockid+0x55>
	return sfd->fd_sock.sockid;
  80415e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804162:	8b 40 0c             	mov    0xc(%rax),%eax
}
  804165:	c9                   	leaveq 
  804166:	c3                   	retq   

0000000000804167 <alloc_sockfd>:

static int
alloc_sockfd(int sockid)
{
  804167:	55                   	push   %rbp
  804168:	48 89 e5             	mov    %rsp,%rbp
  80416b:	48 83 ec 20          	sub    $0x20,%rsp
  80416f:	89 7d ec             	mov    %edi,-0x14(%rbp)
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  804172:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  804176:	48 89 c7             	mov    %rax,%rdi
  804179:	48 b8 56 34 80 00 00 	movabs $0x803456,%rax
  804180:	00 00 00 
  804183:	ff d0                	callq  *%rax
  804185:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804188:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80418c:	78 26                	js     8041b4 <alloc_sockfd+0x4d>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  80418e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804192:	ba 07 04 00 00       	mov    $0x407,%edx
  804197:	48 89 c6             	mov    %rax,%rsi
  80419a:	bf 00 00 00 00       	mov    $0x0,%edi
  80419f:	48 b8 fc 27 80 00 00 	movabs $0x8027fc,%rax
  8041a6:	00 00 00 
  8041a9:	ff d0                	callq  *%rax
  8041ab:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8041ae:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8041b2:	79 16                	jns    8041ca <alloc_sockfd+0x63>
		nsipc_close(sockid);
  8041b4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8041b7:	89 c7                	mov    %eax,%edi
  8041b9:	48 b8 74 46 80 00 00 	movabs $0x804674,%rax
  8041c0:	00 00 00 
  8041c3:	ff d0                	callq  *%rax
		return r;
  8041c5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8041c8:	eb 3a                	jmp    804204 <alloc_sockfd+0x9d>
	}

	sfd->fd_dev_id = devsock.dev_id;
  8041ca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8041ce:	48 ba a0 80 82 00 00 	movabs $0x8280a0,%rdx
  8041d5:	00 00 00 
  8041d8:	8b 12                	mov    (%rdx),%edx
  8041da:	89 10                	mov    %edx,(%rax)
	sfd->fd_omode = O_RDWR;
  8041dc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8041e0:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%rax)
	sfd->fd_sock.sockid = sockid;
  8041e7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8041eb:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8041ee:	89 50 0c             	mov    %edx,0xc(%rax)
	return fd2num(sfd);
  8041f1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8041f5:	48 89 c7             	mov    %rax,%rdi
  8041f8:	48 b8 08 34 80 00 00 	movabs $0x803408,%rax
  8041ff:	00 00 00 
  804202:	ff d0                	callq  *%rax
}
  804204:	c9                   	leaveq 
  804205:	c3                   	retq   

0000000000804206 <accept>:

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  804206:	55                   	push   %rbp
  804207:	48 89 e5             	mov    %rsp,%rbp
  80420a:	48 83 ec 30          	sub    $0x30,%rsp
  80420e:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804211:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  804215:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  804219:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80421c:	89 c7                	mov    %eax,%edi
  80421e:	48 b8 10 41 80 00 00 	movabs $0x804110,%rax
  804225:	00 00 00 
  804228:	ff d0                	callq  *%rax
  80422a:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80422d:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804231:	79 05                	jns    804238 <accept+0x32>
		return r;
  804233:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804236:	eb 3b                	jmp    804273 <accept+0x6d>
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  804238:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80423c:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  804240:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804243:	48 89 ce             	mov    %rcx,%rsi
  804246:	89 c7                	mov    %eax,%edi
  804248:	48 b8 51 45 80 00 00 	movabs $0x804551,%rax
  80424f:	00 00 00 
  804252:	ff d0                	callq  *%rax
  804254:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804257:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80425b:	79 05                	jns    804262 <accept+0x5c>
		return r;
  80425d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804260:	eb 11                	jmp    804273 <accept+0x6d>
	return alloc_sockfd(r);
  804262:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804265:	89 c7                	mov    %eax,%edi
  804267:	48 b8 67 41 80 00 00 	movabs $0x804167,%rax
  80426e:	00 00 00 
  804271:	ff d0                	callq  *%rax
}
  804273:	c9                   	leaveq 
  804274:	c3                   	retq   

0000000000804275 <bind>:

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  804275:	55                   	push   %rbp
  804276:	48 89 e5             	mov    %rsp,%rbp
  804279:	48 83 ec 20          	sub    $0x20,%rsp
  80427d:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804280:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  804284:	89 55 e8             	mov    %edx,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  804287:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80428a:	89 c7                	mov    %eax,%edi
  80428c:	48 b8 10 41 80 00 00 	movabs $0x804110,%rax
  804293:	00 00 00 
  804296:	ff d0                	callq  *%rax
  804298:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80429b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80429f:	79 05                	jns    8042a6 <bind+0x31>
		return r;
  8042a1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8042a4:	eb 1b                	jmp    8042c1 <bind+0x4c>
	return nsipc_bind(r, name, namelen);
  8042a6:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8042a9:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8042ad:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8042b0:	48 89 ce             	mov    %rcx,%rsi
  8042b3:	89 c7                	mov    %eax,%edi
  8042b5:	48 b8 d0 45 80 00 00 	movabs $0x8045d0,%rax
  8042bc:	00 00 00 
  8042bf:	ff d0                	callq  *%rax
}
  8042c1:	c9                   	leaveq 
  8042c2:	c3                   	retq   

00000000008042c3 <shutdown>:

int
shutdown(int s, int how)
{
  8042c3:	55                   	push   %rbp
  8042c4:	48 89 e5             	mov    %rsp,%rbp
  8042c7:	48 83 ec 20          	sub    $0x20,%rsp
  8042cb:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8042ce:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  8042d1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8042d4:	89 c7                	mov    %eax,%edi
  8042d6:	48 b8 10 41 80 00 00 	movabs $0x804110,%rax
  8042dd:	00 00 00 
  8042e0:	ff d0                	callq  *%rax
  8042e2:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8042e5:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8042e9:	79 05                	jns    8042f0 <shutdown+0x2d>
		return r;
  8042eb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8042ee:	eb 16                	jmp    804306 <shutdown+0x43>
	return nsipc_shutdown(r, how);
  8042f0:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8042f3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8042f6:	89 d6                	mov    %edx,%esi
  8042f8:	89 c7                	mov    %eax,%edi
  8042fa:	48 b8 34 46 80 00 00 	movabs $0x804634,%rax
  804301:	00 00 00 
  804304:	ff d0                	callq  *%rax
}
  804306:	c9                   	leaveq 
  804307:	c3                   	retq   

0000000000804308 <devsock_close>:

static int
devsock_close(struct Fd *fd)
{
  804308:	55                   	push   %rbp
  804309:	48 89 e5             	mov    %rsp,%rbp
  80430c:	48 83 ec 10          	sub    $0x10,%rsp
  804310:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (pageref(fd) == 1)
  804314:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804318:	48 89 c7             	mov    %rax,%rdi
  80431b:	48 b8 74 58 80 00 00 	movabs $0x805874,%rax
  804322:	00 00 00 
  804325:	ff d0                	callq  *%rax
  804327:	83 f8 01             	cmp    $0x1,%eax
  80432a:	75 17                	jne    804343 <devsock_close+0x3b>
		return nsipc_close(fd->fd_sock.sockid);
  80432c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804330:	8b 40 0c             	mov    0xc(%rax),%eax
  804333:	89 c7                	mov    %eax,%edi
  804335:	48 b8 74 46 80 00 00 	movabs $0x804674,%rax
  80433c:	00 00 00 
  80433f:	ff d0                	callq  *%rax
  804341:	eb 05                	jmp    804348 <devsock_close+0x40>
	else
		return 0;
  804343:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804348:	c9                   	leaveq 
  804349:	c3                   	retq   

000000000080434a <connect>:

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  80434a:	55                   	push   %rbp
  80434b:	48 89 e5             	mov    %rsp,%rbp
  80434e:	48 83 ec 20          	sub    $0x20,%rsp
  804352:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804355:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  804359:	89 55 e8             	mov    %edx,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  80435c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80435f:	89 c7                	mov    %eax,%edi
  804361:	48 b8 10 41 80 00 00 	movabs $0x804110,%rax
  804368:	00 00 00 
  80436b:	ff d0                	callq  *%rax
  80436d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804370:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804374:	79 05                	jns    80437b <connect+0x31>
		return r;
  804376:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804379:	eb 1b                	jmp    804396 <connect+0x4c>
	return nsipc_connect(r, name, namelen);
  80437b:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80437e:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  804382:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804385:	48 89 ce             	mov    %rcx,%rsi
  804388:	89 c7                	mov    %eax,%edi
  80438a:	48 b8 a1 46 80 00 00 	movabs $0x8046a1,%rax
  804391:	00 00 00 
  804394:	ff d0                	callq  *%rax
}
  804396:	c9                   	leaveq 
  804397:	c3                   	retq   

0000000000804398 <listen>:

int
listen(int s, int backlog)
{
  804398:	55                   	push   %rbp
  804399:	48 89 e5             	mov    %rsp,%rbp
  80439c:	48 83 ec 20          	sub    $0x20,%rsp
  8043a0:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8043a3:	89 75 e8             	mov    %esi,-0x18(%rbp)
	int r;
	if ((r = fd2sockid(s)) < 0)
  8043a6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8043a9:	89 c7                	mov    %eax,%edi
  8043ab:	48 b8 10 41 80 00 00 	movabs $0x804110,%rax
  8043b2:	00 00 00 
  8043b5:	ff d0                	callq  *%rax
  8043b7:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8043ba:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8043be:	79 05                	jns    8043c5 <listen+0x2d>
		return r;
  8043c0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8043c3:	eb 16                	jmp    8043db <listen+0x43>
	return nsipc_listen(r, backlog);
  8043c5:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8043c8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8043cb:	89 d6                	mov    %edx,%esi
  8043cd:	89 c7                	mov    %eax,%edi
  8043cf:	48 b8 05 47 80 00 00 	movabs $0x804705,%rax
  8043d6:	00 00 00 
  8043d9:	ff d0                	callq  *%rax
}
  8043db:	c9                   	leaveq 
  8043dc:	c3                   	retq   

00000000008043dd <devsock_read>:

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  8043dd:	55                   	push   %rbp
  8043de:	48 89 e5             	mov    %rsp,%rbp
  8043e1:	48 83 ec 20          	sub    $0x20,%rsp
  8043e5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8043e9:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8043ed:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  8043f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8043f5:	89 c2                	mov    %eax,%edx
  8043f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8043fb:	8b 40 0c             	mov    0xc(%rax),%eax
  8043fe:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  804402:	b9 00 00 00 00       	mov    $0x0,%ecx
  804407:	89 c7                	mov    %eax,%edi
  804409:	48 b8 45 47 80 00 00 	movabs $0x804745,%rax
  804410:	00 00 00 
  804413:	ff d0                	callq  *%rax
}
  804415:	c9                   	leaveq 
  804416:	c3                   	retq   

0000000000804417 <devsock_write>:

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  804417:	55                   	push   %rbp
  804418:	48 89 e5             	mov    %rsp,%rbp
  80441b:	48 83 ec 20          	sub    $0x20,%rsp
  80441f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  804423:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  804427:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  80442b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80442f:	89 c2                	mov    %eax,%edx
  804431:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804435:	8b 40 0c             	mov    0xc(%rax),%eax
  804438:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80443c:	b9 00 00 00 00       	mov    $0x0,%ecx
  804441:	89 c7                	mov    %eax,%edi
  804443:	48 b8 11 48 80 00 00 	movabs $0x804811,%rax
  80444a:	00 00 00 
  80444d:	ff d0                	callq  *%rax
}
  80444f:	c9                   	leaveq 
  804450:	c3                   	retq   

0000000000804451 <devsock_stat>:

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  804451:	55                   	push   %rbp
  804452:	48 89 e5             	mov    %rsp,%rbp
  804455:	48 83 ec 10          	sub    $0x10,%rsp
  804459:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80445d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	strcpy(stat->st_name, "<sock>");
  804461:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804465:	48 be 3b 12 82 00 00 	movabs $0x82123b,%rsi
  80446c:	00 00 00 
  80446f:	48 89 c7             	mov    %rax,%rdi
  804472:	48 b8 c4 1e 80 00 00 	movabs $0x801ec4,%rax
  804479:	00 00 00 
  80447c:	ff d0                	callq  *%rax
	return 0;
  80447e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  804483:	c9                   	leaveq 
  804484:	c3                   	retq   

0000000000804485 <socket>:

int
socket(int domain, int type, int protocol)
{
  804485:	55                   	push   %rbp
  804486:	48 89 e5             	mov    %rsp,%rbp
  804489:	48 83 ec 20          	sub    $0x20,%rsp
  80448d:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804490:	89 75 e8             	mov    %esi,-0x18(%rbp)
  804493:	89 55 e4             	mov    %edx,-0x1c(%rbp)
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  804496:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  804499:	8b 4d e8             	mov    -0x18(%rbp),%ecx
  80449c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80449f:	89 ce                	mov    %ecx,%esi
  8044a1:	89 c7                	mov    %eax,%edi
  8044a3:	48 b8 c9 48 80 00 00 	movabs $0x8048c9,%rax
  8044aa:	00 00 00 
  8044ad:	ff d0                	callq  *%rax
  8044af:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8044b2:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8044b6:	79 05                	jns    8044bd <socket+0x38>
		return r;
  8044b8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8044bb:	eb 11                	jmp    8044ce <socket+0x49>
	return alloc_sockfd(r);
  8044bd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8044c0:	89 c7                	mov    %eax,%edi
  8044c2:	48 b8 67 41 80 00 00 	movabs $0x804167,%rax
  8044c9:	00 00 00 
  8044cc:	ff d0                	callq  *%rax
}
  8044ce:	c9                   	leaveq 
  8044cf:	c3                   	retq   

00000000008044d0 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  8044d0:	55                   	push   %rbp
  8044d1:	48 89 e5             	mov    %rsp,%rbp
  8044d4:	48 83 ec 10          	sub    $0x10,%rsp
  8044d8:	89 7d fc             	mov    %edi,-0x4(%rbp)
	static envid_t nsenv;
	if (nsenv == 0)
  8044db:	48 b8 d0 90 82 00 00 	movabs $0x8290d0,%rax
  8044e2:	00 00 00 
  8044e5:	8b 00                	mov    (%rax),%eax
  8044e7:	85 c0                	test   %eax,%eax
  8044e9:	75 1d                	jne    804508 <nsipc+0x38>
		nsenv = ipc_find_env(ENV_TYPE_NS);
  8044eb:	bf 02 00 00 00       	mov    $0x2,%edi
  8044f0:	48 b8 83 33 80 00 00 	movabs $0x803383,%rax
  8044f7:	00 00 00 
  8044fa:	ff d0                	callq  *%rax
  8044fc:	48 ba d0 90 82 00 00 	movabs $0x8290d0,%rdx
  804503:	00 00 00 
  804506:	89 02                	mov    %eax,(%rdx)
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  804508:	48 b8 d0 90 82 00 00 	movabs $0x8290d0,%rax
  80450f:	00 00 00 
  804512:	8b 00                	mov    (%rax),%eax
  804514:	8b 75 fc             	mov    -0x4(%rbp),%esi
  804517:	b9 07 00 00 00       	mov    $0x7,%ecx
  80451c:	48 ba 00 a0 b5 00 00 	movabs $0xb5a000,%rdx
  804523:	00 00 00 
  804526:	89 c7                	mov    %eax,%edi
  804528:	48 b8 c0 32 80 00 00 	movabs $0x8032c0,%rax
  80452f:	00 00 00 
  804532:	ff d0                	callq  *%rax
	return ipc_recv(NULL, NULL, NULL);
  804534:	ba 00 00 00 00       	mov    $0x0,%edx
  804539:	be 00 00 00 00       	mov    $0x0,%esi
  80453e:	bf 00 00 00 00       	mov    $0x0,%edi
  804543:	48 b8 00 32 80 00 00 	movabs $0x803200,%rax
  80454a:	00 00 00 
  80454d:	ff d0                	callq  *%rax
}
  80454f:	c9                   	leaveq 
  804550:	c3                   	retq   

0000000000804551 <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  804551:	55                   	push   %rbp
  804552:	48 89 e5             	mov    %rsp,%rbp
  804555:	48 83 ec 30          	sub    $0x30,%rsp
  804559:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80455c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  804560:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int r;

	nsipcbuf.accept.req_s = s;
  804564:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  80456b:	00 00 00 
  80456e:	8b 55 ec             	mov    -0x14(%rbp),%edx
  804571:	89 10                	mov    %edx,(%rax)
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  804573:	bf 01 00 00 00       	mov    $0x1,%edi
  804578:	48 b8 d0 44 80 00 00 	movabs $0x8044d0,%rax
  80457f:	00 00 00 
  804582:	ff d0                	callq  *%rax
  804584:	89 45 fc             	mov    %eax,-0x4(%rbp)
  804587:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80458b:	78 3e                	js     8045cb <nsipc_accept+0x7a>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
  80458d:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804594:	00 00 00 
  804597:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  80459b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80459f:	8b 40 10             	mov    0x10(%rax),%eax
  8045a2:	89 c2                	mov    %eax,%edx
  8045a4:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8045a8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8045ac:	48 89 ce             	mov    %rcx,%rsi
  8045af:	48 89 c7             	mov    %rax,%rdi
  8045b2:	48 b8 e6 21 80 00 00 	movabs $0x8021e6,%rax
  8045b9:	00 00 00 
  8045bc:	ff d0                	callq  *%rax
		*addrlen = ret->ret_addrlen;
  8045be:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8045c2:	8b 50 10             	mov    0x10(%rax),%edx
  8045c5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8045c9:	89 10                	mov    %edx,(%rax)
	}
	return r;
  8045cb:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8045ce:	c9                   	leaveq 
  8045cf:	c3                   	retq   

00000000008045d0 <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  8045d0:	55                   	push   %rbp
  8045d1:	48 89 e5             	mov    %rsp,%rbp
  8045d4:	48 83 ec 10          	sub    $0x10,%rsp
  8045d8:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8045db:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8045df:	89 55 f8             	mov    %edx,-0x8(%rbp)
	nsipcbuf.bind.req_s = s;
  8045e2:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8045e9:	00 00 00 
  8045ec:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8045ef:	89 10                	mov    %edx,(%rax)
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  8045f1:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8045f4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8045f8:	48 89 c6             	mov    %rax,%rsi
  8045fb:	48 bf 04 a0 b5 00 00 	movabs $0xb5a004,%rdi
  804602:	00 00 00 
  804605:	48 b8 e6 21 80 00 00 	movabs $0x8021e6,%rax
  80460c:	00 00 00 
  80460f:	ff d0                	callq  *%rax
	nsipcbuf.bind.req_namelen = namelen;
  804611:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804618:	00 00 00 
  80461b:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80461e:	89 50 14             	mov    %edx,0x14(%rax)
	return nsipc(NSREQ_BIND);
  804621:	bf 02 00 00 00       	mov    $0x2,%edi
  804626:	48 b8 d0 44 80 00 00 	movabs $0x8044d0,%rax
  80462d:	00 00 00 
  804630:	ff d0                	callq  *%rax
}
  804632:	c9                   	leaveq 
  804633:	c3                   	retq   

0000000000804634 <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  804634:	55                   	push   %rbp
  804635:	48 89 e5             	mov    %rsp,%rbp
  804638:	48 83 ec 10          	sub    $0x10,%rsp
  80463c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80463f:	89 75 f8             	mov    %esi,-0x8(%rbp)
	nsipcbuf.shutdown.req_s = s;
  804642:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804649:	00 00 00 
  80464c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80464f:	89 10                	mov    %edx,(%rax)
	nsipcbuf.shutdown.req_how = how;
  804651:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804658:	00 00 00 
  80465b:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80465e:	89 50 04             	mov    %edx,0x4(%rax)
	return nsipc(NSREQ_SHUTDOWN);
  804661:	bf 03 00 00 00       	mov    $0x3,%edi
  804666:	48 b8 d0 44 80 00 00 	movabs $0x8044d0,%rax
  80466d:	00 00 00 
  804670:	ff d0                	callq  *%rax
}
  804672:	c9                   	leaveq 
  804673:	c3                   	retq   

0000000000804674 <nsipc_close>:

int
nsipc_close(int s)
{
  804674:	55                   	push   %rbp
  804675:	48 89 e5             	mov    %rsp,%rbp
  804678:	48 83 ec 10          	sub    $0x10,%rsp
  80467c:	89 7d fc             	mov    %edi,-0x4(%rbp)
	nsipcbuf.close.req_s = s;
  80467f:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804686:	00 00 00 
  804689:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80468c:	89 10                	mov    %edx,(%rax)
	return nsipc(NSREQ_CLOSE);
  80468e:	bf 04 00 00 00       	mov    $0x4,%edi
  804693:	48 b8 d0 44 80 00 00 	movabs $0x8044d0,%rax
  80469a:	00 00 00 
  80469d:	ff d0                	callq  *%rax
}
  80469f:	c9                   	leaveq 
  8046a0:	c3                   	retq   

00000000008046a1 <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  8046a1:	55                   	push   %rbp
  8046a2:	48 89 e5             	mov    %rsp,%rbp
  8046a5:	48 83 ec 10          	sub    $0x10,%rsp
  8046a9:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8046ac:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8046b0:	89 55 f8             	mov    %edx,-0x8(%rbp)
	nsipcbuf.connect.req_s = s;
  8046b3:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8046ba:	00 00 00 
  8046bd:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8046c0:	89 10                	mov    %edx,(%rax)
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  8046c2:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8046c5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8046c9:	48 89 c6             	mov    %rax,%rsi
  8046cc:	48 bf 04 a0 b5 00 00 	movabs $0xb5a004,%rdi
  8046d3:	00 00 00 
  8046d6:	48 b8 e6 21 80 00 00 	movabs $0x8021e6,%rax
  8046dd:	00 00 00 
  8046e0:	ff d0                	callq  *%rax
	nsipcbuf.connect.req_namelen = namelen;
  8046e2:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8046e9:	00 00 00 
  8046ec:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8046ef:	89 50 14             	mov    %edx,0x14(%rax)
	return nsipc(NSREQ_CONNECT);
  8046f2:	bf 05 00 00 00       	mov    $0x5,%edi
  8046f7:	48 b8 d0 44 80 00 00 	movabs $0x8044d0,%rax
  8046fe:	00 00 00 
  804701:	ff d0                	callq  *%rax
}
  804703:	c9                   	leaveq 
  804704:	c3                   	retq   

0000000000804705 <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  804705:	55                   	push   %rbp
  804706:	48 89 e5             	mov    %rsp,%rbp
  804709:	48 83 ec 10          	sub    $0x10,%rsp
  80470d:	89 7d fc             	mov    %edi,-0x4(%rbp)
  804710:	89 75 f8             	mov    %esi,-0x8(%rbp)
	nsipcbuf.listen.req_s = s;
  804713:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  80471a:	00 00 00 
  80471d:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804720:	89 10                	mov    %edx,(%rax)
	nsipcbuf.listen.req_backlog = backlog;
  804722:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804729:	00 00 00 
  80472c:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80472f:	89 50 04             	mov    %edx,0x4(%rax)
	return nsipc(NSREQ_LISTEN);
  804732:	bf 06 00 00 00       	mov    $0x6,%edi
  804737:	48 b8 d0 44 80 00 00 	movabs $0x8044d0,%rax
  80473e:	00 00 00 
  804741:	ff d0                	callq  *%rax
}
  804743:	c9                   	leaveq 
  804744:	c3                   	retq   

0000000000804745 <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  804745:	55                   	push   %rbp
  804746:	48 89 e5             	mov    %rsp,%rbp
  804749:	48 83 ec 30          	sub    $0x30,%rsp
  80474d:	89 7d ec             	mov    %edi,-0x14(%rbp)
  804750:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  804754:	89 55 e8             	mov    %edx,-0x18(%rbp)
  804757:	89 4d dc             	mov    %ecx,-0x24(%rbp)
	int r;

	nsipcbuf.recv.req_s = s;
  80475a:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804761:	00 00 00 
  804764:	8b 55 ec             	mov    -0x14(%rbp),%edx
  804767:	89 10                	mov    %edx,(%rax)
	nsipcbuf.recv.req_len = len;
  804769:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804770:	00 00 00 
  804773:	8b 55 e8             	mov    -0x18(%rbp),%edx
  804776:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.recv.req_flags = flags;
  804779:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804780:	00 00 00 
  804783:	8b 55 dc             	mov    -0x24(%rbp),%edx
  804786:	89 50 08             	mov    %edx,0x8(%rax)

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  804789:	bf 07 00 00 00       	mov    $0x7,%edi
  80478e:	48 b8 d0 44 80 00 00 	movabs $0x8044d0,%rax
  804795:	00 00 00 
  804798:	ff d0                	callq  *%rax
  80479a:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80479d:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8047a1:	78 69                	js     80480c <nsipc_recv+0xc7>
		assert(r < 1600 && r <= len);
  8047a3:	81 7d fc 3f 06 00 00 	cmpl   $0x63f,-0x4(%rbp)
  8047aa:	7f 08                	jg     8047b4 <nsipc_recv+0x6f>
  8047ac:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8047af:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8047b2:	7e 35                	jle    8047e9 <nsipc_recv+0xa4>
  8047b4:	48 b9 42 12 82 00 00 	movabs $0x821242,%rcx
  8047bb:	00 00 00 
  8047be:	48 ba 57 12 82 00 00 	movabs $0x821257,%rdx
  8047c5:	00 00 00 
  8047c8:	be 61 00 00 00       	mov    $0x61,%esi
  8047cd:	48 bf 6c 12 82 00 00 	movabs $0x82126c,%rdi
  8047d4:	00 00 00 
  8047d7:	b8 00 00 00 00       	mov    $0x0,%eax
  8047dc:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  8047e3:	00 00 00 
  8047e6:	41 ff d0             	callq  *%r8
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  8047e9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8047ec:	48 63 d0             	movslq %eax,%rdx
  8047ef:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8047f3:	48 be 00 a0 b5 00 00 	movabs $0xb5a000,%rsi
  8047fa:	00 00 00 
  8047fd:	48 89 c7             	mov    %rax,%rdi
  804800:	48 b8 e6 21 80 00 00 	movabs $0x8021e6,%rax
  804807:	00 00 00 
  80480a:	ff d0                	callq  *%rax
	}

	return r;
  80480c:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80480f:	c9                   	leaveq 
  804810:	c3                   	retq   

0000000000804811 <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  804811:	55                   	push   %rbp
  804812:	48 89 e5             	mov    %rsp,%rbp
  804815:	48 83 ec 20          	sub    $0x20,%rsp
  804819:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80481c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  804820:	89 55 f8             	mov    %edx,-0x8(%rbp)
  804823:	89 4d ec             	mov    %ecx,-0x14(%rbp)
	nsipcbuf.send.req_s = s;
  804826:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  80482d:	00 00 00 
  804830:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804833:	89 10                	mov    %edx,(%rax)
	assert(size < 1600);
  804835:	81 7d f8 3f 06 00 00 	cmpl   $0x63f,-0x8(%rbp)
  80483c:	7e 35                	jle    804873 <nsipc_send+0x62>
  80483e:	48 b9 78 12 82 00 00 	movabs $0x821278,%rcx
  804845:	00 00 00 
  804848:	48 ba 57 12 82 00 00 	movabs $0x821257,%rdx
  80484f:	00 00 00 
  804852:	be 6c 00 00 00       	mov    $0x6c,%esi
  804857:	48 bf 6c 12 82 00 00 	movabs $0x82126c,%rdi
  80485e:	00 00 00 
  804861:	b8 00 00 00 00       	mov    $0x0,%eax
  804866:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  80486d:	00 00 00 
  804870:	41 ff d0             	callq  *%r8
	memmove(&nsipcbuf.send.req_buf, buf, size);
  804873:	8b 45 f8             	mov    -0x8(%rbp),%eax
  804876:	48 63 d0             	movslq %eax,%rdx
  804879:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80487d:	48 89 c6             	mov    %rax,%rsi
  804880:	48 bf 0c a0 b5 00 00 	movabs $0xb5a00c,%rdi
  804887:	00 00 00 
  80488a:	48 b8 e6 21 80 00 00 	movabs $0x8021e6,%rax
  804891:	00 00 00 
  804894:	ff d0                	callq  *%rax
	nsipcbuf.send.req_size = size;
  804896:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  80489d:	00 00 00 
  8048a0:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8048a3:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.send.req_flags = flags;
  8048a6:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8048ad:	00 00 00 
  8048b0:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8048b3:	89 50 08             	mov    %edx,0x8(%rax)
	return nsipc(NSREQ_SEND);
  8048b6:	bf 08 00 00 00       	mov    $0x8,%edi
  8048bb:	48 b8 d0 44 80 00 00 	movabs $0x8044d0,%rax
  8048c2:	00 00 00 
  8048c5:	ff d0                	callq  *%rax
}
  8048c7:	c9                   	leaveq 
  8048c8:	c3                   	retq   

00000000008048c9 <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  8048c9:	55                   	push   %rbp
  8048ca:	48 89 e5             	mov    %rsp,%rbp
  8048cd:	48 83 ec 10          	sub    $0x10,%rsp
  8048d1:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8048d4:	89 75 f8             	mov    %esi,-0x8(%rbp)
  8048d7:	89 55 f4             	mov    %edx,-0xc(%rbp)
	nsipcbuf.socket.req_domain = domain;
  8048da:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8048e1:	00 00 00 
  8048e4:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8048e7:	89 10                	mov    %edx,(%rax)
	nsipcbuf.socket.req_type = type;
  8048e9:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  8048f0:	00 00 00 
  8048f3:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8048f6:	89 50 04             	mov    %edx,0x4(%rax)
	nsipcbuf.socket.req_protocol = protocol;
  8048f9:	48 b8 00 a0 b5 00 00 	movabs $0xb5a000,%rax
  804900:	00 00 00 
  804903:	8b 55 f4             	mov    -0xc(%rbp),%edx
  804906:	89 50 08             	mov    %edx,0x8(%rax)
	return nsipc(NSREQ_SOCKET);
  804909:	bf 09 00 00 00       	mov    $0x9,%edi
  80490e:	48 b8 d0 44 80 00 00 	movabs $0x8044d0,%rax
  804915:	00 00 00 
  804918:	ff d0                	callq  *%rax
}
  80491a:	c9                   	leaveq 
  80491b:	c3                   	retq   

000000000080491c <isfree>:
static uint8_t *mend   = (uint8_t*) 0x10000000;
static uint8_t *mptr;

static int
isfree(void *v, size_t n)
{
  80491c:	55                   	push   %rbp
  80491d:	48 89 e5             	mov    %rsp,%rbp
  804920:	48 83 ec 20          	sub    $0x20,%rsp
  804924:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  804928:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uintptr_t va, end_va = (uintptr_t) v + n;
  80492c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804930:	48 03 45 e0          	add    -0x20(%rbp),%rax
  804934:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  804938:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80493c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  804940:	eb 62                	jmp    8049a4 <isfree+0x88>
		if (va >= (uintptr_t) mend
  804942:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  804949:	00 00 00 
  80494c:	48 8b 00             	mov    (%rax),%rax
  80494f:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  804953:	76 40                	jbe    804995 <isfree+0x79>
		    || ((uvpd[VPD(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  804955:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804959:	48 89 c2             	mov    %rax,%rdx
  80495c:	48 c1 ea 15          	shr    $0x15,%rdx
  804960:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  804967:	01 00 00 
  80496a:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80496e:	83 e0 01             	and    $0x1,%eax
  804971:	84 c0                	test   %al,%al
  804973:	74 27                	je     80499c <isfree+0x80>
  804975:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804979:	48 89 c2             	mov    %rax,%rdx
  80497c:	48 c1 ea 0c          	shr    $0xc,%rdx
  804980:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  804987:	01 00 00 
  80498a:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80498e:	83 e0 01             	and    $0x1,%eax
  804991:	84 c0                	test   %al,%al
  804993:	74 07                	je     80499c <isfree+0x80>
			return 0;
  804995:	b8 00 00 00 00       	mov    $0x0,%eax
  80499a:	eb 17                	jmp    8049b3 <isfree+0x97>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  80499c:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8049a3:	00 
  8049a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8049a8:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8049ac:	72 94                	jb     804942 <isfree+0x26>
		if (va >= (uintptr_t) mend
		    || ((uvpd[VPD(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
			return 0;
	return 1;
  8049ae:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8049b3:	c9                   	leaveq 
  8049b4:	c3                   	retq   

00000000008049b5 <malloc>:

void*
malloc(size_t n)
{
  8049b5:	55                   	push   %rbp
  8049b6:	48 89 e5             	mov    %rsp,%rbp
  8049b9:	48 83 ec 60          	sub    $0x60,%rsp
  8049bd:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  8049c1:	48 b8 e0 90 82 00 00 	movabs $0x8290e0,%rax
  8049c8:	00 00 00 
  8049cb:	48 8b 00             	mov    (%rax),%rax
  8049ce:	48 85 c0             	test   %rax,%rax
  8049d1:	75 1a                	jne    8049ed <malloc+0x38>
		mptr = mbegin;
  8049d3:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  8049da:	00 00 00 
  8049dd:	48 8b 10             	mov    (%rax),%rdx
  8049e0:	48 b8 e0 90 82 00 00 	movabs $0x8290e0,%rax
  8049e7:	00 00 00 
  8049ea:	48 89 10             	mov    %rdx,(%rax)

	n = ROUNDUP(n, 4);
  8049ed:	48 c7 45 f0 04 00 00 	movq   $0x4,-0x10(%rbp)
  8049f4:	00 
  8049f5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8049f9:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8049fd:	48 01 d0             	add    %rdx,%rax
  804a00:	48 83 e8 01          	sub    $0x1,%rax
  804a04:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  804a08:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804a0c:	ba 00 00 00 00       	mov    $0x0,%edx
  804a11:	48 f7 75 f0          	divq   -0x10(%rbp)
  804a15:	48 89 d0             	mov    %rdx,%rax
  804a18:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  804a1c:	48 89 d1             	mov    %rdx,%rcx
  804a1f:	48 29 c1             	sub    %rax,%rcx
  804a22:	48 89 c8             	mov    %rcx,%rax
  804a25:	48 89 45 a8          	mov    %rax,-0x58(%rbp)

	if (n >= MAXMALLOC)
  804a29:	48 81 7d a8 ff ff 0f 	cmpq   $0xfffff,-0x58(%rbp)
  804a30:	00 
  804a31:	76 0a                	jbe    804a3d <malloc+0x88>
		return 0;
  804a33:	b8 00 00 00 00       	mov    $0x0,%eax
  804a38:	e9 f6 02 00 00       	jmpq   804d33 <malloc+0x37e>

	if ((uintptr_t) mptr % PGSIZE){
  804a3d:	48 b8 e0 90 82 00 00 	movabs $0x8290e0,%rax
  804a44:	00 00 00 
  804a47:	48 8b 00             	mov    (%rax),%rax
  804a4a:	25 ff 0f 00 00       	and    $0xfff,%eax
  804a4f:	48 85 c0             	test   %rax,%rax
  804a52:	0f 84 12 01 00 00    	je     804b6a <malloc+0x1b5>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  804a58:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  804a5f:	00 
  804a60:	48 b8 e0 90 82 00 00 	movabs $0x8290e0,%rax
  804a67:	00 00 00 
  804a6a:	48 8b 00             	mov    (%rax),%rax
  804a6d:	48 03 45 e0          	add    -0x20(%rbp),%rax
  804a71:	48 83 e8 01          	sub    $0x1,%rax
  804a75:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  804a79:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804a7d:	ba 00 00 00 00       	mov    $0x0,%edx
  804a82:	48 f7 75 e0          	divq   -0x20(%rbp)
  804a86:	48 89 d0             	mov    %rdx,%rax
  804a89:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  804a8d:	48 89 d1             	mov    %rdx,%rcx
  804a90:	48 29 c1             	sub    %rax,%rcx
  804a93:	48 89 c8             	mov    %rcx,%rax
  804a96:	48 83 e8 04          	sub    $0x4,%rax
  804a9a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  804a9e:	48 b8 e0 90 82 00 00 	movabs $0x8290e0,%rax
  804aa5:	00 00 00 
  804aa8:	48 8b 00             	mov    (%rax),%rax
  804aab:	48 89 c1             	mov    %rax,%rcx
  804aae:	48 c1 e9 0c          	shr    $0xc,%rcx
  804ab2:	48 b8 e0 90 82 00 00 	movabs $0x8290e0,%rax
  804ab9:	00 00 00 
  804abc:	48 8b 00             	mov    (%rax),%rax
  804abf:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804ac3:	48 83 c2 03          	add    $0x3,%rdx
  804ac7:	48 01 d0             	add    %rdx,%rax
  804aca:	48 c1 e8 0c          	shr    $0xc,%rax
  804ace:	48 39 c1             	cmp    %rax,%rcx
  804ad1:	75 4a                	jne    804b1d <malloc+0x168>
			(*ref)++;
  804ad3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804ad7:	8b 00                	mov    (%rax),%eax
  804ad9:	8d 50 01             	lea    0x1(%rax),%edx
  804adc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804ae0:	89 10                	mov    %edx,(%rax)
			v = mptr;
  804ae2:	48 b8 e0 90 82 00 00 	movabs $0x8290e0,%rax
  804ae9:	00 00 00 
  804aec:	48 8b 00             	mov    (%rax),%rax
  804aef:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
			mptr += n;
  804af3:	48 b8 e0 90 82 00 00 	movabs $0x8290e0,%rax
  804afa:	00 00 00 
  804afd:	48 8b 00             	mov    (%rax),%rax
  804b00:	48 89 c2             	mov    %rax,%rdx
  804b03:	48 03 55 a8          	add    -0x58(%rbp),%rdx
  804b07:	48 b8 e0 90 82 00 00 	movabs $0x8290e0,%rax
  804b0e:	00 00 00 
  804b11:	48 89 10             	mov    %rdx,(%rax)
			return v;
  804b14:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  804b18:	e9 16 02 00 00       	jmpq   804d33 <malloc+0x37e>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  804b1d:	48 b8 e0 90 82 00 00 	movabs $0x8290e0,%rax
  804b24:	00 00 00 
  804b27:	48 8b 00             	mov    (%rax),%rax
  804b2a:	48 89 c7             	mov    %rax,%rdi
  804b2d:	48 b8 35 4d 80 00 00 	movabs $0x804d35,%rax
  804b34:	00 00 00 
  804b37:	ff d0                	callq  *%rax
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  804b39:	48 b8 e0 90 82 00 00 	movabs $0x8290e0,%rax
  804b40:	00 00 00 
  804b43:	48 8b 00             	mov    (%rax),%rax
  804b46:	48 05 00 10 00 00    	add    $0x1000,%rax
  804b4c:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  804b50:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  804b54:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  804b5a:	48 89 c2             	mov    %rax,%rdx
  804b5d:	48 b8 e0 90 82 00 00 	movabs $0x8290e0,%rax
  804b64:	00 00 00 
  804b67:	48 89 10             	mov    %rdx,(%rax)
	 * now we need to find some address space for this chunk.
	 * if it's less than a page we leave it open for allocation.
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
  804b6a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  804b71:	eb 01                	jmp    804b74 <malloc+0x1bf>
		if (mptr == mend) {
			mptr = mbegin;
			if (++nwrap == 2)
				return 0;	/* out of address space */
		}
	}
  804b73:	90                   	nop
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
  804b74:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  804b78:	48 8d 50 04          	lea    0x4(%rax),%rdx
  804b7c:	48 b8 e0 90 82 00 00 	movabs $0x8290e0,%rax
  804b83:	00 00 00 
  804b86:	48 8b 00             	mov    (%rax),%rax
  804b89:	48 89 d6             	mov    %rdx,%rsi
  804b8c:	48 89 c7             	mov    %rax,%rdi
  804b8f:	48 b8 1c 49 80 00 00 	movabs $0x80491c,%rax
  804b96:	00 00 00 
  804b99:	ff d0                	callq  *%rax
  804b9b:	85 c0                	test   %eax,%eax
  804b9d:	75 72                	jne    804c11 <malloc+0x25c>
			break;
		mptr += PGSIZE;
  804b9f:	48 b8 e0 90 82 00 00 	movabs $0x8290e0,%rax
  804ba6:	00 00 00 
  804ba9:	48 8b 00             	mov    (%rax),%rax
  804bac:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  804bb3:	48 b8 e0 90 82 00 00 	movabs $0x8290e0,%rax
  804bba:	00 00 00 
  804bbd:	48 89 10             	mov    %rdx,(%rax)
		if (mptr == mend) {
  804bc0:	48 b8 e0 90 82 00 00 	movabs $0x8290e0,%rax
  804bc7:	00 00 00 
  804bca:	48 8b 10             	mov    (%rax),%rdx
  804bcd:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  804bd4:	00 00 00 
  804bd7:	48 8b 00             	mov    (%rax),%rax
  804bda:	48 39 c2             	cmp    %rax,%rdx
  804bdd:	75 94                	jne    804b73 <malloc+0x1be>
			mptr = mbegin;
  804bdf:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  804be6:	00 00 00 
  804be9:	48 8b 10             	mov    (%rax),%rdx
  804bec:	48 b8 e0 90 82 00 00 	movabs $0x8290e0,%rax
  804bf3:	00 00 00 
  804bf6:	48 89 10             	mov    %rdx,(%rax)
			if (++nwrap == 2)
  804bf9:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  804bfd:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  804c01:	0f 85 6c ff ff ff    	jne    804b73 <malloc+0x1be>
				return 0;	/* out of address space */
  804c07:	b8 00 00 00 00       	mov    $0x0,%eax
  804c0c:	e9 22 01 00 00       	jmpq   804d33 <malloc+0x37e>
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
  804c11:	90                   	nop
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  804c12:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  804c19:	e9 a1 00 00 00       	jmpq   804cbf <malloc+0x30a>
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  804c1e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804c21:	05 00 10 00 00       	add    $0x1000,%eax
  804c26:	48 98                	cltq   
  804c28:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804c2c:	48 83 c2 04          	add    $0x4,%rdx
  804c30:	48 39 d0             	cmp    %rdx,%rax
  804c33:	73 07                	jae    804c3c <malloc+0x287>
  804c35:	b8 00 04 00 00       	mov    $0x400,%eax
  804c3a:	eb 05                	jmp    804c41 <malloc+0x28c>
  804c3c:	b8 00 00 00 00       	mov    $0x0,%eax
  804c41:	89 45 bc             	mov    %eax,-0x44(%rbp)
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  804c44:	8b 45 bc             	mov    -0x44(%rbp),%eax
  804c47:	89 c2                	mov    %eax,%edx
  804c49:	83 ca 07             	or     $0x7,%edx
  804c4c:	48 b8 e0 90 82 00 00 	movabs $0x8290e0,%rax
  804c53:	00 00 00 
  804c56:	48 8b 08             	mov    (%rax),%rcx
  804c59:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804c5c:	48 98                	cltq   
  804c5e:	48 01 c8             	add    %rcx,%rax
  804c61:	48 89 c6             	mov    %rax,%rsi
  804c64:	bf 00 00 00 00       	mov    $0x0,%edi
  804c69:	48 b8 fc 27 80 00 00 	movabs $0x8027fc,%rax
  804c70:	00 00 00 
  804c73:	ff d0                	callq  *%rax
  804c75:	85 c0                	test   %eax,%eax
  804c77:	79 3f                	jns    804cb8 <malloc+0x303>
			for (; i >= 0; i -= PGSIZE)
  804c79:	eb 30                	jmp    804cab <malloc+0x2f6>
				sys_page_unmap(0, mptr + i);
  804c7b:	48 b8 e0 90 82 00 00 	movabs $0x8290e0,%rax
  804c82:	00 00 00 
  804c85:	48 8b 10             	mov    (%rax),%rdx
  804c88:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804c8b:	48 98                	cltq   
  804c8d:	48 01 d0             	add    %rdx,%rax
  804c90:	48 89 c6             	mov    %rax,%rsi
  804c93:	bf 00 00 00 00       	mov    $0x0,%edi
  804c98:	48 b8 a7 28 80 00 00 	movabs $0x8028a7,%rax
  804c9f:	00 00 00 
  804ca2:	ff d0                	callq  *%rax
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  804ca4:	81 6d fc 00 10 00 00 	subl   $0x1000,-0x4(%rbp)
  804cab:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  804caf:	79 ca                	jns    804c7b <malloc+0x2c6>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
  804cb1:	b8 00 00 00 00       	mov    $0x0,%eax
  804cb6:	eb 7b                	jmp    804d33 <malloc+0x37e>
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  804cb8:	81 45 fc 00 10 00 00 	addl   $0x1000,-0x4(%rbp)
  804cbf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  804cc2:	48 98                	cltq   
  804cc4:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  804cc8:	48 83 c2 04          	add    $0x4,%rdx
  804ccc:	48 39 d0             	cmp    %rdx,%rax
  804ccf:	0f 82 49 ff ff ff    	jb     804c1e <malloc+0x269>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  804cd5:	48 b8 e0 90 82 00 00 	movabs $0x8290e0,%rax
  804cdc:	00 00 00 
  804cdf:	48 8b 00             	mov    (%rax),%rax
  804ce2:	8b 55 fc             	mov    -0x4(%rbp),%edx
  804ce5:	48 63 d2             	movslq %edx,%rdx
  804ce8:	48 83 ea 04          	sub    $0x4,%rdx
  804cec:	48 01 d0             	add    %rdx,%rax
  804cef:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	*ref = 2;	/* reference for mptr, reference for returned block */
  804cf3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804cf7:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
	v = mptr;
  804cfd:	48 b8 e0 90 82 00 00 	movabs $0x8290e0,%rax
  804d04:	00 00 00 
  804d07:	48 8b 00             	mov    (%rax),%rax
  804d0a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	mptr += n;
  804d0e:	48 b8 e0 90 82 00 00 	movabs $0x8290e0,%rax
  804d15:	00 00 00 
  804d18:	48 8b 00             	mov    (%rax),%rax
  804d1b:	48 89 c2             	mov    %rax,%rdx
  804d1e:	48 03 55 a8          	add    -0x58(%rbp),%rdx
  804d22:	48 b8 e0 90 82 00 00 	movabs $0x8290e0,%rax
  804d29:	00 00 00 
  804d2c:	48 89 10             	mov    %rdx,(%rax)
	return v;
  804d2f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
}
  804d33:	c9                   	leaveq 
  804d34:	c3                   	retq   

0000000000804d35 <free>:

void
free(void *v)
{
  804d35:	55                   	push   %rbp
  804d36:	48 89 e5             	mov    %rsp,%rbp
  804d39:	48 83 ec 30          	sub    $0x30,%rsp
  804d3d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  804d41:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  804d46:	0f 84 56 01 00 00    	je     804ea2 <free+0x16d>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  804d4c:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  804d53:	00 00 00 
  804d56:	48 8b 00             	mov    (%rax),%rax
  804d59:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  804d5d:	77 13                	ja     804d72 <free+0x3d>
  804d5f:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  804d66:	00 00 00 
  804d69:	48 8b 00             	mov    (%rax),%rax
  804d6c:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  804d70:	72 35                	jb     804da7 <free+0x72>
  804d72:	48 b9 88 12 82 00 00 	movabs $0x821288,%rcx
  804d79:	00 00 00 
  804d7c:	48 ba b6 12 82 00 00 	movabs $0x8212b6,%rdx
  804d83:	00 00 00 
  804d86:	be 7a 00 00 00       	mov    $0x7a,%esi
  804d8b:	48 bf cb 12 82 00 00 	movabs $0x8212cb,%rdi
  804d92:	00 00 00 
  804d95:	b8 00 00 00 00       	mov    $0x0,%eax
  804d9a:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  804da1:	00 00 00 
  804da4:	41 ff d0             	callq  *%r8

	c = ROUNDDOWN(v, PGSIZE);
  804da7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804dab:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  804daf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  804db3:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  804db9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  804dbd:	eb 7b                	jmp    804e3a <free+0x105>
		sys_page_unmap(0, c);
  804dbf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804dc3:	48 89 c6             	mov    %rax,%rsi
  804dc6:	bf 00 00 00 00       	mov    $0x0,%edi
  804dcb:	48 b8 a7 28 80 00 00 	movabs $0x8028a7,%rax
  804dd2:	00 00 00 
  804dd5:	ff d0                	callq  *%rax
		c += PGSIZE;
  804dd7:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  804dde:	00 
		assert(mbegin <= c && c < mend);
  804ddf:	48 b8 d8 80 82 00 00 	movabs $0x8280d8,%rax
  804de6:	00 00 00 
  804de9:	48 8b 00             	mov    (%rax),%rax
  804dec:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  804df0:	77 13                	ja     804e05 <free+0xd0>
  804df2:	48 b8 e0 80 82 00 00 	movabs $0x8280e0,%rax
  804df9:	00 00 00 
  804dfc:	48 8b 00             	mov    (%rax),%rax
  804dff:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  804e03:	72 35                	jb     804e3a <free+0x105>
  804e05:	48 b9 d8 12 82 00 00 	movabs $0x8212d8,%rcx
  804e0c:	00 00 00 
  804e0f:	48 ba b6 12 82 00 00 	movabs $0x8212b6,%rdx
  804e16:	00 00 00 
  804e19:	be 81 00 00 00       	mov    $0x81,%esi
  804e1e:	48 bf cb 12 82 00 00 	movabs $0x8212cb,%rdi
  804e25:	00 00 00 
  804e28:	b8 00 00 00 00       	mov    $0x0,%eax
  804e2d:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  804e34:	00 00 00 
  804e37:	41 ff d0             	callq  *%r8
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  804e3a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804e3e:	48 89 c2             	mov    %rax,%rdx
  804e41:	48 c1 ea 0c          	shr    $0xc,%rdx
  804e45:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  804e4c:	01 00 00 
  804e4f:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  804e53:	25 00 04 00 00       	and    $0x400,%eax
  804e58:	48 85 c0             	test   %rax,%rax
  804e5b:	0f 85 5e ff ff ff    	jne    804dbf <free+0x8a>

	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
  804e61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804e65:	48 05 fc 0f 00 00    	add    $0xffc,%rax
  804e6b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (--(*ref) == 0)
  804e6f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804e73:	8b 00                	mov    (%rax),%eax
  804e75:	8d 50 ff             	lea    -0x1(%rax),%edx
  804e78:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804e7c:	89 10                	mov    %edx,(%rax)
  804e7e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  804e82:	8b 00                	mov    (%rax),%eax
  804e84:	85 c0                	test   %eax,%eax
  804e86:	75 1b                	jne    804ea3 <free+0x16e>
		sys_page_unmap(0, c);
  804e88:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  804e8c:	48 89 c6             	mov    %rax,%rsi
  804e8f:	bf 00 00 00 00       	mov    $0x0,%edi
  804e94:	48 b8 a7 28 80 00 00 	movabs $0x8028a7,%rax
  804e9b:	00 00 00 
  804e9e:	ff d0                	callq  *%rax
  804ea0:	eb 01                	jmp    804ea3 <free+0x16e>
{
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
		return;
  804ea2:	90                   	nop
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
		sys_page_unmap(0, c);
}
  804ea3:	c9                   	leaveq 
  804ea4:	c3                   	retq   
  804ea5:	00 00                	add    %al,(%rax)
	...

0000000000804ea8 <pipe>:
	uint8_t p_buf[PIPEBUFSIZ];	// data buffer
};

int
pipe(int pfd[2])
{
  804ea8:	55                   	push   %rbp
  804ea9:	48 89 e5             	mov    %rsp,%rbp
  804eac:	53                   	push   %rbx
  804ead:	48 83 ec 38          	sub    $0x38,%rsp
  804eb1:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	int r;
	struct Fd *fd0, *fd1;
	void *va;

	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
  804eb5:	48 8d 45 d8          	lea    -0x28(%rbp),%rax
  804eb9:	48 89 c7             	mov    %rax,%rdi
  804ebc:	48 b8 56 34 80 00 00 	movabs $0x803456,%rax
  804ec3:	00 00 00 
  804ec6:	ff d0                	callq  *%rax
  804ec8:	89 45 ec             	mov    %eax,-0x14(%rbp)
  804ecb:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  804ecf:	0f 88 bf 01 00 00    	js     805094 <pipe+0x1ec>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  804ed5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804ed9:	ba 07 04 00 00       	mov    $0x407,%edx
  804ede:	48 89 c6             	mov    %rax,%rsi
  804ee1:	bf 00 00 00 00       	mov    $0x0,%edi
  804ee6:	48 b8 fc 27 80 00 00 	movabs $0x8027fc,%rax
  804eed:	00 00 00 
  804ef0:	ff d0                	callq  *%rax
  804ef2:	89 45 ec             	mov    %eax,-0x14(%rbp)
  804ef5:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  804ef9:	0f 88 95 01 00 00    	js     805094 <pipe+0x1ec>
		goto err;

	if ((r = fd_alloc(&fd1)) < 0
  804eff:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  804f03:	48 89 c7             	mov    %rax,%rdi
  804f06:	48 b8 56 34 80 00 00 	movabs $0x803456,%rax
  804f0d:	00 00 00 
  804f10:	ff d0                	callq  *%rax
  804f12:	89 45 ec             	mov    %eax,-0x14(%rbp)
  804f15:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  804f19:	0f 88 5d 01 00 00    	js     80507c <pipe+0x1d4>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  804f1f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804f23:	ba 07 04 00 00       	mov    $0x407,%edx
  804f28:	48 89 c6             	mov    %rax,%rsi
  804f2b:	bf 00 00 00 00       	mov    $0x0,%edi
  804f30:	48 b8 fc 27 80 00 00 	movabs $0x8027fc,%rax
  804f37:	00 00 00 
  804f3a:	ff d0                	callq  *%rax
  804f3c:	89 45 ec             	mov    %eax,-0x14(%rbp)
  804f3f:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  804f43:	0f 88 33 01 00 00    	js     80507c <pipe+0x1d4>
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
  804f49:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804f4d:	48 89 c7             	mov    %rax,%rdi
  804f50:	48 b8 2b 34 80 00 00 	movabs $0x80342b,%rax
  804f57:	00 00 00 
  804f5a:	ff d0                	callq  *%rax
  804f5c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  804f60:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804f64:	ba 07 04 00 00       	mov    $0x407,%edx
  804f69:	48 89 c6             	mov    %rax,%rsi
  804f6c:	bf 00 00 00 00       	mov    $0x0,%edi
  804f71:	48 b8 fc 27 80 00 00 	movabs $0x8027fc,%rax
  804f78:	00 00 00 
  804f7b:	ff d0                	callq  *%rax
  804f7d:	89 45 ec             	mov    %eax,-0x14(%rbp)
  804f80:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  804f84:	0f 88 d9 00 00 00    	js     805063 <pipe+0x1bb>
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  804f8a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804f8e:	48 89 c7             	mov    %rax,%rdi
  804f91:	48 b8 2b 34 80 00 00 	movabs $0x80342b,%rax
  804f98:	00 00 00 
  804f9b:	ff d0                	callq  *%rax
  804f9d:	48 89 c2             	mov    %rax,%rdx
  804fa0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  804fa4:	41 b8 07 04 00 00    	mov    $0x407,%r8d
  804faa:	48 89 d1             	mov    %rdx,%rcx
  804fad:	ba 00 00 00 00       	mov    $0x0,%edx
  804fb2:	48 89 c6             	mov    %rax,%rsi
  804fb5:	bf 00 00 00 00       	mov    $0x0,%edi
  804fba:	48 b8 4c 28 80 00 00 	movabs $0x80284c,%rax
  804fc1:	00 00 00 
  804fc4:	ff d0                	callq  *%rax
  804fc6:	89 45 ec             	mov    %eax,-0x14(%rbp)
  804fc9:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  804fcd:	78 79                	js     805048 <pipe+0x1a0>
		goto err3;

	// set up fd structures
	fd0->fd_dev_id = devpipe.dev_id;
  804fcf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804fd3:	48 ba 00 81 82 00 00 	movabs $0x828100,%rdx
  804fda:	00 00 00 
  804fdd:	8b 12                	mov    (%rdx),%edx
  804fdf:	89 10                	mov    %edx,(%rax)
	fd0->fd_omode = O_RDONLY;
  804fe1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  804fe5:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)

	fd1->fd_dev_id = devpipe.dev_id;
  804fec:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  804ff0:	48 ba 00 81 82 00 00 	movabs $0x828100,%rdx
  804ff7:	00 00 00 
  804ffa:	8b 12                	mov    (%rdx),%edx
  804ffc:	89 10                	mov    %edx,(%rax)
	fd1->fd_omode = O_WRONLY;
  804ffe:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805002:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%rax)

	if (debug)
		cprintf("[%08x] pipecreate %08x\n", thisenv->env_id, uvpt[PGNUM(va)]);

	pfd[0] = fd2num(fd0);
  805009:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80500d:	48 89 c7             	mov    %rax,%rdi
  805010:	48 b8 08 34 80 00 00 	movabs $0x803408,%rax
  805017:	00 00 00 
  80501a:	ff d0                	callq  *%rax
  80501c:	89 c2                	mov    %eax,%edx
  80501e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  805022:	89 10                	mov    %edx,(%rax)
	pfd[1] = fd2num(fd1);
  805024:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  805028:	48 8d 58 04          	lea    0x4(%rax),%rbx
  80502c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805030:	48 89 c7             	mov    %rax,%rdi
  805033:	48 b8 08 34 80 00 00 	movabs $0x803408,%rax
  80503a:	00 00 00 
  80503d:	ff d0                	callq  *%rax
  80503f:	89 03                	mov    %eax,(%rbx)
	return 0;
  805041:	b8 00 00 00 00       	mov    $0x0,%eax
  805046:	eb 4f                	jmp    805097 <pipe+0x1ef>
	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err3;
  805048:	90                   	nop
	pfd[0] = fd2num(fd0);
	pfd[1] = fd2num(fd1);
	return 0;

    err3:
	sys_page_unmap(0, va);
  805049:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80504d:	48 89 c6             	mov    %rax,%rsi
  805050:	bf 00 00 00 00       	mov    $0x0,%edi
  805055:	48 b8 a7 28 80 00 00 	movabs $0x8028a7,%rax
  80505c:	00 00 00 
  80505f:	ff d0                	callq  *%rax
  805061:	eb 01                	jmp    805064 <pipe+0x1bc>
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err2;
  805063:	90                   	nop
	return 0;

    err3:
	sys_page_unmap(0, va);
    err2:
	sys_page_unmap(0, fd1);
  805064:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805068:	48 89 c6             	mov    %rax,%rsi
  80506b:	bf 00 00 00 00       	mov    $0x0,%edi
  805070:	48 b8 a7 28 80 00 00 	movabs $0x8028a7,%rax
  805077:	00 00 00 
  80507a:	ff d0                	callq  *%rax
    err1:
	sys_page_unmap(0, fd0);
  80507c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805080:	48 89 c6             	mov    %rax,%rsi
  805083:	bf 00 00 00 00       	mov    $0x0,%edi
  805088:	48 b8 a7 28 80 00 00 	movabs $0x8028a7,%rax
  80508f:	00 00 00 
  805092:	ff d0                	callq  *%rax
    err:
	return r;
  805094:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  805097:	48 83 c4 38          	add    $0x38,%rsp
  80509b:	5b                   	pop    %rbx
  80509c:	5d                   	pop    %rbp
  80509d:	c3                   	retq   

000000000080509e <_pipeisclosed>:

static int
_pipeisclosed(struct Fd *fd, struct Pipe *p)
{
  80509e:	55                   	push   %rbp
  80509f:	48 89 e5             	mov    %rsp,%rbp
  8050a2:	53                   	push   %rbx
  8050a3:	48 83 ec 28          	sub    $0x28,%rsp
  8050a7:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8050ab:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8050af:	eb 01                	jmp    8050b2 <_pipeisclosed+0x14>
		nn = thisenv->env_runs;
		if (n == nn)
			return ret;
		if (n != nn && ret == 1)
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
	}
  8050b1:	90                   	nop
_pipeisclosed(struct Fd *fd, struct Pipe *p)
{
	int n, nn, ret;

	while (1) {
		n = thisenv->env_runs;
  8050b2:	48 b8 10 76 b5 00 00 	movabs $0xb57610,%rax
  8050b9:	00 00 00 
  8050bc:	48 8b 00             	mov    (%rax),%rax
  8050bf:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  8050c5:	89 45 ec             	mov    %eax,-0x14(%rbp)
		ret = pageref(fd) == pageref(p);
  8050c8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8050cc:	48 89 c7             	mov    %rax,%rdi
  8050cf:	48 b8 74 58 80 00 00 	movabs $0x805874,%rax
  8050d6:	00 00 00 
  8050d9:	ff d0                	callq  *%rax
  8050db:	89 c3                	mov    %eax,%ebx
  8050dd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8050e1:	48 89 c7             	mov    %rax,%rdi
  8050e4:	48 b8 74 58 80 00 00 	movabs $0x805874,%rax
  8050eb:	00 00 00 
  8050ee:	ff d0                	callq  *%rax
  8050f0:	39 c3                	cmp    %eax,%ebx
  8050f2:	0f 94 c0             	sete   %al
  8050f5:	0f b6 c0             	movzbl %al,%eax
  8050f8:	89 45 e8             	mov    %eax,-0x18(%rbp)
		nn = thisenv->env_runs;
  8050fb:	48 b8 10 76 b5 00 00 	movabs $0xb57610,%rax
  805102:	00 00 00 
  805105:	48 8b 00             	mov    (%rax),%rax
  805108:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  80510e:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if (n == nn)
  805111:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805114:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  805117:	75 0a                	jne    805123 <_pipeisclosed+0x85>
			return ret;
  805119:	8b 45 e8             	mov    -0x18(%rbp),%eax
		if (n != nn && ret == 1)
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
	}
}
  80511c:	48 83 c4 28          	add    $0x28,%rsp
  805120:	5b                   	pop    %rbx
  805121:	5d                   	pop    %rbp
  805122:	c3                   	retq   
		n = thisenv->env_runs;
		ret = pageref(fd) == pageref(p);
		nn = thisenv->env_runs;
		if (n == nn)
			return ret;
		if (n != nn && ret == 1)
  805123:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805126:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  805129:	74 86                	je     8050b1 <_pipeisclosed+0x13>
  80512b:	83 7d e8 01          	cmpl   $0x1,-0x18(%rbp)
  80512f:	75 80                	jne    8050b1 <_pipeisclosed+0x13>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  805131:	48 b8 10 76 b5 00 00 	movabs $0xb57610,%rax
  805138:	00 00 00 
  80513b:	48 8b 00             	mov    (%rax),%rax
  80513e:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  805144:	8b 4d e8             	mov    -0x18(%rbp),%ecx
  805147:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80514a:	89 c6                	mov    %eax,%esi
  80514c:	48 bf f5 12 82 00 00 	movabs $0x8212f5,%rdi
  805153:	00 00 00 
  805156:	b8 00 00 00 00       	mov    $0x0,%eax
  80515b:	49 b8 07 13 80 00 00 	movabs $0x801307,%r8
  805162:	00 00 00 
  805165:	41 ff d0             	callq  *%r8
	}
  805168:	e9 44 ff ff ff       	jmpq   8050b1 <_pipeisclosed+0x13>

000000000080516d <pipeisclosed>:
}

int
pipeisclosed(int fdnum)
{
  80516d:	55                   	push   %rbp
  80516e:	48 89 e5             	mov    %rsp,%rbp
  805171:	48 83 ec 30          	sub    $0x30,%rsp
  805175:	89 7d dc             	mov    %edi,-0x24(%rbp)
	struct Fd *fd;
	struct Pipe *p;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  805178:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  80517c:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80517f:	48 89 d6             	mov    %rdx,%rsi
  805182:	89 c7                	mov    %eax,%edi
  805184:	48 b8 ee 34 80 00 00 	movabs $0x8034ee,%rax
  80518b:	00 00 00 
  80518e:	ff d0                	callq  *%rax
  805190:	89 45 fc             	mov    %eax,-0x4(%rbp)
  805193:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805197:	79 05                	jns    80519e <pipeisclosed+0x31>
		return r;
  805199:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80519c:	eb 31                	jmp    8051cf <pipeisclosed+0x62>
	p = (struct Pipe*) fd2data(fd);
  80519e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8051a2:	48 89 c7             	mov    %rax,%rdi
  8051a5:	48 b8 2b 34 80 00 00 	movabs $0x80342b,%rax
  8051ac:	00 00 00 
  8051af:	ff d0                	callq  *%rax
  8051b1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	return _pipeisclosed(fd, p);
  8051b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8051b9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8051bd:	48 89 d6             	mov    %rdx,%rsi
  8051c0:	48 89 c7             	mov    %rax,%rdi
  8051c3:	48 b8 9e 50 80 00 00 	movabs $0x80509e,%rax
  8051ca:	00 00 00 
  8051cd:	ff d0                	callq  *%rax
}
  8051cf:	c9                   	leaveq 
  8051d0:	c3                   	retq   

00000000008051d1 <devpipe_read>:

static ssize_t
devpipe_read(struct Fd *fd, void *vbuf, size_t n)
{
  8051d1:	55                   	push   %rbp
  8051d2:	48 89 e5             	mov    %rsp,%rbp
  8051d5:	48 83 ec 40          	sub    $0x40,%rsp
  8051d9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8051dd:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8051e1:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*)fd2data(fd);
  8051e5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8051e9:	48 89 c7             	mov    %rax,%rdi
  8051ec:	48 b8 2b 34 80 00 00 	movabs $0x80342b,%rax
  8051f3:	00 00 00 
  8051f6:	ff d0                	callq  *%rax
  8051f8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
  8051fc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  805200:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	for (i = 0; i < n; i++) {
  805204:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80520b:	00 
  80520c:	e9 97 00 00 00       	jmpq   8052a8 <devpipe_read+0xd7>
		while (p->p_rpos == p->p_wpos) {
			// pipe is empty
			// if we got any data, return it
			if (i > 0)
  805211:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  805216:	74 09                	je     805221 <devpipe_read+0x50>
				return i;
  805218:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80521c:	e9 95 00 00 00       	jmpq   8052b6 <devpipe_read+0xe5>
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
  805221:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  805225:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805229:	48 89 d6             	mov    %rdx,%rsi
  80522c:	48 89 c7             	mov    %rax,%rdi
  80522f:	48 b8 9e 50 80 00 00 	movabs $0x80509e,%rax
  805236:	00 00 00 
  805239:	ff d0                	callq  *%rax
  80523b:	85 c0                	test   %eax,%eax
  80523d:	74 07                	je     805246 <devpipe_read+0x75>
				return 0;
  80523f:	b8 00 00 00 00       	mov    $0x0,%eax
  805244:	eb 70                	jmp    8052b6 <devpipe_read+0xe5>
			// yield and see what happens
			if (debug)
				cprintf("devpipe_read yield\n");
			sys_yield();
  805246:	48 b8 be 27 80 00 00 	movabs $0x8027be,%rax
  80524d:	00 00 00 
  805250:	ff d0                	callq  *%rax
  805252:	eb 01                	jmp    805255 <devpipe_read+0x84>
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_rpos == p->p_wpos) {
  805254:	90                   	nop
  805255:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805259:	8b 10                	mov    (%rax),%edx
  80525b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80525f:	8b 40 04             	mov    0x4(%rax),%eax
  805262:	39 c2                	cmp    %eax,%edx
  805264:	74 ab                	je     805211 <devpipe_read+0x40>
				cprintf("devpipe_read yield\n");
			sys_yield();
		}
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  805266:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80526a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80526e:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  805272:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805276:	8b 00                	mov    (%rax),%eax
  805278:	89 c2                	mov    %eax,%edx
  80527a:	c1 fa 1f             	sar    $0x1f,%edx
  80527d:	c1 ea 1b             	shr    $0x1b,%edx
  805280:	01 d0                	add    %edx,%eax
  805282:	83 e0 1f             	and    $0x1f,%eax
  805285:	29 d0                	sub    %edx,%eax
  805287:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80528b:	48 98                	cltq   
  80528d:	0f b6 44 02 08       	movzbl 0x8(%rdx,%rax,1),%eax
  805292:	88 01                	mov    %al,(%rcx)
		p->p_rpos++;
  805294:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805298:	8b 00                	mov    (%rax),%eax
  80529a:	8d 50 01             	lea    0x1(%rax),%edx
  80529d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8052a1:	89 10                	mov    %edx,(%rax)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8052a3:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8052a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8052ac:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8052b0:	72 a2                	jb     805254 <devpipe_read+0x83>
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
  8052b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8052b6:	c9                   	leaveq 
  8052b7:	c3                   	retq   

00000000008052b8 <devpipe_write>:

static ssize_t
devpipe_write(struct Fd *fd, const void *vbuf, size_t n)
{
  8052b8:	55                   	push   %rbp
  8052b9:	48 89 e5             	mov    %rsp,%rbp
  8052bc:	48 83 ec 40          	sub    $0x40,%rsp
  8052c0:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8052c4:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8052c8:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	const uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*) fd2data(fd);
  8052cc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8052d0:	48 89 c7             	mov    %rax,%rdi
  8052d3:	48 b8 2b 34 80 00 00 	movabs $0x80342b,%rax
  8052da:	00 00 00 
  8052dd:	ff d0                	callq  *%rax
  8052df:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
  8052e3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8052e7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	for (i = 0; i < n; i++) {
  8052eb:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8052f2:	00 
  8052f3:	e9 93 00 00 00       	jmpq   80538b <devpipe_write+0xd3>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
  8052f8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8052fc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  805300:	48 89 d6             	mov    %rdx,%rsi
  805303:	48 89 c7             	mov    %rax,%rdi
  805306:	48 b8 9e 50 80 00 00 	movabs $0x80509e,%rax
  80530d:	00 00 00 
  805310:	ff d0                	callq  *%rax
  805312:	85 c0                	test   %eax,%eax
  805314:	74 07                	je     80531d <devpipe_write+0x65>
				return 0;
  805316:	b8 00 00 00 00       	mov    $0x0,%eax
  80531b:	eb 7c                	jmp    805399 <devpipe_write+0xe1>
			// yield and see what happens
			if (debug)
				cprintf("devpipe_write yield\n");
			sys_yield();
  80531d:	48 b8 be 27 80 00 00 	movabs $0x8027be,%rax
  805324:	00 00 00 
  805327:	ff d0                	callq  *%rax
  805329:	eb 01                	jmp    80532c <devpipe_write+0x74>
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  80532b:	90                   	nop
  80532c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805330:	8b 40 04             	mov    0x4(%rax),%eax
  805333:	48 63 d0             	movslq %eax,%rdx
  805336:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80533a:	8b 00                	mov    (%rax),%eax
  80533c:	48 98                	cltq   
  80533e:	48 83 c0 20          	add    $0x20,%rax
  805342:	48 39 c2             	cmp    %rax,%rdx
  805345:	73 b1                	jae    8052f8 <devpipe_write+0x40>
				cprintf("devpipe_write yield\n");
			sys_yield();
		}
		// there's room for a byte.  store it.
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  805347:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80534b:	8b 40 04             	mov    0x4(%rax),%eax
  80534e:	89 c2                	mov    %eax,%edx
  805350:	c1 fa 1f             	sar    $0x1f,%edx
  805353:	c1 ea 1b             	shr    $0x1b,%edx
  805356:	01 d0                	add    %edx,%eax
  805358:	83 e0 1f             	and    $0x1f,%eax
  80535b:	29 d0                	sub    %edx,%eax
  80535d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  805361:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  805365:	48 01 ca             	add    %rcx,%rdx
  805368:	0f b6 0a             	movzbl (%rdx),%ecx
  80536b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80536f:	48 98                	cltq   
  805371:	88 4c 02 08          	mov    %cl,0x8(%rdx,%rax,1)
		p->p_wpos++;
  805375:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805379:	8b 40 04             	mov    0x4(%rax),%eax
  80537c:	8d 50 01             	lea    0x1(%rax),%edx
  80537f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805383:	89 50 04             	mov    %edx,0x4(%rax)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  805386:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  80538b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80538f:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  805393:	72 96                	jb     80532b <devpipe_write+0x73>
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
  805395:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  805399:	c9                   	leaveq 
  80539a:	c3                   	retq   

000000000080539b <devpipe_stat>:

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  80539b:	55                   	push   %rbp
  80539c:	48 89 e5             	mov    %rsp,%rbp
  80539f:	48 83 ec 20          	sub    $0x20,%rsp
  8053a3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8053a7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  8053ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8053af:	48 89 c7             	mov    %rax,%rdi
  8053b2:	48 b8 2b 34 80 00 00 	movabs $0x80342b,%rax
  8053b9:	00 00 00 
  8053bc:	ff d0                	callq  *%rax
  8053be:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	strcpy(stat->st_name, "<pipe>");
  8053c2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8053c6:	48 be 08 13 82 00 00 	movabs $0x821308,%rsi
  8053cd:	00 00 00 
  8053d0:	48 89 c7             	mov    %rax,%rdi
  8053d3:	48 b8 c4 1e 80 00 00 	movabs $0x801ec4,%rax
  8053da:	00 00 00 
  8053dd:	ff d0                	callq  *%rax
	stat->st_size = p->p_wpos - p->p_rpos;
  8053df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8053e3:	8b 50 04             	mov    0x4(%rax),%edx
  8053e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8053ea:	8b 00                	mov    (%rax),%eax
  8053ec:	29 c2                	sub    %eax,%edx
  8053ee:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8053f2:	89 90 80 00 00 00    	mov    %edx,0x80(%rax)
	stat->st_isdir = 0;
  8053f8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8053fc:	c7 80 84 00 00 00 00 	movl   $0x0,0x84(%rax)
  805403:	00 00 00 
	stat->st_dev = &devpipe;
  805406:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80540a:	48 ba 00 81 82 00 00 	movabs $0x828100,%rdx
  805411:	00 00 00 
  805414:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
	return 0;
  80541b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805420:	c9                   	leaveq 
  805421:	c3                   	retq   

0000000000805422 <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  805422:	55                   	push   %rbp
  805423:	48 89 e5             	mov    %rsp,%rbp
  805426:	48 83 ec 10          	sub    $0x10,%rsp
  80542a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	(void) sys_page_unmap(0, fd);
  80542e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805432:	48 89 c6             	mov    %rax,%rsi
  805435:	bf 00 00 00 00       	mov    $0x0,%edi
  80543a:	48 b8 a7 28 80 00 00 	movabs $0x8028a7,%rax
  805441:	00 00 00 
  805444:	ff d0                	callq  *%rax
	return sys_page_unmap(0, fd2data(fd));
  805446:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80544a:	48 89 c7             	mov    %rax,%rdi
  80544d:	48 b8 2b 34 80 00 00 	movabs $0x80342b,%rax
  805454:	00 00 00 
  805457:	ff d0                	callq  *%rax
  805459:	48 89 c6             	mov    %rax,%rsi
  80545c:	bf 00 00 00 00       	mov    $0x0,%edi
  805461:	48 b8 a7 28 80 00 00 	movabs $0x8028a7,%rax
  805468:	00 00 00 
  80546b:	ff d0                	callq  *%rax
}
  80546d:	c9                   	leaveq 
  80546e:	c3                   	retq   
	...

0000000000805470 <cputchar>:
#include <inc/string.h>
#include <inc/lib.h>

void
cputchar(int ch)
{
  805470:	55                   	push   %rbp
  805471:	48 89 e5             	mov    %rsp,%rbp
  805474:	48 83 ec 20          	sub    $0x20,%rsp
  805478:	89 7d ec             	mov    %edi,-0x14(%rbp)
	char c = ch;
  80547b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80547e:	88 45 ff             	mov    %al,-0x1(%rbp)

	// Unlike standard Unix's putchar,
	// the cputchar function _always_ outputs to the system console.
	sys_cputs(&c, 1);
  805481:	48 8d 45 ff          	lea    -0x1(%rbp),%rax
  805485:	be 01 00 00 00       	mov    $0x1,%esi
  80548a:	48 89 c7             	mov    %rax,%rdi
  80548d:	48 b8 b4 26 80 00 00 	movabs $0x8026b4,%rax
  805494:	00 00 00 
  805497:	ff d0                	callq  *%rax
}
  805499:	c9                   	leaveq 
  80549a:	c3                   	retq   

000000000080549b <getchar>:

int
getchar(void)
{
  80549b:	55                   	push   %rbp
  80549c:	48 89 e5             	mov    %rsp,%rbp
  80549f:	48 83 ec 10          	sub    $0x10,%rsp
	int r;

	// JOS does, however, support standard _input_ redirection,
	// allowing the user to redirect script files to the shell and such.
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
  8054a3:	48 8d 45 fb          	lea    -0x5(%rbp),%rax
  8054a7:	ba 01 00 00 00       	mov    $0x1,%edx
  8054ac:	48 89 c6             	mov    %rax,%rsi
  8054af:	bf 00 00 00 00       	mov    $0x0,%edi
  8054b4:	48 b8 20 39 80 00 00 	movabs $0x803920,%rax
  8054bb:	00 00 00 
  8054be:	ff d0                	callq  *%rax
  8054c0:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (r < 0)
  8054c3:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8054c7:	79 05                	jns    8054ce <getchar+0x33>
		return r;
  8054c9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8054cc:	eb 14                	jmp    8054e2 <getchar+0x47>
	if (r < 1)
  8054ce:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8054d2:	7f 07                	jg     8054db <getchar+0x40>
		return -E_EOF;
  8054d4:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8054d9:	eb 07                	jmp    8054e2 <getchar+0x47>
	return c;
  8054db:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8054df:	0f b6 c0             	movzbl %al,%eax
}
  8054e2:	c9                   	leaveq 
  8054e3:	c3                   	retq   

00000000008054e4 <iscons>:
	.dev_stat =	devcons_stat
};

int
iscons(int fdnum)
{
  8054e4:	55                   	push   %rbp
  8054e5:	48 89 e5             	mov    %rsp,%rbp
  8054e8:	48 83 ec 20          	sub    $0x20,%rsp
  8054ec:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  8054ef:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8054f3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8054f6:	48 89 d6             	mov    %rdx,%rsi
  8054f9:	89 c7                	mov    %eax,%edi
  8054fb:	48 b8 ee 34 80 00 00 	movabs $0x8034ee,%rax
  805502:	00 00 00 
  805505:	ff d0                	callq  *%rax
  805507:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80550a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80550e:	79 05                	jns    805515 <iscons+0x31>
		return r;
  805510:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805513:	eb 1a                	jmp    80552f <iscons+0x4b>
	return fd->fd_dev_id == devcons.dev_id;
  805515:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805519:	8b 10                	mov    (%rax),%edx
  80551b:	48 b8 40 81 82 00 00 	movabs $0x828140,%rax
  805522:	00 00 00 
  805525:	8b 00                	mov    (%rax),%eax
  805527:	39 c2                	cmp    %eax,%edx
  805529:	0f 94 c0             	sete   %al
  80552c:	0f b6 c0             	movzbl %al,%eax
}
  80552f:	c9                   	leaveq 
  805530:	c3                   	retq   

0000000000805531 <opencons>:

int
opencons(void)
{
  805531:	55                   	push   %rbp
  805532:	48 89 e5             	mov    %rsp,%rbp
  805535:	48 83 ec 10          	sub    $0x10,%rsp
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  805539:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  80553d:	48 89 c7             	mov    %rax,%rdi
  805540:	48 b8 56 34 80 00 00 	movabs $0x803456,%rax
  805547:	00 00 00 
  80554a:	ff d0                	callq  *%rax
  80554c:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80554f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  805553:	79 05                	jns    80555a <opencons+0x29>
		return r;
  805555:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805558:	eb 5b                	jmp    8055b5 <opencons+0x84>
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  80555a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80555e:	ba 07 04 00 00       	mov    $0x407,%edx
  805563:	48 89 c6             	mov    %rax,%rsi
  805566:	bf 00 00 00 00       	mov    $0x0,%edi
  80556b:	48 b8 fc 27 80 00 00 	movabs $0x8027fc,%rax
  805572:	00 00 00 
  805575:	ff d0                	callq  *%rax
  805577:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80557a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80557e:	79 05                	jns    805585 <opencons+0x54>
		return r;
  805580:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805583:	eb 30                	jmp    8055b5 <opencons+0x84>
	fd->fd_dev_id = devcons.dev_id;
  805585:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805589:	48 ba 40 81 82 00 00 	movabs $0x828140,%rdx
  805590:	00 00 00 
  805593:	8b 12                	mov    (%rdx),%edx
  805595:	89 10                	mov    %edx,(%rax)
	fd->fd_omode = O_RDWR;
  805597:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80559b:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%rax)
	return fd2num(fd);
  8055a2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8055a6:	48 89 c7             	mov    %rax,%rdi
  8055a9:	48 b8 08 34 80 00 00 	movabs $0x803408,%rax
  8055b0:	00 00 00 
  8055b3:	ff d0                	callq  *%rax
}
  8055b5:	c9                   	leaveq 
  8055b6:	c3                   	retq   

00000000008055b7 <devcons_read>:

static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
  8055b7:	55                   	push   %rbp
  8055b8:	48 89 e5             	mov    %rsp,%rbp
  8055bb:	48 83 ec 30          	sub    $0x30,%rsp
  8055bf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8055c3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8055c7:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int c;

	if (n == 0)
  8055cb:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8055d0:	75 13                	jne    8055e5 <devcons_read+0x2e>
		return 0;
  8055d2:	b8 00 00 00 00       	mov    $0x0,%eax
  8055d7:	eb 49                	jmp    805622 <devcons_read+0x6b>

	while ((c = sys_cgetc()) == 0)
		sys_yield();
  8055d9:	48 b8 be 27 80 00 00 	movabs $0x8027be,%rax
  8055e0:	00 00 00 
  8055e3:	ff d0                	callq  *%rax
	int c;

	if (n == 0)
		return 0;

	while ((c = sys_cgetc()) == 0)
  8055e5:	48 b8 fe 26 80 00 00 	movabs $0x8026fe,%rax
  8055ec:	00 00 00 
  8055ef:	ff d0                	callq  *%rax
  8055f1:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8055f4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8055f8:	74 df                	je     8055d9 <devcons_read+0x22>
		sys_yield();
	if (c < 0)
  8055fa:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8055fe:	79 05                	jns    805605 <devcons_read+0x4e>
		return c;
  805600:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805603:	eb 1d                	jmp    805622 <devcons_read+0x6b>
	if (c == 0x04)	// ctl-d is eof
  805605:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  805609:	75 07                	jne    805612 <devcons_read+0x5b>
		return 0;
  80560b:	b8 00 00 00 00       	mov    $0x0,%eax
  805610:	eb 10                	jmp    805622 <devcons_read+0x6b>
	*(char*)vbuf = c;
  805612:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805615:	89 c2                	mov    %eax,%edx
  805617:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80561b:	88 10                	mov    %dl,(%rax)
	return 1;
  80561d:	b8 01 00 00 00       	mov    $0x1,%eax
}
  805622:	c9                   	leaveq 
  805623:	c3                   	retq   

0000000000805624 <devcons_write>:

static ssize_t
devcons_write(struct Fd *fd, const void *vbuf, size_t n)
{
  805624:	55                   	push   %rbp
  805625:	48 89 e5             	mov    %rsp,%rbp
  805628:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  80562f:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  805636:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  80563d:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  805644:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80564b:	eb 77                	jmp    8056c4 <devcons_write+0xa0>
		m = n - tot;
  80564d:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  805654:	89 c2                	mov    %eax,%edx
  805656:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805659:	89 d1                	mov    %edx,%ecx
  80565b:	29 c1                	sub    %eax,%ecx
  80565d:	89 c8                	mov    %ecx,%eax
  80565f:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (m > sizeof(buf) - 1)
  805662:	8b 45 f8             	mov    -0x8(%rbp),%eax
  805665:	83 f8 7f             	cmp    $0x7f,%eax
  805668:	76 07                	jbe    805671 <devcons_write+0x4d>
			m = sizeof(buf) - 1;
  80566a:	c7 45 f8 7f 00 00 00 	movl   $0x7f,-0x8(%rbp)
		memmove(buf, (char*)vbuf + tot, m);
  805671:	8b 45 f8             	mov    -0x8(%rbp),%eax
  805674:	48 63 d0             	movslq %eax,%rdx
  805677:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80567a:	48 98                	cltq   
  80567c:	48 89 c1             	mov    %rax,%rcx
  80567f:	48 03 8d 60 ff ff ff 	add    -0xa0(%rbp),%rcx
  805686:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  80568d:	48 89 ce             	mov    %rcx,%rsi
  805690:	48 89 c7             	mov    %rax,%rdi
  805693:	48 b8 e6 21 80 00 00 	movabs $0x8021e6,%rax
  80569a:	00 00 00 
  80569d:	ff d0                	callq  *%rax
		sys_cputs(buf, m);
  80569f:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8056a2:	48 63 d0             	movslq %eax,%rdx
  8056a5:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  8056ac:	48 89 d6             	mov    %rdx,%rsi
  8056af:	48 89 c7             	mov    %rax,%rdi
  8056b2:	48 b8 b4 26 80 00 00 	movabs $0x8026b4,%rax
  8056b9:	00 00 00 
  8056bc:	ff d0                	callq  *%rax
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  8056be:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8056c1:	01 45 fc             	add    %eax,-0x4(%rbp)
  8056c4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8056c7:	48 98                	cltq   
  8056c9:	48 3b 85 58 ff ff ff 	cmp    -0xa8(%rbp),%rax
  8056d0:	0f 82 77 ff ff ff    	jb     80564d <devcons_write+0x29>
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
		sys_cputs(buf, m);
	}
	return tot;
  8056d6:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8056d9:	c9                   	leaveq 
  8056da:	c3                   	retq   

00000000008056db <devcons_close>:

static int
devcons_close(struct Fd *fd)
{
  8056db:	55                   	push   %rbp
  8056dc:	48 89 e5             	mov    %rsp,%rbp
  8056df:	48 83 ec 08          	sub    $0x8,%rsp
  8056e3:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	USED(fd);

	return 0;
  8056e7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8056ec:	c9                   	leaveq 
  8056ed:	c3                   	retq   

00000000008056ee <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  8056ee:	55                   	push   %rbp
  8056ef:	48 89 e5             	mov    %rsp,%rbp
  8056f2:	48 83 ec 10          	sub    $0x10,%rsp
  8056f6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8056fa:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	strcpy(stat->st_name, "<cons>");
  8056fe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805702:	48 be 14 13 82 00 00 	movabs $0x821314,%rsi
  805709:	00 00 00 
  80570c:	48 89 c7             	mov    %rax,%rdi
  80570f:	48 b8 c4 1e 80 00 00 	movabs $0x801ec4,%rax
  805716:	00 00 00 
  805719:	ff d0                	callq  *%rax
	return 0;
  80571b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805720:	c9                   	leaveq 
  805721:	c3                   	retq   
	...

0000000000805724 <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  805724:	55                   	push   %rbp
  805725:	48 89 e5             	mov    %rsp,%rbp
  805728:	48 83 ec 20          	sub    $0x20,%rsp
  80572c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int r,res;

	if (_pgfault_handler == 0) {
  805730:	48 b8 00 b0 b5 00 00 	movabs $0xb5b000,%rax
  805737:	00 00 00 
  80573a:	48 8b 00             	mov    (%rax),%rax
  80573d:	48 85 c0             	test   %rax,%rax
  805740:	0f 85 8e 00 00 00    	jne    8057d4 <set_pgfault_handler+0xb0>
		// First time through!
		// LAB 4: Your code here.
		void *ex_stack = (void *)(UXSTACKTOP - PGSIZE);
  805746:	c7 45 f8 00 f0 7f ef 	movl   $0xef7ff000,-0x8(%rbp)
  80574d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
		envid_t envid = sys_getenvid();
  805754:	48 b8 80 27 80 00 00 	movabs $0x802780,%rax
  80575b:	00 00 00 
  80575e:	ff d0                	callq  *%rax
  805760:	89 45 f4             	mov    %eax,-0xc(%rbp)
		res = sys_page_alloc(envid, ex_stack, PTE_P | PTE_U | PTE_W);
  805763:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  805767:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80576a:	ba 07 00 00 00       	mov    $0x7,%edx
  80576f:	48 89 ce             	mov    %rcx,%rsi
  805772:	89 c7                	mov    %eax,%edi
  805774:	48 b8 fc 27 80 00 00 	movabs $0x8027fc,%rax
  80577b:	00 00 00 
  80577e:	ff d0                	callq  *%rax
  805780:	89 45 f0             	mov    %eax,-0x10(%rbp)
		if(res)
  805783:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  805787:	74 30                	je     8057b9 <set_pgfault_handler+0x95>
			panic("\nNo memory left to allocate for pgfault exception: %e\n", res);
  805789:	8b 45 f0             	mov    -0x10(%rbp),%eax
  80578c:	89 c1                	mov    %eax,%ecx
  80578e:	48 ba 20 13 82 00 00 	movabs $0x821320,%rdx
  805795:	00 00 00 
  805798:	be 24 00 00 00       	mov    $0x24,%esi
  80579d:	48 bf 57 13 82 00 00 	movabs $0x821357,%rdi
  8057a4:	00 00 00 
  8057a7:	b8 00 00 00 00       	mov    $0x0,%eax
  8057ac:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  8057b3:	00 00 00 
  8057b6:	41 ff d0             	callq  *%r8

		sys_env_set_pgfault_upcall(envid, _pgfault_upcall);
  8057b9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8057bc:	48 be e8 57 80 00 00 	movabs $0x8057e8,%rsi
  8057c3:	00 00 00 
  8057c6:	89 c7                	mov    %eax,%edi
  8057c8:	48 b8 86 29 80 00 00 	movabs $0x802986,%rax
  8057cf:	00 00 00 
  8057d2:	ff d0                	callq  *%rax
//		panic("set_pgfault_handler not implemented");
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  8057d4:	48 b8 00 b0 b5 00 00 	movabs $0xb5b000,%rax
  8057db:	00 00 00 
  8057de:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8057e2:	48 89 10             	mov    %rdx,(%rax)
}
  8057e5:	c9                   	leaveq 
  8057e6:	c3                   	retq   
	...

00000000008057e8 <_pgfault_upcall>:
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	// function argument: pointer to UTF
	
	movq  %rsp,%rdi                // passing the function argument in rdi
  8057e8:	48 89 e7             	mov    %rsp,%rdi
	movabs _pgfault_handler, %rax
  8057eb:	48 a1 00 b0 b5 00 00 	movabs 0xb5b000,%rax
  8057f2:	00 00 00 
	call *%rax
  8057f5:	ff d0                	callq  *%rax
	// registers are available for intermediate calculations.  You
	// may find that you have to rearrange your code in non-obvious
	// ways as registers become unavailable as scratch space.
	//
	// LAB 4: Your code here.
		add $8, %rsp  					// For fault_va
  8057f7:	48 83 c4 08          	add    $0x8,%rsp
		add $8, %rsp 					// For error code
  8057fb:	48 83 c4 08          	add    $0x8,%rsp
		movq %rsp, %rax					// save the top of exception stack
  8057ff:	48 89 e0             	mov    %rsp,%rax
		movq 136(%rsp), %rbx				// trap time rsp
  805802:	48 8b 9c 24 88 00 00 	mov    0x88(%rsp),%rbx
  805809:	00 
		movq 120(%rsp), %rcx				// trap time rip
  80580a:	48 8b 4c 24 78       	mov    0x78(%rsp),%rcx
		movq %rbx, %rsp					// move to trap time rsp
  80580f:	48 89 dc             	mov    %rbx,%rsp
		pushq %rcx					// push trap time rip to stack
  805812:	51                   	push   %rcx
	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.
		movq %rax, %rsp                                 // go back to the exception stack
  805813:	48 89 c4             	mov    %rax,%rsp
		subq $8, 136(%rsp)  				// update this stack for the push we did
  805816:	48 83 ac 24 88 00 00 	subq   $0x8,0x88(%rsp)
  80581d:	00 08 
		POPA_						// copy the register contents to the registers
  80581f:	4c 8b 3c 24          	mov    (%rsp),%r15
  805823:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  805828:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  80582d:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  805832:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  805837:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  80583c:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  805841:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  805846:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  80584b:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  805850:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  805855:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  80585a:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  80585f:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  805864:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  805869:	48 83 c4 78          	add    $0x78,%rsp
	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.
		add $8, %rsp					//skip to the eflags value in the stack
  80586d:	48 83 c4 08          	add    $0x8,%rsp
		popfq						// pop that value from the stack
  805871:	9d                   	popfq  
	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.
		popq %rsp					// switch back to the trap time stack
  805872:	5c                   	pop    %rsp
	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
		ret						//return back to the instruction that faulted
  805873:	c3                   	retq   

0000000000805874 <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  805874:	55                   	push   %rbp
  805875:	48 89 e5             	mov    %rsp,%rbp
  805878:	48 83 ec 18          	sub    $0x18,%rsp
  80587c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	pte_t pte;

	if (!(uvpd[VPD(v)] & PTE_P))
  805880:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805884:	48 89 c2             	mov    %rax,%rdx
  805887:	48 c1 ea 15          	shr    $0x15,%rdx
  80588b:	48 b8 00 00 00 80 00 	movabs $0x10080000000,%rax
  805892:	01 00 00 
  805895:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  805899:	83 e0 01             	and    $0x1,%eax
  80589c:	48 85 c0             	test   %rax,%rax
  80589f:	75 07                	jne    8058a8 <pageref+0x34>
		return 0;
  8058a1:	b8 00 00 00 00       	mov    $0x0,%eax
  8058a6:	eb 53                	jmp    8058fb <pageref+0x87>
	pte = uvpt[PGNUM(v)];
  8058a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8058ac:	48 89 c2             	mov    %rax,%rdx
  8058af:	48 c1 ea 0c          	shr    $0xc,%rdx
  8058b3:	48 b8 00 00 00 00 00 	movabs $0x10000000000,%rax
  8058ba:	01 00 00 
  8058bd:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8058c1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (!(pte & PTE_P))
  8058c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8058c9:	83 e0 01             	and    $0x1,%eax
  8058cc:	48 85 c0             	test   %rax,%rax
  8058cf:	75 07                	jne    8058d8 <pageref+0x64>
		return 0;
  8058d1:	b8 00 00 00 00       	mov    $0x0,%eax
  8058d6:	eb 23                	jmp    8058fb <pageref+0x87>
	return pages[PPN(pte)].pp_ref;
  8058d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8058dc:	48 89 c2             	mov    %rax,%rdx
  8058df:	48 c1 ea 0c          	shr    $0xc,%rdx
  8058e3:	48 b8 00 00 a0 00 80 	movabs $0x8000a00000,%rax
  8058ea:	00 00 00 
  8058ed:	48 c1 e2 04          	shl    $0x4,%rdx
  8058f1:	48 01 d0             	add    %rdx,%rax
  8058f4:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8058f8:	0f b7 c0             	movzwl %ax,%eax
}
  8058fb:	c9                   	leaveq 
  8058fc:	c3                   	retq   
  8058fd:	00 00                	add    %al,(%rax)
	...

0000000000805900 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  805900:	55                   	push   %rbp
  805901:	48 89 e5             	mov    %rsp,%rbp
  socksem   = sys_sem_new(1);
  805904:	bf 01 00 00 00       	mov    $0x1,%edi
  805909:	48 b8 e2 79 81 00 00 	movabs $0x8179e2,%rax
  805910:	00 00 00 
  805913:	ff d0                	callq  *%rax
  805915:	48 ba 08 95 82 00 00 	movabs $0x829508,%rdx
  80591c:	00 00 00 
  80591f:	89 02                	mov    %eax,(%rdx)
  selectsem = sys_sem_new(1);
  805921:	bf 01 00 00 00       	mov    $0x1,%edi
  805926:	48 b8 e2 79 81 00 00 	movabs $0x8179e2,%rax
  80592d:	00 00 00 
  805930:	ff d0                	callq  *%rax
  805932:	48 ba 0c 95 82 00 00 	movabs $0x82950c,%rdx
  805939:	00 00 00 
  80593c:	89 02                	mov    %eax,(%rdx)
}
  80593e:	5d                   	pop    %rbp
  80593f:	c3                   	retq   

0000000000805940 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  805940:	55                   	push   %rbp
  805941:	48 89 e5             	mov    %rsp,%rbp
  805944:	48 83 ec 18          	sub    $0x18,%rsp
  805948:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  80594b:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80594f:	78 06                	js     805957 <get_socket+0x17>
  805951:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  805955:	7e 17                	jle    80596e <get_socket+0x2e>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  805957:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  80595e:	00 00 00 
  805961:	c7 00 09 00 00 00    	movl   $0x9,(%rax)
    return NULL;
  805967:	b8 00 00 00 00       	mov    $0x0,%eax
  80596c:	eb 44                	jmp    8059b2 <get_socket+0x72>
  }

  sock = &sockets[s];
  80596e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805971:	48 98                	cltq   
  805973:	48 89 c2             	mov    %rax,%rdx
  805976:	48 c1 e2 05          	shl    $0x5,%rdx
  80597a:	48 b8 00 91 82 00 00 	movabs $0x829100,%rax
  805981:	00 00 00 
  805984:	48 01 d0             	add    %rdx,%rax
  805987:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if (!sock->conn) {
  80598b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80598f:	48 8b 00             	mov    (%rax),%rax
  805992:	48 85 c0             	test   %rax,%rax
  805995:	75 17                	jne    8059ae <get_socket+0x6e>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  805997:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  80599e:	00 00 00 
  8059a1:	c7 00 09 00 00 00    	movl   $0x9,(%rax)
    return NULL;
  8059a7:	b8 00 00 00 00       	mov    $0x0,%eax
  8059ac:	eb 04                	jmp    8059b2 <get_socket+0x72>
  }

  return sock;
  8059ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8059b2:	c9                   	leaveq 
  8059b3:	c3                   	retq   

00000000008059b4 <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  8059b4:	55                   	push   %rbp
  8059b5:	48 89 e5             	mov    %rsp,%rbp
  8059b8:	48 83 ec 20          	sub    $0x20,%rsp
  8059bc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  8059c0:	48 b8 08 95 82 00 00 	movabs $0x829508,%rax
  8059c7:	00 00 00 
  8059ca:	8b 00                	mov    (%rax),%eax
  8059cc:	89 c7                	mov    %eax,%edi
  8059ce:	48 b8 e8 e2 80 00 00 	movabs $0x80e2e8,%rax
  8059d5:	00 00 00 
  8059d8:	ff d0                	callq  *%rax

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  8059da:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8059e1:	e9 28 01 00 00       	jmpq   805b0e <alloc_socket+0x15a>
    if (!sockets[i].conn) {
  8059e6:	48 b8 00 91 82 00 00 	movabs $0x829100,%rax
  8059ed:	00 00 00 
  8059f0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8059f3:	48 63 d2             	movslq %edx,%rdx
  8059f6:	48 c1 e2 05          	shl    $0x5,%rdx
  8059fa:	48 01 d0             	add    %rdx,%rax
  8059fd:	48 8b 00             	mov    (%rax),%rax
  805a00:	48 85 c0             	test   %rax,%rax
  805a03:	0f 85 01 01 00 00    	jne    805b0a <alloc_socket+0x156>
      sockets[i].conn       = newconn;
  805a09:	48 b8 00 91 82 00 00 	movabs $0x829100,%rax
  805a10:	00 00 00 
  805a13:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805a16:	48 63 d2             	movslq %edx,%rdx
  805a19:	48 c1 e2 05          	shl    $0x5,%rdx
  805a1d:	48 01 c2             	add    %rax,%rdx
  805a20:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  805a24:	48 89 02             	mov    %rax,(%rdx)
      sockets[i].lastdata   = NULL;
  805a27:	48 b8 00 91 82 00 00 	movabs $0x829100,%rax
  805a2e:	00 00 00 
  805a31:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805a34:	48 63 d2             	movslq %edx,%rdx
  805a37:	48 c1 e2 05          	shl    $0x5,%rdx
  805a3b:	48 01 d0             	add    %rdx,%rax
  805a3e:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  805a45:	00 
      sockets[i].lastoffset = 0;
  805a46:	48 b8 00 91 82 00 00 	movabs $0x829100,%rax
  805a4d:	00 00 00 
  805a50:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805a53:	48 63 d2             	movslq %edx,%rdx
  805a56:	48 c1 e2 05          	shl    $0x5,%rdx
  805a5a:	48 01 d0             	add    %rdx,%rax
  805a5d:	48 83 c0 10          	add    $0x10,%rax
  805a61:	66 c7 00 00 00       	movw   $0x0,(%rax)
      sockets[i].rcvevent   = 0;
  805a66:	48 b8 00 91 82 00 00 	movabs $0x829100,%rax
  805a6d:	00 00 00 
  805a70:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805a73:	48 63 d2             	movslq %edx,%rdx
  805a76:	48 c1 e2 05          	shl    $0x5,%rdx
  805a7a:	48 01 d0             	add    %rdx,%rax
  805a7d:	48 83 c0 10          	add    $0x10,%rax
  805a81:	66 c7 40 02 00 00    	movw   $0x0,0x2(%rax)
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  805a87:	48 b8 00 91 82 00 00 	movabs $0x829100,%rax
  805a8e:	00 00 00 
  805a91:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805a94:	48 63 d2             	movslq %edx,%rdx
  805a97:	48 c1 e2 05          	shl    $0x5,%rdx
  805a9b:	48 01 d0             	add    %rdx,%rax
  805a9e:	48 83 c0 10          	add    $0x10,%rax
  805aa2:	66 c7 40 04 01 00    	movw   $0x1,0x4(%rax)
      sockets[i].flags      = 0;
  805aa8:	48 b8 00 91 82 00 00 	movabs $0x829100,%rax
  805aaf:	00 00 00 
  805ab2:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805ab5:	48 63 d2             	movslq %edx,%rdx
  805ab8:	48 c1 e2 05          	shl    $0x5,%rdx
  805abc:	48 01 d0             	add    %rdx,%rax
  805abf:	48 83 c0 10          	add    $0x10,%rax
  805ac3:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
      sockets[i].err        = 0;
  805ac9:	48 b8 00 91 82 00 00 	movabs $0x829100,%rax
  805ad0:	00 00 00 
  805ad3:	8b 55 fc             	mov    -0x4(%rbp),%edx
  805ad6:	48 63 d2             	movslq %edx,%rdx
  805ad9:	48 c1 e2 05          	shl    $0x5,%rdx
  805add:	48 01 d0             	add    %rdx,%rax
  805ae0:	48 83 c0 10          	add    $0x10,%rax
  805ae4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
      sys_sem_signal(socksem);
  805aeb:	48 b8 08 95 82 00 00 	movabs $0x829508,%rax
  805af2:	00 00 00 
  805af5:	8b 00                	mov    (%rax),%eax
  805af7:	89 c7                	mov    %eax,%edi
  805af9:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  805b00:	00 00 00 
  805b03:	ff d0                	callq  *%rax
      return i;
  805b05:	8b 45 fc             	mov    -0x4(%rbp),%eax
  805b08:	eb 2d                	jmp    805b37 <alloc_socket+0x183>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  805b0a:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  805b0e:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  805b12:	0f 8e ce fe ff ff    	jle    8059e6 <alloc_socket+0x32>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  805b18:	48 b8 08 95 82 00 00 	movabs $0x829508,%rax
  805b1f:	00 00 00 
  805b22:	8b 00                	mov    (%rax),%eax
  805b24:	89 c7                	mov    %eax,%edi
  805b26:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  805b2d:	00 00 00 
  805b30:	ff d0                	callq  *%rax
  return -1;
  805b32:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  805b37:	c9                   	leaveq 
  805b38:	c3                   	retq   

0000000000805b39 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  805b39:	55                   	push   %rbp
  805b3a:	48 89 e5             	mov    %rsp,%rbp
  805b3d:	48 83 ec 70          	sub    $0x70,%rsp
  805b41:	89 7d ac             	mov    %edi,-0x54(%rbp)
  805b44:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  805b48:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  805b4c:	8b 45 ac             	mov    -0x54(%rbp),%eax
  805b4f:	89 c7                	mov    %eax,%edi
  805b51:	48 b8 40 59 80 00 00 	movabs $0x805940,%rax
  805b58:	00 00 00 
  805b5b:	ff d0                	callq  *%rax
  805b5d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  805b61:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  805b66:	75 0a                	jne    805b72 <lwip_accept+0x39>
    return -1;
  805b68:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805b6d:	e9 ef 02 00 00       	jmpq   805e61 <lwip_accept+0x328>

  newconn = netconn_accept(sock->conn);
  805b72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805b76:	48 8b 00             	mov    (%rax),%rax
  805b79:	48 89 c7             	mov    %rax,%rdi
  805b7c:	48 b8 74 9b 81 00 00 	movabs $0x819b74,%rax
  805b83:	00 00 00 
  805b86:	ff d0                	callq  *%rax
  805b88:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (!newconn) {
  805b8c:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  805b91:	75 62                	jne    805bf5 <lwip_accept+0xbc>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  805b93:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805b97:	48 8b 00             	mov    (%rax),%rax
  805b9a:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  805b9e:	0f be c0             	movsbl %al,%eax
  805ba1:	f7 d8                	neg    %eax
  805ba3:	83 f8 0e             	cmp    $0xe,%eax
  805ba6:	77 24                	ja     805bcc <lwip_accept+0x93>
  805ba8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805bac:	48 8b 00             	mov    (%rax),%rax
  805baf:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  805bb3:	0f be c0             	movsbl %al,%eax
  805bb6:	89 c2                	mov    %eax,%edx
  805bb8:	f7 da                	neg    %edx
  805bba:	48 b8 80 13 82 00 00 	movabs $0x821380,%rax
  805bc1:	00 00 00 
  805bc4:	48 63 d2             	movslq %edx,%rdx
  805bc7:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  805bca:	eb 05                	jmp    805bd1 <lwip_accept+0x98>
  805bcc:	b8 05 00 00 00       	mov    $0x5,%eax
  805bd1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  805bd5:	89 42 18             	mov    %eax,0x18(%rdx)
  805bd8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805bdc:	8b 50 18             	mov    0x18(%rax),%edx
  805bdf:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  805be6:	00 00 00 
  805be9:	89 10                	mov    %edx,(%rax)
    return -1;
  805beb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805bf0:	e9 6c 02 00 00       	jmpq   805e61 <lwip_accept+0x328>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  805bf5:	48 8d 55 ce          	lea    -0x32(%rbp),%rdx
  805bf9:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  805bfd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805c01:	b9 00 00 00 00       	mov    $0x0,%ecx
  805c06:	48 89 c7             	mov    %rax,%rdi
  805c09:	48 b8 85 98 81 00 00 	movabs $0x819885,%rax
  805c10:	00 00 00 
  805c13:	ff d0                	callq  *%rax
  805c15:	88 45 ef             	mov    %al,-0x11(%rbp)
  if (err != ERR_OK) {
  805c18:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  805c1c:	74 61                	je     805c7f <lwip_accept+0x146>
    netconn_delete(newconn);
  805c1e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805c22:	48 89 c7             	mov    %rax,%rdi
  805c25:	48 b8 d7 97 81 00 00 	movabs $0x8197d7,%rax
  805c2c:	00 00 00 
  805c2f:	ff d0                	callq  *%rax
    sock_set_errno(sock, err_to_errno(err));
  805c31:	0f be 45 ef          	movsbl -0x11(%rbp),%eax
  805c35:	f7 d8                	neg    %eax
  805c37:	83 f8 0e             	cmp    $0xe,%eax
  805c3a:	77 1a                	ja     805c56 <lwip_accept+0x11d>
  805c3c:	0f be 45 ef          	movsbl -0x11(%rbp),%eax
  805c40:	89 c2                	mov    %eax,%edx
  805c42:	f7 da                	neg    %edx
  805c44:	48 b8 80 13 82 00 00 	movabs $0x821380,%rax
  805c4b:	00 00 00 
  805c4e:	48 63 d2             	movslq %edx,%rdx
  805c51:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  805c54:	eb 05                	jmp    805c5b <lwip_accept+0x122>
  805c56:	b8 05 00 00 00       	mov    $0x5,%eax
  805c5b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  805c5f:	89 42 18             	mov    %eax,0x18(%rdx)
  805c62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805c66:	8b 50 18             	mov    0x18(%rax),%edx
  805c69:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  805c70:	00 00 00 
  805c73:	89 10                	mov    %edx,(%rax)
    return -1;
  805c75:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805c7a:	e9 e2 01 00 00       	jmpq   805e61 <lwip_accept+0x328>
  }

  memset(&sin, 0, sizeof(sin));
  805c7f:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  805c83:	ba 10 00 00 00       	mov    $0x10,%edx
  805c88:	be 00 00 00 00       	mov    $0x0,%esi
  805c8d:	48 89 c7             	mov    %rax,%rdi
  805c90:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  805c97:	00 00 00 
  805c9a:	ff d0                	callq  *%rax
  sin.sin_len = sizeof(sin);
  805c9c:	c6 45 b0 10          	movb   $0x10,-0x50(%rbp)
  sin.sin_family = AF_INET;
  805ca0:	c6 45 b1 02          	movb   $0x2,-0x4f(%rbp)
  sin.sin_port = htons(port);
  805ca4:	0f b7 45 ce          	movzwl -0x32(%rbp),%eax
  805ca8:	0f b7 c0             	movzwl %ax,%eax
  805cab:	89 c7                	mov    %eax,%edi
  805cad:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  805cb4:	00 00 00 
  805cb7:	ff d0                	callq  *%rax
  805cb9:	66 89 45 b2          	mov    %ax,-0x4e(%rbp)
  sin.sin_addr.s_addr = naddr.addr;
  805cbd:	8b 45 d0             	mov    -0x30(%rbp),%eax
  805cc0:	89 45 b4             	mov    %eax,-0x4c(%rbp)

  if (*addrlen > sizeof(sin))
  805cc3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  805cc7:	8b 00                	mov    (%rax),%eax
  805cc9:	83 f8 10             	cmp    $0x10,%eax
  805ccc:	76 0a                	jbe    805cd8 <lwip_accept+0x19f>
    *addrlen = sizeof(sin);
  805cce:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  805cd2:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

  SMEMCPY(addr, &sin, *addrlen);
  805cd8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  805cdc:	8b 00                	mov    (%rax),%eax
  805cde:	89 c2                	mov    %eax,%edx
  805ce0:	48 8d 4d b0          	lea    -0x50(%rbp),%rcx
  805ce4:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  805ce8:	48 89 ce             	mov    %rcx,%rsi
  805ceb:	48 89 c7             	mov    %rax,%rdi
  805cee:	48 b8 fd 22 80 00 00 	movabs $0x8022fd,%rax
  805cf5:	00 00 00 
  805cf8:	ff d0                	callq  *%rax

  newsock = alloc_socket(newconn);
  805cfa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805cfe:	48 89 c7             	mov    %rax,%rdi
  805d01:	48 b8 b4 59 80 00 00 	movabs $0x8059b4,%rax
  805d08:	00 00 00 
  805d0b:	ff d0                	callq  *%rax
  805d0d:	89 45 e8             	mov    %eax,-0x18(%rbp)
  if (newsock == -1) {
  805d10:	83 7d e8 ff          	cmpl   $0xffffffff,-0x18(%rbp)
  805d14:	75 3b                	jne    805d51 <lwip_accept+0x218>
    netconn_delete(newconn);
  805d16:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805d1a:	48 89 c7             	mov    %rax,%rdi
  805d1d:	48 b8 d7 97 81 00 00 	movabs $0x8197d7,%rax
  805d24:	00 00 00 
  805d27:	ff d0                	callq  *%rax
    sock_set_errno(sock, ENFILE);
  805d29:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805d2d:	c7 40 18 17 00 00 00 	movl   $0x17,0x18(%rax)
  805d34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805d38:	8b 50 18             	mov    0x18(%rax),%edx
  805d3b:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  805d42:	00 00 00 
  805d45:	89 10                	mov    %edx,(%rax)
    return -1;
  805d47:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805d4c:	e9 10 01 00 00       	jmpq   805e61 <lwip_accept+0x328>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  805d51:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  805d55:	78 06                	js     805d5d <lwip_accept+0x224>
  805d57:	83 7d e8 1f          	cmpl   $0x1f,-0x18(%rbp)
  805d5b:	7e 2a                	jle    805d87 <lwip_accept+0x24e>
  805d5d:	48 ba bc 13 82 00 00 	movabs $0x8213bc,%rdx
  805d64:	00 00 00 
  805d67:	be 25 01 00 00       	mov    $0x125,%esi
  805d6c:	48 bf d1 13 82 00 00 	movabs $0x8213d1,%rdi
  805d73:	00 00 00 
  805d76:	b8 00 00 00 00       	mov    $0x0,%eax
  805d7b:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  805d82:	00 00 00 
  805d85:	ff d1                	callq  *%rcx
  newconn->callback = event_callback;
  805d87:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805d8b:	48 ba 02 73 80 00 00 	movabs $0x807302,%rdx
  805d92:	00 00 00 
  805d95:	48 89 50 38          	mov    %rdx,0x38(%rax)
  nsock = &sockets[newsock];
  805d99:	8b 45 e8             	mov    -0x18(%rbp),%eax
  805d9c:	48 98                	cltq   
  805d9e:	48 89 c2             	mov    %rax,%rdx
  805da1:	48 c1 e2 05          	shl    $0x5,%rdx
  805da5:	48 b8 00 91 82 00 00 	movabs $0x829100,%rax
  805dac:	00 00 00 
  805daf:	48 01 d0             	add    %rdx,%rax
  805db2:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);
  805db6:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  805dbb:	75 2a                	jne    805de7 <lwip_accept+0x2ae>
  805dbd:	48 ba e8 13 82 00 00 	movabs $0x8213e8,%rdx
  805dc4:	00 00 00 
  805dc7:	be 28 01 00 00       	mov    $0x128,%esi
  805dcc:	48 bf d1 13 82 00 00 	movabs $0x8213d1,%rdi
  805dd3:	00 00 00 
  805dd6:	b8 00 00 00 00       	mov    $0x0,%eax
  805ddb:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  805de2:	00 00 00 
  805de5:	ff d1                	callq  *%rcx

  sys_sem_wait(socksem);
  805de7:	48 b8 08 95 82 00 00 	movabs $0x829508,%rax
  805dee:	00 00 00 
  805df1:	8b 00                	mov    (%rax),%eax
  805df3:	89 c7                	mov    %eax,%edi
  805df5:	48 b8 e8 e2 80 00 00 	movabs $0x80e2e8,%rax
  805dfc:	00 00 00 
  805dff:	ff d0                	callq  *%rax
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  805e01:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805e05:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  805e09:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805e0d:	8b 40 20             	mov    0x20(%rax),%eax
  805e10:	f7 d0                	not    %eax
  805e12:	01 c2                	add    %eax,%edx
  805e14:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805e18:	66 89 50 12          	mov    %dx,0x12(%rax)
  newconn->socket = newsock;
  805e1c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  805e20:	8b 55 e8             	mov    -0x18(%rbp),%edx
  805e23:	89 50 20             	mov    %edx,0x20(%rax)
  sys_sem_signal(socksem);
  805e26:	48 b8 08 95 82 00 00 	movabs $0x829508,%rax
  805e2d:	00 00 00 
  805e30:	8b 00                	mov    (%rax),%eax
  805e32:	89 c7                	mov    %eax,%edi
  805e34:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  805e3b:	00 00 00 
  805e3e:	ff d0                	callq  *%rax

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  805e40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805e44:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  805e4b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805e4f:	8b 50 18             	mov    0x18(%rax),%edx
  805e52:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  805e59:	00 00 00 
  805e5c:	89 10                	mov    %edx,(%rax)
  return newsock;
  805e5e:	8b 45 e8             	mov    -0x18(%rbp),%eax
}
  805e61:	c9                   	leaveq 
  805e62:	c3                   	retq   

0000000000805e63 <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  805e63:	55                   	push   %rbp
  805e64:	48 89 e5             	mov    %rsp,%rbp
  805e67:	48 83 ec 20          	sub    $0x20,%rsp
  805e6b:	89 7d ec             	mov    %edi,-0x14(%rbp)
  805e6e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  805e72:	89 55 e8             	mov    %edx,-0x18(%rbp)
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  805e75:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805e78:	89 c7                	mov    %eax,%edi
  805e7a:	48 b8 40 59 80 00 00 	movabs $0x805940,%rax
  805e81:	00 00 00 
  805e84:	ff d0                	callq  *%rax
  805e86:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  805e8a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  805e8f:	75 0a                	jne    805e9b <lwip_bind+0x38>
    return -1;
  805e91:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805e96:	e9 fb 00 00 00       	jmpq   805f96 <lwip_bind+0x133>

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  805e9b:	83 7d e8 10          	cmpl   $0x10,-0x18(%rbp)
  805e9f:	75 0c                	jne    805ead <lwip_bind+0x4a>
  805ea1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805ea5:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  805ea9:	3c 02                	cmp    $0x2,%al
  805eab:	74 2a                	je     805ed7 <lwip_bind+0x74>
  805ead:	48 ba ff 13 82 00 00 	movabs $0x8213ff,%rdx
  805eb4:	00 00 00 
  805eb7:	be 4a 01 00 00       	mov    $0x14a,%esi
  805ebc:	48 bf d1 13 82 00 00 	movabs $0x8213d1,%rdi
  805ec3:	00 00 00 
  805ec6:	b8 00 00 00 00       	mov    $0x0,%eax
  805ecb:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  805ed2:	00 00 00 
  805ed5:	ff d1                	callq  *%rcx
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  805ed7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805edb:	8b 40 04             	mov    0x4(%rax),%eax
  805ede:	89 45 f0             	mov    %eax,-0x10(%rbp)
  local_port = ((struct sockaddr_in *)name)->sin_port;
  805ee1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  805ee5:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  805ee9:	66 89 45 f6          	mov    %ax,-0xa(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  805eed:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  805ef1:	89 c7                	mov    %eax,%edi
  805ef3:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  805efa:	00 00 00 
  805efd:	ff d0                	callq  *%rax
  805eff:	0f b7 d0             	movzwl %ax,%edx
  805f02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805f06:	48 8b 00             	mov    (%rax),%rax
  805f09:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  805f0d:	48 89 ce             	mov    %rcx,%rsi
  805f10:	48 89 c7             	mov    %rax,%rdi
  805f13:	48 b8 7b 99 81 00 00 	movabs $0x81997b,%rax
  805f1a:	00 00 00 
  805f1d:	ff d0                	callq  *%rax
  805f1f:	88 45 f5             	mov    %al,-0xb(%rbp)

  if (err != ERR_OK) {
  805f22:	80 7d f5 00          	cmpb   $0x0,-0xb(%rbp)
  805f26:	74 4b                	je     805f73 <lwip_bind+0x110>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  805f28:	0f be 45 f5          	movsbl -0xb(%rbp),%eax
  805f2c:	f7 d8                	neg    %eax
  805f2e:	83 f8 0e             	cmp    $0xe,%eax
  805f31:	77 1a                	ja     805f4d <lwip_bind+0xea>
  805f33:	0f be 45 f5          	movsbl -0xb(%rbp),%eax
  805f37:	89 c2                	mov    %eax,%edx
  805f39:	f7 da                	neg    %edx
  805f3b:	48 b8 80 13 82 00 00 	movabs $0x821380,%rax
  805f42:	00 00 00 
  805f45:	48 63 d2             	movslq %edx,%rdx
  805f48:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  805f4b:	eb 05                	jmp    805f52 <lwip_bind+0xef>
  805f4d:	b8 05 00 00 00       	mov    $0x5,%eax
  805f52:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  805f56:	89 42 18             	mov    %eax,0x18(%rdx)
  805f59:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805f5d:	8b 50 18             	mov    0x18(%rax),%edx
  805f60:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  805f67:	00 00 00 
  805f6a:	89 10                	mov    %edx,(%rax)
    return -1;
  805f6c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805f71:	eb 23                	jmp    805f96 <lwip_bind+0x133>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  805f73:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805f77:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  805f7e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805f82:	8b 50 18             	mov    0x18(%rax),%edx
  805f85:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  805f8c:	00 00 00 
  805f8f:	89 10                	mov    %edx,(%rax)
  return 0;
  805f91:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805f96:	c9                   	leaveq 
  805f97:	c3                   	retq   

0000000000805f98 <lwip_close>:

int
lwip_close(int s)
{
  805f98:	55                   	push   %rbp
  805f99:	48 89 e5             	mov    %rsp,%rbp
  805f9c:	48 83 ec 20          	sub    $0x20,%rsp
  805fa0:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  805fa3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  805fa6:	89 c7                	mov    %eax,%edi
  805fa8:	48 b8 40 59 80 00 00 	movabs $0x805940,%rax
  805faf:	00 00 00 
  805fb2:	ff d0                	callq  *%rax
  805fb4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock) {
  805fb8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  805fbd:	75 0a                	jne    805fc9 <lwip_close+0x31>
    return -1;
  805fbf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805fc4:	e9 b2 00 00 00       	jmpq   80607b <lwip_close+0xe3>
  }

  netconn_delete(sock->conn);
  805fc9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805fcd:	48 8b 00             	mov    (%rax),%rax
  805fd0:	48 89 c7             	mov    %rax,%rdi
  805fd3:	48 b8 d7 97 81 00 00 	movabs $0x8197d7,%rax
  805fda:	00 00 00 
  805fdd:	ff d0                	callq  *%rax

  sys_sem_wait(socksem);
  805fdf:	48 b8 08 95 82 00 00 	movabs $0x829508,%rax
  805fe6:	00 00 00 
  805fe9:	8b 00                	mov    (%rax),%eax
  805feb:	89 c7                	mov    %eax,%edi
  805fed:	48 b8 e8 e2 80 00 00 	movabs $0x80e2e8,%rax
  805ff4:	00 00 00 
  805ff7:	ff d0                	callq  *%rax
  if (sock->lastdata) {
  805ff9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  805ffd:	48 8b 40 08          	mov    0x8(%rax),%rax
  806001:	48 85 c0             	test   %rax,%rax
  806004:	74 17                	je     80601d <lwip_close+0x85>
    netbuf_delete(sock->lastdata);
  806006:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80600a:	48 8b 40 08          	mov    0x8(%rax),%rax
  80600e:	48 89 c7             	mov    %rax,%rdi
  806011:	48 b8 9c 8a 80 00 00 	movabs $0x808a9c,%rax
  806018:	00 00 00 
  80601b:	ff d0                	callq  *%rax
  }
  sock->lastdata   = NULL;
  80601d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806021:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  806028:	00 
  sock->lastoffset = 0;
  806029:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80602d:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
  sock->conn       = NULL;
  806033:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806037:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  sock_set_errno(sock, 0);
  80603e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806042:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  806049:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80604d:	8b 50 18             	mov    0x18(%rax),%edx
  806050:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  806057:	00 00 00 
  80605a:	89 10                	mov    %edx,(%rax)
  sys_sem_signal(socksem);
  80605c:	48 b8 08 95 82 00 00 	movabs $0x829508,%rax
  806063:	00 00 00 
  806066:	8b 00                	mov    (%rax),%eax
  806068:	89 c7                	mov    %eax,%edi
  80606a:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  806071:	00 00 00 
  806074:	ff d0                	callq  *%rax
  return 0;
  806076:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80607b:	c9                   	leaveq 
  80607c:	c3                   	retq   

000000000080607d <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  80607d:	55                   	push   %rbp
  80607e:	48 89 e5             	mov    %rsp,%rbp
  806081:	48 83 ec 30          	sub    $0x30,%rsp
  806085:	89 7d dc             	mov    %edi,-0x24(%rbp)
  806088:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80608c:	89 55 d8             	mov    %edx,-0x28(%rbp)
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  80608f:	8b 45 dc             	mov    -0x24(%rbp),%eax
  806092:	89 c7                	mov    %eax,%edi
  806094:	48 b8 40 59 80 00 00 	movabs $0x805940,%rax
  80609b:	00 00 00 
  80609e:	ff d0                	callq  *%rax
  8060a0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (!sock)
  8060a4:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8060a9:	75 0a                	jne    8060b5 <lwip_connect+0x38>
    return -1;
  8060ab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8060b0:	e9 22 01 00 00       	jmpq   8061d7 <lwip_connect+0x15a>

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8060b5:	83 7d d8 10          	cmpl   $0x10,-0x28(%rbp)
  8060b9:	75 0c                	jne    8060c7 <lwip_connect+0x4a>
  8060bb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8060bf:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8060c3:	3c 02                	cmp    $0x2,%al
  8060c5:	74 2a                	je     8060f1 <lwip_connect+0x74>
  8060c7:	48 ba 1a 14 82 00 00 	movabs $0x82141a,%rdx
  8060ce:	00 00 00 
  8060d1:	be 86 01 00 00       	mov    $0x186,%esi
  8060d6:	48 bf d1 13 82 00 00 	movabs $0x8213d1,%rdi
  8060dd:	00 00 00 
  8060e0:	b8 00 00 00 00       	mov    $0x0,%eax
  8060e5:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8060ec:	00 00 00 
  8060ef:	ff d1                	callq  *%rcx
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  if (((struct sockaddr_in *)name)->sin_family == AF_UNSPEC) {
  8060f1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8060f5:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8060f9:	84 c0                	test   %al,%al
  8060fb:	75 1b                	jne    806118 <lwip_connect+0x9b>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, AF_UNSPEC)\n", s));
    err = netconn_disconnect(sock->conn);
  8060fd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806101:	48 8b 00             	mov    (%rax),%rax
  806104:	48 89 c7             	mov    %rax,%rdi
  806107:	48 b8 8f 9a 81 00 00 	movabs $0x819a8f,%rax
  80610e:	00 00 00 
  806111:	ff d0                	callq  *%rax
  806113:	88 45 ff             	mov    %al,-0x1(%rbp)
  806116:	eb 4b                	jmp    806163 <lwip_connect+0xe6>
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  806118:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80611c:	8b 40 04             	mov    0x4(%rax),%eax
  80611f:	89 45 e0             	mov    %eax,-0x20(%rbp)
    remote_port = ((struct sockaddr_in *)name)->sin_port;
  806122:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  806126:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  80612a:	66 89 45 ee          	mov    %ax,-0x12(%rbp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  80612e:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  806132:	89 c7                	mov    %eax,%edi
  806134:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  80613b:	00 00 00 
  80613e:	ff d0                	callq  *%rax
  806140:	0f b7 d0             	movzwl %ax,%edx
  806143:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806147:	48 8b 00             	mov    (%rax),%rax
  80614a:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  80614e:	48 89 ce             	mov    %rcx,%rsi
  806151:	48 89 c7             	mov    %rax,%rdi
  806154:	48 b8 05 9a 81 00 00 	movabs $0x819a05,%rax
  80615b:	00 00 00 
  80615e:	ff d0                	callq  *%rax
  806160:	88 45 ff             	mov    %al,-0x1(%rbp)
  }

  if (err != ERR_OK) {
  806163:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  806167:	74 4b                	je     8061b4 <lwip_connect+0x137>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  806169:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  80616d:	f7 d8                	neg    %eax
  80616f:	83 f8 0e             	cmp    $0xe,%eax
  806172:	77 1a                	ja     80618e <lwip_connect+0x111>
  806174:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  806178:	89 c2                	mov    %eax,%edx
  80617a:	f7 da                	neg    %edx
  80617c:	48 b8 80 13 82 00 00 	movabs $0x821380,%rax
  806183:	00 00 00 
  806186:	48 63 d2             	movslq %edx,%rdx
  806189:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  80618c:	eb 05                	jmp    806193 <lwip_connect+0x116>
  80618e:	b8 05 00 00 00       	mov    $0x5,%eax
  806193:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  806197:	89 42 18             	mov    %eax,0x18(%rdx)
  80619a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80619e:	8b 50 18             	mov    0x18(%rax),%edx
  8061a1:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  8061a8:	00 00 00 
  8061ab:	89 10                	mov    %edx,(%rax)
    return -1;
  8061ad:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8061b2:	eb 23                	jmp    8061d7 <lwip_connect+0x15a>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8061b4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8061b8:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8061bf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8061c3:	8b 50 18             	mov    0x18(%rax),%edx
  8061c6:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  8061cd:	00 00 00 
  8061d0:	89 10                	mov    %edx,(%rax)
  return 0;
  8061d2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8061d7:	c9                   	leaveq 
  8061d8:	c3                   	retq   

00000000008061d9 <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  8061d9:	55                   	push   %rbp
  8061da:	48 89 e5             	mov    %rsp,%rbp
  8061dd:	48 83 ec 20          	sub    $0x20,%rsp
  8061e1:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8061e4:	89 75 e8             	mov    %esi,-0x18(%rbp)
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  8061e7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8061ea:	89 c7                	mov    %eax,%edi
  8061ec:	48 b8 40 59 80 00 00 	movabs $0x805940,%rax
  8061f3:	00 00 00 
  8061f6:	ff d0                	callq  *%rax
  8061f8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  8061fc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806201:	75 0a                	jne    80620d <lwip_listen+0x34>
    return -1;
  806203:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806208:	e9 b2 00 00 00       	jmpq   8062bf <lwip_listen+0xe6>

  /* limit the "backlog" parameter to fit in an u8_t */
  if (backlog < 0) {
  80620d:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  806211:	79 07                	jns    80621a <lwip_listen+0x41>
    backlog = 0;
  806213:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
  }
  if (backlog > 0xff) {
  80621a:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%rbp)
  806221:	7e 07                	jle    80622a <lwip_listen+0x51>
    backlog = 0xff;
  806223:	c7 45 e8 ff 00 00 00 	movl   $0xff,-0x18(%rbp)
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  80622a:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80622d:	0f b6 d0             	movzbl %al,%edx
  806230:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806234:	48 8b 00             	mov    (%rax),%rax
  806237:	89 d6                	mov    %edx,%esi
  806239:	48 89 c7             	mov    %rax,%rdi
  80623c:	48 b8 ff 9a 81 00 00 	movabs $0x819aff,%rax
  806243:	00 00 00 
  806246:	ff d0                	callq  *%rax
  806248:	88 45 f7             	mov    %al,-0x9(%rbp)

  if (err != ERR_OK) {
  80624b:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80624f:	74 4b                	je     80629c <lwip_listen+0xc3>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  806251:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  806255:	f7 d8                	neg    %eax
  806257:	83 f8 0e             	cmp    $0xe,%eax
  80625a:	77 1a                	ja     806276 <lwip_listen+0x9d>
  80625c:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  806260:	89 c2                	mov    %eax,%edx
  806262:	f7 da                	neg    %edx
  806264:	48 b8 80 13 82 00 00 	movabs $0x821380,%rax
  80626b:	00 00 00 
  80626e:	48 63 d2             	movslq %edx,%rdx
  806271:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806274:	eb 05                	jmp    80627b <lwip_listen+0xa2>
  806276:	b8 05 00 00 00       	mov    $0x5,%eax
  80627b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80627f:	89 42 18             	mov    %eax,0x18(%rdx)
  806282:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806286:	8b 50 18             	mov    0x18(%rax),%edx
  806289:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  806290:	00 00 00 
  806293:	89 10                	mov    %edx,(%rax)
    return -1;
  806295:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80629a:	eb 23                	jmp    8062bf <lwip_listen+0xe6>
  }

  sock_set_errno(sock, 0);
  80629c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8062a0:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8062a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8062ab:	8b 50 18             	mov    0x18(%rax),%edx
  8062ae:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  8062b5:	00 00 00 
  8062b8:	89 10                	mov    %edx,(%rax)
  return 0;
  8062ba:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8062bf:	c9                   	leaveq 
  8062c0:	c3                   	retq   

00000000008062c1 <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  8062c1:	55                   	push   %rbp
  8062c2:	48 89 e5             	mov    %rsp,%rbp
  8062c5:	48 83 ec 70          	sub    $0x70,%rsp
  8062c9:	89 7d bc             	mov    %edi,-0x44(%rbp)
  8062cc:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8062d0:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8062d3:	89 4d ac             	mov    %ecx,-0x54(%rbp)
  8062d6:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  8062da:	4c 89 4d 98          	mov    %r9,-0x68(%rbp)
  struct lwip_socket *sock;
  struct netbuf      *buf;
  u16_t               buflen, copylen, off = 0;
  8062de:	66 c7 45 f4 00 00    	movw   $0x0,-0xc(%rbp)
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;
  8062e4:	c6 45 e7 00          	movb   $0x0,-0x19(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  8062e8:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8062eb:	89 c7                	mov    %eax,%edi
  8062ed:	48 b8 40 59 80 00 00 	movabs $0x805940,%rax
  8062f4:	00 00 00 
  8062f7:	ff d0                	callq  *%rax
  8062f9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (!sock)
  8062fd:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  806302:	75 0a                	jne    80630e <lwip_recvfrom+0x4d>
    return -1;
  806304:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806309:	e9 8d 03 00 00       	jmpq   80669b <lwip_recvfrom+0x3da>

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  80630e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806312:	48 8b 40 08          	mov    0x8(%rax),%rax
  806316:	48 85 c0             	test   %rax,%rax
  806319:	74 11                	je     80632c <lwip_recvfrom+0x6b>
      buf = sock->lastdata;
  80631b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80631f:	48 8b 40 08          	mov    0x8(%rax),%rax
  806323:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  806327:	e9 0c 01 00 00       	jmpq   806438 <lwip_recvfrom+0x177>
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  80632c:	8b 45 ac             	mov    -0x54(%rbp),%eax
  80632f:	83 e0 08             	and    $0x8,%eax
  806332:	85 c0                	test   %eax,%eax
  806334:	75 14                	jne    80634a <lwip_recvfrom+0x89>
  806336:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80633a:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80633e:	0f b7 c0             	movzwl %ax,%eax
  806341:	25 00 08 00 00       	and    $0x800,%eax
  806346:	85 c0                	test   %eax,%eax
  806348:	74 35                	je     80637f <lwip_recvfrom+0xbe>
  80634a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80634e:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  806352:	66 85 c0             	test   %ax,%ax
  806355:	75 28                	jne    80637f <lwip_recvfrom+0xbe>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  806357:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80635b:	c7 40 18 0b 00 00 00 	movl   $0xb,0x18(%rax)
  806362:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806366:	8b 50 18             	mov    0x18(%rax),%edx
  806369:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  806370:	00 00 00 
  806373:	89 10                	mov    %edx,(%rax)
        return -1;
  806375:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80637a:	e9 1c 03 00 00       	jmpq   80669b <lwip_recvfrom+0x3da>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  80637f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806383:	48 8b 00             	mov    (%rax),%rax
  806386:	48 89 c7             	mov    %rax,%rdi
  806389:	48 b8 36 9c 81 00 00 	movabs $0x819c36,%rax
  806390:	00 00 00 
  806393:	ff d0                	callq  *%rax
  806395:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  806399:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80639d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8063a1:	48 89 50 08          	mov    %rdx,0x8(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  8063a5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8063aa:	0f 85 88 00 00 00    	jne    806438 <lwip_recvfrom+0x177>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  8063b0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8063b4:	48 8b 00             	mov    (%rax),%rax
  8063b7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8063bb:	48 85 c0             	test   %rax,%rax
  8063be:	74 0f                	je     8063cf <lwip_recvfrom+0x10e>
  8063c0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8063c4:	48 8b 00             	mov    (%rax),%rax
  8063c7:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  8063cb:	84 c0                	test   %al,%al
  8063cd:	74 40                	je     80640f <lwip_recvfrom+0x14e>
  8063cf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8063d3:	48 8b 00             	mov    (%rax),%rax
  8063d6:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  8063da:	0f be c0             	movsbl %al,%eax
  8063dd:	f7 d8                	neg    %eax
  8063df:	83 f8 0e             	cmp    $0xe,%eax
  8063e2:	77 24                	ja     806408 <lwip_recvfrom+0x147>
  8063e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8063e8:	48 8b 00             	mov    (%rax),%rax
  8063eb:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  8063ef:	0f be c0             	movsbl %al,%eax
  8063f2:	89 c2                	mov    %eax,%edx
  8063f4:	f7 da                	neg    %edx
  8063f6:	48 b8 80 13 82 00 00 	movabs $0x821380,%rax
  8063fd:	00 00 00 
  806400:	48 63 d2             	movslq %edx,%rdx
  806403:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806406:	eb 05                	jmp    80640d <lwip_recvfrom+0x14c>
  806408:	b8 05 00 00 00       	mov    $0x5,%eax
  80640d:	eb 05                	jmp    806414 <lwip_recvfrom+0x153>
  80640f:	b8 6e 00 00 00       	mov    $0x6e,%eax
  806414:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  806418:	89 42 18             	mov    %eax,0x18(%rdx)
  80641b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80641f:	8b 50 18             	mov    0x18(%rax),%edx
  806422:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  806429:	00 00 00 
  80642c:	89 10                	mov    %edx,(%rax)
        return 0;
  80642e:	b8 00 00 00 00       	mov    $0x0,%eax
  806433:	e9 63 02 00 00       	jmpq   80669b <lwip_recvfrom+0x3da>
      }
    }

    buflen = netbuf_len(buf);
  806438:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80643c:	48 8b 00             	mov    (%rax),%rax
  80643f:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  806443:	66 89 45 d6          	mov    %ax,-0x2a(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  806447:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80644b:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80644f:	66 29 45 d6          	sub    %ax,-0x2a(%rbp)

    if (len > buflen) {
  806453:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
  806457:	3b 45 b8             	cmp    -0x48(%rbp),%eax
  80645a:	7d 0a                	jge    806466 <lwip_recvfrom+0x1a5>
      copylen = buflen;
  80645c:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
  806460:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  806464:	eb 07                	jmp    80646d <lwip_recvfrom+0x1ac>
    } else {
      copylen = len;
  806466:	8b 45 b8             	mov    -0x48(%rbp),%eax
  806469:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  80646d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806471:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  806475:	0f b7 c8             	movzwl %ax,%ecx
  806478:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80647c:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  806480:	48 89 c6             	mov    %rax,%rsi
  806483:	48 03 75 b0          	add    -0x50(%rbp),%rsi
  806487:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80648b:	48 8b 00             	mov    (%rax),%rax
  80648e:	48 89 c7             	mov    %rax,%rdi
  806491:	48 b8 4b e0 80 00 00 	movabs $0x80e04b,%rax
  806498:	00 00 00 
  80649b:	ff d0                	callq  *%rax

    off += copylen;
  80649d:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8064a1:	66 01 45 f4          	add    %ax,-0xc(%rbp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8064a5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8064a9:	48 8b 00             	mov    (%rax),%rax
  8064ac:	48 89 c7             	mov    %rax,%rdi
  8064af:	48 b8 40 98 81 00 00 	movabs $0x819840,%rax
  8064b6:	00 00 00 
  8064b9:	ff d0                	callq  *%rax
  8064bb:	83 f8 10             	cmp    $0x10,%eax
  8064be:	75 35                	jne    8064f5 <lwip_recvfrom+0x234>
      len -= copylen;
  8064c0:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8064c4:	29 45 b8             	sub    %eax,-0x48(%rbp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  8064c7:	83 7d b8 00          	cmpl   $0x0,-0x48(%rbp)
  8064cb:	7e 22                	jle    8064ef <lwip_recvfrom+0x22e>
  8064cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8064d1:	48 8b 00             	mov    (%rax),%rax
  8064d4:	0f b6 40 15          	movzbl 0x15(%rax),%eax
  8064d8:	0f b6 c0             	movzbl %al,%eax
  8064db:	83 e0 01             	and    $0x1,%eax
  8064de:	84 c0                	test   %al,%al
  8064e0:	75 0d                	jne    8064ef <lwip_recvfrom+0x22e>
  8064e2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8064e6:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8064ea:	66 85 c0             	test   %ax,%ax
  8064ed:	75 0a                	jne    8064f9 <lwip_recvfrom+0x238>
        done = 1;
  8064ef:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
  8064f3:	eb 04                	jmp    8064f9 <lwip_recvfrom+0x238>
      }
    } else {
      done = 1;
  8064f5:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  8064f9:	8b 45 ac             	mov    -0x54(%rbp),%eax
  8064fc:	83 e0 01             	and    $0x1,%eax
  8064ff:	85 c0                	test   %eax,%eax
  806501:	75 70                	jne    806573 <lwip_recvfrom+0x2b2>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  806503:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806507:	48 8b 00             	mov    (%rax),%rax
  80650a:	8b 00                	mov    (%rax),%eax
  80650c:	83 f8 10             	cmp    $0x10,%eax
  80650f:	75 37                	jne    806548 <lwip_recvfrom+0x287>
  806511:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
  806515:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  806519:	89 d1                	mov    %edx,%ecx
  80651b:	29 c1                	sub    %eax,%ecx
  80651d:	89 c8                	mov    %ecx,%eax
  80651f:	85 c0                	test   %eax,%eax
  806521:	7e 25                	jle    806548 <lwip_recvfrom+0x287>
        sock->lastdata = buf;
  806523:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806527:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80652b:	48 89 50 08          	mov    %rdx,0x8(%rax)
        sock->lastoffset += copylen;
  80652f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806533:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  806537:	89 c2                	mov    %eax,%edx
  806539:	66 03 55 f6          	add    -0xa(%rbp),%dx
  80653d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806541:	66 89 50 10          	mov    %dx,0x10(%rax)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  806545:	90                   	nop
  806546:	eb 2f                	jmp    806577 <lwip_recvfrom+0x2b6>
      } else {
        sock->lastdata = NULL;
  806548:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80654c:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  806553:	00 
        sock->lastoffset = 0;
  806554:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806558:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  80655e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806562:	48 89 c7             	mov    %rax,%rdi
  806565:	48 b8 9c 8a 80 00 00 	movabs $0x808a9c,%rax
  80656c:	00 00 00 
  80656f:	ff d0                	callq  *%rax
  806571:	eb 04                	jmp    806577 <lwip_recvfrom+0x2b6>
      }
    } else {
      done = 1;
  806573:	c6 45 e7 01          	movb   $0x1,-0x19(%rbp)
    }
  } while (!done);
  806577:	80 7d e7 00          	cmpb   $0x0,-0x19(%rbp)
  80657b:	0f 84 8d fd ff ff    	je     80630e <lwip_recvfrom+0x4d>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  806581:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  806586:	0f 84 ed 00 00 00    	je     806679 <lwip_recvfrom+0x3b8>
  80658c:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  806591:	0f 84 e2 00 00 00    	je     806679 <lwip_recvfrom+0x3b8>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  806597:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80659b:	48 8b 00             	mov    (%rax),%rax
  80659e:	48 89 c7             	mov    %rax,%rdi
  8065a1:	48 b8 40 98 81 00 00 	movabs $0x819840,%rax
  8065a8:	00 00 00 
  8065ab:	ff d0                	callq  *%rax
  8065ad:	83 f8 10             	cmp    $0x10,%eax
  8065b0:	75 31                	jne    8065e3 <lwip_recvfrom+0x322>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  8065b2:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8065b6:	48 83 c0 04          	add    $0x4,%rax
  8065ba:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      netconn_getaddr(sock->conn, addr, &port, 0);
  8065be:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8065c2:	48 8b 00             	mov    (%rax),%rax
  8065c5:	48 8d 55 d4          	lea    -0x2c(%rbp),%rdx
  8065c9:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8065cd:	b9 00 00 00 00       	mov    $0x0,%ecx
  8065d2:	48 89 c7             	mov    %rax,%rdi
  8065d5:	48 b8 85 98 81 00 00 	movabs $0x819885,%rax
  8065dc:	00 00 00 
  8065df:	ff d0                	callq  *%rax
  8065e1:	eb 18                	jmp    8065fb <lwip_recvfrom+0x33a>
    } else {
      addr = netbuf_fromaddr(buf);
  8065e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8065e7:	48 8b 40 10          	mov    0x10(%rax),%rax
  8065eb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      port = netbuf_fromport(buf);
  8065ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8065f3:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8065f7:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)
    }

    memset(&sin, 0, sizeof(sin));
  8065fb:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8065ff:	ba 10 00 00 00       	mov    $0x10,%edx
  806604:	be 00 00 00 00       	mov    $0x0,%esi
  806609:	48 89 c7             	mov    %rax,%rdi
  80660c:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  806613:	00 00 00 
  806616:	ff d0                	callq  *%rax
    sin.sin_len = sizeof(sin);
  806618:	c6 45 c0 10          	movb   $0x10,-0x40(%rbp)
    sin.sin_family = AF_INET;
  80661c:	c6 45 c1 02          	movb   $0x2,-0x3f(%rbp)
    sin.sin_port = htons(port);
  806620:	0f b7 45 d4          	movzwl -0x2c(%rbp),%eax
  806624:	0f b7 c0             	movzwl %ax,%eax
  806627:	89 c7                	mov    %eax,%edi
  806629:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  806630:	00 00 00 
  806633:	ff d0                	callq  *%rax
  806635:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
    sin.sin_addr.s_addr = addr->addr;
  806639:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80663d:	8b 00                	mov    (%rax),%eax
  80663f:	89 45 c4             	mov    %eax,-0x3c(%rbp)

    if (*fromlen > sizeof(sin))
  806642:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  806646:	8b 00                	mov    (%rax),%eax
  806648:	83 f8 10             	cmp    $0x10,%eax
  80664b:	76 0a                	jbe    806657 <lwip_recvfrom+0x396>
      *fromlen = sizeof(sin);
  80664d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  806651:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

    SMEMCPY(from, &sin, *fromlen);
  806657:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80665b:	8b 00                	mov    (%rax),%eax
  80665d:	89 c2                	mov    %eax,%edx
  80665f:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  806663:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806667:	48 89 ce             	mov    %rcx,%rsi
  80666a:	48 89 c7             	mov    %rax,%rdi
  80666d:	48 b8 fd 22 80 00 00 	movabs $0x8022fd,%rax
  806674:	00 00 00 
  806677:	ff d0                	callq  *%rax
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  806679:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80667d:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  806684:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  806688:	8b 50 18             	mov    0x18(%rax),%edx
  80668b:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  806692:	00 00 00 
  806695:	89 10                	mov    %edx,(%rax)
  return off;
  806697:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
}
  80669b:	c9                   	leaveq 
  80669c:	c3                   	retq   

000000000080669d <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
  80669d:	55                   	push   %rbp
  80669e:	48 89 e5             	mov    %rsp,%rbp
  8066a1:	48 83 ec 10          	sub    $0x10,%rsp
  8066a5:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8066a8:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8066ac:	89 55 f8             	mov    %edx,-0x8(%rbp)
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  8066af:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8066b2:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8066b6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8066b9:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8066bf:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8066c5:	b9 00 00 00 00       	mov    $0x0,%ecx
  8066ca:	89 c7                	mov    %eax,%edi
  8066cc:	48 b8 c1 62 80 00 00 	movabs $0x8062c1,%rax
  8066d3:	00 00 00 
  8066d6:	ff d0                	callq  *%rax
}
  8066d8:	c9                   	leaveq 
  8066d9:	c3                   	retq   

00000000008066da <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  8066da:	55                   	push   %rbp
  8066db:	48 89 e5             	mov    %rsp,%rbp
  8066de:	48 83 ec 20          	sub    $0x20,%rsp
  8066e2:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8066e5:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8066e9:	89 55 f8             	mov    %edx,-0x8(%rbp)
  8066ec:	89 4d ec             	mov    %ecx,-0x14(%rbp)
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  8066ef:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  8066f2:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8066f5:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8066f9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8066fc:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  806702:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  806708:	89 c7                	mov    %eax,%edi
  80670a:	48 b8 c1 62 80 00 00 	movabs $0x8062c1,%rax
  806711:	00 00 00 
  806714:	ff d0                	callq  *%rax
}
  806716:	c9                   	leaveq 
  806717:	c3                   	retq   

0000000000806718 <lwip_send>:

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  806718:	55                   	push   %rbp
  806719:	48 89 e5             	mov    %rsp,%rbp
  80671c:	48 83 ec 30          	sub    $0x30,%rsp
  806720:	89 7d ec             	mov    %edi,-0x14(%rbp)
  806723:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  806727:	89 55 e8             	mov    %edx,-0x18(%rbp)
  80672a:	89 4d dc             	mov    %ecx,-0x24(%rbp)
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  80672d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806730:	89 c7                	mov    %eax,%edi
  806732:	48 b8 40 59 80 00 00 	movabs $0x805940,%rax
  806739:	00 00 00 
  80673c:	ff d0                	callq  *%rax
  80673e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  806742:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806747:	75 0a                	jne    806753 <lwip_send+0x3b>
    return -1;
  806749:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80674e:	e9 c3 00 00 00       	jmpq   806816 <lwip_send+0xfe>

  if (sock->conn->type!=NETCONN_TCP) {
  806753:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806757:	48 8b 00             	mov    (%rax),%rax
  80675a:	8b 00                	mov    (%rax),%eax
  80675c:	83 f8 10             	cmp    $0x10,%eax
  80675f:	74 2c                	je     80678d <lwip_send+0x75>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  806761:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  806764:	8b 55 e8             	mov    -0x18(%rbp),%edx
  806767:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  80676b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80676e:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  806774:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80677a:	89 c7                	mov    %eax,%edi
  80677c:	48 b8 18 68 80 00 00 	movabs $0x806818,%rax
  806783:	00 00 00 
  806786:	ff d0                	callq  *%rax
  806788:	e9 89 00 00 00       	jmpq   806816 <lwip_send+0xfe>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  80678d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  806790:	83 e0 10             	and    $0x10,%eax
  806793:	85 c0                	test   %eax,%eax
  806795:	74 07                	je     80679e <lwip_send+0x86>
  806797:	b8 03 00 00 00       	mov    $0x3,%eax
  80679c:	eb 05                	jmp    8067a3 <lwip_send+0x8b>
  80679e:	b8 01 00 00 00       	mov    $0x1,%eax
  8067a3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8067a7:	48 8b 3a             	mov    (%rdx),%rdi
  8067aa:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8067ad:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8067b1:	89 c1                	mov    %eax,%ecx
  8067b3:	48 b8 95 9f 81 00 00 	movabs $0x819f95,%rax
  8067ba:	00 00 00 
  8067bd:	ff d0                	callq  *%rax
  8067bf:	88 45 f7             	mov    %al,-0x9(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  8067c2:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  8067c6:	f7 d8                	neg    %eax
  8067c8:	83 f8 0e             	cmp    $0xe,%eax
  8067cb:	77 1a                	ja     8067e7 <lwip_send+0xcf>
  8067cd:	0f be 45 f7          	movsbl -0x9(%rbp),%eax
  8067d1:	89 c2                	mov    %eax,%edx
  8067d3:	f7 da                	neg    %edx
  8067d5:	48 b8 80 13 82 00 00 	movabs $0x821380,%rax
  8067dc:	00 00 00 
  8067df:	48 63 d2             	movslq %edx,%rdx
  8067e2:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  8067e5:	eb 05                	jmp    8067ec <lwip_send+0xd4>
  8067e7:	b8 05 00 00 00       	mov    $0x5,%eax
  8067ec:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8067f0:	89 42 18             	mov    %eax,0x18(%rdx)
  8067f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8067f7:	8b 50 18             	mov    0x18(%rax),%edx
  8067fa:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  806801:	00 00 00 
  806804:	89 10                	mov    %edx,(%rax)
  return (err==ERR_OK?size:-1);
  806806:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80680a:	75 05                	jne    806811 <lwip_send+0xf9>
  80680c:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80680f:	eb 05                	jmp    806816 <lwip_send+0xfe>
  806811:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  806816:	c9                   	leaveq 
  806817:	c3                   	retq   

0000000000806818 <lwip_sendto>:

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  806818:	55                   	push   %rbp
  806819:	48 89 e5             	mov    %rsp,%rbp
  80681c:	48 83 ec 60          	sub    $0x60,%rsp
  806820:	89 7d bc             	mov    %edi,-0x44(%rbp)
  806823:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  806827:	89 55 b8             	mov    %edx,-0x48(%rbp)
  80682a:	89 4d ac             	mov    %ecx,-0x54(%rbp)
  80682d:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  806831:	44 89 4d a8          	mov    %r9d,-0x58(%rbp)
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  806835:	8b 45 bc             	mov    -0x44(%rbp),%eax
  806838:	89 c7                	mov    %eax,%edi
  80683a:	48 b8 40 59 80 00 00 	movabs $0x805940,%rax
  806841:	00 00 00 
  806844:	ff d0                	callq  *%rax
  806846:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (!sock)
  80684a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80684f:	75 0a                	jne    80685b <lwip_sendto+0x43>
    return -1;
  806851:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806856:	e9 d8 01 00 00       	jmpq   806a33 <lwip_sendto+0x21b>

  if (sock->conn->type==NETCONN_TCP) {
  80685b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80685f:	48 8b 00             	mov    (%rax),%rax
  806862:	8b 00                	mov    (%rax),%eax
  806864:	83 f8 10             	cmp    $0x10,%eax
  806867:	75 20                	jne    806889 <lwip_sendto+0x71>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  806869:	8b 4d ac             	mov    -0x54(%rbp),%ecx
  80686c:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80686f:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  806873:	8b 45 bc             	mov    -0x44(%rbp),%eax
  806876:	89 c7                	mov    %eax,%edi
  806878:	48 b8 18 67 80 00 00 	movabs $0x806718,%rax
  80687f:	00 00 00 
  806882:	ff d0                	callq  *%rax
  806884:	e9 aa 01 00 00       	jmpq   806a33 <lwip_sendto+0x21b>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  806889:	83 7d b8 00          	cmpl   $0x0,-0x48(%rbp)
  80688d:	78 09                	js     806898 <lwip_sendto+0x80>
  80688f:	81 7d b8 ff ff 00 00 	cmpl   $0xffff,-0x48(%rbp)
  806896:	7e 2a                	jle    8068c2 <lwip_sendto+0xaa>
  806898:	48 ba 38 14 82 00 00 	movabs $0x821438,%rdx
  80689f:	00 00 00 
  8068a2:	be 97 02 00 00       	mov    $0x297,%esi
  8068a7:	48 bf d1 13 82 00 00 	movabs $0x8213d1,%rdi
  8068ae:	00 00 00 
  8068b1:	b8 00 00 00 00       	mov    $0x0,%eax
  8068b6:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8068bd:	00 00 00 
  8068c0:	ff d1                	callq  *%rcx
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  8068c2:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8068c7:	75 06                	jne    8068cf <lwip_sendto+0xb7>
  8068c9:	83 7d a8 00          	cmpl   $0x0,-0x58(%rbp)
  8068cd:	74 3c                	je     80690b <lwip_sendto+0xf3>
  8068cf:	83 7d a8 10          	cmpl   $0x10,-0x58(%rbp)
  8068d3:	75 0c                	jne    8068e1 <lwip_sendto+0xc9>
  8068d5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8068d9:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8068dd:	3c 02                	cmp    $0x2,%al
  8068df:	74 2a                	je     80690b <lwip_sendto+0xf3>
  8068e1:	48 ba 5c 14 82 00 00 	movabs $0x82145c,%rdx
  8068e8:	00 00 00 
  8068eb:	be 9b 02 00 00       	mov    $0x29b,%esi
  8068f0:	48 bf d1 13 82 00 00 	movabs $0x8213d1,%rdi
  8068f7:	00 00 00 
  8068fa:	b8 00 00 00 00       	mov    $0x0,%eax
  8068ff:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  806906:	00 00 00 
  806909:	ff d1                	callq  *%rcx
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  80690b:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  806912:	00 
  806913:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  806917:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  if (to) {
  80691b:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  806920:	74 39                	je     80695b <lwip_sendto+0x143>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  806922:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806926:	8b 40 04             	mov    0x4(%rax),%eax
  806929:	89 45 e0             	mov    %eax,-0x20(%rbp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  80692c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806930:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  806934:	0f b7 c0             	movzwl %ax,%eax
  806937:	89 c7                	mov    %eax,%edi
  806939:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  806940:	00 00 00 
  806943:	ff d0                	callq  *%rax
  806945:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    buf.addr         = &remote_addr;
  806949:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  80694d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    buf.port         = remote_port;
  806951:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  806955:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  806959:	eb 1b                	jmp    806976 <lwip_sendto+0x15e>
  } else {
    remote_addr.addr = 0;
  80695b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
    remote_port      = 0;
  806962:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
    buf.addr         = NULL;
  806968:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  80696f:	00 
    buf.port         = 0;
  806970:	66 c7 45 d8 00 00    	movw   $0x0,-0x28(%rbp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  806976:	8b 45 b8             	mov    -0x48(%rbp),%eax
  806979:	0f b7 d0             	movzwl %ax,%edx
  80697c:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  806980:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  806984:	48 89 ce             	mov    %rcx,%rsi
  806987:	48 89 c7             	mov    %rax,%rdi
  80698a:	48 b8 74 8c 80 00 00 	movabs $0x808c74,%rax
  806991:	00 00 00 
  806994:	ff d0                	callq  *%rax
  806996:	0f be c0             	movsbl %al,%eax
  806999:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80699c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8069a0:	75 23                	jne    8069c5 <lwip_sendto+0x1ad>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  8069a2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8069a6:	48 8b 00             	mov    (%rax),%rax
  8069a9:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  8069ad:	48 89 d6             	mov    %rdx,%rsi
  8069b0:	48 89 c7             	mov    %rax,%rdi
  8069b3:	48 b8 19 9f 81 00 00 	movabs $0x819f19,%rax
  8069ba:	00 00 00 
  8069bd:	ff d0                	callq  *%rax
  8069bf:	0f be c0             	movsbl %al,%eax
  8069c2:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  8069c5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8069c9:	48 85 c0             	test   %rax,%rax
  8069cc:	74 13                	je     8069e1 <lwip_sendto+0x1c9>
    pbuf_free(buf.p);
  8069ce:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8069d2:	48 89 c7             	mov    %rax,%rdi
  8069d5:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  8069dc:	00 00 00 
  8069df:	ff d0                	callq  *%rax
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  8069e1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8069e4:	f7 d8                	neg    %eax
  8069e6:	83 f8 0e             	cmp    $0xe,%eax
  8069e9:	77 19                	ja     806a04 <lwip_sendto+0x1ec>
  8069eb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8069ee:	89 c2                	mov    %eax,%edx
  8069f0:	f7 da                	neg    %edx
  8069f2:	48 b8 80 13 82 00 00 	movabs $0x821380,%rax
  8069f9:	00 00 00 
  8069fc:	48 63 d2             	movslq %edx,%rdx
  8069ff:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  806a02:	eb 05                	jmp    806a09 <lwip_sendto+0x1f1>
  806a04:	b8 05 00 00 00       	mov    $0x5,%eax
  806a09:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  806a0d:	89 42 18             	mov    %eax,0x18(%rdx)
  806a10:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  806a14:	8b 50 18             	mov    0x18(%rax),%edx
  806a17:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  806a1e:	00 00 00 
  806a21:	89 10                	mov    %edx,(%rax)
  return (err==ERR_OK?size:-1);
  806a23:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  806a27:	75 05                	jne    806a2e <lwip_sendto+0x216>
  806a29:	8b 45 b8             	mov    -0x48(%rbp),%eax
  806a2c:	eb 05                	jmp    806a33 <lwip_sendto+0x21b>
  806a2e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  806a33:	c9                   	leaveq 
  806a34:	c3                   	retq   

0000000000806a35 <lwip_socket>:

int
lwip_socket(int domain, int type, int protocol)
{
  806a35:	55                   	push   %rbp
  806a36:	48 89 e5             	mov    %rsp,%rbp
  806a39:	48 83 ec 20          	sub    $0x20,%rsp
  806a3d:	89 7d ec             	mov    %edi,-0x14(%rbp)
  806a40:	89 75 e8             	mov    %esi,-0x18(%rbp)
  806a43:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  806a46:	8b 45 e8             	mov    -0x18(%rbp),%eax
  806a49:	83 f8 02             	cmp    $0x2,%eax
  806a4c:	74 38                	je     806a86 <lwip_socket+0x51>
  806a4e:	83 f8 03             	cmp    $0x3,%eax
  806a51:	74 0a                	je     806a5d <lwip_socket+0x28>
  806a53:	83 f8 01             	cmp    $0x1,%eax
  806a56:	74 66                	je     806abe <lwip_socket+0x89>
  806a58:	e9 87 00 00 00       	jmpq   806ae4 <lwip_socket+0xaf>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  806a5d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  806a60:	0f b6 c0             	movzbl %al,%eax
  806a63:	48 ba 02 73 80 00 00 	movabs $0x807302,%rdx
  806a6a:	00 00 00 
  806a6d:	89 c6                	mov    %eax,%esi
  806a6f:	bf 40 00 00 00       	mov    $0x40,%edi
  806a74:	48 b8 34 96 81 00 00 	movabs $0x819634,%rax
  806a7b:	00 00 00 
  806a7e:	ff d0                	callq  *%rax
  806a80:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  806a84:	eb 78                	jmp    806afe <lwip_socket+0xc9>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  806a86:	81 7d e4 88 00 00 00 	cmpl   $0x88,-0x1c(%rbp)
  806a8d:	75 07                	jne    806a96 <lwip_socket+0x61>
  806a8f:	b8 21 00 00 00       	mov    $0x21,%eax
  806a94:	eb 05                	jmp    806a9b <lwip_socket+0x66>
  806a96:	b8 20 00 00 00       	mov    $0x20,%eax
  806a9b:	48 ba 02 73 80 00 00 	movabs $0x807302,%rdx
  806aa2:	00 00 00 
  806aa5:	be 00 00 00 00       	mov    $0x0,%esi
  806aaa:	89 c7                	mov    %eax,%edi
  806aac:	48 b8 34 96 81 00 00 	movabs $0x819634,%rax
  806ab3:	00 00 00 
  806ab6:	ff d0                	callq  *%rax
  806ab8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  806abc:	eb 40                	jmp    806afe <lwip_socket+0xc9>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  806abe:	48 ba 02 73 80 00 00 	movabs $0x807302,%rdx
  806ac5:	00 00 00 
  806ac8:	be 00 00 00 00       	mov    $0x0,%esi
  806acd:	bf 10 00 00 00       	mov    $0x10,%edi
  806ad2:	48 b8 34 96 81 00 00 	movabs $0x819634,%rax
  806ad9:	00 00 00 
  806adc:	ff d0                	callq  *%rax
  806ade:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  806ae2:	eb 1a                	jmp    806afe <lwip_socket+0xc9>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  806ae4:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  806aeb:	00 00 00 
  806aee:	c7 00 16 00 00 00    	movl   $0x16,(%rax)
    return -1;
  806af4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806af9:	e9 81 00 00 00       	jmpq   806b7f <lwip_socket+0x14a>
  }

  if (!conn) {
  806afe:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  806b03:	75 17                	jne    806b1c <lwip_socket+0xe7>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  806b05:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  806b0c:	00 00 00 
  806b0f:	c7 00 69 00 00 00    	movl   $0x69,(%rax)
    return -1;
  806b15:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806b1a:	eb 63                	jmp    806b7f <lwip_socket+0x14a>
  }

  i = alloc_socket(conn);
  806b1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806b20:	48 89 c7             	mov    %rax,%rdi
  806b23:	48 b8 b4 59 80 00 00 	movabs $0x8059b4,%rax
  806b2a:	00 00 00 
  806b2d:	ff d0                	callq  *%rax
  806b2f:	89 45 f4             	mov    %eax,-0xc(%rbp)

  if (i == -1) {
  806b32:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%rbp)
  806b36:	75 2a                	jne    806b62 <lwip_socket+0x12d>
    netconn_delete(conn);
  806b38:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806b3c:	48 89 c7             	mov    %rax,%rdi
  806b3f:	48 b8 d7 97 81 00 00 	movabs $0x8197d7,%rax
  806b46:	00 00 00 
  806b49:	ff d0                	callq  *%rax
    set_errno(ENFILE);
  806b4b:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  806b52:	00 00 00 
  806b55:	c7 00 17 00 00 00    	movl   $0x17,(%rax)
    return -1;
  806b5b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806b60:	eb 1d                	jmp    806b7f <lwip_socket+0x14a>
  }
  conn->socket = i;
  806b62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  806b66:	8b 55 f4             	mov    -0xc(%rbp),%edx
  806b69:	89 50 20             	mov    %edx,0x20(%rax)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  806b6c:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  806b73:	00 00 00 
  806b76:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  return i;
  806b7c:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  806b7f:	c9                   	leaveq 
  806b80:	c3                   	retq   

0000000000806b81 <lwip_write>:

int
lwip_write(int s, const void *data, int size)
{
  806b81:	55                   	push   %rbp
  806b82:	48 89 e5             	mov    %rsp,%rbp
  806b85:	48 83 ec 10          	sub    $0x10,%rsp
  806b89:	89 7d fc             	mov    %edi,-0x4(%rbp)
  806b8c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  806b90:	89 55 f8             	mov    %edx,-0x8(%rbp)
  return lwip_send(s, data, size, 0);
  806b93:	8b 55 f8             	mov    -0x8(%rbp),%edx
  806b96:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  806b9a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  806b9d:	b9 00 00 00 00       	mov    $0x0,%ecx
  806ba2:	89 c7                	mov    %eax,%edi
  806ba4:	48 b8 18 67 80 00 00 	movabs $0x806718,%rax
  806bab:	00 00 00 
  806bae:	ff d0                	callq  *%rax
}
  806bb0:	c9                   	leaveq 
  806bb1:	c3                   	retq   

0000000000806bb2 <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  806bb2:	55                   	push   %rbp
  806bb3:	48 89 e5             	mov    %rsp,%rbp
  806bb6:	53                   	push   %rbx
  806bb7:	48 83 ec 68          	sub    $0x68,%rsp
  806bbb:	89 7d ac             	mov    %edi,-0x54(%rbp)
  806bbe:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  806bc2:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  806bc6:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
  int i, nready = 0;
  806bca:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  806bd1:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  806bd5:	ba 04 00 00 00       	mov    $0x4,%edx
  806bda:	be 00 00 00 00       	mov    $0x0,%esi
  806bdf:	48 89 c7             	mov    %rax,%rdi
  806be2:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  806be9:	00 00 00 
  806bec:	ff d0                	callq  *%rax
  FD_ZERO(&lwriteset);
  806bee:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  806bf2:	ba 04 00 00 00       	mov    $0x4,%edx
  806bf7:	be 00 00 00 00       	mov    $0x0,%esi
  806bfc:	48 89 c7             	mov    %rax,%rdi
  806bff:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  806c06:	00 00 00 
  806c09:	ff d0                	callq  *%rax
  FD_ZERO(&lexceptset);
  806c0b:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  806c0f:	ba 04 00 00 00       	mov    $0x4,%edx
  806c14:	be 00 00 00 00       	mov    $0x0,%esi
  806c19:	48 89 c7             	mov    %rax,%rdi
  806c1c:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  806c23:	00 00 00 
  806c26:	ff d0                	callq  *%rax
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  806c28:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  806c2f:	e9 31 01 00 00       	jmpq   806d65 <lwip_selscan+0x1b3>
    if (FD_ISSET(i, readset)) {
  806c34:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806c37:	8d 50 07             	lea    0x7(%rax),%edx
  806c3a:	85 c0                	test   %eax,%eax
  806c3c:	0f 48 c2             	cmovs  %edx,%eax
  806c3f:	c1 f8 03             	sar    $0x3,%eax
  806c42:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  806c46:	48 98                	cltq   
  806c48:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  806c4c:	0f b6 d0             	movzbl %al,%edx
  806c4f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806c52:	83 e0 07             	and    $0x7,%eax
  806c55:	89 d3                	mov    %edx,%ebx
  806c57:	89 c1                	mov    %eax,%ecx
  806c59:	d3 fb                	sar    %cl,%ebx
  806c5b:	89 d8                	mov    %ebx,%eax
  806c5d:	83 e0 01             	and    $0x1,%eax
  806c60:	84 c0                	test   %al,%al
  806c62:	74 6d                	je     806cd1 <lwip_selscan+0x11f>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  806c64:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806c67:	89 c7                	mov    %eax,%edi
  806c69:	48 b8 40 59 80 00 00 	movabs $0x805940,%rax
  806c70:	00 00 00 
  806c73:	ff d0                	callq  *%rax
  806c75:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  806c79:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  806c7e:	74 51                	je     806cd1 <lwip_selscan+0x11f>
  806c80:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  806c84:	48 8b 40 08          	mov    0x8(%rax),%rax
  806c88:	48 85 c0             	test   %rax,%rax
  806c8b:	75 0d                	jne    806c9a <lwip_selscan+0xe8>
  806c8d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  806c91:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  806c95:	66 85 c0             	test   %ax,%ax
  806c98:	74 37                	je     806cd1 <lwip_selscan+0x11f>
        FD_SET(i, &lreadset);
  806c9a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806c9d:	8d 50 07             	lea    0x7(%rax),%edx
  806ca0:	85 c0                	test   %eax,%eax
  806ca2:	0f 48 c2             	cmovs  %edx,%eax
  806ca5:	c1 f8 03             	sar    $0x3,%eax
  806ca8:	48 63 d0             	movslq %eax,%rdx
  806cab:	0f b6 54 15 d0       	movzbl -0x30(%rbp,%rdx,1),%edx
  806cb0:	89 d6                	mov    %edx,%esi
  806cb2:	8b 55 ec             	mov    -0x14(%rbp),%edx
  806cb5:	83 e2 07             	and    $0x7,%edx
  806cb8:	bf 01 00 00 00       	mov    $0x1,%edi
  806cbd:	89 fb                	mov    %edi,%ebx
  806cbf:	89 d1                	mov    %edx,%ecx
  806cc1:	d3 e3                	shl    %cl,%ebx
  806cc3:	89 da                	mov    %ebx,%edx
  806cc5:	09 f2                	or     %esi,%edx
  806cc7:	48 98                	cltq   
  806cc9:	88 54 05 d0          	mov    %dl,-0x30(%rbp,%rax,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  806ccd:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  806cd1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806cd4:	8d 50 07             	lea    0x7(%rax),%edx
  806cd7:	85 c0                	test   %eax,%eax
  806cd9:	0f 48 c2             	cmovs  %edx,%eax
  806cdc:	c1 f8 03             	sar    $0x3,%eax
  806cdf:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  806ce3:	48 98                	cltq   
  806ce5:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  806ce9:	0f b6 d0             	movzbl %al,%edx
  806cec:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806cef:	83 e0 07             	and    $0x7,%eax
  806cf2:	89 d3                	mov    %edx,%ebx
  806cf4:	89 c1                	mov    %eax,%ecx
  806cf6:	d3 fb                	sar    %cl,%ebx
  806cf8:	89 d8                	mov    %ebx,%eax
  806cfa:	83 e0 01             	and    $0x1,%eax
  806cfd:	84 c0                	test   %al,%al
  806cff:	74 60                	je     806d61 <lwip_selscan+0x1af>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  806d01:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806d04:	89 c7                	mov    %eax,%edi
  806d06:	48 b8 40 59 80 00 00 	movabs $0x805940,%rax
  806d0d:	00 00 00 
  806d10:	ff d0                	callq  *%rax
  806d12:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      if (p_sock && p_sock->sendevent) {
  806d16:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  806d1b:	74 44                	je     806d61 <lwip_selscan+0x1af>
  806d1d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  806d21:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  806d25:	66 85 c0             	test   %ax,%ax
  806d28:	74 37                	je     806d61 <lwip_selscan+0x1af>
        FD_SET(i, &lwriteset);
  806d2a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806d2d:	8d 50 07             	lea    0x7(%rax),%edx
  806d30:	85 c0                	test   %eax,%eax
  806d32:	0f 48 c2             	cmovs  %edx,%eax
  806d35:	c1 f8 03             	sar    $0x3,%eax
  806d38:	48 63 d0             	movslq %eax,%rdx
  806d3b:	0f b6 54 15 c0       	movzbl -0x40(%rbp,%rdx,1),%edx
  806d40:	89 d6                	mov    %edx,%esi
  806d42:	8b 55 ec             	mov    -0x14(%rbp),%edx
  806d45:	83 e2 07             	and    $0x7,%edx
  806d48:	bf 01 00 00 00       	mov    $0x1,%edi
  806d4d:	89 fb                	mov    %edi,%ebx
  806d4f:	89 d1                	mov    %edx,%ecx
  806d51:	d3 e3                	shl    %cl,%ebx
  806d53:	89 da                	mov    %ebx,%edx
  806d55:	09 f2                	or     %esi,%edx
  806d57:	48 98                	cltq   
  806d59:	88 54 05 c0          	mov    %dl,-0x40(%rbp,%rax,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  806d5d:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  806d61:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  806d65:	8b 45 ec             	mov    -0x14(%rbp),%eax
  806d68:	3b 45 ac             	cmp    -0x54(%rbp),%eax
  806d6b:	0f 8c c3 fe ff ff    	jl     806c34 <lwip_selscan+0x82>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  806d71:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  806d75:	8b 55 d0             	mov    -0x30(%rbp),%edx
  806d78:	89 10                	mov    %edx,(%rax)
  *writeset = lwriteset;
  806d7a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  806d7e:	8b 55 c0             	mov    -0x40(%rbp),%edx
  806d81:	89 10                	mov    %edx,(%rax)
  FD_ZERO(exceptset);
  806d83:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  806d87:	ba 04 00 00 00       	mov    $0x4,%edx
  806d8c:	be 00 00 00 00       	mov    $0x0,%esi
  806d91:	48 89 c7             	mov    %rax,%rdi
  806d94:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  806d9b:	00 00 00 
  806d9e:	ff d0                	callq  *%rax
  
  return nready;
  806da0:	8b 45 e8             	mov    -0x18(%rbp),%eax
}
  806da3:	48 83 c4 68          	add    $0x68,%rsp
  806da7:	5b                   	pop    %rbx
  806da8:	5d                   	pop    %rbp
  806da9:	c3                   	retq   

0000000000806daa <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  806daa:	55                   	push   %rbp
  806dab:	48 89 e5             	mov    %rsp,%rbp
  806dae:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  806db5:	89 7d 8c             	mov    %edi,-0x74(%rbp)
  806db8:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
  806dbc:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  806dc3:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
  806dca:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  806dd1:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  806dd8:	00 
  select_cb.readset = readset;
  806dd9:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  806ddd:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  select_cb.writeset = writeset;
  806de1:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  806de8:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  select_cb.exceptset = exceptset;
  806dec:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  806df3:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  select_cb.sem_signalled = 0;
  806df7:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  806dfe:	48 b8 0c 95 82 00 00 	movabs $0x82950c,%rax
  806e05:	00 00 00 
  806e08:	8b 00                	mov    (%rax),%eax
  806e0a:	89 c7                	mov    %eax,%edi
  806e0c:	48 b8 e8 e2 80 00 00 	movabs $0x80e2e8,%rax
  806e13:	00 00 00 
  806e16:	ff d0                	callq  *%rax

  if (readset)
  806e18:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  806e1d:	74 0b                	je     806e2a <lwip_select+0x80>
    lreadset = *readset;
  806e1f:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  806e23:	8b 00                	mov    (%rax),%eax
  806e25:	89 45 e0             	mov    %eax,-0x20(%rbp)
  806e28:	eb 1d                	jmp    806e47 <lwip_select+0x9d>
  else
    FD_ZERO(&lreadset);
  806e2a:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  806e2e:	ba 04 00 00 00       	mov    $0x4,%edx
  806e33:	be 00 00 00 00       	mov    $0x0,%esi
  806e38:	48 89 c7             	mov    %rax,%rdi
  806e3b:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  806e42:	00 00 00 
  806e45:	ff d0                	callq  *%rax
  if (writeset)
  806e47:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  806e4e:	00 
  806e4f:	74 0e                	je     806e5f <lwip_select+0xb5>
    lwriteset = *writeset;
  806e51:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  806e58:	8b 00                	mov    (%rax),%eax
  806e5a:	89 45 d0             	mov    %eax,-0x30(%rbp)
  806e5d:	eb 1d                	jmp    806e7c <lwip_select+0xd2>
  else
    FD_ZERO(&lwriteset);
  806e5f:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  806e63:	ba 04 00 00 00       	mov    $0x4,%edx
  806e68:	be 00 00 00 00       	mov    $0x0,%esi
  806e6d:	48 89 c7             	mov    %rax,%rdi
  806e70:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  806e77:	00 00 00 
  806e7a:	ff d0                	callq  *%rax
  if (exceptset)
  806e7c:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  806e83:	00 
  806e84:	74 0e                	je     806e94 <lwip_select+0xea>
    lexceptset = *exceptset;
  806e86:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  806e8d:	8b 00                	mov    (%rax),%eax
  806e8f:	89 45 c0             	mov    %eax,-0x40(%rbp)
  806e92:	eb 1d                	jmp    806eb1 <lwip_select+0x107>
  else
    FD_ZERO(&lexceptset);
  806e94:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  806e98:	ba 04 00 00 00       	mov    $0x4,%edx
  806e9d:	be 00 00 00 00       	mov    $0x0,%esi
  806ea2:	48 89 c7             	mov    %rax,%rdi
  806ea5:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  806eac:	00 00 00 
  806eaf:	ff d0                	callq  *%rax

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  806eb1:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  806eb5:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  806eb9:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  806ebd:	8b 45 8c             	mov    -0x74(%rbp),%eax
  806ec0:	89 c7                	mov    %eax,%edi
  806ec2:	48 b8 b2 6b 80 00 00 	movabs $0x806bb2,%rax
  806ec9:	00 00 00 
  806ecc:	ff d0                	callq  *%rax
  806ece:	89 45 fc             	mov    %eax,-0x4(%rbp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  806ed1:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  806ed5:	0f 85 bc 03 00 00    	jne    807297 <lwip_select+0x4ed>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  806edb:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  806ee2:	00 
  806ee3:	0f 84 d3 00 00 00    	je     806fbc <lwip_select+0x212>
  806ee9:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  806ef0:	48 8b 00             	mov    (%rax),%rax
  806ef3:	48 85 c0             	test   %rax,%rax
  806ef6:	0f 85 c0 00 00 00    	jne    806fbc <lwip_select+0x212>
  806efc:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  806f03:	48 8b 40 08          	mov    0x8(%rax),%rax
  806f07:	48 85 c0             	test   %rax,%rax
  806f0a:	0f 85 ac 00 00 00    	jne    806fbc <lwip_select+0x212>
      sys_sem_signal(selectsem);
  806f10:	48 b8 0c 95 82 00 00 	movabs $0x82950c,%rax
  806f17:	00 00 00 
  806f1a:	8b 00                	mov    (%rax),%eax
  806f1c:	89 c7                	mov    %eax,%edi
  806f1e:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  806f25:	00 00 00 
  806f28:	ff d0                	callq  *%rax
      if (readset)
  806f2a:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  806f2f:	74 1d                	je     806f4e <lwip_select+0x1a4>
        FD_ZERO(readset);
  806f31:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  806f35:	ba 04 00 00 00       	mov    $0x4,%edx
  806f3a:	be 00 00 00 00       	mov    $0x0,%esi
  806f3f:	48 89 c7             	mov    %rax,%rdi
  806f42:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  806f49:	00 00 00 
  806f4c:	ff d0                	callq  *%rax
      if (writeset)
  806f4e:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  806f55:	00 
  806f56:	74 20                	je     806f78 <lwip_select+0x1ce>
        FD_ZERO(writeset);
  806f58:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  806f5f:	ba 04 00 00 00       	mov    $0x4,%edx
  806f64:	be 00 00 00 00       	mov    $0x0,%esi
  806f69:	48 89 c7             	mov    %rax,%rdi
  806f6c:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  806f73:	00 00 00 
  806f76:	ff d0                	callq  *%rax
      if (exceptset)
  806f78:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  806f7f:	00 
  806f80:	74 20                	je     806fa2 <lwip_select+0x1f8>
        FD_ZERO(exceptset);
  806f82:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  806f89:	ba 04 00 00 00       	mov    $0x4,%edx
  806f8e:	be 00 00 00 00       	mov    $0x0,%esi
  806f93:	48 89 c7             	mov    %rax,%rdi
  806f96:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  806f9d:	00 00 00 
  806fa0:	ff d0                	callq  *%rax
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  806fa2:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  806fa9:	00 00 00 
  806fac:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
      return 0;
  806fb2:	b8 00 00 00 00       	mov    $0x0,%eax
  806fb7:	e9 44 03 00 00       	jmpq   807300 <lwip_select+0x556>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  806fbc:	bf 00 00 00 00       	mov    $0x0,%edi
  806fc1:	48 b8 e2 79 81 00 00 	movabs $0x8179e2,%rax
  806fc8:	00 00 00 
  806fcb:	ff d0                	callq  *%rax
  806fcd:	89 45 b4             	mov    %eax,-0x4c(%rbp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  806fd0:	48 b8 00 95 82 00 00 	movabs $0x829500,%rax
  806fd7:	00 00 00 
  806fda:	48 8b 00             	mov    (%rax),%rax
  806fdd:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    select_cb_list = &select_cb;
  806fe1:	48 b8 00 95 82 00 00 	movabs $0x829500,%rax
  806fe8:	00 00 00 
  806feb:	48 8d 55 90          	lea    -0x70(%rbp),%rdx
  806fef:	48 89 10             	mov    %rdx,(%rax)
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  806ff2:	48 b8 0c 95 82 00 00 	movabs $0x82950c,%rax
  806ff9:	00 00 00 
  806ffc:	8b 00                	mov    (%rax),%eax
  806ffe:	89 c7                	mov    %eax,%edi
  807000:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  807007:	00 00 00 
  80700a:	ff d0                	callq  *%rax
    
    /* Now just wait to be woken */
    if (timeout == 0)
  80700c:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  807013:	00 
  807014:	75 09                	jne    80701f <lwip_select+0x275>
      /* Wait forever */
      msectimeout = 0;
  807016:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  80701d:	eb 58                	jmp    807077 <lwip_select+0x2cd>
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  80701f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  807026:	48 8b 00             	mov    (%rax),%rax
  807029:	69 f0 e8 03 00 00    	imul   $0x3e8,%eax,%esi
  80702f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  807036:	48 8b 40 08          	mov    0x8(%rax),%rax
  80703a:	48 8d 88 f4 01 00 00 	lea    0x1f4(%rax),%rcx
  807041:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  807048:	9b c4 20 
  80704b:	48 89 c8             	mov    %rcx,%rax
  80704e:	48 f7 ea             	imul   %rdx
  807051:	48 c1 fa 07          	sar    $0x7,%rdx
  807055:	48 89 c8             	mov    %rcx,%rax
  807058:	48 c1 f8 3f          	sar    $0x3f,%rax
  80705c:	48 89 d1             	mov    %rdx,%rcx
  80705f:	48 29 c1             	sub    %rax,%rcx
  807062:	48 89 c8             	mov    %rcx,%rax
  807065:	01 f0                	add    %esi,%eax
  807067:	89 45 f8             	mov    %eax,-0x8(%rbp)
      if(msectimeout == 0)
  80706a:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80706e:	75 07                	jne    807077 <lwip_select+0x2cd>
        msectimeout = 1;
  807070:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%rbp)
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  807077:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80707a:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80707d:	89 d6                	mov    %edx,%esi
  80707f:	89 c7                	mov    %eax,%edi
  807081:	48 b8 67 e7 80 00 00 	movabs $0x80e767,%rax
  807088:	00 00 00 
  80708b:	ff d0                	callq  *%rax
  80708d:	89 45 ec             	mov    %eax,-0x14(%rbp)
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  807090:	48 b8 0c 95 82 00 00 	movabs $0x82950c,%rax
  807097:	00 00 00 
  80709a:	8b 00                	mov    (%rax),%eax
  80709c:	89 c7                	mov    %eax,%edi
  80709e:	48 b8 e8 e2 80 00 00 	movabs $0x80e2e8,%rax
  8070a5:	00 00 00 
  8070a8:	ff d0                	callq  *%rax
    if (select_cb_list == &select_cb)
  8070aa:	48 b8 00 95 82 00 00 	movabs $0x829500,%rax
  8070b1:	00 00 00 
  8070b4:	48 8b 10             	mov    (%rax),%rdx
  8070b7:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  8070bb:	48 39 c2             	cmp    %rax,%rdx
  8070be:	75 13                	jne    8070d3 <lwip_select+0x329>
      select_cb_list = select_cb.next;
  8070c0:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8070c4:	48 b8 00 95 82 00 00 	movabs $0x829500,%rax
  8070cb:	00 00 00 
  8070ce:	48 89 10             	mov    %rdx,(%rax)
  8070d1:	eb 42                	jmp    807115 <lwip_select+0x36b>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  8070d3:	48 b8 00 95 82 00 00 	movabs $0x829500,%rax
  8070da:	00 00 00 
  8070dd:	48 8b 00             	mov    (%rax),%rax
  8070e0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8070e4:	eb 28                	jmp    80710e <lwip_select+0x364>
        if (p_selcb->next == &select_cb) {
  8070e6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8070ea:	48 8b 10             	mov    (%rax),%rdx
  8070ed:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  8070f1:	48 39 c2             	cmp    %rax,%rdx
  8070f4:	75 0d                	jne    807103 <lwip_select+0x359>
          p_selcb->next = select_cb.next;
  8070f6:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8070fa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8070fe:	48 89 10             	mov    %rdx,(%rax)
          break;
  807101:	eb 12                	jmp    807115 <lwip_select+0x36b>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  807103:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807107:	48 8b 00             	mov    (%rax),%rax
  80710a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80710e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  807113:	75 d1                	jne    8070e6 <lwip_select+0x33c>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  807115:	48 b8 0c 95 82 00 00 	movabs $0x82950c,%rax
  80711c:	00 00 00 
  80711f:	8b 00                	mov    (%rax),%eax
  807121:	89 c7                	mov    %eax,%edi
  807123:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  80712a:	00 00 00 
  80712d:	ff d0                	callq  *%rax
    
    sys_sem_free(select_cb.sem);
  80712f:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807132:	89 c7                	mov    %eax,%edi
  807134:	48 b8 e3 7a 81 00 00 	movabs $0x817ae3,%rax
  80713b:	00 00 00 
  80713e:	ff d0                	callq  *%rax
    if (i == 0)  {
  807140:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  807144:	0f 85 92 00 00 00    	jne    8071dc <lwip_select+0x432>
      /* Timeout */
      if (readset)
  80714a:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  80714f:	74 1d                	je     80716e <lwip_select+0x3c4>
        FD_ZERO(readset);
  807151:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  807155:	ba 04 00 00 00       	mov    $0x4,%edx
  80715a:	be 00 00 00 00       	mov    $0x0,%esi
  80715f:	48 89 c7             	mov    %rax,%rdi
  807162:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  807169:	00 00 00 
  80716c:	ff d0                	callq  *%rax
      if (writeset)
  80716e:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  807175:	00 
  807176:	74 20                	je     807198 <lwip_select+0x3ee>
        FD_ZERO(writeset);
  807178:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80717f:	ba 04 00 00 00       	mov    $0x4,%edx
  807184:	be 00 00 00 00       	mov    $0x0,%esi
  807189:	48 89 c7             	mov    %rax,%rdi
  80718c:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  807193:	00 00 00 
  807196:	ff d0                	callq  *%rax
      if (exceptset)
  807198:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  80719f:	00 
  8071a0:	74 20                	je     8071c2 <lwip_select+0x418>
        FD_ZERO(exceptset);
  8071a2:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8071a9:	ba 04 00 00 00       	mov    $0x4,%edx
  8071ae:	be 00 00 00 00       	mov    $0x0,%esi
  8071b3:	48 89 c7             	mov    %rax,%rdi
  8071b6:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  8071bd:	00 00 00 
  8071c0:	ff d0                	callq  *%rax
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  8071c2:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  8071c9:	00 00 00 
  8071cc:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
      return 0;
  8071d2:	b8 00 00 00 00       	mov    $0x0,%eax
  8071d7:	e9 24 01 00 00       	jmpq   807300 <lwip_select+0x556>
    }
    
    if (readset)
  8071dc:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  8071e1:	74 0b                	je     8071ee <lwip_select+0x444>
      lreadset = *readset;
  8071e3:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8071e7:	8b 00                	mov    (%rax),%eax
  8071e9:	89 45 e0             	mov    %eax,-0x20(%rbp)
  8071ec:	eb 1d                	jmp    80720b <lwip_select+0x461>
    else
      FD_ZERO(&lreadset);
  8071ee:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8071f2:	ba 04 00 00 00       	mov    $0x4,%edx
  8071f7:	be 00 00 00 00       	mov    $0x0,%esi
  8071fc:	48 89 c7             	mov    %rax,%rdi
  8071ff:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  807206:	00 00 00 
  807209:	ff d0                	callq  *%rax
    if (writeset)
  80720b:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  807212:	00 
  807213:	74 0e                	je     807223 <lwip_select+0x479>
      lwriteset = *writeset;
  807215:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80721c:	8b 00                	mov    (%rax),%eax
  80721e:	89 45 d0             	mov    %eax,-0x30(%rbp)
  807221:	eb 1d                	jmp    807240 <lwip_select+0x496>
    else
      FD_ZERO(&lwriteset);
  807223:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  807227:	ba 04 00 00 00       	mov    $0x4,%edx
  80722c:	be 00 00 00 00       	mov    $0x0,%esi
  807231:	48 89 c7             	mov    %rax,%rdi
  807234:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  80723b:	00 00 00 
  80723e:	ff d0                	callq  *%rax
    if (exceptset)
  807240:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  807247:	00 
  807248:	74 0e                	je     807258 <lwip_select+0x4ae>
      lexceptset = *exceptset;
  80724a:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  807251:	8b 00                	mov    (%rax),%eax
  807253:	89 45 c0             	mov    %eax,-0x40(%rbp)
  807256:	eb 1d                	jmp    807275 <lwip_select+0x4cb>
    else
      FD_ZERO(&lexceptset);
  807258:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  80725c:	ba 04 00 00 00       	mov    $0x4,%edx
  807261:	be 00 00 00 00       	mov    $0x0,%esi
  807266:	48 89 c7             	mov    %rax,%rdi
  807269:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  807270:	00 00 00 
  807273:	ff d0                	callq  *%rax
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  807275:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  807279:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80727d:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  807281:	8b 45 8c             	mov    -0x74(%rbp),%eax
  807284:	89 c7                	mov    %eax,%edi
  807286:	48 b8 b2 6b 80 00 00 	movabs $0x806bb2,%rax
  80728d:	00 00 00 
  807290:	ff d0                	callq  *%rax
  807292:	89 45 fc             	mov    %eax,-0x4(%rbp)
  807295:	eb 1a                	jmp    8072b1 <lwip_select+0x507>
  } else
    sys_sem_signal(selectsem);
  807297:	48 b8 0c 95 82 00 00 	movabs $0x82950c,%rax
  80729e:	00 00 00 
  8072a1:	8b 00                	mov    (%rax),%eax
  8072a3:	89 c7                	mov    %eax,%edi
  8072a5:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  8072ac:	00 00 00 
  8072af:	ff d0                	callq  *%rax
  
  if (readset)
  8072b1:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
  8072b6:	74 09                	je     8072c1 <lwip_select+0x517>
    *readset = lreadset;
  8072b8:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8072bc:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8072bf:	89 10                	mov    %edx,(%rax)
  if (writeset)
  8072c1:	48 83 bd 78 ff ff ff 	cmpq   $0x0,-0x88(%rbp)
  8072c8:	00 
  8072c9:	74 0c                	je     8072d7 <lwip_select+0x52d>
    *writeset = lwriteset;
  8072cb:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8072d2:	8b 55 d0             	mov    -0x30(%rbp),%edx
  8072d5:	89 10                	mov    %edx,(%rax)
  if (exceptset)
  8072d7:	48 83 bd 70 ff ff ff 	cmpq   $0x0,-0x90(%rbp)
  8072de:	00 
  8072df:	74 0c                	je     8072ed <lwip_select+0x543>
    *exceptset = lexceptset;
  8072e1:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8072e8:	8b 55 c0             	mov    -0x40(%rbp),%edx
  8072eb:	89 10                	mov    %edx,(%rax)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  8072ed:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  8072f4:	00 00 00 
  8072f7:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  
  return nready;
  8072fd:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  807300:	c9                   	leaveq 
  807301:	c3                   	retq   

0000000000807302 <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  807302:	55                   	push   %rbp
  807303:	48 89 e5             	mov    %rsp,%rbp
  807306:	53                   	push   %rbx
  807307:	48 83 ec 38          	sub    $0x38,%rsp
  80730b:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80730f:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  807312:	89 d0                	mov    %edx,%eax
  807314:	66 89 45 c0          	mov    %ax,-0x40(%rbp)
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  807318:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80731d:	0f 84 b8 02 00 00    	je     8075db <event_callback+0x2d9>
    s = conn->socket;
  807323:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  807327:	8b 40 20             	mov    0x20(%rax),%eax
  80732a:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    if (s < 0) {
  80732d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  807331:	79 75                	jns    8073a8 <event_callback+0xa6>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  807333:	48 b8 08 95 82 00 00 	movabs $0x829508,%rax
  80733a:	00 00 00 
  80733d:	8b 00                	mov    (%rax),%eax
  80733f:	89 c7                	mov    %eax,%edi
  807341:	48 b8 e8 e2 80 00 00 	movabs $0x80e2e8,%rax
  807348:	00 00 00 
  80734b:	ff d0                	callq  *%rax
      if (conn->socket < 0) {
  80734d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  807351:	8b 40 20             	mov    0x20(%rax),%eax
  807354:	85 c0                	test   %eax,%eax
  807356:	79 36                	jns    80738e <event_callback+0x8c>
        if (evt == NETCONN_EVT_RCVPLUS) {
  807358:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  80735c:	75 11                	jne    80736f <event_callback+0x6d>
          conn->socket--;
  80735e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  807362:	8b 40 20             	mov    0x20(%rax),%eax
  807365:	8d 50 ff             	lea    -0x1(%rax),%edx
  807368:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80736c:	89 50 20             	mov    %edx,0x20(%rax)
        }
        sys_sem_signal(socksem);
  80736f:	48 b8 08 95 82 00 00 	movabs $0x829508,%rax
  807376:	00 00 00 
  807379:	8b 00                	mov    (%rax),%eax
  80737b:	89 c7                	mov    %eax,%edi
  80737d:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  807384:	00 00 00 
  807387:	ff d0                	callq  *%rax
        return;
  807389:	e9 51 02 00 00       	jmpq   8075df <event_callback+0x2dd>
      }
      sys_sem_signal(socksem);
  80738e:	48 b8 08 95 82 00 00 	movabs $0x829508,%rax
  807395:	00 00 00 
  807398:	8b 00                	mov    (%rax),%eax
  80739a:	89 c7                	mov    %eax,%edi
  80739c:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  8073a3:	00 00 00 
  8073a6:	ff d0                	callq  *%rax
    }

    sock = get_socket(s);
  8073a8:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8073ab:	89 c7                	mov    %eax,%edi
  8073ad:	48 b8 40 59 80 00 00 	movabs $0x805940,%rax
  8073b4:	00 00 00 
  8073b7:	ff d0                	callq  *%rax
  8073b9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    if (!sock) {
  8073bd:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8073c2:	0f 84 16 02 00 00    	je     8075de <event_callback+0x2dc>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
  8073c8:	48 b8 0c 95 82 00 00 	movabs $0x82950c,%rax
  8073cf:	00 00 00 
  8073d2:	8b 00                	mov    (%rax),%eax
  8073d4:	89 c7                	mov    %eax,%edi
  8073d6:	48 b8 e8 e2 80 00 00 	movabs $0x80e2e8,%rax
  8073dd:	00 00 00 
  8073e0:	ff d0                	callq  *%rax
  /* Set event as required */
  switch (evt) {
  8073e2:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8073e5:	83 f8 01             	cmp    $0x1,%eax
  8073e8:	74 26                	je     807410 <event_callback+0x10e>
  8073ea:	83 f8 01             	cmp    $0x1,%eax
  8073ed:	72 0c                	jb     8073fb <event_callback+0xf9>
  8073ef:	83 f8 02             	cmp    $0x2,%eax
  8073f2:	74 31                	je     807425 <event_callback+0x123>
  8073f4:	83 f8 03             	cmp    $0x3,%eax
  8073f7:	74 38                	je     807431 <event_callback+0x12f>
  8073f9:	eb 42                	jmp    80743d <event_callback+0x13b>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  8073fb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8073ff:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  807403:	8d 50 01             	lea    0x1(%rax),%edx
  807406:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80740a:	66 89 50 12          	mov    %dx,0x12(%rax)
      break;
  80740e:	eb 57                	jmp    807467 <event_callback+0x165>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  807410:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807414:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  807418:	8d 50 ff             	lea    -0x1(%rax),%edx
  80741b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80741f:	66 89 50 12          	mov    %dx,0x12(%rax)
      break;
  807423:	eb 42                	jmp    807467 <event_callback+0x165>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  807425:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807429:	66 c7 40 14 01 00    	movw   $0x1,0x14(%rax)
      break;
  80742f:	eb 36                	jmp    807467 <event_callback+0x165>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  807431:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807435:	66 c7 40 14 00 00    	movw   $0x0,0x14(%rax)
      break;
  80743b:	eb 2a                	jmp    807467 <event_callback+0x165>
    default:
      LWIP_ASSERT("unknown event", 0);
  80743d:	48 ba 79 14 82 00 00 	movabs $0x821479,%rdx
  807444:	00 00 00 
  807447:	be 17 04 00 00       	mov    $0x417,%esi
  80744c:	48 bf d1 13 82 00 00 	movabs $0x8213d1,%rdi
  807453:	00 00 00 
  807456:	b8 00 00 00 00       	mov    $0x0,%eax
  80745b:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  807462:	00 00 00 
  807465:	ff d1                	callq  *%rcx
      break;
  }
  sys_sem_signal(selectsem);
  807467:	48 b8 0c 95 82 00 00 	movabs $0x82950c,%rax
  80746e:	00 00 00 
  807471:	8b 00                	mov    (%rax),%eax
  807473:	89 c7                	mov    %eax,%edi
  807475:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  80747c:	00 00 00 
  80747f:	ff d0                	callq  *%rax
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  807481:	48 b8 0c 95 82 00 00 	movabs $0x82950c,%rax
  807488:	00 00 00 
  80748b:	8b 00                	mov    (%rax),%eax
  80748d:	89 c7                	mov    %eax,%edi
  80748f:	48 b8 e8 e2 80 00 00 	movabs $0x80e2e8,%rax
  807496:	00 00 00 
  807499:	ff d0                	callq  *%rax
    for (scb = select_cb_list; scb; scb = scb->next) {
  80749b:	48 b8 00 95 82 00 00 	movabs $0x829500,%rax
  8074a2:	00 00 00 
  8074a5:	48 8b 00             	mov    (%rax),%rax
  8074a8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8074ac:	e9 b6 00 00 00       	jmpq   807567 <event_callback+0x265>
      if (scb->sem_signalled == 0) {
  8074b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8074b5:	8b 40 20             	mov    0x20(%rax),%eax
  8074b8:	85 c0                	test   %eax,%eax
  8074ba:	0f 85 9c 00 00 00    	jne    80755c <event_callback+0x25a>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  8074c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8074c4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8074c8:	48 85 c0             	test   %rax,%rax
  8074cb:	74 41                	je     80750e <event_callback+0x20c>
  8074cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8074d1:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8074d5:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8074d8:	8d 48 07             	lea    0x7(%rax),%ecx
  8074db:	85 c0                	test   %eax,%eax
  8074dd:	0f 48 c1             	cmovs  %ecx,%eax
  8074e0:	c1 f8 03             	sar    $0x3,%eax
  8074e3:	48 98                	cltq   
  8074e5:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8074e9:	0f b6 d0             	movzbl %al,%edx
  8074ec:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8074ef:	83 e0 07             	and    $0x7,%eax
  8074f2:	89 d3                	mov    %edx,%ebx
  8074f4:	89 c1                	mov    %eax,%ecx
  8074f6:	d3 fb                	sar    %cl,%ebx
  8074f8:	89 d8                	mov    %ebx,%eax
  8074fa:	83 e0 01             	and    $0x1,%eax
  8074fd:	84 c0                	test   %al,%al
  8074ff:	74 0d                	je     80750e <event_callback+0x20c>
          if (sock->rcvevent)
  807501:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807505:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  807509:	66 85 c0             	test   %ax,%ax
  80750c:	75 66                	jne    807574 <event_callback+0x272>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  80750e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807512:	48 8b 40 10          	mov    0x10(%rax),%rax
  807516:	48 85 c0             	test   %rax,%rax
  807519:	74 41                	je     80755c <event_callback+0x25a>
  80751b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80751f:	48 8b 50 10          	mov    0x10(%rax),%rdx
  807523:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807526:	8d 48 07             	lea    0x7(%rax),%ecx
  807529:	85 c0                	test   %eax,%eax
  80752b:	0f 48 c1             	cmovs  %ecx,%eax
  80752e:	c1 f8 03             	sar    $0x3,%eax
  807531:	48 98                	cltq   
  807533:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  807537:	0f b6 d0             	movzbl %al,%edx
  80753a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80753d:	83 e0 07             	and    $0x7,%eax
  807540:	89 d3                	mov    %edx,%ebx
  807542:	89 c1                	mov    %eax,%ecx
  807544:	d3 fb                	sar    %cl,%ebx
  807546:	89 d8                	mov    %ebx,%eax
  807548:	83 e0 01             	and    $0x1,%eax
  80754b:	84 c0                	test   %al,%al
  80754d:	74 0d                	je     80755c <event_callback+0x25a>
          if (sock->sendevent)
  80754f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807553:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  807557:	66 85 c0             	test   %ax,%ax
  80755a:	75 1b                	jne    807577 <event_callback+0x275>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  80755c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807560:	48 8b 00             	mov    (%rax),%rax
  807563:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  807567:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80756c:	0f 85 3f ff ff ff    	jne    8074b1 <event_callback+0x1af>
  807572:	eb 04                	jmp    807578 <event_callback+0x276>
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
          if (sock->rcvevent)
            break;
  807574:	90                   	nop
  807575:	eb 01                	jmp    807578 <event_callback+0x276>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
          if (sock->sendevent)
            break;
  807577:	90                   	nop
      }
    }
    if (scb) {
  807578:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80757d:	74 3f                	je     8075be <event_callback+0x2bc>
      scb->sem_signalled = 1;
  80757f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  807583:	c7 40 20 01 00 00 00 	movl   $0x1,0x20(%rax)
      sys_sem_signal(selectsem);
  80758a:	48 b8 0c 95 82 00 00 	movabs $0x82950c,%rax
  807591:	00 00 00 
  807594:	8b 00                	mov    (%rax),%eax
  807596:	89 c7                	mov    %eax,%edi
  807598:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  80759f:	00 00 00 
  8075a2:	ff d0                	callq  *%rax
      sys_sem_signal(scb->sem);
  8075a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8075a8:	8b 40 24             	mov    0x24(%rax),%eax
  8075ab:	89 c7                	mov    %eax,%edi
  8075ad:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  8075b4:	00 00 00 
  8075b7:	ff d0                	callq  *%rax
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
  8075b9:	e9 c3 fe ff ff       	jmpq   807481 <event_callback+0x17f>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
  8075be:	48 b8 0c 95 82 00 00 	movabs $0x82950c,%rax
  8075c5:	00 00 00 
  8075c8:	8b 00                	mov    (%rax),%eax
  8075ca:	89 c7                	mov    %eax,%edi
  8075cc:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  8075d3:	00 00 00 
  8075d6:	ff d0                	callq  *%rax
      break;
  8075d8:	90                   	nop
  8075d9:	eb 04                	jmp    8075df <event_callback+0x2dd>
    sock = get_socket(s);
    if (!sock) {
      return;
    }
  } else {
    return;
  8075db:	90                   	nop
  8075dc:	eb 01                	jmp    8075df <event_callback+0x2dd>
      sys_sem_signal(socksem);
    }

    sock = get_socket(s);
    if (!sock) {
      return;
  8075de:	90                   	nop
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
}
  8075df:	48 83 c4 38          	add    $0x38,%rsp
  8075e3:	5b                   	pop    %rbx
  8075e4:	5d                   	pop    %rbp
  8075e5:	c3                   	retq   

00000000008075e6 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  8075e6:	55                   	push   %rbp
  8075e7:	48 89 e5             	mov    %rsp,%rbp
  8075ea:	48 83 ec 10          	sub    $0x10,%rsp
  8075ee:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8075f1:	89 75 f8             	mov    %esi,-0x8(%rbp)
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  8075f4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8075f7:	89 c7                	mov    %eax,%edi
  8075f9:	48 b8 98 5f 80 00 00 	movabs $0x805f98,%rax
  807600:	00 00 00 
  807603:	ff d0                	callq  *%rax
}
  807605:	c9                   	leaveq 
  807606:	c3                   	retq   

0000000000807607 <lwip_getaddrname>:

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  807607:	55                   	push   %rbp
  807608:	48 89 e5             	mov    %rsp,%rbp
  80760b:	48 83 ec 50          	sub    $0x50,%rsp
  80760f:	89 7d cc             	mov    %edi,-0x34(%rbp)
  807612:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  807616:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80761a:	89 c8                	mov    %ecx,%eax
  80761c:	88 45 c8             	mov    %al,-0x38(%rbp)
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  80761f:	8b 45 cc             	mov    -0x34(%rbp),%eax
  807622:	89 c7                	mov    %eax,%edi
  807624:	48 b8 40 59 80 00 00 	movabs $0x805940,%rax
  80762b:	00 00 00 
  80762e:	ff d0                	callq  *%rax
  807630:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (!sock)
  807634:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  807639:	75 0a                	jne    807645 <lwip_getaddrname+0x3e>
    return -1;
  80763b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807640:	e9 c9 00 00 00       	jmpq   80770e <lwip_getaddrname+0x107>

  memset(&sin, 0, sizeof(sin));
  807645:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  807649:	ba 10 00 00 00       	mov    $0x10,%edx
  80764e:	be 00 00 00 00       	mov    $0x0,%esi
  807653:	48 89 c7             	mov    %rax,%rdi
  807656:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  80765d:	00 00 00 
  807660:	ff d0                	callq  *%rax
  sin.sin_len = sizeof(sin);
  807662:	c6 45 e0 10          	movb   $0x10,-0x20(%rbp)
  sin.sin_family = AF_INET;
  807666:	c6 45 e1 02          	movb   $0x2,-0x1f(%rbp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  80766a:	0f b6 55 c8          	movzbl -0x38(%rbp),%edx
  80766e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807672:	48 8b 00             	mov    (%rax),%rax
  807675:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  807679:	48 8d 79 02          	lea    0x2(%rcx),%rdi
  80767d:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  807681:	89 d1                	mov    %edx,%ecx
  807683:	48 89 fa             	mov    %rdi,%rdx
  807686:	48 89 c7             	mov    %rax,%rdi
  807689:	48 b8 85 98 81 00 00 	movabs $0x819885,%rax
  807690:	00 00 00 
  807693:	ff d0                	callq  *%rax

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  807695:	0f b7 45 e2          	movzwl -0x1e(%rbp),%eax
  807699:	0f b7 c0             	movzwl %ax,%eax
  80769c:	89 c7                	mov    %eax,%edi
  80769e:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  8076a5:	00 00 00 
  8076a8:	ff d0                	callq  *%rax
  8076aa:	66 89 45 e2          	mov    %ax,-0x1e(%rbp)
  sin.sin_addr.s_addr = naddr.addr;
  8076ae:	8b 45 d0             	mov    -0x30(%rbp),%eax
  8076b1:	89 45 e4             	mov    %eax,-0x1c(%rbp)

  if (*namelen > sizeof(sin))
  8076b4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8076b8:	8b 00                	mov    (%rax),%eax
  8076ba:	83 f8 10             	cmp    $0x10,%eax
  8076bd:	76 0a                	jbe    8076c9 <lwip_getaddrname+0xc2>
    *namelen = sizeof(sin);
  8076bf:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8076c3:	c7 00 10 00 00 00    	movl   $0x10,(%rax)

  SMEMCPY(name, &sin, *namelen);
  8076c9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8076cd:	8b 00                	mov    (%rax),%eax
  8076cf:	89 c2                	mov    %eax,%edx
  8076d1:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  8076d5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8076d9:	48 89 ce             	mov    %rcx,%rsi
  8076dc:	48 89 c7             	mov    %rax,%rdi
  8076df:	48 b8 fd 22 80 00 00 	movabs $0x8022fd,%rax
  8076e6:	00 00 00 
  8076e9:	ff d0                	callq  *%rax
  sock_set_errno(sock, 0);
  8076eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8076ef:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8076f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8076fa:	8b 50 18             	mov    0x18(%rax),%edx
  8076fd:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  807704:	00 00 00 
  807707:	89 10                	mov    %edx,(%rax)
  return 0;
  807709:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80770e:	c9                   	leaveq 
  80770f:	c3                   	retq   

0000000000807710 <lwip_getpeername>:

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  807710:	55                   	push   %rbp
  807711:	48 89 e5             	mov    %rsp,%rbp
  807714:	48 83 ec 20          	sub    $0x20,%rsp
  807718:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80771b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80771f:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  return lwip_getaddrname(s, name, namelen, 0);
  807723:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  807727:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80772b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80772e:	b9 00 00 00 00       	mov    $0x0,%ecx
  807733:	89 c7                	mov    %eax,%edi
  807735:	48 b8 07 76 80 00 00 	movabs $0x807607,%rax
  80773c:	00 00 00 
  80773f:	ff d0                	callq  *%rax
}
  807741:	c9                   	leaveq 
  807742:	c3                   	retq   

0000000000807743 <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  807743:	55                   	push   %rbp
  807744:	48 89 e5             	mov    %rsp,%rbp
  807747:	48 83 ec 20          	sub    $0x20,%rsp
  80774b:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80774e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  807752:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  return lwip_getaddrname(s, name, namelen, 1);
  807756:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80775a:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80775e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807761:	b9 01 00 00 00       	mov    $0x1,%ecx
  807766:	89 c7                	mov    %eax,%edi
  807768:	48 b8 07 76 80 00 00 	movabs $0x807607,%rax
  80776f:	00 00 00 
  807772:	ff d0                	callq  *%rax
}
  807774:	c9                   	leaveq 
  807775:	c3                   	retq   

0000000000807776 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  807776:	55                   	push   %rbp
  807777:	48 89 e5             	mov    %rsp,%rbp
  80777a:	48 83 ec 60          	sub    $0x60,%rsp
  80777e:	89 7d bc             	mov    %edi,-0x44(%rbp)
  807781:	89 75 b8             	mov    %esi,-0x48(%rbp)
  807784:	89 55 b4             	mov    %edx,-0x4c(%rbp)
  807787:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
  80778b:	4c 89 45 a0          	mov    %r8,-0x60(%rbp)
  err_t err = ERR_OK;
  80778f:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  struct lwip_socket *sock = get_socket(s);
  807793:	8b 45 bc             	mov    -0x44(%rbp),%eax
  807796:	89 c7                	mov    %eax,%edi
  807798:	48 b8 40 59 80 00 00 	movabs $0x805940,%rax
  80779f:	00 00 00 
  8077a2:	ff d0                	callq  *%rax
  8077a4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  struct lwip_setgetsockopt_data data;

  if (!sock)
  8077a8:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8077ad:	75 0a                	jne    8077b9 <lwip_getsockopt+0x43>
    return -1;
  8077af:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8077b4:	e9 14 02 00 00       	jmpq   8079cd <lwip_getsockopt+0x257>

  if ((NULL == optval) || (NULL == optlen)) {
  8077b9:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  8077be:	74 07                	je     8077c7 <lwip_getsockopt+0x51>
  8077c0:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8077c5:	75 28                	jne    8077ef <lwip_getsockopt+0x79>
    sock_set_errno(sock, EFAULT);
  8077c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8077cb:	c7 40 18 0e 00 00 00 	movl   $0xe,0x18(%rax)
  8077d2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8077d6:	8b 50 18             	mov    0x18(%rax),%edx
  8077d9:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  8077e0:	00 00 00 
  8077e3:	89 10                	mov    %edx,(%rax)
    return -1;
  8077e5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8077ea:	e9 de 01 00 00       	jmpq   8079cd <lwip_getsockopt+0x257>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  8077ef:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8077f2:	83 f8 06             	cmp    $0x6,%eax
  8077f5:	0f 84 c2 00 00 00    	je     8078bd <lwip_getsockopt+0x147>
  8077fb:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  807800:	74 0d                	je     80780f <lwip_getsockopt+0x99>
  807802:	85 c0                	test   %eax,%eax
  807804:	0f 84 8e 00 00 00    	je     807898 <lwip_getsockopt+0x122>
  80780a:	e9 eb 00 00 00       	jmpq   8078fa <lwip_getsockopt+0x184>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  80780f:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807812:	83 f8 20             	cmp    $0x20,%eax
  807815:	74 28                	je     80783f <lwip_getsockopt+0xc9>
  807817:	83 f8 20             	cmp    $0x20,%eax
  80781a:	7f 0c                	jg     807828 <lwip_getsockopt+0xb2>
  80781c:	83 f8 02             	cmp    $0x2,%eax
  80781f:	74 1e                	je     80783f <lwip_getsockopt+0xc9>
  807821:	83 f8 08             	cmp    $0x8,%eax
  807824:	74 19                	je     80783f <lwip_getsockopt+0xc9>
  807826:	eb 64                	jmp    80788c <lwip_getsockopt+0x116>
  807828:	3d 07 10 00 00       	cmp    $0x1007,%eax
  80782d:	7c 5d                	jl     80788c <lwip_getsockopt+0x116>
  80782f:	3d 08 10 00 00       	cmp    $0x1008,%eax
  807834:	7e 09                	jle    80783f <lwip_getsockopt+0xc9>
  807836:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  80783b:	74 13                	je     807850 <lwip_getsockopt+0xda>
  80783d:	eb 4d                	jmp    80788c <lwip_getsockopt+0x116>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  80783f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807843:	8b 00                	mov    (%rax),%eax
  807845:	83 f8 03             	cmp    $0x3,%eax
  807848:	77 48                	ja     807892 <lwip_getsockopt+0x11c>
        err = EINVAL;
  80784a:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
      break;
  80784e:	eb 42                	jmp    807892 <lwip_getsockopt+0x11c>

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
  807850:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  807854:	8b 00                	mov    (%rax),%eax
  807856:	83 f8 03             	cmp    $0x3,%eax
  807859:	77 04                	ja     80785f <lwip_getsockopt+0xe9>
        err = EINVAL;
  80785b:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  80785f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807863:	48 8b 00             	mov    (%rax),%rax
  807866:	8b 00                	mov    (%rax),%eax
  807868:	83 f8 20             	cmp    $0x20,%eax
  80786b:	75 19                	jne    807886 <lwip_getsockopt+0x110>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  80786d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807871:	48 8b 00             	mov    (%rax),%rax
  807874:	48 8b 40 08          	mov    0x8(%rax),%rax
  807878:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  80787c:	0f b6 c0             	movzbl %al,%eax
  80787f:	83 e0 02             	and    $0x2,%eax
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  807882:	85 c0                	test   %eax,%eax
  807884:	74 0f                	je     807895 <lwip_getsockopt+0x11f>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  807886:	c6 45 ff 61          	movb   $0x61,-0x1(%rbp)
      }
#endif /* LWIP_UDP */
      break;
  80788a:	eb 09                	jmp    807895 <lwip_getsockopt+0x11f>

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  80788c:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  807890:	eb 6c                	jmp    8078fe <lwip_getsockopt+0x188>
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
  807892:	90                   	nop
  807893:	eb 01                	jmp    807896 <lwip_getsockopt+0x120>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
      }
#endif /* LWIP_UDP */
      break;
  807895:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  807896:	eb 66                	jmp    8078fe <lwip_getsockopt+0x188>
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  807898:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80789b:	83 e8 01             	sub    $0x1,%eax
  80789e:	83 f8 01             	cmp    $0x1,%eax
  8078a1:	77 11                	ja     8078b4 <lwip_getsockopt+0x13e>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  8078a3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8078a7:	8b 00                	mov    (%rax),%eax
  8078a9:	83 f8 03             	cmp    $0x3,%eax
  8078ac:	77 0c                	ja     8078ba <lwip_getsockopt+0x144>
        err = EINVAL;
  8078ae:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      }
      break;
  8078b2:	eb 06                	jmp    8078ba <lwip_getsockopt+0x144>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  8078b4:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  8078b8:	eb 44                	jmp    8078fe <lwip_getsockopt+0x188>
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
  8078ba:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  8078bb:	eb 41                	jmp    8078fe <lwip_getsockopt+0x188>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  8078bd:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8078c1:	8b 00                	mov    (%rax),%eax
  8078c3:	83 f8 03             	cmp    $0x3,%eax
  8078c6:	77 06                	ja     8078ce <lwip_getsockopt+0x158>
      err = EINVAL;
  8078c8:	c6 45 ff 16          	movb   $0x16,-0x1(%rbp)
      break;
  8078cc:	eb 30                	jmp    8078fe <lwip_getsockopt+0x188>
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  8078ce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8078d2:	48 8b 00             	mov    (%rax),%rax
  8078d5:	8b 00                	mov    (%rax),%eax
  8078d7:	83 f8 10             	cmp    $0x10,%eax
  8078da:	74 0a                	je     8078e6 <lwip_getsockopt+0x170>
      return 0;
  8078dc:	b8 00 00 00 00       	mov    $0x0,%eax
  8078e1:	e9 e7 00 00 00       	jmpq   8079cd <lwip_getsockopt+0x257>

    switch (optname) {
  8078e6:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8078e9:	83 e8 01             	sub    $0x1,%eax
  8078ec:	83 f8 01             	cmp    $0x1,%eax
  8078ef:	77 03                	ja     8078f4 <lwip_getsockopt+0x17e>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
  8078f1:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  8078f2:	eb 0a                	jmp    8078fe <lwip_getsockopt+0x188>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  8078f4:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
    }  /* switch (optname) */
    break;
  8078f8:	eb 04                	jmp    8078fe <lwip_getsockopt+0x188>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
  8078fa:	c6 45 ff 5c          	movb   $0x5c,-0x1(%rbp)
  }  /* switch */

   
  if (err != ERR_OK) {
  8078fe:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  807902:	74 28                	je     80792c <lwip_getsockopt+0x1b6>
    sock_set_errno(sock, err);
  807904:	0f be 55 ff          	movsbl -0x1(%rbp),%edx
  807908:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80790c:	89 50 18             	mov    %edx,0x18(%rax)
  80790f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807913:	8b 50 18             	mov    0x18(%rax),%edx
  807916:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  80791d:	00 00 00 
  807920:	89 10                	mov    %edx,(%rax)
    return -1;
  807922:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807927:	e9 a1 00 00 00       	jmpq   8079cd <lwip_getsockopt+0x257>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  80792c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807930:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  data.level = level;
  807934:	8b 45 b8             	mov    -0x48(%rbp),%eax
  807937:	89 45 cc             	mov    %eax,-0x34(%rbp)
  data.optname = optname;
  80793a:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80793d:	89 45 d0             	mov    %eax,-0x30(%rbp)
  data.optval = optval;
  807940:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  807944:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  data.optlen = optlen;
  807948:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80794c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  data.err = err;
  807950:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  807954:	88 45 e8             	mov    %al,-0x18(%rbp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  807957:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  80795b:	ba 01 00 00 00       	mov    $0x1,%edx
  807960:	48 89 c6             	mov    %rax,%rsi
  807963:	48 bf cf 79 80 00 00 	movabs $0x8079cf,%rdi
  80796a:	00 00 00 
  80796d:	48 b8 28 87 80 00 00 	movabs $0x808728,%rax
  807974:	00 00 00 
  807977:	ff d0                	callq  *%rax
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  807979:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80797d:	48 8b 00             	mov    (%rax),%rax
  807980:	8b 40 14             	mov    0x14(%rax),%eax
  807983:	be 00 00 00 00       	mov    $0x0,%esi
  807988:	89 c7                	mov    %eax,%edi
  80798a:	48 b8 46 7d 81 00 00 	movabs $0x817d46,%rax
  807991:	00 00 00 
  807994:	ff d0                	callq  *%rax
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  807996:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
  80799a:	88 45 ff             	mov    %al,-0x1(%rbp)

  sock_set_errno(sock, err);
  80799d:	0f be 55 ff          	movsbl -0x1(%rbp),%edx
  8079a1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8079a5:	89 50 18             	mov    %edx,0x18(%rax)
  8079a8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8079ac:	8b 50 18             	mov    0x18(%rax),%edx
  8079af:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  8079b6:	00 00 00 
  8079b9:	89 10                	mov    %edx,(%rax)
  return err ? -1 : 0;
  8079bb:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  8079bf:	74 07                	je     8079c8 <lwip_getsockopt+0x252>
  8079c1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8079c6:	eb 05                	jmp    8079cd <lwip_getsockopt+0x257>
  8079c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8079cd:	c9                   	leaveq 
  8079ce:	c3                   	retq   

00000000008079cf <lwip_getsockopt_internal>:

static void
lwip_getsockopt_internal(void *arg)
{
  8079cf:	55                   	push   %rbp
  8079d0:	48 89 e5             	mov    %rsp,%rbp
  8079d3:	48 83 ec 40          	sub    $0x40,%rsp
  8079d7:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  8079db:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8079e0:	75 2a                	jne    807a0c <lwip_getsockopt_internal+0x3d>
  8079e2:	48 ba 87 14 82 00 00 	movabs $0x821487,%rdx
  8079e9:	00 00 00 
  8079ec:	be 38 05 00 00       	mov    $0x538,%esi
  8079f1:	48 bf d1 13 82 00 00 	movabs $0x8213d1,%rdi
  8079f8:	00 00 00 
  8079fb:	b8 00 00 00 00       	mov    $0x0,%eax
  807a00:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  807a07:	00 00 00 
  807a0a:	ff d1                	callq  *%rcx

  data = (struct lwip_setgetsockopt_data*)arg;
  807a0c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  807a10:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sock = data->sock;
  807a14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807a18:	48 8b 00             	mov    (%rax),%rax
  807a1b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#ifdef LWIP_DEBUG
  s = data->s;
  807a1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807a23:	8b 40 08             	mov    0x8(%rax),%eax
  807a26:	89 45 ec             	mov    %eax,-0x14(%rbp)
#endif /* LWIP_DEBUG */
  level = data->level;
  807a29:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807a2d:	8b 40 0c             	mov    0xc(%rax),%eax
  807a30:	89 45 e8             	mov    %eax,-0x18(%rbp)
  optname = data->optname;
  807a33:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807a37:	8b 40 10             	mov    0x10(%rax),%eax
  807a3a:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  optval = data->optval;
  807a3d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807a41:	48 8b 40 18          	mov    0x18(%rax),%rax
  807a45:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  switch (level) {
  807a49:	8b 45 e8             	mov    -0x18(%rbp),%eax
  807a4c:	83 f8 06             	cmp    $0x6,%eax
  807a4f:	0f 84 b4 01 00 00    	je     807c09 <lwip_getsockopt_internal+0x23a>
  807a55:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  807a5a:	74 0d                	je     807a69 <lwip_getsockopt_internal+0x9a>
  807a5c:	85 c0                	test   %eax,%eax
  807a5e:	0f 84 63 01 00 00    	je     807bc7 <lwip_getsockopt_internal+0x1f8>
  807a64:	e9 e9 01 00 00       	jmpq   807c52 <lwip_getsockopt_internal+0x283>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  807a69:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807a6c:	83 f8 20             	cmp    $0x20,%eax
  807a6f:	74 36                	je     807aa7 <lwip_getsockopt_internal+0xd8>
  807a71:	83 f8 20             	cmp    $0x20,%eax
  807a74:	7f 0f                	jg     807a85 <lwip_getsockopt_internal+0xb6>
  807a76:	83 f8 02             	cmp    $0x2,%eax
  807a79:	74 2c                	je     807aa7 <lwip_getsockopt_internal+0xd8>
  807a7b:	83 f8 08             	cmp    $0x8,%eax
  807a7e:	74 27                	je     807aa7 <lwip_getsockopt_internal+0xd8>
  807a80:	e9 3d 01 00 00       	jmpq   807bc2 <lwip_getsockopt_internal+0x1f3>
  807a85:	3d 08 10 00 00       	cmp    $0x1008,%eax
  807a8a:	74 3d                	je     807ac9 <lwip_getsockopt_internal+0xfa>
  807a8c:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  807a91:	0f 84 0d 01 00 00    	je     807ba4 <lwip_getsockopt_internal+0x1d5>
  807a97:	3d 07 10 00 00       	cmp    $0x1007,%eax
  807a9c:	0f 84 85 00 00 00    	je     807b27 <lwip_getsockopt_internal+0x158>
  807aa2:	e9 1b 01 00 00       	jmpq   807bc2 <lwip_getsockopt_internal+0x1f3>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  807aa7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807aab:	48 8b 00             	mov    (%rax),%rax
  807aae:	48 8b 40 08          	mov    0x8(%rax),%rax
  807ab2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  807ab6:	0f b7 c0             	movzwl %ax,%eax
  807ab9:	89 c2                	mov    %eax,%edx
  807abb:	23 55 e4             	and    -0x1c(%rbp),%edx
  807abe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807ac2:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  807ac4:	e9 f9 00 00 00       	jmpq   807bc2 <lwip_getsockopt_internal+0x1f3>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  807ac9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807acd:	48 8b 00             	mov    (%rax),%rax
  807ad0:	8b 00                	mov    (%rax),%eax
  807ad2:	25 f0 00 00 00       	and    $0xf0,%eax
  807ad7:	83 f8 20             	cmp    $0x20,%eax
  807ada:	74 24                	je     807b00 <lwip_getsockopt_internal+0x131>
  807adc:	83 f8 40             	cmp    $0x40,%eax
  807adf:	74 07                	je     807ae8 <lwip_getsockopt_internal+0x119>
  807ae1:	83 f8 10             	cmp    $0x10,%eax
  807ae4:	74 0e                	je     807af4 <lwip_getsockopt_internal+0x125>
  807ae6:	eb 24                	jmp    807b0c <lwip_getsockopt_internal+0x13d>
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  807ae8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807aec:	c7 00 03 00 00 00    	movl   $0x3,(%rax)
        break;
  807af2:	eb 2e                	jmp    807b22 <lwip_getsockopt_internal+0x153>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
  807af4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807af8:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
        break;
  807afe:	eb 22                	jmp    807b22 <lwip_getsockopt_internal+0x153>
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  807b00:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807b04:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
        break;
  807b0a:	eb 16                	jmp    807b22 <lwip_getsockopt_internal+0x153>
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  807b0c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807b10:	48 8b 00             	mov    (%rax),%rax
  807b13:	8b 00                	mov    (%rax),%eax
  807b15:	89 c2                	mov    %eax,%edx
  807b17:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807b1b:	89 10                	mov    %edx,(%rax)
                    ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE): unrecognized socket type %d\n",
                    s, *(int *)optval));
      }  /* switch (sock->conn->type) */
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;
  807b1d:	e9 a0 00 00 00       	jmpq   807bc2 <lwip_getsockopt_internal+0x1f3>
  807b22:	e9 9b 00 00 00       	jmpq   807bc2 <lwip_getsockopt_internal+0x1f3>

    case SO_ERROR:
      if (sock->err == 0) {
  807b27:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807b2b:	8b 40 18             	mov    0x18(%rax),%eax
  807b2e:	85 c0                	test   %eax,%eax
  807b30:	75 58                	jne    807b8a <lwip_getsockopt_internal+0x1bb>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  807b32:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807b36:	48 8b 00             	mov    (%rax),%rax
  807b39:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  807b3d:	0f be c0             	movsbl %al,%eax
  807b40:	f7 d8                	neg    %eax
  807b42:	83 f8 0e             	cmp    $0xe,%eax
  807b45:	77 24                	ja     807b6b <lwip_getsockopt_internal+0x19c>
  807b47:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807b4b:	48 8b 00             	mov    (%rax),%rax
  807b4e:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  807b52:	0f be c0             	movsbl %al,%eax
  807b55:	89 c2                	mov    %eax,%edx
  807b57:	f7 da                	neg    %edx
  807b59:	48 b8 80 13 82 00 00 	movabs $0x821380,%rax
  807b60:	00 00 00 
  807b63:	48 63 d2             	movslq %edx,%rdx
  807b66:	8b 04 90             	mov    (%rax,%rdx,4),%eax
  807b69:	eb 05                	jmp    807b70 <lwip_getsockopt_internal+0x1a1>
  807b6b:	b8 05 00 00 00       	mov    $0x5,%eax
  807b70:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  807b74:	89 42 18             	mov    %eax,0x18(%rdx)
  807b77:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807b7b:	8b 50 18             	mov    0x18(%rax),%edx
  807b7e:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  807b85:	00 00 00 
  807b88:	89 10                	mov    %edx,(%rax)
      } 
      *(int *)optval = sock->err;
  807b8a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807b8e:	8b 50 18             	mov    0x18(%rax),%edx
  807b91:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807b95:	89 10                	mov    %edx,(%rax)
      sock->err = 0;
  807b97:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807b9b:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  807ba2:	eb 1e                	jmp    807bc2 <lwip_getsockopt_internal+0x1f3>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  807ba4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807ba8:	48 8b 00             	mov    (%rax),%rax
  807bab:	48 8b 40 08          	mov    0x8(%rax),%rax
  807baf:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  807bb3:	0f b6 c0             	movzbl %al,%eax
  807bb6:	89 c2                	mov    %eax,%edx
  807bb8:	83 e2 01             	and    $0x1,%edx
  807bbb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807bbf:	89 10                	mov    %edx,(%rax)
      break;
  807bc1:	90                   	nop
#endif /* LWIP_UDP*/
    }  /* switch (optname) */
    break;
  807bc2:	e9 8b 00 00 00       	jmpq   807c52 <lwip_getsockopt_internal+0x283>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  807bc7:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807bca:	83 f8 01             	cmp    $0x1,%eax
  807bcd:	74 1f                	je     807bee <lwip_getsockopt_internal+0x21f>
  807bcf:	83 f8 02             	cmp    $0x2,%eax
  807bd2:	75 33                	jne    807c07 <lwip_getsockopt_internal+0x238>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  807bd4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807bd8:	48 8b 00             	mov    (%rax),%rax
  807bdb:	48 8b 40 08          	mov    0x8(%rax),%rax
  807bdf:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  807be3:	0f b6 d0             	movzbl %al,%edx
  807be6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807bea:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  807bec:	eb 19                	jmp    807c07 <lwip_getsockopt_internal+0x238>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  807bee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807bf2:	48 8b 00             	mov    (%rax),%rax
  807bf5:	48 8b 40 08          	mov    0x8(%rax),%rax
  807bf9:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  807bfd:	0f b6 d0             	movzbl %al,%edx
  807c00:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807c04:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
  807c06:	90                   	nop
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_IF) = 0x%x\n",
                  s, *(u32_t *)optval));
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  807c07:	eb 49                	jmp    807c52 <lwip_getsockopt_internal+0x283>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  807c09:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807c0c:	83 f8 01             	cmp    $0x1,%eax
  807c0f:	74 07                	je     807c18 <lwip_getsockopt_internal+0x249>
  807c11:	83 f8 02             	cmp    $0x2,%eax
  807c14:	74 21                	je     807c37 <lwip_getsockopt_internal+0x268>
  807c16:	eb 39                	jmp    807c51 <lwip_getsockopt_internal+0x282>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  807c18:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c1c:	48 8b 00             	mov    (%rax),%rax
  807c1f:	48 8b 40 08          	mov    0x8(%rax),%rax
  807c23:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  807c27:	0f b6 c0             	movzbl %al,%eax
  807c2a:	89 c2                	mov    %eax,%edx
  807c2c:	83 e2 40             	and    $0x40,%edx
  807c2f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807c33:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  807c35:	eb 1a                	jmp    807c51 <lwip_getsockopt_internal+0x282>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  807c37:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c3b:	48 8b 00             	mov    (%rax),%rax
  807c3e:	48 8b 40 08          	mov    0x8(%rax),%rax
  807c42:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  807c48:	89 c2                	mov    %eax,%edx
  807c4a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807c4e:	89 10                	mov    %edx,(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPALIVE) = %d\n",
                  s, *(int *)optval));
      break;
  807c50:	90                   	nop
                  s, *(int *)optval));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  807c51:	90                   	nop
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  807c52:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807c56:	48 8b 00             	mov    (%rax),%rax
  807c59:	8b 40 14             	mov    0x14(%rax),%eax
  807c5c:	89 c7                	mov    %eax,%edi
  807c5e:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  807c65:	00 00 00 
  807c68:	ff d0                	callq  *%rax
}
  807c6a:	c9                   	leaveq 
  807c6b:	c3                   	retq   

0000000000807c6c <lwip_setsockopt>:

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  807c6c:	55                   	push   %rbp
  807c6d:	48 89 e5             	mov    %rsp,%rbp
  807c70:	48 83 ec 60          	sub    $0x60,%rsp
  807c74:	89 7d bc             	mov    %edi,-0x44(%rbp)
  807c77:	89 75 b8             	mov    %esi,-0x48(%rbp)
  807c7a:	89 55 b4             	mov    %edx,-0x4c(%rbp)
  807c7d:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
  807c81:	44 89 45 b0          	mov    %r8d,-0x50(%rbp)
  struct lwip_socket *sock = get_socket(s);
  807c85:	8b 45 bc             	mov    -0x44(%rbp),%eax
  807c88:	89 c7                	mov    %eax,%edi
  807c8a:	48 b8 40 59 80 00 00 	movabs $0x805940,%rax
  807c91:	00 00 00 
  807c94:	ff d0                	callq  *%rax
  807c96:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  int err = ERR_OK;
  807c9a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  struct lwip_setgetsockopt_data data;

  if (!sock)
  807ca1:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  807ca6:	75 0a                	jne    807cb2 <lwip_setsockopt+0x46>
    return -1;
  807ca8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807cad:	e9 fc 01 00 00       	jmpq   807eae <lwip_setsockopt+0x242>

  if (NULL == optval) {
  807cb2:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  807cb7:	75 28                	jne    807ce1 <lwip_setsockopt+0x75>
    sock_set_errno(sock, EFAULT);
  807cb9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807cbd:	c7 40 18 0e 00 00 00 	movl   $0xe,0x18(%rax)
  807cc4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807cc8:	8b 50 18             	mov    0x18(%rax),%edx
  807ccb:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  807cd2:	00 00 00 
  807cd5:	89 10                	mov    %edx,(%rax)
    return -1;
  807cd7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807cdc:	e9 cd 01 00 00       	jmpq   807eae <lwip_setsockopt+0x242>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  807ce1:	8b 45 b8             	mov    -0x48(%rbp),%eax
  807ce4:	83 f8 06             	cmp    $0x6,%eax
  807ce7:	0f 84 ab 00 00 00    	je     807d98 <lwip_setsockopt+0x12c>
  807ced:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  807cf2:	74 09                	je     807cfd <lwip_setsockopt+0x91>
  807cf4:	85 c0                	test   %eax,%eax
  807cf6:	74 78                	je     807d70 <lwip_setsockopt+0x104>
  807cf8:	e9 db 00 00 00       	jmpq   807dd8 <lwip_setsockopt+0x16c>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  807cfd:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807d00:	83 f8 20             	cmp    $0x20,%eax
  807d03:	74 0c                	je     807d11 <lwip_setsockopt+0xa5>
  807d05:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  807d0a:	74 16                	je     807d22 <lwip_setsockopt+0xb6>
  807d0c:	83 f8 08             	cmp    $0x8,%eax
  807d0f:	75 50                	jne    807d61 <lwip_setsockopt+0xf5>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  807d11:	8b 45 b0             	mov    -0x50(%rbp),%eax
  807d14:	83 f8 03             	cmp    $0x3,%eax
  807d17:	77 51                	ja     807d6a <lwip_setsockopt+0xfe>
        err = EINVAL;
  807d19:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
      break;
  807d20:	eb 48                	jmp    807d6a <lwip_setsockopt+0xfe>
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
  807d22:	8b 45 b0             	mov    -0x50(%rbp),%eax
  807d25:	83 f8 03             	cmp    $0x3,%eax
  807d28:	77 07                	ja     807d31 <lwip_setsockopt+0xc5>
        err = EINVAL;
  807d2a:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  807d31:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807d35:	48 8b 00             	mov    (%rax),%rax
  807d38:	8b 00                	mov    (%rax),%eax
  807d3a:	83 f8 20             	cmp    $0x20,%eax
  807d3d:	75 19                	jne    807d58 <lwip_setsockopt+0xec>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  807d3f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807d43:	48 8b 00             	mov    (%rax),%rax
  807d46:	48 8b 40 08          	mov    0x8(%rax),%rax
  807d4a:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  807d4e:	0f b6 c0             	movzbl %al,%eax
  807d51:	83 e0 02             	and    $0x2,%eax
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  807d54:	85 c0                	test   %eax,%eax
  807d56:	74 15                	je     807d6d <lwip_setsockopt+0x101>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  807d58:	c7 45 fc 61 00 00 00 	movl   $0x61,-0x4(%rbp)
      }
#endif /* LWIP_UDP */
      break;
  807d5f:	eb 0c                	jmp    807d6d <lwip_setsockopt+0x101>
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  807d61:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  807d68:	eb 75                	jmp    807ddf <lwip_setsockopt+0x173>
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
  807d6a:	90                   	nop
  807d6b:	eb 01                	jmp    807d6e <lwip_setsockopt+0x102>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
      }
#endif /* LWIP_UDP */
      break;
  807d6d:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  807d6e:	eb 6f                	jmp    807ddf <lwip_setsockopt+0x173>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  807d70:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807d73:	83 e8 01             	sub    $0x1,%eax
  807d76:	83 f8 01             	cmp    $0x1,%eax
  807d79:	77 11                	ja     807d8c <lwip_setsockopt+0x120>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  807d7b:	8b 45 b0             	mov    -0x50(%rbp),%eax
  807d7e:	83 f8 03             	cmp    $0x3,%eax
  807d81:	77 12                	ja     807d95 <lwip_setsockopt+0x129>
        err = EINVAL;
  807d83:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      }
      break;
  807d8a:	eb 09                	jmp    807d95 <lwip_setsockopt+0x129>
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
  807d8c:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  807d93:	eb 4a                	jmp    807ddf <lwip_setsockopt+0x173>
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
  807d95:	90                   	nop
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  807d96:	eb 47                	jmp    807ddf <lwip_setsockopt+0x173>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  807d98:	8b 45 b0             	mov    -0x50(%rbp),%eax
  807d9b:	83 f8 03             	cmp    $0x3,%eax
  807d9e:	77 09                	ja     807da9 <lwip_setsockopt+0x13d>
      err = EINVAL;
  807da0:	c7 45 fc 16 00 00 00 	movl   $0x16,-0x4(%rbp)
      break;
  807da7:	eb 36                	jmp    807ddf <lwip_setsockopt+0x173>
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  807da9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807dad:	48 8b 00             	mov    (%rax),%rax
  807db0:	8b 00                	mov    (%rax),%eax
  807db2:	83 f8 10             	cmp    $0x10,%eax
  807db5:	74 0a                	je     807dc1 <lwip_setsockopt+0x155>
      return 0;
  807db7:	b8 00 00 00 00       	mov    $0x0,%eax
  807dbc:	e9 ed 00 00 00       	jmpq   807eae <lwip_setsockopt+0x242>

    switch (optname) {
  807dc1:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807dc4:	83 e8 01             	sub    $0x1,%eax
  807dc7:	83 f8 01             	cmp    $0x1,%eax
  807dca:	77 03                	ja     807dcf <lwip_setsockopt+0x163>
#if LWIP_TCP_KEEPALIVE
    case TCP_KEEPIDLE:
    case TCP_KEEPINTVL:
    case TCP_KEEPCNT:
#endif /* LWIP_TCP_KEEPALIVE */
      break;
  807dcc:	90                   	nop
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
    }  /* switch (optname) */
    break;
  807dcd:	eb 10                	jmp    807ddf <lwip_setsockopt+0x173>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  807dcf:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
    }  /* switch (optname) */
    break;
  807dd6:	eb 07                	jmp    807ddf <lwip_setsockopt+0x173>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
  807dd8:	c7 45 fc 5c 00 00 00 	movl   $0x5c,-0x4(%rbp)
  }  /* switch (level) */


  if (err != ERR_OK) {
  807ddf:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  807de3:	74 27                	je     807e0c <lwip_setsockopt+0x1a0>
    sock_set_errno(sock, err);
  807de5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807de9:	8b 55 fc             	mov    -0x4(%rbp),%edx
  807dec:	89 50 18             	mov    %edx,0x18(%rax)
  807def:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807df3:	8b 50 18             	mov    0x18(%rax),%edx
  807df6:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  807dfd:	00 00 00 
  807e00:	89 10                	mov    %edx,(%rax)
    return -1;
  807e02:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807e07:	e9 a2 00 00 00       	jmpq   807eae <lwip_setsockopt+0x242>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  807e0c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807e10:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  data.level = level;
  807e14:	8b 45 b8             	mov    -0x48(%rbp),%eax
  807e17:	89 45 cc             	mov    %eax,-0x34(%rbp)
  data.optname = optname;
  807e1a:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  807e1d:	89 45 d0             	mov    %eax,-0x30(%rbp)
  data.optval = (void*)optval;
  807e20:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  807e24:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  data.optlen = &optlen;
  807e28:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  807e2c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  data.err = err;
  807e30:	8b 45 fc             	mov    -0x4(%rbp),%eax
  807e33:	88 45 e8             	mov    %al,-0x18(%rbp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  807e36:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  807e3a:	ba 01 00 00 00       	mov    $0x1,%edx
  807e3f:	48 89 c6             	mov    %rax,%rsi
  807e42:	48 bf b0 7e 80 00 00 	movabs $0x807eb0,%rdi
  807e49:	00 00 00 
  807e4c:	48 b8 28 87 80 00 00 	movabs $0x808728,%rax
  807e53:	00 00 00 
  807e56:	ff d0                	callq  *%rax
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  807e58:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807e5c:	48 8b 00             	mov    (%rax),%rax
  807e5f:	8b 40 14             	mov    0x14(%rax),%eax
  807e62:	be 00 00 00 00       	mov    $0x0,%esi
  807e67:	89 c7                	mov    %eax,%edi
  807e69:	48 b8 46 7d 81 00 00 	movabs $0x817d46,%rax
  807e70:	00 00 00 
  807e73:	ff d0                	callq  *%rax
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  807e75:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
  807e79:	0f be c0             	movsbl %al,%eax
  807e7c:	89 45 fc             	mov    %eax,-0x4(%rbp)

  sock_set_errno(sock, err);
  807e7f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807e83:	8b 55 fc             	mov    -0x4(%rbp),%edx
  807e86:	89 50 18             	mov    %edx,0x18(%rax)
  807e89:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807e8d:	8b 50 18             	mov    0x18(%rax),%edx
  807e90:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  807e97:	00 00 00 
  807e9a:	89 10                	mov    %edx,(%rax)
  return err ? -1 : 0;
  807e9c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  807ea0:	74 07                	je     807ea9 <lwip_setsockopt+0x23d>
  807ea2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807ea7:	eb 05                	jmp    807eae <lwip_setsockopt+0x242>
  807ea9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  807eae:	c9                   	leaveq 
  807eaf:	c3                   	retq   

0000000000807eb0 <lwip_setsockopt_internal>:

static void
lwip_setsockopt_internal(void *arg)
{
  807eb0:	55                   	push   %rbp
  807eb1:	48 89 e5             	mov    %rsp,%rbp
  807eb4:	48 83 ec 40          	sub    $0x40,%rsp
  807eb8:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  807ebc:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  807ec1:	75 2a                	jne    807eed <lwip_setsockopt_internal+0x3d>
  807ec3:	48 ba 87 14 82 00 00 	movabs $0x821487,%rdx
  807eca:	00 00 00 
  807ecd:	be ae 06 00 00       	mov    $0x6ae,%esi
  807ed2:	48 bf d1 13 82 00 00 	movabs $0x8213d1,%rdi
  807ed9:	00 00 00 
  807edc:	b8 00 00 00 00       	mov    $0x0,%eax
  807ee1:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  807ee8:	00 00 00 
  807eeb:	ff d1                	callq  *%rcx

  data = (struct lwip_setgetsockopt_data*)arg;
  807eed:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  807ef1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sock = data->sock;
  807ef5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807ef9:	48 8b 00             	mov    (%rax),%rax
  807efc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#ifdef LWIP_DEBUG
  s = data->s;
  807f00:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807f04:	8b 40 08             	mov    0x8(%rax),%eax
  807f07:	89 45 ec             	mov    %eax,-0x14(%rbp)
#endif /* LWIP_DEBUG */
  level = data->level;
  807f0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807f0e:	8b 40 0c             	mov    0xc(%rax),%eax
  807f11:	89 45 e8             	mov    %eax,-0x18(%rbp)
  optname = data->optname;
  807f14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807f18:	8b 40 10             	mov    0x10(%rax),%eax
  807f1b:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  optval = data->optval;
  807f1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  807f22:	48 8b 40 18          	mov    0x18(%rax),%rax
  807f26:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  switch (level) {
  807f2a:	8b 45 e8             	mov    -0x18(%rbp),%eax
  807f2d:	83 f8 06             	cmp    $0x6,%eax
  807f30:	0f 84 10 01 00 00    	je     808046 <lwip_setsockopt_internal+0x196>
  807f36:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  807f3b:	74 0d                	je     807f4a <lwip_setsockopt_internal+0x9a>
  807f3d:	85 c0                	test   %eax,%eax
  807f3f:	0f 84 c7 00 00 00    	je     80800c <lwip_setsockopt_internal+0x15c>
  807f45:	e9 72 01 00 00       	jmpq   8080bc <lwip_setsockopt_internal+0x20c>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  807f4a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  807f4d:	83 f8 20             	cmp    $0x20,%eax
  807f50:	74 10                	je     807f62 <lwip_setsockopt_internal+0xb2>
  807f52:	3d 0a 10 00 00       	cmp    $0x100a,%eax
  807f57:	74 61                	je     807fba <lwip_setsockopt_internal+0x10a>
  807f59:	83 f8 08             	cmp    $0x8,%eax
  807f5c:	0f 85 a5 00 00 00    	jne    808007 <lwip_setsockopt_internal+0x157>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  807f62:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807f66:	8b 00                	mov    (%rax),%eax
  807f68:	85 c0                	test   %eax,%eax
  807f6a:	74 27                	je     807f93 <lwip_setsockopt_internal+0xe3>
        sock->conn->pcb.ip->so_options |= optname;
  807f6c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f70:	48 8b 00             	mov    (%rax),%rax
  807f73:	48 8b 40 08          	mov    0x8(%rax),%rax
  807f77:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  807f7b:	48 8b 12             	mov    (%rdx),%rdx
  807f7e:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  807f82:	0f b7 52 08          	movzwl 0x8(%rdx),%edx
  807f86:	89 d1                	mov    %edx,%ecx
  807f88:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  807f8b:	09 ca                	or     %ecx,%edx
  807f8d:	66 89 50 08          	mov    %dx,0x8(%rax)
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
  807f91:	eb 74                	jmp    808007 <lwip_setsockopt_internal+0x157>
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
        sock->conn->pcb.ip->so_options |= optname;
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  807f93:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807f97:	48 8b 00             	mov    (%rax),%rax
  807f9a:	48 8b 40 08          	mov    0x8(%rax),%rax
  807f9e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  807fa2:	48 8b 12             	mov    (%rdx),%rdx
  807fa5:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  807fa9:	0f b7 52 08          	movzwl 0x8(%rdx),%edx
  807fad:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  807fb0:	f7 d1                	not    %ecx
  807fb2:	21 ca                	and    %ecx,%edx
  807fb4:	66 89 50 08          	mov    %dx,0x8(%rax)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, optname=0x%x, ..) -> %s\n",
                  s, optname, (*(int*)optval?"on":"off")));
      break;
  807fb8:	eb 4d                	jmp    808007 <lwip_setsockopt_internal+0x157>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  807fba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  807fbe:	8b 00                	mov    (%rax),%eax
  807fc0:	85 c0                	test   %eax,%eax
  807fc2:	74 22                	je     807fe6 <lwip_setsockopt_internal+0x136>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  807fc4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807fc8:	48 8b 00             	mov    (%rax),%rax
  807fcb:	48 8b 40 08          	mov    0x8(%rax),%rax
  807fcf:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  807fd3:	48 8b 12             	mov    (%rdx),%rdx
  807fd6:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  807fda:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  807fde:	83 ca 01             	or     $0x1,%edx
  807fe1:	88 50 18             	mov    %dl,0x18(%rax)
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
  807fe4:	eb 20                	jmp    808006 <lwip_setsockopt_internal+0x156>
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  807fe6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  807fea:	48 8b 00             	mov    (%rax),%rax
  807fed:	48 8b 40 08          	mov    0x8(%rax),%rax
  807ff1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  807ff5:	48 8b 12             	mov    (%rdx),%rdx
  807ff8:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  807ffc:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  808000:	83 e2 fe             	and    $0xfffffffe,%edx
  808003:	88 50 18             	mov    %dl,0x18(%rax)
      }
      break;
  808006:	90                   	nop
#endif /* LWIP_UDP */
    }  /* switch (optname) */
    break;
  808007:	e9 b0 00 00 00       	jmpq   8080bc <lwip_setsockopt_internal+0x20c>

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  80800c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80800f:	83 f8 01             	cmp    $0x1,%eax
  808012:	74 1b                	je     80802f <lwip_setsockopt_internal+0x17f>
  808014:	83 f8 02             	cmp    $0x2,%eax
  808017:	75 2b                	jne    808044 <lwip_setsockopt_internal+0x194>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  808019:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80801d:	48 8b 00             	mov    (%rax),%rax
  808020:	48 8b 40 08          	mov    0x8(%rax),%rax
  808024:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  808028:	8b 12                	mov    (%rdx),%edx
  80802a:	88 50 0b             	mov    %dl,0xb(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  80802d:	eb 15                	jmp    808044 <lwip_setsockopt_internal+0x194>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  80802f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808033:	48 8b 00             	mov    (%rax),%rax
  808036:	48 8b 40 08          	mov    0x8(%rax),%rax
  80803a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80803e:	8b 12                	mov    (%rdx),%edx
  808040:	88 50 0a             	mov    %dl,0xa(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
                  s, sock->conn->pcb.ip->tos));
      break;
  808043:	90                   	nop
        }
      }
      break;
#endif /* LWIP_IGMP */
    }  /* switch (optname) */
    break;
  808044:	eb 76                	jmp    8080bc <lwip_setsockopt_internal+0x20c>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  808046:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  808049:	83 f8 01             	cmp    $0x1,%eax
  80804c:	74 07                	je     808055 <lwip_setsockopt_internal+0x1a5>
  80804e:	83 f8 02             	cmp    $0x2,%eax
  808051:	74 50                	je     8080a3 <lwip_setsockopt_internal+0x1f3>
  808053:	eb 66                	jmp    8080bb <lwip_setsockopt_internal+0x20b>
    case TCP_NODELAY:
      if (*(int*)optval) {
  808055:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  808059:	8b 00                	mov    (%rax),%eax
  80805b:	85 c0                	test   %eax,%eax
  80805d:	74 22                	je     808081 <lwip_setsockopt_internal+0x1d1>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  80805f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808063:	48 8b 00             	mov    (%rax),%rax
  808066:	48 8b 40 08          	mov    0x8(%rax),%rax
  80806a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80806e:	48 8b 12             	mov    (%rdx),%rdx
  808071:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  808075:	0f b6 52 2c          	movzbl 0x2c(%rdx),%edx
  808079:	83 ca 40             	or     $0x40,%edx
  80807c:	88 50 2c             	mov    %dl,0x2c(%rax)
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
  80807f:	eb 3a                	jmp    8080bb <lwip_setsockopt_internal+0x20b>
    switch (optname) {
    case TCP_NODELAY:
      if (*(int*)optval) {
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  808081:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808085:	48 8b 00             	mov    (%rax),%rax
  808088:	48 8b 40 08          	mov    0x8(%rax),%rax
  80808c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  808090:	48 8b 12             	mov    (%rdx),%rdx
  808093:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  808097:	0f b6 52 2c          	movzbl 0x2c(%rdx),%edx
  80809b:	83 e2 bf             	and    $0xffffffbf,%edx
  80809e:	88 50 2c             	mov    %dl,0x2c(%rax)
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
  8080a1:	eb 18                	jmp    8080bb <lwip_setsockopt_internal+0x20b>
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  8080a3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8080a7:	48 8b 00             	mov    (%rax),%rax
  8080aa:	48 8b 40 08          	mov    0x8(%rax),%rax
  8080ae:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8080b2:	8b 12                	mov    (%rdx),%edx
  8080b4:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) -> %lu\n",
                  s, sock->conn->pcb.tcp->keep_idle));
      break;
  8080ba:	90                   	nop
                  s, sock->conn->pcb.tcp->keep_cnt));
      break;
#endif /* LWIP_TCP_KEEPALIVE */

    }  /* switch (optname) */
    break;
  8080bb:	90                   	nop
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  8080bc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8080c0:	48 8b 00             	mov    (%rax),%rax
  8080c3:	8b 40 14             	mov    0x14(%rax),%eax
  8080c6:	89 c7                	mov    %eax,%edi
  8080c8:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  8080cf:	00 00 00 
  8080d2:	ff d0                	callq  *%rax
}
  8080d4:	c9                   	leaveq 
  8080d5:	c3                   	retq   

00000000008080d6 <lwip_ioctl>:

int
lwip_ioctl(int s, long cmd, void *argp)
{
  8080d6:	55                   	push   %rbp
  8080d7:	48 89 e5             	mov    %rsp,%rbp
  8080da:	48 83 ec 28          	sub    $0x28,%rsp
  8080de:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8080e1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8080e5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  struct lwip_socket *sock = get_socket(s);
  8080e9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8080ec:	89 c7                	mov    %eax,%edi
  8080ee:	48 b8 40 59 80 00 00 	movabs $0x805940,%rax
  8080f5:	00 00 00 
  8080f8:	ff d0                	callq  *%rax
  8080fa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  u16_t buflen = 0;
  8080fe:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)

  if (!sock)
  808104:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808109:	75 0a                	jne    808115 <lwip_ioctl+0x3f>
    return -1;
  80810b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808110:	e9 4d 01 00 00       	jmpq   808262 <lwip_ioctl+0x18c>

  switch (cmd) {
  808115:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  808119:	48 3d 7f 66 08 40    	cmp    $0x4008667f,%rax
  80811f:	74 13                	je     808134 <lwip_ioctl+0x5e>
  808121:	ba 7e 66 08 80       	mov    $0x8008667e,%edx
  808126:	48 39 d0             	cmp    %rdx,%rax
  808129:	0f 84 ae 00 00 00    	je     8081dd <lwip_ioctl+0x107>
  80812f:	e9 0b 01 00 00       	jmpq   80823f <lwip_ioctl+0x169>
  case FIONREAD:
    if (!argp) {
  808134:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  808139:	75 28                	jne    808163 <lwip_ioctl+0x8d>
      sock_set_errno(sock, EINVAL);
  80813b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80813f:	c7 40 18 16 00 00 00 	movl   $0x16,0x18(%rax)
  808146:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80814a:	8b 50 18             	mov    0x18(%rax),%edx
  80814d:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  808154:	00 00 00 
  808157:	89 10                	mov    %edx,(%rax)
      return -1;
  808159:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80815e:	e9 ff 00 00 00       	jmpq   808262 <lwip_ioctl+0x18c>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  808163:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808167:	48 8b 00             	mov    (%rax),%rax
  80816a:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  80816e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  808172:	66 89 10             	mov    %dx,(%rax)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  808175:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808179:	48 8b 40 08          	mov    0x8(%rax),%rax
  80817d:	48 85 c0             	test   %rax,%rax
  808180:	74 33                	je     8081b5 <lwip_ioctl+0xdf>
      buflen = netbuf_len(sock->lastdata);
  808182:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808186:	48 8b 40 08          	mov    0x8(%rax),%rax
  80818a:	48 8b 00             	mov    (%rax),%rax
  80818d:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  808191:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
      buflen -= sock->lastoffset;
  808195:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808199:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80819d:	66 29 45 f6          	sub    %ax,-0xa(%rbp)

      *((u16_t*)argp) += buflen;
  8081a1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8081a5:	0f b7 00             	movzwl (%rax),%eax
  8081a8:	89 c2                	mov    %eax,%edx
  8081aa:	66 03 55 f6          	add    -0xa(%rbp),%dx
  8081ae:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8081b2:	66 89 10             	mov    %dx,(%rax)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  8081b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8081b9:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  8081c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8081c4:	8b 50 18             	mov    0x18(%rax),%edx
  8081c7:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  8081ce:	00 00 00 
  8081d1:	89 10                	mov    %edx,(%rax)
    return 0;
  8081d3:	b8 00 00 00 00       	mov    $0x0,%eax
  8081d8:	e9 85 00 00 00       	jmpq   808262 <lwip_ioctl+0x18c>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  8081dd:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8081e2:	74 21                	je     808205 <lwip_ioctl+0x12f>
  8081e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8081e8:	8b 00                	mov    (%rax),%eax
  8081ea:	85 c0                	test   %eax,%eax
  8081ec:	74 17                	je     808205 <lwip_ioctl+0x12f>
      sock->flags |= O_NONBLOCK;
  8081ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8081f2:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  8081f6:	89 c2                	mov    %eax,%edx
  8081f8:	80 ce 08             	or     $0x8,%dh
  8081fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8081ff:	66 89 50 16          	mov    %dx,0x16(%rax)
  808203:	eb 15                	jmp    80821a <lwip_ioctl+0x144>
    else
      sock->flags &= ~O_NONBLOCK;
  808205:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808209:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80820d:	89 c2                	mov    %eax,%edx
  80820f:	80 e6 f7             	and    $0xf7,%dh
  808212:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808216:	66 89 50 16          	mov    %dx,0x16(%rax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  80821a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80821e:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  808225:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808229:	8b 50 18             	mov    0x18(%rax),%edx
  80822c:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  808233:	00 00 00 
  808236:	89 10                	mov    %edx,(%rax)
    return 0;
  808238:	b8 00 00 00 00       	mov    $0x0,%eax
  80823d:	eb 23                	jmp    808262 <lwip_ioctl+0x18c>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  80823f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808243:	c7 40 18 26 00 00 00 	movl   $0x26,0x18(%rax)
  80824a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80824e:	8b 50 18             	mov    0x18(%rax),%edx
  808251:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  808258:	00 00 00 
  80825b:	89 10                	mov    %edx,(%rax)
    return -1;
  80825d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  } /* switch (cmd) */
}
  808262:	c9                   	leaveq 
  808263:	c3                   	retq   

0000000000808264 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  808264:	55                   	push   %rbp
  808265:	48 89 e5             	mov    %rsp,%rbp
  808268:	48 83 ec 10          	sub    $0x10,%rsp
  80826c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  808270:	48 b8 38 e8 80 00 00 	movabs $0x80e838,%rax
  808277:	00 00 00 
  80827a:	ff d0                	callq  *%rax
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  80827c:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  808283:	00 00 00 
  808286:	48 8b 00             	mov    (%rax),%rax
  808289:	48 85 c0             	test   %rax,%rax
  80828c:	75 12                	jne    8082a0 <tcpip_tcp_timer+0x3c>
  80828e:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  808295:	00 00 00 
  808298:	48 8b 00             	mov    (%rax),%rax
  80829b:	48 85 c0             	test   %rax,%rax
  80829e:	74 22                	je     8082c2 <tcpip_tcp_timer+0x5e>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  8082a0:	ba 00 00 00 00       	mov    $0x0,%edx
  8082a5:	48 be 64 82 80 00 00 	movabs $0x808264,%rsi
  8082ac:	00 00 00 
  8082af:	bf fa 00 00 00       	mov    $0xfa,%edi
  8082b4:	48 b8 11 e4 80 00 00 	movabs $0x80e411,%rax
  8082bb:	00 00 00 
  8082be:	ff d0                	callq  *%rax
  8082c0:	eb 10                	jmp    8082d2 <tcpip_tcp_timer+0x6e>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  8082c2:	48 b8 20 95 82 00 00 	movabs $0x829520,%rax
  8082c9:	00 00 00 
  8082cc:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  }
}
  8082d2:	c9                   	leaveq 
  8082d3:	c3                   	retq   

00000000008082d4 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  8082d4:	55                   	push   %rbp
  8082d5:	48 89 e5             	mov    %rsp,%rbp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  8082d8:	48 b8 20 95 82 00 00 	movabs $0x829520,%rax
  8082df:	00 00 00 
  8082e2:	8b 00                	mov    (%rax),%eax
  8082e4:	85 c0                	test   %eax,%eax
  8082e6:	75 54                	jne    80833c <tcp_timer_needed+0x68>
  8082e8:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  8082ef:	00 00 00 
  8082f2:	48 8b 00             	mov    (%rax),%rax
  8082f5:	48 85 c0             	test   %rax,%rax
  8082f8:	75 12                	jne    80830c <tcp_timer_needed+0x38>
  8082fa:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  808301:	00 00 00 
  808304:	48 8b 00             	mov    (%rax),%rax
  808307:	48 85 c0             	test   %rax,%rax
  80830a:	74 30                	je     80833c <tcp_timer_needed+0x68>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  80830c:	48 b8 20 95 82 00 00 	movabs $0x829520,%rax
  808313:	00 00 00 
  808316:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  80831c:	ba 00 00 00 00       	mov    $0x0,%edx
  808321:	48 be 64 82 80 00 00 	movabs $0x808264,%rsi
  808328:	00 00 00 
  80832b:	bf fa 00 00 00       	mov    $0xfa,%edi
  808330:	48 b8 11 e4 80 00 00 	movabs $0x80e411,%rax
  808337:	00 00 00 
  80833a:	ff d0                	callq  *%rax
  }
}
  80833c:	5d                   	pop    %rbp
  80833d:	c3                   	retq   

000000000080833e <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  80833e:	55                   	push   %rbp
  80833f:	48 89 e5             	mov    %rsp,%rbp
  808342:	48 83 ec 10          	sub    $0x10,%rsp
  808346:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  80834a:	48 b8 8c 12 81 00 00 	movabs $0x81128c,%rax
  808351:	00 00 00 
  808354:	ff d0                	callq  *%rax
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  808356:	ba 00 00 00 00       	mov    $0x0,%edx
  80835b:	48 be 3e 83 80 00 00 	movabs $0x80833e,%rsi
  808362:	00 00 00 
  808365:	bf e8 03 00 00       	mov    $0x3e8,%edi
  80836a:	48 b8 11 e4 80 00 00 	movabs $0x80e411,%rax
  808371:	00 00 00 
  808374:	ff d0                	callq  *%rax
}
  808376:	c9                   	leaveq 
  808377:	c3                   	retq   

0000000000808378 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  808378:	55                   	push   %rbp
  808379:	48 89 e5             	mov    %rsp,%rbp
  80837c:	48 83 ec 10          	sub    $0x10,%rsp
  808380:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  808384:	48 b8 32 57 81 00 00 	movabs $0x815732,%rax
  80838b:	00 00 00 
  80838e:	ff d0                	callq  *%rax
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  808390:	ba 00 00 00 00       	mov    $0x0,%edx
  808395:	48 be 78 83 80 00 00 	movabs $0x808378,%rsi
  80839c:	00 00 00 
  80839f:	bf 88 13 00 00       	mov    $0x1388,%edi
  8083a4:	48 b8 11 e4 80 00 00 	movabs $0x80e411,%rax
  8083ab:	00 00 00 
  8083ae:	ff d0                	callq  *%rax
}
  8083b0:	c9                   	leaveq 
  8083b1:	c3                   	retq   

00000000008083b2 <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  8083b2:	55                   	push   %rbp
  8083b3:	48 89 e5             	mov    %rsp,%rbp
  8083b6:	48 83 ec 10          	sub    $0x10,%rsp
  8083ba:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  8083be:	48 b8 ec 94 80 00 00 	movabs $0x8094ec,%rax
  8083c5:	00 00 00 
  8083c8:	ff d0                	callq  *%rax
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  8083ca:	ba 00 00 00 00       	mov    $0x0,%edx
  8083cf:	48 be b2 83 80 00 00 	movabs $0x8083b2,%rsi
  8083d6:	00 00 00 
  8083d9:	bf 60 ea 00 00       	mov    $0xea60,%edi
  8083de:	48 b8 11 e4 80 00 00 	movabs $0x80e411,%rax
  8083e5:	00 00 00 
  8083e8:	ff d0                	callq  *%rax
}
  8083ea:	c9                   	leaveq 
  8083eb:	c3                   	retq   

00000000008083ec <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  8083ec:	55                   	push   %rbp
  8083ed:	48 89 e5             	mov    %rsp,%rbp
  8083f0:	48 83 ec 10          	sub    $0x10,%rsp
  8083f4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  8083f8:	48 b8 90 95 80 00 00 	movabs $0x809590,%rax
  8083ff:	00 00 00 
  808402:	ff d0                	callq  *%rax
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  808404:	ba 00 00 00 00       	mov    $0x0,%edx
  808409:	48 be ec 83 80 00 00 	movabs $0x8083ec,%rsi
  808410:	00 00 00 
  808413:	bf f4 01 00 00       	mov    $0x1f4,%edi
  808418:	48 b8 11 e4 80 00 00 	movabs $0x80e411,%rax
  80841f:	00 00 00 
  808422:	ff d0                	callq  *%rax
}
  808424:	c9                   	leaveq 
  808425:	c3                   	retq   

0000000000808426 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  808426:	55                   	push   %rbp
  808427:	48 89 e5             	mov    %rsp,%rbp
  80842a:	48 83 ec 20          	sub    $0x20,%rsp
  80842e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  808432:	ba 00 00 00 00       	mov    $0x0,%edx
  808437:	48 be 3e 83 80 00 00 	movabs $0x80833e,%rsi
  80843e:	00 00 00 
  808441:	bf e8 03 00 00       	mov    $0x3e8,%edi
  808446:	48 b8 11 e4 80 00 00 	movabs $0x80e411,%rax
  80844d:	00 00 00 
  808450:	ff d0                	callq  *%rax
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  808452:	ba 00 00 00 00       	mov    $0x0,%edx
  808457:	48 be 78 83 80 00 00 	movabs $0x808378,%rsi
  80845e:	00 00 00 
  808461:	bf 88 13 00 00       	mov    $0x1388,%edi
  808466:	48 b8 11 e4 80 00 00 	movabs $0x80e411,%rax
  80846d:	00 00 00 
  808470:	ff d0                	callq  *%rax
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  808472:	ba 00 00 00 00       	mov    $0x0,%edx
  808477:	48 be b2 83 80 00 00 	movabs $0x8083b2,%rsi
  80847e:	00 00 00 
  808481:	bf 60 ea 00 00       	mov    $0xea60,%edi
  808486:	48 b8 11 e4 80 00 00 	movabs $0x80e411,%rax
  80848d:	00 00 00 
  808490:	ff d0                	callq  *%rax
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  808492:	ba 00 00 00 00       	mov    $0x0,%edx
  808497:	48 be ec 83 80 00 00 	movabs $0x8083ec,%rsi
  80849e:	00 00 00 
  8084a1:	bf f4 01 00 00       	mov    $0x1f4,%edi
  8084a6:	48 b8 11 e4 80 00 00 	movabs $0x80e411,%rax
  8084ad:	00 00 00 
  8084b0:	ff d0                	callq  *%rax
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  8084b2:	48 b8 10 95 82 00 00 	movabs $0x829510,%rax
  8084b9:	00 00 00 
  8084bc:	48 8b 00             	mov    (%rax),%rax
  8084bf:	48 85 c0             	test   %rax,%rax
  8084c2:	74 1f                	je     8084e3 <tcpip_thread+0xbd>
    tcpip_init_done(tcpip_init_done_arg);
  8084c4:	48 b8 10 95 82 00 00 	movabs $0x829510,%rax
  8084cb:	00 00 00 
  8084ce:	48 8b 10             	mov    (%rax),%rdx
  8084d1:	48 b8 18 95 82 00 00 	movabs $0x829518,%rax
  8084d8:	00 00 00 
  8084db:	48 8b 00             	mov    (%rax),%rax
  8084de:	48 89 c7             	mov    %rax,%rdi
  8084e1:	ff d2                	callq  *%rdx
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  8084e3:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  8084ea:	00 00 00 
  8084ed:	8b 00                	mov    (%rax),%eax
  8084ef:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  8084f3:	48 89 d6             	mov    %rdx,%rsi
  8084f6:	89 c7                	mov    %eax,%edi
  8084f8:	48 b8 ac e1 80 00 00 	movabs $0x80e1ac,%rax
  8084ff:	00 00 00 
  808502:	ff d0                	callq  *%rax
    switch (msg->type) {
  808504:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808508:	8b 00                	mov    (%rax),%eax
  80850a:	83 f8 01             	cmp    $0x1,%eax
  80850d:	74 3d                	je     80854c <tcpip_thread+0x126>
  80850f:	83 f8 01             	cmp    $0x1,%eax
  808512:	72 17                	jb     80852b <tcpip_thread+0x105>
  808514:	83 f8 02             	cmp    $0x2,%eax
  808517:	0f 84 a8 00 00 00    	je     8085c5 <tcpip_thread+0x19f>
  80851d:	83 f8 03             	cmp    $0x3,%eax
  808520:	0f 84 ce 00 00 00    	je     8085f4 <tcpip_thread+0x1ce>
  808526:	e9 3b 01 00 00       	jmpq   808666 <tcpip_thread+0x240>
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  80852b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80852f:	48 8b 40 10          	mov    0x10(%rax),%rax
  808533:	48 8b 10             	mov    (%rax),%rdx
  808536:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80853a:	48 8b 40 10          	mov    0x10(%rax),%rax
  80853e:	48 83 c0 08          	add    $0x8,%rax
  808542:	48 89 c7             	mov    %rax,%rdi
  808545:	ff d2                	callq  *%rdx
      break;
  808547:	e9 1b 01 00 00       	jmpq   808667 <tcpip_thread+0x241>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  80854c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808550:	48 8b 40 18          	mov    0x18(%rax),%rax
  808554:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  808558:	0f b6 c0             	movzbl %al,%eax
  80855b:	83 e0 20             	and    $0x20,%eax
  80855e:	85 c0                	test   %eax,%eax
  808560:	74 24                	je     808586 <tcpip_thread+0x160>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  808562:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808566:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80856a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80856e:	48 8b 40 10          	mov    0x10(%rax),%rax
  808572:	48 89 d6             	mov    %rdx,%rsi
  808575:	48 89 c7             	mov    %rax,%rdi
  808578:	48 b8 bd 6f 81 00 00 	movabs $0x816fbd,%rax
  80857f:	00 00 00 
  808582:	ff d0                	callq  *%rax
  808584:	eb 22                	jmp    8085a8 <tcpip_thread+0x182>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  808586:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80858a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80858e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808592:	48 8b 40 10          	mov    0x10(%rax),%rax
  808596:	48 89 d6             	mov    %rdx,%rsi
  808599:	48 89 c7             	mov    %rax,%rdi
  80859c:	48 b8 d2 0a 81 00 00 	movabs $0x810ad2,%rax
  8085a3:	00 00 00 
  8085a6:	ff d0                	callq  *%rax
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8085a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085ac:	48 89 c6             	mov    %rax,%rsi
  8085af:	bf 09 00 00 00       	mov    $0x9,%edi
  8085b4:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  8085bb:	00 00 00 
  8085be:	ff d0                	callq  *%rax
      break;
  8085c0:	e9 a2 00 00 00       	jmpq   808667 <tcpip_thread+0x241>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  8085c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085c9:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8085cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085d1:	48 8b 40 18          	mov    0x18(%rax),%rax
  8085d5:	48 89 c7             	mov    %rax,%rdi
  8085d8:	ff d2                	callq  *%rdx
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8085da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085de:	48 89 c6             	mov    %rax,%rsi
  8085e1:	bf 08 00 00 00       	mov    $0x8,%edi
  8085e6:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  8085ed:	00 00 00 
  8085f0:	ff d0                	callq  *%rax
      break;
  8085f2:	eb 73                	jmp    808667 <tcpip_thread+0x241>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  8085f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8085f8:	8b 40 10             	mov    0x10(%rax),%eax
  8085fb:	83 f8 ff             	cmp    $0xffffffff,%eax
  8085fe:	74 2a                	je     80862a <tcpip_thread+0x204>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  808600:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808604:	48 8b 50 20          	mov    0x20(%rax),%rdx
  808608:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80860c:	48 8b 48 18          	mov    0x18(%rax),%rcx
  808610:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808614:	8b 40 10             	mov    0x10(%rax),%eax
  808617:	48 89 ce             	mov    %rcx,%rsi
  80861a:	89 c7                	mov    %eax,%edi
  80861c:	48 b8 11 e4 80 00 00 	movabs $0x80e411,%rax
  808623:	00 00 00 
  808626:	ff d0                	callq  *%rax
  808628:	eb 22                	jmp    80864c <tcpip_thread+0x226>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  80862a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80862e:	48 8b 50 20          	mov    0x20(%rax),%rdx
  808632:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808636:	48 8b 40 18          	mov    0x18(%rax),%rax
  80863a:	48 89 d6             	mov    %rdx,%rsi
  80863d:	48 89 c7             	mov    %rax,%rdi
  808640:	48 b8 02 e6 80 00 00 	movabs $0x80e602,%rax
  808647:	00 00 00 
  80864a:	ff d0                	callq  *%rax
      memp_free(MEMP_TCPIP_MSG_API, msg);
  80864c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808650:	48 89 c6             	mov    %rax,%rsi
  808653:	bf 08 00 00 00       	mov    $0x8,%edi
  808658:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  80865f:	00 00 00 
  808662:	ff d0                	callq  *%rax
      break;
  808664:	eb 01                	jmp    808667 <tcpip_thread+0x241>

    default:
      break;
  808666:	90                   	nop
    }
  }
  808667:	e9 77 fe ff ff       	jmpq   8084e3 <tcpip_thread+0xbd>

000000000080866c <tcpip_input>:
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  80866c:	55                   	push   %rbp
  80866d:	48 89 e5             	mov    %rsp,%rbp
  808670:	48 83 ec 20          	sub    $0x20,%rsp
  808674:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  808678:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  80867c:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808683:	00 00 00 
  808686:	8b 00                	mov    (%rax),%eax
  808688:	83 f8 ff             	cmp    $0xffffffff,%eax
  80868b:	0f 84 90 00 00 00    	je     808721 <tcpip_input+0xb5>
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  808691:	bf 09 00 00 00       	mov    $0x9,%edi
  808696:	48 b8 41 ca 80 00 00 	movabs $0x80ca41,%rax
  80869d:	00 00 00 
  8086a0:	ff d0                	callq  *%rax
  8086a2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  8086a6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8086ab:	75 07                	jne    8086b4 <tcpip_input+0x48>
      return ERR_MEM;
  8086ad:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8086b2:	eb 72                	jmp    808726 <tcpip_input+0xba>
    }

    msg->type = TCPIP_MSG_INPKT;
  8086b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8086b8:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    msg->msg.inp.p = p;
  8086be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8086c2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8086c6:	48 89 50 10          	mov    %rdx,0x10(%rax)
    msg->msg.inp.netif = inp;
  8086ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8086ce:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8086d2:	48 89 50 18          	mov    %rdx,0x18(%rax)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8086d6:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  8086dd:	00 00 00 
  8086e0:	8b 00                	mov    (%rax),%eax
  8086e2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8086e6:	48 89 d6             	mov    %rdx,%rsi
  8086e9:	89 c7                	mov    %eax,%edi
  8086eb:	48 b8 7a 77 81 00 00 	movabs $0x81777a,%rax
  8086f2:	00 00 00 
  8086f5:	ff d0                	callq  *%rax
  8086f7:	84 c0                	test   %al,%al
  8086f9:	74 1f                	je     80871a <tcpip_input+0xae>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8086fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8086ff:	48 89 c6             	mov    %rax,%rsi
  808702:	bf 09 00 00 00       	mov    $0x9,%edi
  808707:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  80870e:	00 00 00 
  808711:	ff d0                	callq  *%rax
      return ERR_MEM;
  808713:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808718:	eb 0c                	jmp    808726 <tcpip_input+0xba>
    }
    return ERR_OK;
  80871a:	b8 00 00 00 00       	mov    $0x0,%eax
  80871f:	eb 05                	jmp    808726 <tcpip_input+0xba>
  }
  return ERR_VAL;
  808721:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  808726:	c9                   	leaveq 
  808727:	c3                   	retq   

0000000000808728 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  808728:	55                   	push   %rbp
  808729:	48 89 e5             	mov    %rsp,%rbp
  80872c:	48 83 ec 30          	sub    $0x30,%rsp
  808730:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  808734:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  808738:	89 d0                	mov    %edx,%eax
  80873a:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  80873d:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  808744:	00 00 00 
  808747:	8b 00                	mov    (%rax),%eax
  808749:	83 f8 ff             	cmp    $0xffffffff,%eax
  80874c:	0f 84 bc 00 00 00    	je     80880e <tcpip_callback_with_block+0xe6>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  808752:	bf 08 00 00 00       	mov    $0x8,%edi
  808757:	48 b8 41 ca 80 00 00 	movabs $0x80ca41,%rax
  80875e:	00 00 00 
  808761:	ff d0                	callq  *%rax
  808763:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  808767:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80876c:	75 0a                	jne    808778 <tcpip_callback_with_block+0x50>
      return ERR_MEM;
  80876e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808773:	e9 9b 00 00 00       	jmpq   808813 <tcpip_callback_with_block+0xeb>
    }

    msg->type = TCPIP_MSG_CALLBACK;
  808778:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80877c:	c7 00 02 00 00 00    	movl   $0x2,(%rax)
    msg->msg.cb.f = f;
  808782:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808786:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80878a:	48 89 50 10          	mov    %rdx,0x10(%rax)
    msg->msg.cb.ctx = ctx;
  80878e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808792:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  808796:	48 89 50 18          	mov    %rdx,0x18(%rax)
    if (block) {
  80879a:	80 7d dc 00          	cmpb   $0x0,-0x24(%rbp)
  80879e:	74 23                	je     8087c3 <tcpip_callback_with_block+0x9b>
      sys_mbox_post(mbox, msg);
  8087a0:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  8087a7:	00 00 00 
  8087aa:	8b 00                	mov    (%rax),%eax
  8087ac:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8087b0:	48 89 d6             	mov    %rdx,%rsi
  8087b3:	89 c7                	mov    %eax,%edi
  8087b5:	48 b8 18 77 81 00 00 	movabs $0x817718,%rax
  8087bc:	00 00 00 
  8087bf:	ff d0                	callq  *%rax
  8087c1:	eb 44                	jmp    808807 <tcpip_callback_with_block+0xdf>
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8087c3:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  8087ca:	00 00 00 
  8087cd:	8b 00                	mov    (%rax),%eax
  8087cf:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8087d3:	48 89 d6             	mov    %rdx,%rsi
  8087d6:	89 c7                	mov    %eax,%edi
  8087d8:	48 b8 7a 77 81 00 00 	movabs $0x81777a,%rax
  8087df:	00 00 00 
  8087e2:	ff d0                	callq  *%rax
  8087e4:	84 c0                	test   %al,%al
  8087e6:	74 1f                	je     808807 <tcpip_callback_with_block+0xdf>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  8087e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8087ec:	48 89 c6             	mov    %rax,%rsi
  8087ef:	bf 08 00 00 00       	mov    $0x8,%edi
  8087f4:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  8087fb:	00 00 00 
  8087fe:	ff d0                	callq  *%rax
        return ERR_MEM;
  808800:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808805:	eb 0c                	jmp    808813 <tcpip_callback_with_block+0xeb>
      }
    }
    return ERR_OK;
  808807:	b8 00 00 00 00       	mov    $0x0,%eax
  80880c:	eb 05                	jmp    808813 <tcpip_callback_with_block+0xeb>
  }
  return ERR_VAL;
  80880e:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  808813:	c9                   	leaveq 
  808814:	c3                   	retq   

0000000000808815 <tcpip_timeout>:

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  808815:	55                   	push   %rbp
  808816:	48 89 e5             	mov    %rsp,%rbp
  808819:	48 83 ec 30          	sub    $0x30,%rsp
  80881d:	89 7d ec             	mov    %edi,-0x14(%rbp)
  808820:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  808824:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  808828:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  80882f:	00 00 00 
  808832:	8b 00                	mov    (%rax),%eax
  808834:	83 f8 ff             	cmp    $0xffffffff,%eax
  808837:	74 77                	je     8088b0 <tcpip_timeout+0x9b>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  808839:	bf 08 00 00 00       	mov    $0x8,%edi
  80883e:	48 b8 41 ca 80 00 00 	movabs $0x80ca41,%rax
  808845:	00 00 00 
  808848:	ff d0                	callq  *%rax
  80884a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (msg == NULL) {
  80884e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808853:	75 07                	jne    80885c <tcpip_timeout+0x47>
      return ERR_MEM;
  808855:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80885a:	eb 59                	jmp    8088b5 <tcpip_timeout+0xa0>
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  80885c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808860:	c7 00 03 00 00 00    	movl   $0x3,(%rax)
    msg->msg.tmo.msecs = msecs;
  808866:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80886a:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80886d:	89 50 10             	mov    %edx,0x10(%rax)
    msg->msg.tmo.h = h;
  808870:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808874:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  808878:	48 89 50 18          	mov    %rdx,0x18(%rax)
    msg->msg.tmo.arg = arg;
  80887c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808880:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  808884:	48 89 50 20          	mov    %rdx,0x20(%rax)
    sys_mbox_post(mbox, msg);
  808888:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  80888f:	00 00 00 
  808892:	8b 00                	mov    (%rax),%eax
  808894:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808898:	48 89 d6             	mov    %rdx,%rsi
  80889b:	89 c7                	mov    %eax,%edi
  80889d:	48 b8 18 77 81 00 00 	movabs $0x817718,%rax
  8088a4:	00 00 00 
  8088a7:	ff d0                	callq  *%rax
    return ERR_OK;
  8088a9:	b8 00 00 00 00       	mov    $0x0,%eax
  8088ae:	eb 05                	jmp    8088b5 <tcpip_timeout+0xa0>
  }
  return ERR_VAL;
  8088b0:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  8088b5:	c9                   	leaveq 
  8088b6:	c3                   	retq   

00000000008088b7 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  8088b7:	55                   	push   %rbp
  8088b8:	48 89 e5             	mov    %rsp,%rbp
  8088bb:	48 83 ec 40          	sub    $0x40,%rsp
  8088bf:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  8088c3:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  8088ca:	00 00 00 
  8088cd:	8b 00                	mov    (%rax),%eax
  8088cf:	83 f8 ff             	cmp    $0xffffffff,%eax
  8088d2:	74 55                	je     808929 <tcpip_apimsg+0x72>
    msg.type = TCPIP_MSG_API;
  8088d4:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%rbp)
    msg.msg.apimsg = apimsg;
  8088db:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8088df:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    sys_mbox_post(mbox, &msg);
  8088e3:	48 b8 78 81 82 00 00 	movabs $0x828178,%rax
  8088ea:	00 00 00 
  8088ed:	8b 00                	mov    (%rax),%eax
  8088ef:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8088f3:	48 89 d6             	mov    %rdx,%rsi
  8088f6:	89 c7                	mov    %eax,%edi
  8088f8:	48 b8 18 77 81 00 00 	movabs $0x817718,%rax
  8088ff:	00 00 00 
  808902:	ff d0                	callq  *%rax
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  808904:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  808908:	48 8b 40 08          	mov    0x8(%rax),%rax
  80890c:	8b 40 14             	mov    0x14(%rax),%eax
  80890f:	be 00 00 00 00       	mov    $0x0,%esi
  808914:	89 c7                	mov    %eax,%edi
  808916:	48 b8 46 7d 81 00 00 	movabs $0x817d46,%rax
  80891d:	00 00 00 
  808920:	ff d0                	callq  *%rax
    return ERR_OK;
  808922:	b8 00 00 00 00       	mov    $0x0,%eax
  808927:	eb 05                	jmp    80892e <tcpip_apimsg+0x77>
  }
  return ERR_VAL;
  808929:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  80892e:	c9                   	leaveq 
  80892f:	c3                   	retq   

0000000000808930 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  808930:	55                   	push   %rbp
  808931:	48 89 e5             	mov    %rsp,%rbp
  808934:	48 83 ec 10          	sub    $0x10,%rsp
  808938:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80893c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  lwip_init();
  808940:	48 b8 de 8f 80 00 00 	movabs $0x808fde,%rax
  808947:	00 00 00 
  80894a:	ff d0                	callq  *%rax

  tcpip_init_done = initfunc;
  80894c:	48 b8 10 95 82 00 00 	movabs $0x829510,%rax
  808953:	00 00 00 
  808956:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80895a:	48 89 10             	mov    %rdx,(%rax)
  tcpip_init_done_arg = arg;
  80895d:	48 b8 18 95 82 00 00 	movabs $0x829518,%rax
  808964:	00 00 00 
  808967:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80896b:	48 89 10             	mov    %rdx,(%rax)
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  80896e:	bf 00 00 00 00       	mov    $0x0,%edi
  808973:	48 b8 16 73 81 00 00 	movabs $0x817316,%rax
  80897a:	00 00 00 
  80897d:	ff d0                	callq  *%rax
  80897f:	48 ba 78 81 82 00 00 	movabs $0x828178,%rdx
  808986:	00 00 00 
  808989:	89 02                	mov    %eax,(%rdx)
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  80898b:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  808991:	b9 00 00 00 00       	mov    $0x0,%ecx
  808996:	ba 00 00 00 00       	mov    $0x0,%edx
  80899b:	48 be 26 84 80 00 00 	movabs $0x808426,%rsi
  8089a2:	00 00 00 
  8089a5:	48 bf 93 14 82 00 00 	movabs $0x821493,%rdi
  8089ac:	00 00 00 
  8089af:	48 b8 6d 82 81 00 00 	movabs $0x81826d,%rax
  8089b6:	00 00 00 
  8089b9:	ff d0                	callq  *%rax
}
  8089bb:	c9                   	leaveq 
  8089bc:	c3                   	retq   

00000000008089bd <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  8089bd:	55                   	push   %rbp
  8089be:	48 89 e5             	mov    %rsp,%rbp
  8089c1:	48 83 ec 20          	sub    $0x20,%rsp
  8089c5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct pbuf *q = p;
  8089c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8089cd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  pbuf_free(q);
  8089d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089d5:	48 89 c7             	mov    %rax,%rdi
  8089d8:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  8089df:	00 00 00 
  8089e2:	ff d0                	callq  *%rax
}
  8089e4:	c9                   	leaveq 
  8089e5:	c3                   	retq   

00000000008089e6 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  8089e6:	55                   	push   %rbp
  8089e7:	48 89 e5             	mov    %rsp,%rbp
  8089ea:	48 83 ec 10          	sub    $0x10,%rsp
  8089ee:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  8089f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8089f6:	ba 00 00 00 00       	mov    $0x0,%edx
  8089fb:	48 89 c6             	mov    %rax,%rsi
  8089fe:	48 bf bd 89 80 00 00 	movabs $0x8089bd,%rdi
  808a05:	00 00 00 
  808a08:	48 b8 28 87 80 00 00 	movabs $0x808728,%rax
  808a0f:	00 00 00 
  808a12:	ff d0                	callq  *%rax
}
  808a14:	c9                   	leaveq 
  808a15:	c3                   	retq   

0000000000808a16 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  808a16:	55                   	push   %rbp
  808a17:	48 89 e5             	mov    %rsp,%rbp
  808a1a:	48 83 ec 10          	sub    $0x10,%rsp
  808a1e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return tcpip_callback_with_block(mem_free, m, 0);
  808a22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a26:	ba 00 00 00 00       	mov    $0x0,%edx
  808a2b:	48 89 c6             	mov    %rax,%rsi
  808a2e:	48 bf d3 c0 80 00 00 	movabs $0x80c0d3,%rdi
  808a35:	00 00 00 
  808a38:	48 b8 28 87 80 00 00 	movabs $0x808728,%rax
  808a3f:	00 00 00 
  808a42:	ff d0                	callq  *%rax
}
  808a44:	c9                   	leaveq 
  808a45:	c3                   	retq   
	...

0000000000808a48 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  808a48:	55                   	push   %rbp
  808a49:	48 89 e5             	mov    %rsp,%rbp
  808a4c:	48 83 ec 10          	sub    $0x10,%rsp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  808a50:	bf 06 00 00 00       	mov    $0x6,%edi
  808a55:	48 b8 41 ca 80 00 00 	movabs $0x80ca41,%rax
  808a5c:	00 00 00 
  808a5f:	ff d0                	callq  *%rax
  808a61:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (buf != NULL) {
  808a65:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808a6a:	74 29                	je     808a95 <netbuf_new+0x4d>
    buf->p = NULL;
  808a6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a70:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    buf->ptr = NULL;
  808a77:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a7b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  808a82:	00 
    buf->addr = NULL;
  808a83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a87:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  808a8e:	00 
    return buf;
  808a8f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808a93:	eb 05                	jmp    808a9a <netbuf_new+0x52>
  } else {
    return NULL;
  808a95:	b8 00 00 00 00       	mov    $0x0,%eax
  }
}
  808a9a:	c9                   	leaveq 
  808a9b:	c3                   	retq   

0000000000808a9c <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  808a9c:	55                   	push   %rbp
  808a9d:	48 89 e5             	mov    %rsp,%rbp
  808aa0:	48 83 ec 10          	sub    $0x10,%rsp
  808aa4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (buf != NULL) {
  808aa8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808aad:	74 55                	je     808b04 <netbuf_delete+0x68>
    if (buf->p != NULL) {
  808aaf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ab3:	48 8b 00             	mov    (%rax),%rax
  808ab6:	48 85 c0             	test   %rax,%rax
  808ab9:	74 31                	je     808aec <netbuf_delete+0x50>
      pbuf_free(buf->p);
  808abb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808abf:	48 8b 00             	mov    (%rax),%rax
  808ac2:	48 89 c7             	mov    %rax,%rdi
  808ac5:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  808acc:	00 00 00 
  808acf:	ff d0                	callq  *%rax
      buf->p = buf->ptr = NULL;
  808ad1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ad5:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  808adc:	00 
  808add:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ae1:	48 8b 50 08          	mov    0x8(%rax),%rdx
  808ae5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ae9:	48 89 10             	mov    %rdx,(%rax)
    }
    memp_free(MEMP_NETBUF, buf);
  808aec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808af0:	48 89 c6             	mov    %rax,%rsi
  808af3:	bf 06 00 00 00       	mov    $0x6,%edi
  808af8:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  808aff:	00 00 00 
  808b02:	ff d0                	callq  *%rax
  }
}
  808b04:	c9                   	leaveq 
  808b05:	c3                   	retq   

0000000000808b06 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  808b06:	55                   	push   %rbp
  808b07:	48 89 e5             	mov    %rsp,%rbp
  808b0a:	48 83 ec 10          	sub    $0x10,%rsp
  808b0e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808b12:	89 f0                	mov    %esi,%eax
  808b14:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  808b18:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808b1d:	75 2a                	jne    808b49 <netbuf_alloc+0x43>
  808b1f:	48 ba a0 14 82 00 00 	movabs $0x8214a0,%rdx
  808b26:	00 00 00 
  808b29:	be 63 00 00 00       	mov    $0x63,%esi
  808b2e:	48 bf ba 14 82 00 00 	movabs $0x8214ba,%rdi
  808b35:	00 00 00 
  808b38:	b8 00 00 00 00       	mov    $0x0,%eax
  808b3d:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  808b44:	00 00 00 
  808b47:	ff d1                	callq  *%rcx

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  808b49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b4d:	48 8b 00             	mov    (%rax),%rax
  808b50:	48 85 c0             	test   %rax,%rax
  808b53:	74 16                	je     808b6b <netbuf_alloc+0x65>
    pbuf_free(buf->p);
  808b55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b59:	48 8b 00             	mov    (%rax),%rax
  808b5c:	48 89 c7             	mov    %rax,%rdi
  808b5f:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  808b66:	00 00 00 
  808b69:	ff d0                	callq  *%rax
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  808b6b:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  808b6f:	ba 00 00 00 00       	mov    $0x0,%edx
  808b74:	89 c6                	mov    %eax,%esi
  808b76:	bf 00 00 00 00       	mov    $0x0,%edi
  808b7b:	48 b8 4c d0 80 00 00 	movabs $0x80d04c,%rax
  808b82:	00 00 00 
  808b85:	ff d0                	callq  *%rax
  808b87:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808b8b:	48 89 02             	mov    %rax,(%rdx)
  if (buf->p == NULL) {
  808b8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808b92:	48 8b 00             	mov    (%rax),%rax
  808b95:	48 85 c0             	test   %rax,%rax
  808b98:	75 07                	jne    808ba1 <netbuf_alloc+0x9b>
     return NULL;
  808b9a:	b8 00 00 00 00       	mov    $0x0,%eax
  808b9f:	eb 55                	jmp    808bf6 <netbuf_alloc+0xf0>
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  808ba1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ba5:	48 8b 00             	mov    (%rax),%rax
  808ba8:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  808bac:	66 3b 45 f4          	cmp    -0xc(%rbp),%ax
  808bb0:	73 2a                	jae    808bdc <netbuf_alloc+0xd6>
  808bb2:	48 ba d0 14 82 00 00 	movabs $0x8214d0,%rdx
  808bb9:	00 00 00 
  808bbc:	be 6e 00 00 00       	mov    $0x6e,%esi
  808bc1:	48 bf ba 14 82 00 00 	movabs $0x8214ba,%rdi
  808bc8:	00 00 00 
  808bcb:	b8 00 00 00 00       	mov    $0x0,%eax
  808bd0:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  808bd7:	00 00 00 
  808bda:	ff d1                	callq  *%rcx
             (buf->p->len >= size));
  buf->ptr = buf->p;
  808bdc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808be0:	48 8b 10             	mov    (%rax),%rdx
  808be3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808be7:	48 89 50 08          	mov    %rdx,0x8(%rax)
  return buf->p->payload;
  808beb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808bef:	48 8b 00             	mov    (%rax),%rax
  808bf2:	48 8b 40 08          	mov    0x8(%rax),%rax
}
  808bf6:	c9                   	leaveq 
  808bf7:	c3                   	retq   

0000000000808bf8 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  808bf8:	55                   	push   %rbp
  808bf9:	48 89 e5             	mov    %rsp,%rbp
  808bfc:	48 83 ec 10          	sub    $0x10,%rsp
  808c00:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  808c04:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808c09:	75 2a                	jne    808c35 <netbuf_free+0x3d>
  808c0b:	48 ba f4 14 82 00 00 	movabs $0x8214f4,%rdx
  808c12:	00 00 00 
  808c15:	be 7b 00 00 00       	mov    $0x7b,%esi
  808c1a:	48 bf ba 14 82 00 00 	movabs $0x8214ba,%rdi
  808c21:	00 00 00 
  808c24:	b8 00 00 00 00       	mov    $0x0,%eax
  808c29:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  808c30:	00 00 00 
  808c33:	ff d1                	callq  *%rcx
  if (buf->p != NULL) {
  808c35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c39:	48 8b 00             	mov    (%rax),%rax
  808c3c:	48 85 c0             	test   %rax,%rax
  808c3f:	74 16                	je     808c57 <netbuf_free+0x5f>
    pbuf_free(buf->p);
  808c41:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c45:	48 8b 00             	mov    (%rax),%rax
  808c48:	48 89 c7             	mov    %rax,%rdi
  808c4b:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  808c52:	00 00 00 
  808c55:	ff d0                	callq  *%rax
  }
  buf->p = buf->ptr = NULL;
  808c57:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c5b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  808c62:	00 
  808c63:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c67:	48 8b 50 08          	mov    0x8(%rax),%rdx
  808c6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808c6f:	48 89 10             	mov    %rdx,(%rax)
}
  808c72:	c9                   	leaveq 
  808c73:	c3                   	retq   

0000000000808c74 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  808c74:	55                   	push   %rbp
  808c75:	48 89 e5             	mov    %rsp,%rbp
  808c78:	48 83 ec 20          	sub    $0x20,%rsp
  808c7c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808c80:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  808c84:	89 d0                	mov    %edx,%eax
  808c86:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  808c8a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808c8f:	75 2a                	jne    808cbb <netbuf_ref+0x47>
  808c91:	48 ba 0d 15 82 00 00 	movabs $0x82150d,%rdx
  808c98:	00 00 00 
  808c9b:	be 8e 00 00 00       	mov    $0x8e,%esi
  808ca0:	48 bf ba 14 82 00 00 	movabs $0x8214ba,%rdi
  808ca7:	00 00 00 
  808caa:	b8 00 00 00 00       	mov    $0x0,%eax
  808caf:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  808cb6:	00 00 00 
  808cb9:	ff d1                	callq  *%rcx
  if (buf->p != NULL) {
  808cbb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808cbf:	48 8b 00             	mov    (%rax),%rax
  808cc2:	48 85 c0             	test   %rax,%rax
  808cc5:	74 16                	je     808cdd <netbuf_ref+0x69>
    pbuf_free(buf->p);
  808cc7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ccb:	48 8b 00             	mov    (%rax),%rax
  808cce:	48 89 c7             	mov    %rax,%rdi
  808cd1:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  808cd8:	00 00 00 
  808cdb:	ff d0                	callq  *%rax
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  808cdd:	ba 02 00 00 00       	mov    $0x2,%edx
  808ce2:	be 00 00 00 00       	mov    $0x0,%esi
  808ce7:	bf 00 00 00 00       	mov    $0x0,%edi
  808cec:	48 b8 4c d0 80 00 00 	movabs $0x80d04c,%rax
  808cf3:	00 00 00 
  808cf6:	ff d0                	callq  *%rax
  808cf8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  808cfc:	48 89 02             	mov    %rax,(%rdx)
  if (buf->p == NULL) {
  808cff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d03:	48 8b 00             	mov    (%rax),%rax
  808d06:	48 85 c0             	test   %rax,%rax
  808d09:	75 13                	jne    808d1e <netbuf_ref+0xaa>
    buf->ptr = NULL;
  808d0b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d0f:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  808d16:	00 
    return ERR_MEM;
  808d17:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808d1c:	eb 41                	jmp    808d5f <netbuf_ref+0xeb>
  }
  buf->p->payload = (void*)dataptr;
  808d1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d22:	48 8b 00             	mov    (%rax),%rax
  808d25:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  808d29:	48 89 50 08          	mov    %rdx,0x8(%rax)
  buf->p->len = buf->p->tot_len = size;
  808d2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d31:	48 8b 10             	mov    (%rax),%rdx
  808d34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d38:	48 8b 00             	mov    (%rax),%rax
  808d3b:	0f b7 4d ec          	movzwl -0x14(%rbp),%ecx
  808d3f:	66 89 48 10          	mov    %cx,0x10(%rax)
  808d43:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  808d47:	66 89 42 12          	mov    %ax,0x12(%rdx)
  buf->ptr = buf->p;
  808d4b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d4f:	48 8b 10             	mov    (%rax),%rdx
  808d52:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808d56:	48 89 50 08          	mov    %rdx,0x8(%rax)
  return ERR_OK;
  808d5a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808d5f:	c9                   	leaveq 
  808d60:	c3                   	retq   

0000000000808d61 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  808d61:	55                   	push   %rbp
  808d62:	48 89 e5             	mov    %rsp,%rbp
  808d65:	48 83 ec 10          	sub    $0x10,%rsp
  808d69:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808d6d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  808d71:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808d76:	75 2a                	jne    808da2 <netbuf_chain+0x41>
  808d78:	48 ba 25 15 82 00 00 	movabs $0x821525,%rdx
  808d7f:	00 00 00 
  808d82:	be a6 00 00 00       	mov    $0xa6,%esi
  808d87:	48 bf ba 14 82 00 00 	movabs $0x8214ba,%rdi
  808d8e:	00 00 00 
  808d91:	b8 00 00 00 00       	mov    $0x0,%eax
  808d96:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  808d9d:	00 00 00 
  808da0:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  808da2:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  808da7:	75 2a                	jne    808dd3 <netbuf_chain+0x72>
  808da9:	48 ba 3e 15 82 00 00 	movabs $0x82153e,%rdx
  808db0:	00 00 00 
  808db3:	be a7 00 00 00       	mov    $0xa7,%esi
  808db8:	48 bf ba 14 82 00 00 	movabs $0x8214ba,%rdi
  808dbf:	00 00 00 
  808dc2:	b8 00 00 00 00       	mov    $0x0,%eax
  808dc7:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  808dce:	00 00 00 
  808dd1:	ff d1                	callq  *%rcx
  pbuf_chain(head->p, tail->p);
  808dd3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808dd7:	48 8b 10             	mov    (%rax),%rdx
  808dda:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808dde:	48 8b 00             	mov    (%rax),%rax
  808de1:	48 89 d6             	mov    %rdx,%rsi
  808de4:	48 89 c7             	mov    %rax,%rdi
  808de7:	48 b8 56 dc 80 00 00 	movabs $0x80dc56,%rax
  808dee:	00 00 00 
  808df1:	ff d0                	callq  *%rax
  head->ptr = head->p;
  808df3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808df7:	48 8b 10             	mov    (%rax),%rdx
  808dfa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808dfe:	48 89 50 08          	mov    %rdx,0x8(%rax)
  memp_free(MEMP_NETBUF, tail);
  808e02:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808e06:	48 89 c6             	mov    %rax,%rsi
  808e09:	bf 06 00 00 00       	mov    $0x6,%edi
  808e0e:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  808e15:	00 00 00 
  808e18:	ff d0                	callq  *%rax
}
  808e1a:	c9                   	leaveq 
  808e1b:	c3                   	retq   

0000000000808e1c <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  808e1c:	55                   	push   %rbp
  808e1d:	48 89 e5             	mov    %rsp,%rbp
  808e20:	48 83 ec 20          	sub    $0x20,%rsp
  808e24:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  808e28:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  808e2c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  808e30:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808e35:	75 2a                	jne    808e61 <netbuf_data+0x45>
  808e37:	48 ba 59 15 82 00 00 	movabs $0x821559,%rdx
  808e3e:	00 00 00 
  808e41:	be b9 00 00 00       	mov    $0xb9,%esi
  808e46:	48 bf ba 14 82 00 00 	movabs $0x8214ba,%rdi
  808e4d:	00 00 00 
  808e50:	b8 00 00 00 00       	mov    $0x0,%eax
  808e55:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  808e5c:	00 00 00 
  808e5f:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  808e61:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  808e66:	75 2a                	jne    808e92 <netbuf_data+0x76>
  808e68:	48 ba 72 15 82 00 00 	movabs $0x821572,%rdx
  808e6f:	00 00 00 
  808e72:	be ba 00 00 00       	mov    $0xba,%esi
  808e77:	48 bf ba 14 82 00 00 	movabs $0x8214ba,%rdi
  808e7e:	00 00 00 
  808e81:	b8 00 00 00 00       	mov    $0x0,%eax
  808e86:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  808e8d:	00 00 00 
  808e90:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  808e92:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  808e97:	75 2a                	jne    808ec3 <netbuf_data+0xa7>
  808e99:	48 ba 8f 15 82 00 00 	movabs $0x82158f,%rdx
  808ea0:	00 00 00 
  808ea3:	be bb 00 00 00       	mov    $0xbb,%esi
  808ea8:	48 bf ba 14 82 00 00 	movabs $0x8214ba,%rdi
  808eaf:	00 00 00 
  808eb2:	b8 00 00 00 00       	mov    $0x0,%eax
  808eb7:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  808ebe:	00 00 00 
  808ec1:	ff d1                	callq  *%rcx

  if (buf->ptr == NULL) {
  808ec3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808ec7:	48 8b 40 08          	mov    0x8(%rax),%rax
  808ecb:	48 85 c0             	test   %rax,%rax
  808ece:	75 07                	jne    808ed7 <netbuf_data+0xbb>
    return ERR_BUF;
  808ed0:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  808ed5:	eb 2b                	jmp    808f02 <netbuf_data+0xe6>
  }
  *dataptr = buf->ptr->payload;
  808ed7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808edb:	48 8b 40 08          	mov    0x8(%rax),%rax
  808edf:	48 8b 50 08          	mov    0x8(%rax),%rdx
  808ee3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  808ee7:	48 89 10             	mov    %rdx,(%rax)
  *len = buf->ptr->len;
  808eea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808eee:	48 8b 40 08          	mov    0x8(%rax),%rax
  808ef2:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  808ef6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  808efa:	66 89 10             	mov    %dx,(%rax)
  return ERR_OK;
  808efd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808f02:	c9                   	leaveq 
  808f03:	c3                   	retq   

0000000000808f04 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  808f04:	55                   	push   %rbp
  808f05:	48 89 e5             	mov    %rsp,%rbp
  808f08:	48 83 ec 10          	sub    $0x10,%rsp
  808f0c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  808f10:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808f15:	75 2a                	jne    808f41 <netbuf_next+0x3d>
  808f17:	48 ba f4 14 82 00 00 	movabs $0x8214f4,%rdx
  808f1e:	00 00 00 
  808f21:	be d2 00 00 00       	mov    $0xd2,%esi
  808f26:	48 bf ba 14 82 00 00 	movabs $0x8214ba,%rdi
  808f2d:	00 00 00 
  808f30:	b8 00 00 00 00       	mov    $0x0,%eax
  808f35:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  808f3c:	00 00 00 
  808f3f:	ff d1                	callq  *%rcx
  if (buf->ptr->next == NULL) {
  808f41:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f45:	48 8b 40 08          	mov    0x8(%rax),%rax
  808f49:	48 8b 00             	mov    (%rax),%rax
  808f4c:	48 85 c0             	test   %rax,%rax
  808f4f:	75 07                	jne    808f58 <netbuf_next+0x54>
    return -1;
  808f51:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808f56:	eb 2f                	jmp    808f87 <netbuf_next+0x83>
  }
  buf->ptr = buf->ptr->next;
  808f58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f5c:	48 8b 40 08          	mov    0x8(%rax),%rax
  808f60:	48 8b 10             	mov    (%rax),%rdx
  808f63:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f67:	48 89 50 08          	mov    %rdx,0x8(%rax)
  if (buf->ptr->next == NULL) {
  808f6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808f6f:	48 8b 40 08          	mov    0x8(%rax),%rax
  808f73:	48 8b 00             	mov    (%rax),%rax
  808f76:	48 85 c0             	test   %rax,%rax
  808f79:	75 07                	jne    808f82 <netbuf_next+0x7e>
    return 1;
  808f7b:	b8 01 00 00 00       	mov    $0x1,%eax
  808f80:	eb 05                	jmp    808f87 <netbuf_next+0x83>
  }
  return 0;
  808f82:	b8 00 00 00 00       	mov    $0x0,%eax
}
  808f87:	c9                   	leaveq 
  808f88:	c3                   	retq   

0000000000808f89 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  808f89:	55                   	push   %rbp
  808f8a:	48 89 e5             	mov    %rsp,%rbp
  808f8d:	48 83 ec 10          	sub    $0x10,%rsp
  808f91:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  808f95:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  808f9a:	75 2a                	jne    808fc6 <netbuf_first+0x3d>
  808f9c:	48 ba f4 14 82 00 00 	movabs $0x8214f4,%rdx
  808fa3:	00 00 00 
  808fa6:	be e7 00 00 00       	mov    $0xe7,%esi
  808fab:	48 bf ba 14 82 00 00 	movabs $0x8214ba,%rdi
  808fb2:	00 00 00 
  808fb5:	b8 00 00 00 00       	mov    $0x0,%eax
  808fba:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  808fc1:	00 00 00 
  808fc4:	ff d1                	callq  *%rcx
  buf->ptr = buf->p;
  808fc6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808fca:	48 8b 10             	mov    (%rax),%rdx
  808fcd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  808fd1:	48 89 50 08          	mov    %rdx,0x8(%rax)
}
  808fd5:	c9                   	leaveq 
  808fd6:	c3                   	retq   
	...

0000000000808fd8 <lwip_sanity_check>:
#endif

#ifdef LWIP_DEBUG
static void
lwip_sanity_check(void)
{
  808fd8:	55                   	push   %rbp
  808fd9:	48 89 e5             	mov    %rsp,%rbp
  if (TCP_WND > (PBUF_POOL_SIZE*PBUF_POOL_BUFSIZE))
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_WND is larger than space provided by PBUF_POOL_SIZE*PBUF_POOL_BUFSIZE\n"));
  if (TCP_WND < TCP_MSS)
    LWIP_PLATFORM_DIAG(("lwip_sanity_check: WARNING: TCP_WND is smaller than MSS\n"));
#endif /* LWIP_TCP */
}
  808fdc:	5d                   	pop    %rbp
  808fdd:	c3                   	retq   

0000000000808fde <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  808fde:	55                   	push   %rbp
  808fdf:	48 89 e5             	mov    %rsp,%rbp
  /* Sanity check user-configurable values */
  lwip_sanity_check();
  808fe2:	48 b8 d8 8f 80 00 00 	movabs $0x808fd8,%rax
  808fe9:	00 00 00 
  808fec:	ff d0                	callq  *%rax

  /* Modules initialization */
  stats_init();
  sys_init();
  808fee:	48 b8 d0 70 81 00 00 	movabs $0x8170d0,%rax
  808ff5:	00 00 00 
  808ff8:	ff d0                	callq  *%rax
  mem_init();
  808ffa:	48 b8 e9 bf 80 00 00 	movabs $0x80bfe9,%rax
  809001:	00 00 00 
  809004:	ff d0                	callq  *%rax
  memp_init();
  809006:	48 b8 60 c9 80 00 00 	movabs $0x80c960,%rax
  80900d:	00 00 00 
  809010:	ff d0                	callq  *%rax
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  809012:	48 b8 00 59 80 00 00 	movabs $0x805900,%rax
  809019:	00 00 00 
  80901c:	ff d0                	callq  *%rax
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  80901e:	5d                   	pop    %rbp
  80901f:	c3                   	retq   

0000000000809020 <dhcp_handle_nak>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  809020:	55                   	push   %rbp
  809021:	48 89 e5             	mov    %rsp,%rbp
  809024:	48 83 ec 20          	sub    $0x20,%rsp
  809028:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80902c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809030:	48 8b 40 38          	mov    0x38(%rax),%rax
  809034:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  809038:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80903c:	48 89 c7             	mov    %rax,%rdi
  80903f:	48 b8 ff cf 80 00 00 	movabs $0x80cfff,%rax
  809046:	00 00 00 
  809049:	ff d0                	callq  *%rax
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  80904b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80904f:	48 be a8 23 82 00 00 	movabs $0x8223a8,%rsi
  809056:	00 00 00 
  809059:	48 89 c7             	mov    %rax,%rdi
  80905c:	48 b8 17 ce 80 00 00 	movabs $0x80ce17,%rax
  809063:	00 00 00 
  809066:	ff d0                	callq  *%rax
  netif_set_gw(netif, IP_ADDR_ANY);
  809068:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80906c:	48 be a8 23 82 00 00 	movabs $0x8223a8,%rsi
  809073:	00 00 00 
  809076:	48 89 c7             	mov    %rax,%rdi
  809079:	48 b8 1d cf 80 00 00 	movabs $0x80cf1d,%rax
  809080:	00 00 00 
  809083:	ff d0                	callq  *%rax
  netif_set_netmask(netif, IP_ADDR_ANY); 
  809085:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809089:	48 be a8 23 82 00 00 	movabs $0x8223a8,%rsi
  809090:	00 00 00 
  809093:	48 89 c7             	mov    %rax,%rdi
  809096:	48 b8 4a cf 80 00 00 	movabs $0x80cf4a,%rax
  80909d:	00 00 00 
  8090a0:	ff d0                	callq  *%rax
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  8090a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8090a6:	be 0c 00 00 00       	mov    $0xc,%esi
  8090ab:	48 89 c7             	mov    %rax,%rdi
  8090ae:	48 b8 d7 ad 80 00 00 	movabs $0x80add7,%rax
  8090b5:	00 00 00 
  8090b8:	ff d0                	callq  *%rax
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  8090ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8090be:	48 89 c7             	mov    %rax,%rdi
  8090c1:	48 b8 da a1 80 00 00 	movabs $0x80a1da,%rax
  8090c8:	00 00 00 
  8090cb:	ff d0                	callq  *%rax
}
  8090cd:	c9                   	leaveq 
  8090ce:	c3                   	retq   

00000000008090cf <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  8090cf:	55                   	push   %rbp
  8090d0:	48 89 e5             	mov    %rsp,%rbp
  8090d3:	48 83 ec 20          	sub    $0x20,%rsp
  8090d7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  8090db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8090df:	48 8b 40 38          	mov    0x38(%rax),%rax
  8090e3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  8090e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8090eb:	48 8d 48 4c          	lea    0x4c(%rax),%rcx
  8090ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8090f3:	ba 00 00 00 00       	mov    $0x0,%edx
  8090f8:	48 89 ce             	mov    %rcx,%rsi
  8090fb:	48 89 c7             	mov    %rax,%rdi
  8090fe:	48 b8 7b 68 81 00 00 	movabs $0x81687b,%rax
  809105:	00 00 00 
  809108:	ff d0                	callq  *%rax
  80910a:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  80910d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809111:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809115:	8d 50 01             	lea    0x1(%rax),%edx
  809118:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80911c:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = 500;
  80911f:	66 c7 45 f4 f4 01    	movw   $0x1f4,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  809125:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  809129:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80912f:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  809134:	89 c8                	mov    %ecx,%eax
  809136:	f7 ea                	imul   %edx
  809138:	c1 fa 05             	sar    $0x5,%edx
  80913b:	89 c8                	mov    %ecx,%eax
  80913d:	c1 f8 1f             	sar    $0x1f,%eax
  809140:	89 d1                	mov    %edx,%ecx
  809142:	29 c1                	sub    %eax,%ecx
  809144:	89 c8                	mov    %ecx,%eax
  809146:	89 c2                	mov    %eax,%edx
  809148:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80914c:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  809150:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809154:	be 08 00 00 00       	mov    $0x8,%esi
  809159:	48 89 c7             	mov    %rax,%rdi
  80915c:	48 b8 d7 ad 80 00 00 	movabs $0x80add7,%rax
  809163:	00 00 00 
  809166:	ff d0                	callq  *%rax
}
  809168:	c9                   	leaveq 
  809169:	c3                   	retq   

000000000080916a <dhcp_handle_offer>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  80916a:	55                   	push   %rbp
  80916b:	48 89 e5             	mov    %rsp,%rbp
  80916e:	48 83 ec 20          	sub    $0x20,%rsp
  809172:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809176:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80917a:	48 8b 40 38          	mov    0x38(%rax),%rax
  80917e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  809182:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809186:	be 36 00 00 00       	mov    $0x36,%esi
  80918b:	48 89 c7             	mov    %rax,%rdi
  80918e:	48 b8 a5 bb 80 00 00 	movabs $0x80bba5,%rax
  809195:	00 00 00 
  809198:	ff d0                	callq  *%rax
  80919a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  80919e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8091a3:	74 69                	je     80920e <dhcp_handle_offer+0xa4>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8091a5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8091a9:	48 83 c0 02          	add    $0x2,%rax
  8091ad:	48 89 c7             	mov    %rax,%rdi
  8091b0:	48 b8 46 bd 80 00 00 	movabs $0x80bd46,%rax
  8091b7:	00 00 00 
  8091ba:	ff d0                	callq  *%rax
  8091bc:	89 c7                	mov    %eax,%edi
  8091be:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  8091c5:	00 00 00 
  8091c8:	ff d0                	callq  *%rax
  8091ca:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8091ce:	89 42 48             	mov    %eax,0x48(%rdx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  8091d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8091d5:	48 8b 40 18          	mov    0x18(%rax),%rax
  8091d9:	48 83 c0 10          	add    $0x10,%rax
  8091dd:	48 85 c0             	test   %rax,%rax
  8091e0:	74 0d                	je     8091ef <dhcp_handle_offer+0x85>
  8091e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8091e6:	48 8b 40 18          	mov    0x18(%rax),%rax
  8091ea:	8b 40 10             	mov    0x10(%rax),%eax
  8091ed:	eb 05                	jmp    8091f4 <dhcp_handle_offer+0x8a>
  8091ef:	b8 00 00 00 00       	mov    $0x0,%eax
  8091f4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8091f8:	89 42 4c             	mov    %eax,0x4c(%rdx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  8091fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8091ff:	48 89 c7             	mov    %rax,%rdi
  809202:	48 b8 10 92 80 00 00 	movabs $0x809210,%rax
  809209:	00 00 00 
  80920c:	ff d0                	callq  *%rax
  }
}
  80920e:	c9                   	leaveq 
  80920f:	c3                   	retq   

0000000000809210 <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  809210:	55                   	push   %rbp
  809211:	48 89 e5             	mov    %rsp,%rbp
  809214:	48 83 ec 20          	sub    $0x20,%rsp
  809218:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80921c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809220:	48 8b 40 38          	mov    0x38(%rax),%rax
  809224:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  809228:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80922c:	48 89 c7             	mov    %rax,%rdi
  80922f:	48 b8 e4 b5 80 00 00 	movabs $0x80b5e4,%rax
  809236:	00 00 00 
  809239:	ff d0                	callq  *%rax
  80923b:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80923e:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  809242:	0f 85 3a 02 00 00    	jne    809482 <dhcp_select+0x272>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  809248:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80924c:	ba 01 00 00 00       	mov    $0x1,%edx
  809251:	be 35 00 00 00       	mov    $0x35,%esi
  809256:	48 89 c7             	mov    %rax,%rdi
  809259:	48 b8 08 ae 80 00 00 	movabs $0x80ae08,%rax
  809260:	00 00 00 
  809263:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  809265:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809269:	be 03 00 00 00       	mov    $0x3,%esi
  80926e:	48 89 c7             	mov    %rax,%rdi
  809271:	48 b8 bd ae 80 00 00 	movabs $0x80aebd,%rax
  809278:	00 00 00 
  80927b:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80927d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809281:	ba 02 00 00 00       	mov    $0x2,%edx
  809286:	be 39 00 00 00       	mov    $0x39,%esi
  80928b:	48 89 c7             	mov    %rax,%rdi
  80928e:	48 b8 08 ae 80 00 00 	movabs $0x80ae08,%rax
  809295:	00 00 00 
  809298:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80929a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80929e:	be 40 02 00 00       	mov    $0x240,%esi
  8092a3:	48 89 c7             	mov    %rax,%rdi
  8092a6:	48 b8 35 af 80 00 00 	movabs $0x80af35,%rax
  8092ad:	00 00 00 
  8092b0:	ff d0                	callq  *%rax

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8092b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8092b6:	ba 04 00 00 00       	mov    $0x4,%edx
  8092bb:	be 32 00 00 00       	mov    $0x32,%esi
  8092c0:	48 89 c7             	mov    %rax,%rdi
  8092c3:	48 b8 08 ae 80 00 00 	movabs $0x80ae08,%rax
  8092ca:	00 00 00 
  8092cd:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8092cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8092d3:	8b 40 4c             	mov    0x4c(%rax),%eax
  8092d6:	89 c7                	mov    %eax,%edi
  8092d8:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  8092df:	00 00 00 
  8092e2:	ff d0                	callq  *%rax
  8092e4:	89 c2                	mov    %eax,%edx
  8092e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8092ea:	89 d6                	mov    %edx,%esi
  8092ec:	48 89 c7             	mov    %rax,%rdi
  8092ef:	48 b8 e4 af 80 00 00 	movabs $0x80afe4,%rax
  8092f6:	00 00 00 
  8092f9:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  8092fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8092ff:	ba 04 00 00 00       	mov    $0x4,%edx
  809304:	be 36 00 00 00       	mov    $0x36,%esi
  809309:	48 89 c7             	mov    %rax,%rdi
  80930c:	48 b8 08 ae 80 00 00 	movabs $0x80ae08,%rax
  809313:	00 00 00 
  809316:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  809318:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80931c:	8b 40 48             	mov    0x48(%rax),%eax
  80931f:	89 c7                	mov    %eax,%edi
  809321:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  809328:	00 00 00 
  80932b:	ff d0                	callq  *%rax
  80932d:	89 c2                	mov    %eax,%edx
  80932f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809333:	89 d6                	mov    %edx,%esi
  809335:	48 89 c7             	mov    %rax,%rdi
  809338:	48 b8 e4 af 80 00 00 	movabs $0x80afe4,%rax
  80933f:	00 00 00 
  809342:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  809344:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809348:	ba 04 00 00 00       	mov    $0x4,%edx
  80934d:	be 37 00 00 00       	mov    $0x37,%esi
  809352:	48 89 c7             	mov    %rax,%rdi
  809355:	48 b8 08 ae 80 00 00 	movabs $0x80ae08,%rax
  80935c:	00 00 00 
  80935f:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  809361:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809365:	be 01 00 00 00       	mov    $0x1,%esi
  80936a:	48 89 c7             	mov    %rax,%rdi
  80936d:	48 b8 bd ae 80 00 00 	movabs $0x80aebd,%rax
  809374:	00 00 00 
  809377:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  809379:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80937d:	be 03 00 00 00       	mov    $0x3,%esi
  809382:	48 89 c7             	mov    %rax,%rdi
  809385:	48 b8 bd ae 80 00 00 	movabs $0x80aebd,%rax
  80938c:	00 00 00 
  80938f:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  809391:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809395:	be 1c 00 00 00       	mov    $0x1c,%esi
  80939a:	48 89 c7             	mov    %rax,%rdi
  80939d:	48 b8 bd ae 80 00 00 	movabs $0x80aebd,%rax
  8093a4:	00 00 00 
  8093a7:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  8093a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8093ad:	be 06 00 00 00       	mov    $0x6,%esi
  8093b2:	48 89 c7             	mov    %rax,%rdi
  8093b5:	48 b8 bd ae 80 00 00 	movabs $0x80aebd,%rax
  8093bc:	00 00 00 
  8093bf:	ff d0                	callq  *%rax
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  8093c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8093c5:	48 89 c7             	mov    %rax,%rdi
  8093c8:	48 b8 47 ba 80 00 00 	movabs $0x80ba47,%rax
  8093cf:	00 00 00 
  8093d2:	ff d0                	callq  *%rax
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8093d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8093d8:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  8093dc:	66 05 f0 00          	add    $0xf0,%ax
  8093e0:	0f b7 d0             	movzwl %ax,%edx
  8093e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8093e7:	48 8b 40 30          	mov    0x30(%rax),%rax
  8093eb:	89 d6                	mov    %edx,%esi
  8093ed:	48 89 c7             	mov    %rax,%rdi
  8093f0:	48 b8 1f d5 80 00 00 	movabs $0x80d51f,%rax
  8093f7:	00 00 00 
  8093fa:	ff d0                	callq  *%rax

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8093fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809400:	48 8b 70 30          	mov    0x30(%rax),%rsi
  809404:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809408:	48 8b 40 08          	mov    0x8(%rax),%rax
  80940c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  809410:	49 89 d0             	mov    %rdx,%r8
  809413:	b9 43 00 00 00       	mov    $0x43,%ecx
  809418:	48 ba ac 23 82 00 00 	movabs $0x8223ac,%rdx
  80941f:	00 00 00 
  809422:	48 89 c7             	mov    %rax,%rdi
  809425:	48 b8 e2 4f 81 00 00 	movabs $0x814fe2,%rax
  80942c:	00 00 00 
  80942f:	ff d0                	callq  *%rax
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  809431:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809435:	48 8b 40 08          	mov    0x8(%rax),%rax
  809439:	ba 43 00 00 00       	mov    $0x43,%edx
  80943e:	48 be a8 23 82 00 00 	movabs $0x8223a8,%rsi
  809445:	00 00 00 
  809448:	48 89 c7             	mov    %rax,%rdi
  80944b:	48 b8 d9 53 81 00 00 	movabs $0x8153d9,%rax
  809452:	00 00 00 
  809455:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  809457:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80945b:	48 89 c7             	mov    %rax,%rdi
  80945e:	48 b8 21 b9 80 00 00 	movabs $0x80b921,%rax
  809465:	00 00 00 
  809468:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  80946a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80946e:	be 01 00 00 00       	mov    $0x1,%esi
  809473:	48 89 c7             	mov    %rax,%rdi
  809476:	48 b8 d7 ad 80 00 00 	movabs $0x80add7,%rax
  80947d:	00 00 00 
  809480:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  809482:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809486:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80948a:	8d 50 01             	lea    0x1(%rax),%edx
  80948d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809491:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  809494:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809498:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80949c:	3c 03                	cmp    $0x3,%al
  80949e:	77 12                	ja     8094b2 <dhcp_select+0x2a2>
  8094a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8094a4:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8094a8:	0f b6 c0             	movzbl %al,%eax
  8094ab:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  8094b0:	eb 05                	jmp    8094b7 <dhcp_select+0x2a7>
  8094b2:	b8 a0 0f 00 00       	mov    $0xfa0,%eax
  8094b7:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8094bb:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  8094bf:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  8094c5:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  8094ca:	89 c8                	mov    %ecx,%eax
  8094cc:	f7 ea                	imul   %edx
  8094ce:	c1 fa 05             	sar    $0x5,%edx
  8094d1:	89 c8                	mov    %ecx,%eax
  8094d3:	c1 f8 1f             	sar    $0x1f,%eax
  8094d6:	89 d1                	mov    %edx,%ecx
  8094d8:	29 c1                	sub    %eax,%ecx
  8094da:	89 c8                	mov    %ecx,%eax
  8094dc:	89 c2                	mov    %eax,%edx
  8094de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8094e2:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  8094e6:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  8094ea:	c9                   	leaveq 
  8094eb:	c3                   	retq   

00000000008094ec <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  8094ec:	55                   	push   %rbp
  8094ed:	48 89 e5             	mov    %rsp,%rbp
  8094f0:	48 83 ec 10          	sub    $0x10,%rsp
  struct netif *netif = netif_list;
  8094f4:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  8094fb:	00 00 00 
  8094fe:	48 8b 00             	mov    (%rax),%rax
  809501:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  809505:	eb 7c                	jmp    809583 <dhcp_coarse_tmr+0x97>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  809507:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80950b:	48 8b 40 38          	mov    0x38(%rax),%rax
  80950f:	48 85 c0             	test   %rax,%rax
  809512:	74 64                	je     809578 <dhcp_coarse_tmr+0x8c>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  809514:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809518:	48 8b 40 38          	mov    0x38(%rax),%rax
  80951c:	0f b7 50 46          	movzwl 0x46(%rax),%edx
  809520:	66 83 fa 01          	cmp    $0x1,%dx
  809524:	0f 94 c1             	sete   %cl
  809527:	83 ea 01             	sub    $0x1,%edx
  80952a:	66 89 50 46          	mov    %dx,0x46(%rax)
  80952e:	84 c9                	test   %cl,%cl
  809530:	74 15                	je     809547 <dhcp_coarse_tmr+0x5b>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
  809532:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809536:	48 89 c7             	mov    %rax,%rdi
  809539:	48 b8 d1 97 80 00 00 	movabs $0x8097d1,%rax
  809540:	00 00 00 
  809543:	ff d0                	callq  *%rax
  809545:	eb 31                	jmp    809578 <dhcp_coarse_tmr+0x8c>
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  809547:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80954b:	48 8b 40 38          	mov    0x38(%rax),%rax
  80954f:	0f b7 50 44          	movzwl 0x44(%rax),%edx
  809553:	66 83 fa 01          	cmp    $0x1,%dx
  809557:	0f 94 c1             	sete   %cl
  80955a:	83 ea 01             	sub    $0x1,%edx
  80955d:	66 89 50 44          	mov    %dx,0x44(%rax)
  809561:	84 c9                	test   %cl,%cl
  809563:	74 13                	je     809578 <dhcp_coarse_tmr+0x8c>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
  809565:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809569:	48 89 c7             	mov    %rax,%rdi
  80956c:	48 b8 83 97 80 00 00 	movabs $0x809783,%rax
  809573:	00 00 00 
  809576:	ff d0                	callq  *%rax
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  809578:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80957c:	48 8b 00             	mov    (%rax),%rax
  80957f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  809583:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809588:	0f 85 79 ff ff ff    	jne    809507 <dhcp_coarse_tmr+0x1b>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  80958e:	c9                   	leaveq 
  80958f:	c3                   	retq   

0000000000809590 <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  809590:	55                   	push   %rbp
  809591:	48 89 e5             	mov    %rsp,%rbp
  809594:	48 83 ec 10          	sub    $0x10,%rsp
  struct netif *netif = netif_list;
  809598:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80959f:	00 00 00 
  8095a2:	48 8b 00             	mov    (%rax),%rax
  8095a5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* loop through netif's */
  while (netif != NULL) {
  8095a9:	eb 77                	jmp    809622 <dhcp_fine_tmr+0x92>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  8095ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8095af:	48 8b 40 38          	mov    0x38(%rax),%rax
  8095b3:	48 85 c0             	test   %rax,%rax
  8095b6:	74 5f                	je     809617 <dhcp_fine_tmr+0x87>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  8095b8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8095bc:	48 8b 40 38          	mov    0x38(%rax),%rax
  8095c0:	0f b7 40 42          	movzwl 0x42(%rax),%eax
  8095c4:	66 83 f8 01          	cmp    $0x1,%ax
  8095c8:	76 15                	jbe    8095df <dhcp_fine_tmr+0x4f>
        netif->dhcp->request_timeout--;
  8095ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8095ce:	48 8b 40 38          	mov    0x38(%rax),%rax
  8095d2:	0f b7 50 42          	movzwl 0x42(%rax),%edx
  8095d6:	83 ea 01             	sub    $0x1,%edx
  8095d9:	66 89 50 42          	mov    %dx,0x42(%rax)
  8095dd:	eb 38                	jmp    809617 <dhcp_fine_tmr+0x87>
      }
      else if (netif->dhcp->request_timeout == 1) {
  8095df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8095e3:	48 8b 40 38          	mov    0x38(%rax),%rax
  8095e7:	0f b7 40 42          	movzwl 0x42(%rax),%eax
  8095eb:	66 83 f8 01          	cmp    $0x1,%ax
  8095ef:	75 26                	jne    809617 <dhcp_fine_tmr+0x87>
        netif->dhcp->request_timeout--;
  8095f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8095f5:	48 8b 40 38          	mov    0x38(%rax),%rax
  8095f9:	0f b7 50 42          	movzwl 0x42(%rax),%edx
  8095fd:	83 ea 01             	sub    $0x1,%edx
  809600:	66 89 50 42          	mov    %dx,0x42(%rax)
        /* { netif->dhcp->request_timeout == 0 } */
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
  809604:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809608:	48 89 c7             	mov    %rax,%rdi
  80960b:	48 b8 2b 96 80 00 00 	movabs $0x80962b,%rax
  809612:	00 00 00 
  809615:	ff d0                	callq  *%rax
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  809617:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80961b:	48 8b 00             	mov    (%rax),%rax
  80961e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  809622:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809627:	75 82                	jne    8095ab <dhcp_fine_tmr+0x1b>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  809629:	c9                   	leaveq 
  80962a:	c3                   	retq   

000000000080962b <dhcp_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  80962b:	55                   	push   %rbp
  80962c:	48 89 e5             	mov    %rsp,%rbp
  80962f:	48 83 ec 20          	sub    $0x20,%rsp
  809633:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809637:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80963b:	48 8b 40 38          	mov    0x38(%rax),%rax
  80963f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  809643:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809647:	0f b6 00             	movzbl (%rax),%eax
  80964a:	3c 0c                	cmp    $0xc,%al
  80964c:	74 0b                	je     809659 <dhcp_timeout+0x2e>
  80964e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809652:	0f b6 00             	movzbl (%rax),%eax
  809655:	3c 06                	cmp    $0x6,%al
  809657:	75 18                	jne    809671 <dhcp_timeout+0x46>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  809659:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80965d:	48 89 c7             	mov    %rax,%rdi
  809660:	48 b8 da a1 80 00 00 	movabs $0x80a1da,%rax
  809667:	00 00 00 
  80966a:	ff d0                	callq  *%rax
  80966c:	e9 10 01 00 00       	jmpq   809781 <dhcp_timeout+0x156>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  809671:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809675:	0f b6 00             	movzbl (%rax),%eax
  809678:	3c 01                	cmp    $0x1,%al
  80967a:	75 4f                	jne    8096cb <dhcp_timeout+0xa0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  80967c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809680:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809684:	3c 05                	cmp    $0x5,%al
  809686:	77 18                	ja     8096a0 <dhcp_timeout+0x75>
      dhcp_select(netif);
  809688:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80968c:	48 89 c7             	mov    %rax,%rdi
  80968f:	48 b8 10 92 80 00 00 	movabs $0x809210,%rax
  809696:	00 00 00 
  809699:	ff d0                	callq  *%rax
  80969b:	e9 e1 00 00 00       	jmpq   809781 <dhcp_timeout+0x156>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  8096a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8096a4:	48 89 c7             	mov    %rax,%rdi
  8096a7:	48 b8 6b aa 80 00 00 	movabs $0x80aa6b,%rax
  8096ae:	00 00 00 
  8096b1:	ff d0                	callq  *%rax
      dhcp_discover(netif);
  8096b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8096b7:	48 89 c7             	mov    %rax,%rdi
  8096ba:	48 b8 da a1 80 00 00 	movabs $0x80a1da,%rax
  8096c1:	00 00 00 
  8096c4:	ff d0                	callq  *%rax
  8096c6:	e9 b6 00 00 00       	jmpq   809781 <dhcp_timeout+0x156>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  8096cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096cf:	0f b6 00             	movzbl (%rax),%eax
  8096d2:	3c 08                	cmp    $0x8,%al
  8096d4:	75 39                	jne    80970f <dhcp_timeout+0xe4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  8096d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8096da:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8096de:	3c 01                	cmp    $0x1,%al
  8096e0:	77 18                	ja     8096fa <dhcp_timeout+0xcf>
      dhcp_check(netif);
  8096e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8096e6:	48 89 c7             	mov    %rax,%rdi
  8096e9:	48 b8 cf 90 80 00 00 	movabs $0x8090cf,%rax
  8096f0:	00 00 00 
  8096f3:	ff d0                	callq  *%rax
  8096f5:	e9 87 00 00 00       	jmpq   809781 <dhcp_timeout+0x156>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  8096fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8096fe:	48 89 c7             	mov    %rax,%rdi
  809701:	48 b8 3e a4 80 00 00 	movabs $0x80a43e,%rax
  809708:	00 00 00 
  80970b:	ff d0                	callq  *%rax
  80970d:	eb 72                	jmp    809781 <dhcp_timeout+0x156>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  80970f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809713:	0f b6 00             	movzbl (%rax),%eax
  809716:	3c 05                	cmp    $0x5,%al
  809718:	75 15                	jne    80972f <dhcp_timeout+0x104>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  80971a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80971e:	48 89 c7             	mov    %rax,%rdi
  809721:	48 b8 d2 a6 80 00 00 	movabs $0x80a6d2,%rax
  809728:	00 00 00 
  80972b:	ff d0                	callq  *%rax
  80972d:	eb 52                	jmp    809781 <dhcp_timeout+0x156>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  80972f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809733:	0f b6 00             	movzbl (%rax),%eax
  809736:	3c 04                	cmp    $0x4,%al
  809738:	75 47                	jne    809781 <dhcp_timeout+0x156>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  80973a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80973e:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  809742:	3c 08                	cmp    $0x8,%al
  809744:	77 15                	ja     80975b <dhcp_timeout+0x130>
      dhcp_rebind(netif);
  809746:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80974a:	48 89 c7             	mov    %rax,%rdi
  80974d:	48 b8 9e a8 80 00 00 	movabs $0x80a89e,%rax
  809754:	00 00 00 
  809757:	ff d0                	callq  *%rax
  809759:	eb 26                	jmp    809781 <dhcp_timeout+0x156>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  80975b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80975f:	48 89 c7             	mov    %rax,%rdi
  809762:	48 b8 6b aa 80 00 00 	movabs $0x80aa6b,%rax
  809769:	00 00 00 
  80976c:	ff d0                	callq  *%rax
      dhcp_discover(netif);
  80976e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809772:	48 89 c7             	mov    %rax,%rdi
  809775:	48 b8 da a1 80 00 00 	movabs $0x80a1da,%rax
  80977c:	00 00 00 
  80977f:	ff d0                	callq  *%rax
    }
  }
}
  809781:	c9                   	leaveq 
  809782:	c3                   	retq   

0000000000809783 <dhcp_t1_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t1_timeout(struct netif *netif)
{
  809783:	55                   	push   %rbp
  809784:	48 89 e5             	mov    %rsp,%rbp
  809787:	48 83 ec 20          	sub    $0x20,%rsp
  80978b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80978f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809793:	48 8b 40 38          	mov    0x38(%rax),%rax
  809797:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  80979b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80979f:	0f b6 00             	movzbl (%rax),%eax
  8097a2:	3c 01                	cmp    $0x1,%al
  8097a4:	74 16                	je     8097bc <dhcp_t1_timeout+0x39>
  8097a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097aa:	0f b6 00             	movzbl (%rax),%eax
  8097ad:	3c 0a                	cmp    $0xa,%al
  8097af:	74 0b                	je     8097bc <dhcp_t1_timeout+0x39>
  8097b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097b5:	0f b6 00             	movzbl (%rax),%eax
  8097b8:	3c 05                	cmp    $0x5,%al
  8097ba:	75 13                	jne    8097cf <dhcp_t1_timeout+0x4c>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  8097bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8097c0:	48 89 c7             	mov    %rax,%rdi
  8097c3:	48 b8 d2 a6 80 00 00 	movabs $0x80a6d2,%rax
  8097ca:	00 00 00 
  8097cd:	ff d0                	callq  *%rax
  }
}
  8097cf:	c9                   	leaveq 
  8097d0:	c3                   	retq   

00000000008097d1 <dhcp_t2_timeout>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_t2_timeout(struct netif *netif)
{
  8097d1:	55                   	push   %rbp
  8097d2:	48 89 e5             	mov    %rsp,%rbp
  8097d5:	48 83 ec 20          	sub    $0x20,%rsp
  8097d9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  8097dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8097e1:	48 8b 40 38          	mov    0x38(%rax),%rax
  8097e5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  8097e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097ed:	0f b6 00             	movzbl (%rax),%eax
  8097f0:	3c 01                	cmp    $0x1,%al
  8097f2:	74 16                	je     80980a <dhcp_t2_timeout+0x39>
  8097f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8097f8:	0f b6 00             	movzbl (%rax),%eax
  8097fb:	3c 0a                	cmp    $0xa,%al
  8097fd:	74 0b                	je     80980a <dhcp_t2_timeout+0x39>
  8097ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809803:	0f b6 00             	movzbl (%rax),%eax
  809806:	3c 05                	cmp    $0x5,%al
  809808:	75 13                	jne    80981d <dhcp_t2_timeout+0x4c>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  80980a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80980e:	48 89 c7             	mov    %rax,%rdi
  809811:	48 b8 9e a8 80 00 00 	movabs $0x80a89e,%rax
  809818:	00 00 00 
  80981b:	ff d0                	callq  *%rax
  }
}
  80981d:	c9                   	leaveq 
  80981e:	c3                   	retq   

000000000080981f <dhcp_handle_ack>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  80981f:	55                   	push   %rbp
  809820:	48 89 e5             	mov    %rsp,%rbp
  809823:	53                   	push   %rbx
  809824:	48 83 ec 38          	sub    $0x38,%rsp
  809828:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80982c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  809830:	48 8b 40 38          	mov    0x38(%rax),%rax
  809834:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  809838:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80983c:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%rax)
  dhcp->offered_gw_addr.addr = 0;
  809843:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809847:	c7 40 54 00 00 00 00 	movl   $0x0,0x54(%rax)
  dhcp->offered_bc_addr.addr = 0;
  80984e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809852:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%rax)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  809859:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80985d:	be 33 00 00 00       	mov    $0x33,%esi
  809862:	48 89 c7             	mov    %rax,%rdi
  809865:	48 b8 a5 bb 80 00 00 	movabs $0x80bba5,%rax
  80986c:	00 00 00 
  80986f:	ff d0                	callq  *%rax
  809871:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809875:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80987a:	74 1e                	je     80989a <dhcp_handle_ack+0x7b>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  80987c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809880:	48 83 c0 02          	add    $0x2,%rax
  809884:	48 89 c7             	mov    %rax,%rdi
  809887:	48 b8 46 bd 80 00 00 	movabs $0x80bd46,%rax
  80988e:	00 00 00 
  809891:	ff d0                	callq  *%rax
  809893:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809897:	89 42 68             	mov    %eax,0x68(%rdx)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  80989a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80989e:	be 3a 00 00 00       	mov    $0x3a,%esi
  8098a3:	48 89 c7             	mov    %rax,%rdi
  8098a6:	48 b8 a5 bb 80 00 00 	movabs $0x80bba5,%rax
  8098ad:	00 00 00 
  8098b0:	ff d0                	callq  *%rax
  8098b2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  8098b6:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8098bb:	74 20                	je     8098dd <dhcp_handle_ack+0xbe>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  8098bd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8098c1:	48 83 c0 02          	add    $0x2,%rax
  8098c5:	48 89 c7             	mov    %rax,%rdi
  8098c8:	48 b8 46 bd 80 00 00 	movabs $0x80bd46,%rax
  8098cf:	00 00 00 
  8098d2:	ff d0                	callq  *%rax
  8098d4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8098d8:	89 42 6c             	mov    %eax,0x6c(%rdx)
  8098db:	eb 12                	jmp    8098ef <dhcp_handle_ack+0xd0>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  8098dd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8098e1:	8b 40 68             	mov    0x68(%rax),%eax
  8098e4:	89 c2                	mov    %eax,%edx
  8098e6:	d1 ea                	shr    %edx
  8098e8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8098ec:	89 50 6c             	mov    %edx,0x6c(%rax)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  8098ef:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8098f3:	be 3b 00 00 00       	mov    $0x3b,%esi
  8098f8:	48 89 c7             	mov    %rax,%rdi
  8098fb:	48 b8 a5 bb 80 00 00 	movabs $0x80bba5,%rax
  809902:	00 00 00 
  809905:	ff d0                	callq  *%rax
  809907:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  80990b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809910:	74 20                	je     809932 <dhcp_handle_ack+0x113>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  809912:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809916:	48 83 c0 02          	add    $0x2,%rax
  80991a:	48 89 c7             	mov    %rax,%rdi
  80991d:	48 b8 46 bd 80 00 00 	movabs $0x80bd46,%rax
  809924:	00 00 00 
  809927:	ff d0                	callq  *%rax
  809929:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80992d:	89 42 70             	mov    %eax,0x70(%rdx)
  809930:	eb 0e                	jmp    809940 <dhcp_handle_ack+0x121>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  809932:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809936:	8b 50 68             	mov    0x68(%rax),%edx
  809939:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80993d:	89 50 70             	mov    %edx,0x70(%rax)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  809940:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809944:	48 8b 40 18          	mov    0x18(%rax),%rax
  809948:	48 83 c0 10          	add    $0x10,%rax
  80994c:	48 85 c0             	test   %rax,%rax
  80994f:	74 0d                	je     80995e <dhcp_handle_ack+0x13f>
  809951:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809955:	48 8b 40 18          	mov    0x18(%rax),%rax
  809959:	8b 40 10             	mov    0x10(%rax),%eax
  80995c:	eb 05                	jmp    809963 <dhcp_handle_ack+0x144>
  80995e:	b8 00 00 00 00       	mov    $0x0,%eax
  809963:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809967:	89 42 4c             	mov    %eax,0x4c(%rdx)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  80996a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80996e:	be 01 00 00 00       	mov    $0x1,%esi
  809973:	48 89 c7             	mov    %rax,%rdi
  809976:	48 b8 a5 bb 80 00 00 	movabs $0x80bba5,%rax
  80997d:	00 00 00 
  809980:	ff d0                	callq  *%rax
  809982:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  /* subnet mask given? */
  if (option_ptr != NULL) {
  809986:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80998b:	74 2c                	je     8099b9 <dhcp_handle_ack+0x19a>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  80998d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809991:	48 83 c0 02          	add    $0x2,%rax
  809995:	48 89 c7             	mov    %rax,%rdi
  809998:	48 b8 46 bd 80 00 00 	movabs $0x80bd46,%rax
  80999f:	00 00 00 
  8099a2:	ff d0                	callq  *%rax
  8099a4:	89 c7                	mov    %eax,%edi
  8099a6:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  8099ad:	00 00 00 
  8099b0:	ff d0                	callq  *%rax
  8099b2:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8099b6:	89 42 50             	mov    %eax,0x50(%rdx)
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  8099b9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8099bd:	be 03 00 00 00       	mov    $0x3,%esi
  8099c2:	48 89 c7             	mov    %rax,%rdi
  8099c5:	48 b8 a5 bb 80 00 00 	movabs $0x80bba5,%rax
  8099cc:	00 00 00 
  8099cf:	ff d0                	callq  *%rax
  8099d1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  8099d5:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8099da:	74 2c                	je     809a08 <dhcp_handle_ack+0x1e9>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8099dc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8099e0:	48 83 c0 02          	add    $0x2,%rax
  8099e4:	48 89 c7             	mov    %rax,%rdi
  8099e7:	48 b8 46 bd 80 00 00 	movabs $0x80bd46,%rax
  8099ee:	00 00 00 
  8099f1:	ff d0                	callq  *%rax
  8099f3:	89 c7                	mov    %eax,%edi
  8099f5:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  8099fc:	00 00 00 
  8099ff:	ff d0                	callq  *%rax
  809a01:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809a05:	89 42 54             	mov    %eax,0x54(%rdx)
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  809a08:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809a0c:	be 1c 00 00 00       	mov    $0x1c,%esi
  809a11:	48 89 c7             	mov    %rax,%rdi
  809a14:	48 b8 a5 bb 80 00 00 	movabs $0x80bba5,%rax
  809a1b:	00 00 00 
  809a1e:	ff d0                	callq  *%rax
  809a20:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809a24:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809a29:	74 2c                	je     809a57 <dhcp_handle_ack+0x238>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  809a2b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809a2f:	48 83 c0 02          	add    $0x2,%rax
  809a33:	48 89 c7             	mov    %rax,%rdi
  809a36:	48 b8 46 bd 80 00 00 	movabs $0x80bd46,%rax
  809a3d:	00 00 00 
  809a40:	ff d0                	callq  *%rax
  809a42:	89 c7                	mov    %eax,%edi
  809a44:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  809a4b:	00 00 00 
  809a4e:	ff d0                	callq  *%rax
  809a50:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809a54:	89 42 58             	mov    %eax,0x58(%rdx)
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  809a57:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809a5b:	be 06 00 00 00       	mov    $0x6,%esi
  809a60:	48 89 c7             	mov    %rax,%rdi
  809a63:	48 b8 a5 bb 80 00 00 	movabs $0x80bba5,%rax
  809a6a:	00 00 00 
  809a6d:	ff d0                	callq  *%rax
  809a6f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (option_ptr != NULL) {
  809a73:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  809a78:	0f 84 93 00 00 00    	je     809b11 <dhcp_handle_ack+0x2f2>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  809a7e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809a82:	48 83 c0 01          	add    $0x1,%rax
  809a86:	48 89 c7             	mov    %rax,%rdi
  809a89:	48 b8 31 bd 80 00 00 	movabs $0x80bd31,%rax
  809a90:	00 00 00 
  809a93:	ff d0                	callq  *%rax
  809a95:	c0 e8 02             	shr    $0x2,%al
  809a98:	0f b6 d0             	movzbl %al,%edx
  809a9b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809a9f:	89 50 5c             	mov    %edx,0x5c(%rax)
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
  809aa2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809aa6:	8b 40 5c             	mov    0x5c(%rax),%eax
  809aa9:	83 f8 02             	cmp    $0x2,%eax
  809aac:	76 0b                	jbe    809ab9 <dhcp_handle_ack+0x29a>
      dhcp->dns_count = DHCP_MAX_DNS;
  809aae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809ab2:	c7 40 5c 02 00 00 00 	movl   $0x2,0x5c(%rax)
    for (n = 0; n < dhcp->dns_count; n++) {
  809ab9:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  809abd:	eb 43                	jmp    809b02 <dhcp_handle_ack+0x2e3>
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  809abf:	0f b6 5d ef          	movzbl -0x11(%rbp),%ebx
  809ac3:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  809ac7:	c1 e0 02             	shl    $0x2,%eax
  809aca:	83 c0 02             	add    $0x2,%eax
  809acd:	48 98                	cltq   
  809acf:	48 03 45 d8          	add    -0x28(%rbp),%rax
  809ad3:	48 89 c7             	mov    %rax,%rdi
  809ad6:	48 b8 46 bd 80 00 00 	movabs $0x80bd46,%rax
  809add:	00 00 00 
  809ae0:	ff d0                	callq  *%rax
  809ae2:	89 c7                	mov    %eax,%edi
  809ae4:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  809aeb:	00 00 00 
  809aee:	ff d0                	callq  *%rax
  809af0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  809af4:	48 63 cb             	movslq %ebx,%rcx
  809af7:	48 83 c1 18          	add    $0x18,%rcx
  809afb:	89 04 8a             	mov    %eax,(%rdx,%rcx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  809afe:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
  809b02:	0f b6 55 ef          	movzbl -0x11(%rbp),%edx
  809b06:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  809b0a:	8b 40 5c             	mov    0x5c(%rax),%eax
  809b0d:	39 c2                	cmp    %eax,%edx
  809b0f:	72 ae                	jb     809abf <dhcp_handle_ack+0x2a0>
    }
#if LWIP_DNS
    dns_setserver( n, (struct ip_addr *)(&ip_addr_any));
#endif /* LWIP_DNS */
  }
}
  809b11:	48 83 c4 38          	add    $0x38,%rsp
  809b15:	5b                   	pop    %rbx
  809b16:	5d                   	pop    %rbp
  809b17:	c3                   	retq   

0000000000809b18 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  809b18:	55                   	push   %rbp
  809b19:	48 89 e5             	mov    %rsp,%rbp
  809b1c:	48 83 ec 20          	sub    $0x20,%rsp
  809b20:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp;
  err_t result = ERR_OK;
  809b24:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  809b28:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  809b2d:	75 2a                	jne    809b59 <dhcp_start+0x41>
  809b2f:	48 ba a8 15 82 00 00 	movabs $0x8215a8,%rdx
  809b36:	00 00 00 
  809b39:	be 38 02 00 00       	mov    $0x238,%esi
  809b3e:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  809b45:	00 00 00 
  809b48:	b8 00 00 00 00       	mov    $0x0,%eax
  809b4d:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  809b54:	00 00 00 
  809b57:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  809b59:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809b5d:	48 8b 40 38          	mov    0x38(%rax),%rax
  809b61:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  809b65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809b69:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  809b6d:	89 c2                	mov    %eax,%edx
  809b6f:	83 e2 f7             	and    $0xfffffff7,%edx
  809b72:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809b76:	88 50 4a             	mov    %dl,0x4a(%rax)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  809b79:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809b7e:	75 32                	jne    809bb2 <dhcp_start+0x9a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  809b80:	bf 78 00 00 00       	mov    $0x78,%edi
  809b85:	48 b8 79 c5 80 00 00 	movabs $0x80c579,%rax
  809b8c:	00 00 00 
  809b8f:	ff d0                	callq  *%rax
  809b91:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (dhcp == NULL) {
  809b95:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809b9a:	75 0a                	jne    809ba6 <dhcp_start+0x8e>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
  809b9c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809ba1:	e9 3a 01 00 00       	jmpq   809ce0 <dhcp_start+0x1c8>
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  809ba6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809baa:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  809bae:	48 89 50 38          	mov    %rdx,0x38(%rax)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  809bb2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809bb6:	ba 78 00 00 00       	mov    $0x78,%edx
  809bbb:	be 00 00 00 00       	mov    $0x0,%esi
  809bc0:	48 89 c7             	mov    %rax,%rdi
  809bc3:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  809bca:	00 00 00 
  809bcd:	ff d0                	callq  *%rax
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  809bcf:	48 b8 e9 55 81 00 00 	movabs $0x8155e9,%rax
  809bd6:	00 00 00 
  809bd9:	ff d0                	callq  *%rax
  809bdb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  809bdf:	48 89 42 08          	mov    %rax,0x8(%rdx)
  if (dhcp->pcb == NULL) {
  809be3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809be7:	48 8b 40 08          	mov    0x8(%rax),%rax
  809beb:	48 85 c0             	test   %rax,%rax
  809bee:	75 31                	jne    809c21 <dhcp_start+0x109>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  809bf0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809bf4:	48 89 c7             	mov    %rax,%rdi
  809bf7:	48 b8 d3 c0 80 00 00 	movabs $0x80c0d3,%rax
  809bfe:	00 00 00 
  809c01:	ff d0                	callq  *%rax
    netif->dhcp = dhcp = NULL;
  809c03:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  809c0a:	00 
  809c0b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809c0f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  809c13:	48 89 50 38          	mov    %rdx,0x38(%rax)
    return ERR_MEM;
  809c17:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809c1c:	e9 bf 00 00 00       	jmpq   809ce0 <dhcp_start+0x1c8>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  809c21:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809c25:	48 8b 40 08          	mov    0x8(%rax),%rax
  809c29:	ba 44 00 00 00       	mov    $0x44,%edx
  809c2e:	48 be a8 23 82 00 00 	movabs $0x8223a8,%rsi
  809c35:	00 00 00 
  809c38:	48 89 c7             	mov    %rax,%rdi
  809c3b:	48 b8 93 52 81 00 00 	movabs $0x815293,%rax
  809c42:	00 00 00 
  809c45:	ff d0                	callq  *%rax
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  809c47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809c4b:	48 8b 40 08          	mov    0x8(%rax),%rax
  809c4f:	ba 43 00 00 00       	mov    $0x43,%edx
  809c54:	48 be a8 23 82 00 00 	movabs $0x8223a8,%rsi
  809c5b:	00 00 00 
  809c5e:	48 89 c7             	mov    %rax,%rdi
  809c61:	48 b8 d9 53 81 00 00 	movabs $0x8153d9,%rax
  809c68:	00 00 00 
  809c6b:	ff d0                	callq  *%rax
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  809c6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809c71:	48 8b 40 08          	mov    0x8(%rax),%rax
  809c75:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  809c79:	48 be 8d b3 80 00 00 	movabs $0x80b38d,%rsi
  809c80:	00 00 00 
  809c83:	48 89 c7             	mov    %rax,%rdi
  809c86:	48 b8 11 55 81 00 00 	movabs $0x815511,%rax
  809c8d:	00 00 00 
  809c90:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  809c92:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809c96:	48 89 c7             	mov    %rax,%rdi
  809c99:	48 b8 da a1 80 00 00 	movabs $0x80a1da,%rax
  809ca0:	00 00 00 
  809ca3:	ff d0                	callq  *%rax
  809ca5:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result != ERR_OK) {
  809ca8:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  809cac:	74 1a                	je     809cc8 <dhcp_start+0x1b0>
    /* free resources allocated above */
    dhcp_stop(netif);
  809cae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809cb2:	48 89 c7             	mov    %rax,%rdi
  809cb5:	48 b8 db ac 80 00 00 	movabs $0x80acdb,%rax
  809cbc:	00 00 00 
  809cbf:	ff d0                	callq  *%rax
    return ERR_MEM;
  809cc1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809cc6:	eb 18                	jmp    809ce0 <dhcp_start+0x1c8>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  809cc8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809ccc:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  809cd0:	89 c2                	mov    %eax,%edx
  809cd2:	83 ca 08             	or     $0x8,%edx
  809cd5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809cd9:	88 50 4a             	mov    %dl,0x4a(%rax)
  return result;
  809cdc:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  809ce0:	c9                   	leaveq 
  809ce1:	c3                   	retq   

0000000000809ce2 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  809ce2:	55                   	push   %rbp
  809ce3:	48 89 e5             	mov    %rsp,%rbp
  809ce6:	48 83 ec 30          	sub    $0x30,%rsp
  809cea:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  809cee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809cf2:	48 8b 40 38          	mov    0x38(%rax),%rax
  809cf6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  809cfa:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  dhcp = mem_malloc(sizeof(struct dhcp));
  809cfe:	bf 78 00 00 00       	mov    $0x78,%edi
  809d03:	48 b8 79 c5 80 00 00 	movabs $0x80c579,%rax
  809d0a:	00 00 00 
  809d0d:	ff d0                	callq  *%rax
  809d0f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (dhcp == NULL) {
  809d13:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  809d18:	0f 84 39 02 00 00    	je     809f57 <dhcp_inform+0x275>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  809d1e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809d22:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  809d26:	48 89 50 38          	mov    %rdx,0x38(%rax)
  memset(dhcp, 0, sizeof(struct dhcp));
  809d2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809d2e:	ba 78 00 00 00       	mov    $0x78,%edx
  809d33:	be 00 00 00 00       	mov    $0x0,%esi
  809d38:	48 89 c7             	mov    %rax,%rdi
  809d3b:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  809d42:	00 00 00 
  809d45:	ff d0                	callq  *%rax

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  809d47:	48 b8 e9 55 81 00 00 	movabs $0x8155e9,%rax
  809d4e:	00 00 00 
  809d51:	ff d0                	callq  *%rax
  809d53:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  809d57:	48 89 42 08          	mov    %rax,0x8(%rdx)
  if (dhcp->pcb == NULL) {
  809d5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809d5f:	48 8b 40 08          	mov    0x8(%rax),%rax
  809d63:	48 85 c0             	test   %rax,%rax
  809d66:	75 18                	jne    809d80 <dhcp_inform+0x9e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  809d68:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809d6c:	48 89 c7             	mov    %rax,%rdi
  809d6f:	48 b8 d3 c0 80 00 00 	movabs $0x80c0d3,%rax
  809d76:	00 00 00 
  809d79:	ff d0                	callq  *%rax
    return;
  809d7b:	e9 d8 01 00 00       	jmpq   809f58 <dhcp_inform+0x276>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  809d80:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809d84:	48 89 c7             	mov    %rax,%rdi
  809d87:	48 b8 e4 b5 80 00 00 	movabs $0x80b5e4,%rax
  809d8e:	00 00 00 
  809d91:	ff d0                	callq  *%rax
  809d93:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  809d96:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  809d9a:	0f 85 5f 01 00 00    	jne    809eff <dhcp_inform+0x21d>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  809da0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809da4:	ba 01 00 00 00       	mov    $0x1,%edx
  809da9:	be 35 00 00 00       	mov    $0x35,%esi
  809dae:	48 89 c7             	mov    %rax,%rdi
  809db1:	48 b8 08 ae 80 00 00 	movabs $0x80ae08,%rax
  809db8:	00 00 00 
  809dbb:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_INFORM);
  809dbd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809dc1:	be 08 00 00 00       	mov    $0x8,%esi
  809dc6:	48 89 c7             	mov    %rax,%rdi
  809dc9:	48 b8 bd ae 80 00 00 	movabs $0x80aebd,%rax
  809dd0:	00 00 00 
  809dd3:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  809dd5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809dd9:	ba 02 00 00 00       	mov    $0x2,%edx
  809dde:	be 39 00 00 00       	mov    $0x39,%esi
  809de3:	48 89 c7             	mov    %rax,%rdi
  809de6:	48 b8 08 ae 80 00 00 	movabs $0x80ae08,%rax
  809ded:	00 00 00 
  809df0:	ff d0                	callq  *%rax
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  809df2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809df6:	be 40 02 00 00       	mov    $0x240,%esi
  809dfb:	48 89 c7             	mov    %rax,%rdi
  809dfe:	48 b8 35 af 80 00 00 	movabs $0x80af35,%rax
  809e05:	00 00 00 
  809e08:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  809e0a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809e0e:	48 89 c7             	mov    %rax,%rdi
  809e11:	48 b8 47 ba 80 00 00 	movabs $0x80ba47,%rax
  809e18:	00 00 00 
  809e1b:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  809e1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809e21:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  809e25:	66 05 f0 00          	add    $0xf0,%ax
  809e29:	0f b7 d0             	movzwl %ax,%edx
  809e2c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809e30:	48 8b 40 30          	mov    0x30(%rax),%rax
  809e34:	89 d6                	mov    %edx,%esi
  809e36:	48 89 c7             	mov    %rax,%rdi
  809e39:	48 b8 1f d5 80 00 00 	movabs $0x80d51f,%rax
  809e40:	00 00 00 
  809e43:	ff d0                	callq  *%rax

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  809e45:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809e49:	48 8b 40 08          	mov    0x8(%rax),%rax
  809e4d:	ba 44 00 00 00       	mov    $0x44,%edx
  809e52:	48 be a8 23 82 00 00 	movabs $0x8223a8,%rsi
  809e59:	00 00 00 
  809e5c:	48 89 c7             	mov    %rax,%rdi
  809e5f:	48 b8 93 52 81 00 00 	movabs $0x815293,%rax
  809e66:	00 00 00 
  809e69:	ff d0                	callq  *%rax
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  809e6b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809e6f:	48 8b 40 08          	mov    0x8(%rax),%rax
  809e73:	ba 43 00 00 00       	mov    $0x43,%edx
  809e78:	48 be ac 23 82 00 00 	movabs $0x8223ac,%rsi
  809e7f:	00 00 00 
  809e82:	48 89 c7             	mov    %rax,%rdi
  809e85:	48 b8 d9 53 81 00 00 	movabs $0x8153d9,%rax
  809e8c:	00 00 00 
  809e8f:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  809e91:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809e95:	48 8b 70 30          	mov    0x30(%rax),%rsi
  809e99:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809e9d:	48 8b 40 08          	mov    0x8(%rax),%rax
  809ea1:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  809ea5:	49 89 d0             	mov    %rdx,%r8
  809ea8:	b9 43 00 00 00       	mov    $0x43,%ecx
  809ead:	48 ba ac 23 82 00 00 	movabs $0x8223ac,%rdx
  809eb4:	00 00 00 
  809eb7:	48 89 c7             	mov    %rax,%rdi
  809eba:	48 b8 e2 4f 81 00 00 	movabs $0x814fe2,%rax
  809ec1:	00 00 00 
  809ec4:	ff d0                	callq  *%rax
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  809ec6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809eca:	48 8b 40 08          	mov    0x8(%rax),%rax
  809ece:	ba 43 00 00 00       	mov    $0x43,%edx
  809ed3:	48 be a8 23 82 00 00 	movabs $0x8223a8,%rsi
  809eda:	00 00 00 
  809edd:	48 89 c7             	mov    %rax,%rdi
  809ee0:	48 b8 d9 53 81 00 00 	movabs $0x8153d9,%rax
  809ee7:	00 00 00 
  809eea:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  809eec:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809ef0:	48 89 c7             	mov    %rax,%rdi
  809ef3:	48 b8 21 b9 80 00 00 	movabs $0x80b921,%rax
  809efa:	00 00 00 
  809efd:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
  809eff:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  809f04:	74 52                	je     809f58 <dhcp_inform+0x276>
    if (dhcp->pcb != NULL) {
  809f06:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809f0a:	48 8b 40 08          	mov    0x8(%rax),%rax
  809f0e:	48 85 c0             	test   %rax,%rax
  809f11:	74 17                	je     809f2a <dhcp_inform+0x248>
      udp_remove(dhcp->pcb);
  809f13:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809f17:	48 8b 40 08          	mov    0x8(%rax),%rax
  809f1b:	48 89 c7             	mov    %rax,%rdi
  809f1e:	48 b8 3f 55 81 00 00 	movabs $0x81553f,%rax
  809f25:	00 00 00 
  809f28:	ff d0                	callq  *%rax
    }
    dhcp->pcb = NULL;
  809f2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809f2e:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  809f35:	00 
    mem_free((void *)dhcp);
  809f36:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809f3a:	48 89 c7             	mov    %rax,%rdi
  809f3d:	48 b8 d3 c0 80 00 00 	movabs $0x80c0d3,%rax
  809f44:	00 00 00 
  809f47:	ff d0                	callq  *%rax
    netif->dhcp = old_dhcp;
  809f49:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  809f4d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  809f51:	48 89 50 38          	mov    %rdx,0x38(%rax)
  809f55:	eb 01                	jmp    809f58 <dhcp_inform+0x276>
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  if (dhcp == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  809f57:	90                   	nop
    }
    dhcp->pcb = NULL;
    mem_free((void *)dhcp);
    netif->dhcp = old_dhcp;
  }
}
  809f58:	c9                   	leaveq 
  809f59:	c3                   	retq   

0000000000809f5a <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  809f5a:	55                   	push   %rbp
  809f5b:	48 89 e5             	mov    %rsp,%rbp
  809f5e:	48 83 ec 10          	sub    $0x10,%rsp
  809f62:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  809f66:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809f6a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  809f6f:	75 2a                	jne    809f9b <dhcp_arp_reply+0x41>
  809f71:	48 ba a8 15 82 00 00 	movabs $0x8215a8,%rdx
  809f78:	00 00 00 
  809f7b:	be b5 02 00 00       	mov    $0x2b5,%esi
  809f80:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  809f87:	00 00 00 
  809f8a:	b8 00 00 00 00       	mov    $0x0,%eax
  809f8f:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  809f96:	00 00 00 
  809f99:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  809f9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809f9f:	48 8b 40 38          	mov    0x38(%rax),%rax
  809fa3:	48 85 c0             	test   %rax,%rax
  809fa6:	74 37                	je     809fdf <dhcp_arp_reply+0x85>
  809fa8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809fac:	48 8b 40 38          	mov    0x38(%rax),%rax
  809fb0:	0f b6 00             	movzbl (%rax),%eax
  809fb3:	3c 08                	cmp    $0x8,%al
  809fb5:	75 28                	jne    809fdf <dhcp_arp_reply+0x85>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  809fb7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  809fbb:	8b 10                	mov    (%rax),%edx
  809fbd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809fc1:	48 8b 40 38          	mov    0x38(%rax),%rax
  809fc5:	8b 40 4c             	mov    0x4c(%rax),%eax
  809fc8:	39 c2                	cmp    %eax,%edx
  809fca:	75 13                	jne    809fdf <dhcp_arp_reply+0x85>
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
  809fcc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  809fd0:	48 89 c7             	mov    %rax,%rdi
  809fd3:	48 b8 e1 9f 80 00 00 	movabs $0x809fe1,%rax
  809fda:	00 00 00 
  809fdd:	ff d0                	callq  *%rax
    }
  }
}
  809fdf:	c9                   	leaveq 
  809fe0:	c3                   	retq   

0000000000809fe1 <dhcp_decline>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_decline(struct netif *netif)
{
  809fe1:	55                   	push   %rbp
  809fe2:	48 89 e5             	mov    %rsp,%rbp
  809fe5:	48 83 ec 20          	sub    $0x20,%rsp
  809fe9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  809fed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  809ff1:	48 8b 40 38          	mov    0x38(%rax),%rax
  809ff5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  809ff9:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  809ffd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a001:	be 0c 00 00 00       	mov    $0xc,%esi
  80a006:	48 89 c7             	mov    %rax,%rdi
  80a009:	48 b8 d7 ad 80 00 00 	movabs $0x80add7,%rax
  80a010:	00 00 00 
  80a013:	ff d0                	callq  *%rax
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a015:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a019:	48 89 c7             	mov    %rax,%rdi
  80a01c:	48 b8 e4 b5 80 00 00 	movabs $0x80b5e4,%rax
  80a023:	00 00 00 
  80a026:	ff d0                	callq  *%rax
  80a028:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a02b:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a02f:	0f 85 5c 01 00 00    	jne    80a191 <dhcp_decline+0x1b0>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a035:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a039:	ba 01 00 00 00       	mov    $0x1,%edx
  80a03e:	be 35 00 00 00       	mov    $0x35,%esi
  80a043:	48 89 c7             	mov    %rax,%rdi
  80a046:	48 b8 08 ae 80 00 00 	movabs $0x80ae08,%rax
  80a04d:	00 00 00 
  80a050:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  80a052:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a056:	be 04 00 00 00       	mov    $0x4,%esi
  80a05b:	48 89 c7             	mov    %rax,%rdi
  80a05e:	48 b8 bd ae 80 00 00 	movabs $0x80aebd,%rax
  80a065:	00 00 00 
  80a068:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a06a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a06e:	ba 02 00 00 00       	mov    $0x2,%edx
  80a073:	be 39 00 00 00       	mov    $0x39,%esi
  80a078:	48 89 c7             	mov    %rax,%rdi
  80a07b:	48 b8 08 ae 80 00 00 	movabs $0x80ae08,%rax
  80a082:	00 00 00 
  80a085:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80a087:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a08b:	be 40 02 00 00       	mov    $0x240,%esi
  80a090:	48 89 c7             	mov    %rax,%rdi
  80a093:	48 b8 35 af 80 00 00 	movabs $0x80af35,%rax
  80a09a:	00 00 00 
  80a09d:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  80a09f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a0a3:	ba 04 00 00 00       	mov    $0x4,%edx
  80a0a8:	be 32 00 00 00       	mov    $0x32,%esi
  80a0ad:	48 89 c7             	mov    %rax,%rdi
  80a0b0:	48 b8 08 ae 80 00 00 	movabs $0x80ae08,%rax
  80a0b7:	00 00 00 
  80a0ba:	ff d0                	callq  *%rax
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  80a0bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a0c0:	8b 40 4c             	mov    0x4c(%rax),%eax
  80a0c3:	89 c7                	mov    %eax,%edi
  80a0c5:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  80a0cc:	00 00 00 
  80a0cf:	ff d0                	callq  *%rax
  80a0d1:	89 c2                	mov    %eax,%edx
  80a0d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a0d7:	89 d6                	mov    %edx,%esi
  80a0d9:	48 89 c7             	mov    %rax,%rdi
  80a0dc:	48 b8 e4 af 80 00 00 	movabs $0x80afe4,%rax
  80a0e3:	00 00 00 
  80a0e6:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80a0e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a0ec:	48 89 c7             	mov    %rax,%rdi
  80a0ef:	48 b8 47 ba 80 00 00 	movabs $0x80ba47,%rax
  80a0f6:	00 00 00 
  80a0f9:	ff d0                	callq  *%rax
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a0fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a0ff:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a103:	66 05 f0 00          	add    $0xf0,%ax
  80a107:	0f b7 d0             	movzwl %ax,%edx
  80a10a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a10e:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a112:	89 d6                	mov    %edx,%esi
  80a114:	48 89 c7             	mov    %rax,%rdi
  80a117:	48 b8 1f d5 80 00 00 	movabs $0x80d51f,%rax
  80a11e:	00 00 00 
  80a121:	ff d0                	callq  *%rax

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80a123:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a127:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a12b:	ba 43 00 00 00       	mov    $0x43,%edx
  80a130:	48 be a8 23 82 00 00 	movabs $0x8223a8,%rsi
  80a137:	00 00 00 
  80a13a:	48 89 c7             	mov    %rax,%rdi
  80a13d:	48 b8 d9 53 81 00 00 	movabs $0x8153d9,%rax
  80a144:	00 00 00 
  80a147:	ff d0                	callq  *%rax
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80a149:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a14d:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a151:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a155:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a159:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a15d:	49 89 d0             	mov    %rdx,%r8
  80a160:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a165:	48 ba ac 23 82 00 00 	movabs $0x8223ac,%rdx
  80a16c:	00 00 00 
  80a16f:	48 89 c7             	mov    %rax,%rdi
  80a172:	48 b8 e2 4f 81 00 00 	movabs $0x814fe2,%rax
  80a179:	00 00 00 
  80a17c:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80a17e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a182:	48 89 c7             	mov    %rax,%rdi
  80a185:	48 b8 21 b9 80 00 00 	movabs $0x80b921,%rax
  80a18c:	00 00 00 
  80a18f:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80a191:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a195:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a199:	8d 50 01             	lea    0x1(%rax),%edx
  80a19c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a1a0:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = 10*1000;
  80a1a3:	66 c7 45 f4 10 27    	movw   $0x2710,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80a1a9:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80a1ad:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80a1b3:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80a1b8:	89 c8                	mov    %ecx,%eax
  80a1ba:	f7 ea                	imul   %edx
  80a1bc:	c1 fa 05             	sar    $0x5,%edx
  80a1bf:	89 c8                	mov    %ecx,%eax
  80a1c1:	c1 f8 1f             	sar    $0x1f,%eax
  80a1c4:	89 d1                	mov    %edx,%ecx
  80a1c6:	29 c1                	sub    %eax,%ecx
  80a1c8:	89 c8                	mov    %ecx,%eax
  80a1ca:	89 c2                	mov    %eax,%edx
  80a1cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a1d0:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80a1d4:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80a1d8:	c9                   	leaveq 
  80a1d9:	c3                   	retq   

000000000080a1da <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  80a1da:	55                   	push   %rbp
  80a1db:	48 89 e5             	mov    %rsp,%rbp
  80a1de:	48 83 ec 20          	sub    $0x20,%rsp
  80a1e2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80a1e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a1ea:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a1ee:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result = ERR_OK;
  80a1f2:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  80a1f6:	48 b8 a8 23 82 00 00 	movabs $0x8223a8,%rax
  80a1fd:	00 00 00 
  80a200:	8b 10                	mov    (%rax),%edx
  80a202:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a206:	89 50 4c             	mov    %edx,0x4c(%rax)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a209:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a20d:	48 89 c7             	mov    %rax,%rdi
  80a210:	48 b8 e4 b5 80 00 00 	movabs $0x80b5e4,%rax
  80a217:	00 00 00 
  80a21a:	ff d0                	callq  *%rax
  80a21c:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a21f:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a223:	0f 85 a8 01 00 00    	jne    80a3d1 <dhcp_discover+0x1f7>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a229:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a22d:	ba 01 00 00 00       	mov    $0x1,%edx
  80a232:	be 35 00 00 00       	mov    $0x35,%esi
  80a237:	48 89 c7             	mov    %rax,%rdi
  80a23a:	48 b8 08 ae 80 00 00 	movabs $0x80ae08,%rax
  80a241:	00 00 00 
  80a244:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  80a246:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a24a:	be 01 00 00 00       	mov    $0x1,%esi
  80a24f:	48 89 c7             	mov    %rax,%rdi
  80a252:	48 b8 bd ae 80 00 00 	movabs $0x80aebd,%rax
  80a259:	00 00 00 
  80a25c:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a25e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a262:	ba 02 00 00 00       	mov    $0x2,%edx
  80a267:	be 39 00 00 00       	mov    $0x39,%esi
  80a26c:	48 89 c7             	mov    %rax,%rdi
  80a26f:	48 b8 08 ae 80 00 00 	movabs $0x80ae08,%rax
  80a276:	00 00 00 
  80a279:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80a27b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a27f:	be 40 02 00 00       	mov    $0x240,%esi
  80a284:	48 89 c7             	mov    %rax,%rdi
  80a287:	48 b8 35 af 80 00 00 	movabs $0x80af35,%rax
  80a28e:	00 00 00 
  80a291:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  80a293:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a297:	ba 04 00 00 00       	mov    $0x4,%edx
  80a29c:	be 37 00 00 00       	mov    $0x37,%esi
  80a2a1:	48 89 c7             	mov    %rax,%rdi
  80a2a4:	48 b8 08 ae 80 00 00 	movabs $0x80ae08,%rax
  80a2ab:	00 00 00 
  80a2ae:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  80a2b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a2b4:	be 01 00 00 00       	mov    $0x1,%esi
  80a2b9:	48 89 c7             	mov    %rax,%rdi
  80a2bc:	48 b8 bd ae 80 00 00 	movabs $0x80aebd,%rax
  80a2c3:	00 00 00 
  80a2c6:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80a2c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a2cc:	be 03 00 00 00       	mov    $0x3,%esi
  80a2d1:	48 89 c7             	mov    %rax,%rdi
  80a2d4:	48 b8 bd ae 80 00 00 	movabs $0x80aebd,%rax
  80a2db:	00 00 00 
  80a2de:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  80a2e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a2e4:	be 1c 00 00 00       	mov    $0x1c,%esi
  80a2e9:	48 89 c7             	mov    %rax,%rdi
  80a2ec:	48 b8 bd ae 80 00 00 	movabs $0x80aebd,%rax
  80a2f3:	00 00 00 
  80a2f6:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  80a2f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a2fc:	be 06 00 00 00       	mov    $0x6,%esi
  80a301:	48 89 c7             	mov    %rax,%rdi
  80a304:	48 b8 bd ae 80 00 00 	movabs $0x80aebd,%rax
  80a30b:	00 00 00 
  80a30e:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80a310:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a314:	48 89 c7             	mov    %rax,%rdi
  80a317:	48 b8 47 ba 80 00 00 	movabs $0x80ba47,%rax
  80a31e:	00 00 00 
  80a321:	ff d0                	callq  *%rax

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a323:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a327:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a32b:	66 05 f0 00          	add    $0xf0,%ax
  80a32f:	0f b7 d0             	movzwl %ax,%edx
  80a332:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a336:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a33a:	89 d6                	mov    %edx,%esi
  80a33c:	48 89 c7             	mov    %rax,%rdi
  80a33f:	48 b8 1f d5 80 00 00 	movabs $0x80d51f,%rax
  80a346:	00 00 00 
  80a349:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80a34b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a34f:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a353:	ba 43 00 00 00       	mov    $0x43,%edx
  80a358:	48 be a8 23 82 00 00 	movabs $0x8223a8,%rsi
  80a35f:	00 00 00 
  80a362:	48 89 c7             	mov    %rax,%rdi
  80a365:	48 b8 d9 53 81 00 00 	movabs $0x8153d9,%rax
  80a36c:	00 00 00 
  80a36f:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80a371:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a375:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a379:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a37d:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a381:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a385:	49 89 d0             	mov    %rdx,%r8
  80a388:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a38d:	48 ba ac 23 82 00 00 	movabs $0x8223ac,%rdx
  80a394:	00 00 00 
  80a397:	48 89 c7             	mov    %rax,%rdi
  80a39a:	48 b8 e2 4f 81 00 00 	movabs $0x814fe2,%rax
  80a3a1:	00 00 00 
  80a3a4:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  80a3a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a3aa:	48 89 c7             	mov    %rax,%rdi
  80a3ad:	48 b8 21 b9 80 00 00 	movabs $0x80b921,%rax
  80a3b4:	00 00 00 
  80a3b7:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  80a3b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3bd:	be 06 00 00 00       	mov    $0x6,%esi
  80a3c2:	48 89 c7             	mov    %rax,%rdi
  80a3c5:	48 b8 d7 ad 80 00 00 	movabs $0x80add7,%rax
  80a3cc:	00 00 00 
  80a3cf:	ff d0                	callq  *%rax
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80a3d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3d5:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a3d9:	8d 50 01             	lea    0x1(%rax),%edx
  80a3dc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3e0:	88 50 01             	mov    %dl,0x1(%rax)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  80a3e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3e7:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a3eb:	3c 03                	cmp    $0x3,%al
  80a3ed:	77 15                	ja     80a404 <dhcp_discover+0x22a>
  80a3ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a3f3:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a3f7:	0f b6 c0             	movzbl %al,%eax
  80a3fa:	83 c0 01             	add    $0x1,%eax
  80a3fd:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80a402:	eb 05                	jmp    80a409 <dhcp_discover+0x22f>
  80a404:	b8 10 27 00 00       	mov    $0x2710,%eax
  80a409:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80a40d:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80a411:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80a417:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80a41c:	89 c8                	mov    %ecx,%eax
  80a41e:	f7 ea                	imul   %edx
  80a420:	c1 fa 05             	sar    $0x5,%edx
  80a423:	89 c8                	mov    %ecx,%eax
  80a425:	c1 f8 1f             	sar    $0x1f,%eax
  80a428:	89 d1                	mov    %edx,%ecx
  80a42a:	29 c1                	sub    %eax,%ecx
  80a42c:	89 c8                	mov    %ecx,%eax
  80a42e:	89 c2                	mov    %eax,%edx
  80a430:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a434:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80a438:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80a43c:	c9                   	leaveq 
  80a43d:	c3                   	retq   

000000000080a43e <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  80a43e:	55                   	push   %rbp
  80a43f:	48 89 e5             	mov    %rsp,%rbp
  80a442:	53                   	push   %rbx
  80a443:	48 83 ec 48          	sub    $0x48,%rsp
  80a447:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  80a44b:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  80a450:	75 2a                	jne    80a47c <dhcp_bind+0x3e>
  80a452:	48 ba cb 15 82 00 00 	movabs $0x8215cb,%rdx
  80a459:	00 00 00 
  80a45c:	be 3d 03 00 00       	mov    $0x33d,%esi
  80a461:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80a468:	00 00 00 
  80a46b:	b8 00 00 00 00       	mov    $0x0,%eax
  80a470:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80a477:	00 00 00 
  80a47a:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80a47c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80a480:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a484:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  80a488:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80a48d:	75 2a                	jne    80a4b9 <dhcp_bind+0x7b>
  80a48f:	48 ba e4 15 82 00 00 	movabs $0x8215e4,%rdx
  80a496:	00 00 00 
  80a499:	be 3f 03 00 00       	mov    $0x33f,%esi
  80a49e:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80a4a5:	00 00 00 
  80a4a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80a4ad:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80a4b4:	00 00 00 
  80a4b7:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  80a4b9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a4bd:	8b 40 6c             	mov    0x6c(%rax),%eax
  80a4c0:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a4c3:	74 53                	je     80a518 <dhcp_bind+0xda>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80a4c5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a4c9:	8b 40 6c             	mov    0x6c(%rax),%eax
  80a4cc:	83 c0 1e             	add    $0x1e,%eax
  80a4cf:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  80a4d2:	ba 89 88 88 88       	mov    $0x88888889,%edx
  80a4d7:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80a4da:	f7 e2                	mul    %edx
  80a4dc:	89 d0                	mov    %edx,%eax
  80a4de:	c1 e8 05             	shr    $0x5,%eax
  80a4e1:	89 45 ec             	mov    %eax,-0x14(%rbp)
    if(timeout > 0xffff) {
  80a4e4:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%rbp)
  80a4eb:	76 07                	jbe    80a4f4 <dhcp_bind+0xb6>
      timeout = 0xffff;
  80a4ed:	c7 45 ec ff ff 00 00 	movl   $0xffff,-0x14(%rbp)
    }
    dhcp->t1_timeout = (u16_t)timeout;
  80a4f4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80a4f7:	89 c2                	mov    %eax,%edx
  80a4f9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a4fd:	66 89 50 44          	mov    %dx,0x44(%rax)
    if (dhcp->t1_timeout == 0) {
  80a501:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a505:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  80a509:	66 85 c0             	test   %ax,%ax
  80a50c:	75 0a                	jne    80a518 <dhcp_bind+0xda>
      dhcp->t1_timeout = 1;
  80a50e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a512:	66 c7 40 44 01 00    	movw   $0x1,0x44(%rax)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  80a518:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a51c:	8b 40 70             	mov    0x70(%rax),%eax
  80a51f:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a522:	74 53                	je     80a577 <dhcp_bind+0x139>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80a524:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a528:	8b 40 70             	mov    0x70(%rax),%eax
  80a52b:	83 c0 1e             	add    $0x1e,%eax
  80a52e:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  80a531:	ba 89 88 88 88       	mov    $0x88888889,%edx
  80a536:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80a539:	f7 e2                	mul    %edx
  80a53b:	89 d0                	mov    %edx,%eax
  80a53d:	c1 e8 05             	shr    $0x5,%eax
  80a540:	89 45 ec             	mov    %eax,-0x14(%rbp)
    if(timeout > 0xffff) {
  80a543:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%rbp)
  80a54a:	76 07                	jbe    80a553 <dhcp_bind+0x115>
      timeout = 0xffff;
  80a54c:	c7 45 ec ff ff 00 00 	movl   $0xffff,-0x14(%rbp)
    }
    dhcp->t2_timeout = (u16_t)timeout;
  80a553:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80a556:	89 c2                	mov    %eax,%edx
  80a558:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a55c:	66 89 50 46          	mov    %dx,0x46(%rax)
    if (dhcp->t2_timeout == 0) {
  80a560:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a564:	0f b7 40 46          	movzwl 0x46(%rax),%eax
  80a568:	66 85 c0             	test   %ax,%ax
  80a56b:	75 0a                	jne    80a577 <dhcp_bind+0x139>
      dhcp->t2_timeout = 1;
  80a56d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a571:	66 c7 40 46 01 00    	movw   $0x1,0x46(%rax)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  80a577:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a57b:	48 83 c0 50          	add    $0x50,%rax
  80a57f:	48 85 c0             	test   %rax,%rax
  80a582:	74 09                	je     80a58d <dhcp_bind+0x14f>
  80a584:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a588:	8b 40 50             	mov    0x50(%rax),%eax
  80a58b:	eb 05                	jmp    80a592 <dhcp_bind+0x154>
  80a58d:	b8 00 00 00 00       	mov    $0x0,%eax
  80a592:	89 45 d0             	mov    %eax,-0x30(%rbp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  80a595:	8b 45 d0             	mov    -0x30(%rbp),%eax
  80a598:	85 c0                	test   %eax,%eax
  80a59a:	75 65                	jne    80a601 <dhcp_bind+0x1c3>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  80a59c:	8b 45 d0             	mov    -0x30(%rbp),%eax
  80a59f:	89 c7                	mov    %eax,%edi
  80a5a1:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  80a5a8:	00 00 00 
  80a5ab:	ff d0                	callq  *%rax
  80a5ad:	c1 e8 18             	shr    $0x18,%eax
  80a5b0:	88 45 df             	mov    %al,-0x21(%rbp)
    if (first_octet <= 127) {
  80a5b3:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  80a5b7:	84 c0                	test   %al,%al
  80a5b9:	78 16                	js     80a5d1 <dhcp_bind+0x193>
      sn_mask.addr = htonl(0xff000000);
  80a5bb:	bf 00 00 00 ff       	mov    $0xff000000,%edi
  80a5c0:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  80a5c7:	00 00 00 
  80a5ca:	ff d0                	callq  *%rax
  80a5cc:	89 45 d0             	mov    %eax,-0x30(%rbp)
  80a5cf:	eb 30                	jmp    80a601 <dhcp_bind+0x1c3>
    } else if (first_octet >= 192) {
  80a5d1:	80 7d df bf          	cmpb   $0xbf,-0x21(%rbp)
  80a5d5:	76 16                	jbe    80a5ed <dhcp_bind+0x1af>
      sn_mask.addr = htonl(0xffffff00);
  80a5d7:	bf 00 ff ff ff       	mov    $0xffffff00,%edi
  80a5dc:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  80a5e3:	00 00 00 
  80a5e6:	ff d0                	callq  *%rax
  80a5e8:	89 45 d0             	mov    %eax,-0x30(%rbp)
  80a5eb:	eb 14                	jmp    80a601 <dhcp_bind+0x1c3>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  80a5ed:	bf 00 00 ff ff       	mov    $0xffff0000,%edi
  80a5f2:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  80a5f9:	00 00 00 
  80a5fc:	ff d0                	callq  *%rax
  80a5fe:	89 45 d0             	mov    %eax,-0x30(%rbp)
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  80a601:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a605:	48 83 c0 54          	add    $0x54,%rax
  80a609:	48 85 c0             	test   %rax,%rax
  80a60c:	74 09                	je     80a617 <dhcp_bind+0x1d9>
  80a60e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a612:	8b 40 54             	mov    0x54(%rax),%eax
  80a615:	eb 05                	jmp    80a61c <dhcp_bind+0x1de>
  80a617:	b8 00 00 00 00       	mov    $0x0,%eax
  80a61c:	89 45 c0             	mov    %eax,-0x40(%rbp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  80a61f:	8b 45 c0             	mov    -0x40(%rbp),%eax
  80a622:	85 c0                	test   %eax,%eax
  80a624:	75 28                	jne    80a64e <dhcp_bind+0x210>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  80a626:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a62a:	8b 50 4c             	mov    0x4c(%rax),%edx
  80a62d:	8b 45 d0             	mov    -0x30(%rbp),%eax
  80a630:	21 d0                	and    %edx,%eax
  80a632:	89 45 c0             	mov    %eax,-0x40(%rbp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  80a635:	8b 5d c0             	mov    -0x40(%rbp),%ebx
  80a638:	bf 01 00 00 00       	mov    $0x1,%edi
  80a63d:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  80a644:	00 00 00 
  80a647:	ff d0                	callq  *%rax
  80a649:	09 d8                	or     %ebx,%eax
  80a64b:	89 45 c0             	mov    %eax,-0x40(%rbp)
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  80a64e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a652:	48 8d 50 4c          	lea    0x4c(%rax),%rdx
  80a656:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80a65a:	48 89 d6             	mov    %rdx,%rsi
  80a65d:	48 89 c7             	mov    %rax,%rdi
  80a660:	48 b8 17 ce 80 00 00 	movabs $0x80ce17,%rax
  80a667:	00 00 00 
  80a66a:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  80a66c:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80a670:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80a674:	48 89 d6             	mov    %rdx,%rsi
  80a677:	48 89 c7             	mov    %rax,%rdi
  80a67a:	48 b8 4a cf 80 00 00 	movabs $0x80cf4a,%rax
  80a681:	00 00 00 
  80a684:	ff d0                	callq  *%rax
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  80a686:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  80a68a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80a68e:	48 89 d6             	mov    %rdx,%rsi
  80a691:	48 89 c7             	mov    %rax,%rdi
  80a694:	48 b8 1d cf 80 00 00 	movabs $0x80cf1d,%rax
  80a69b:	00 00 00 
  80a69e:	ff d0                	callq  *%rax
  /* bring the interface up */
  netif_set_up(netif);
  80a6a0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80a6a4:	48 89 c7             	mov    %rax,%rdi
  80a6a7:	48 b8 96 cf 80 00 00 	movabs $0x80cf96,%rax
  80a6ae:	00 00 00 
  80a6b1:	ff d0                	callq  *%rax
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  80a6b3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80a6b7:	be 0a 00 00 00       	mov    $0xa,%esi
  80a6bc:	48 89 c7             	mov    %rax,%rdi
  80a6bf:	48 b8 d7 ad 80 00 00 	movabs $0x80add7,%rax
  80a6c6:	00 00 00 
  80a6c9:	ff d0                	callq  *%rax
}
  80a6cb:	48 83 c4 48          	add    $0x48,%rsp
  80a6cf:	5b                   	pop    %rbx
  80a6d0:	5d                   	pop    %rbp
  80a6d1:	c3                   	retq   

000000000080a6d2 <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  80a6d2:	55                   	push   %rbp
  80a6d3:	48 89 e5             	mov    %rsp,%rbp
  80a6d6:	48 83 ec 20          	sub    $0x20,%rsp
  80a6da:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80a6de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a6e2:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a6e6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  80a6ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a6ee:	be 05 00 00 00       	mov    $0x5,%esi
  80a6f3:	48 89 c7             	mov    %rax,%rdi
  80a6f6:	48 b8 d7 ad 80 00 00 	movabs $0x80add7,%rax
  80a6fd:	00 00 00 
  80a700:	ff d0                	callq  *%rax

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a702:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a706:	48 89 c7             	mov    %rax,%rdi
  80a709:	48 b8 e4 b5 80 00 00 	movabs $0x80b5e4,%rax
  80a710:	00 00 00 
  80a713:	ff d0                	callq  *%rax
  80a715:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a718:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a71c:	0f 85 12 01 00 00    	jne    80a834 <dhcp_renew+0x162>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a722:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a726:	ba 01 00 00 00       	mov    $0x1,%edx
  80a72b:	be 35 00 00 00       	mov    $0x35,%esi
  80a730:	48 89 c7             	mov    %rax,%rdi
  80a733:	48 b8 08 ae 80 00 00 	movabs $0x80ae08,%rax
  80a73a:	00 00 00 
  80a73d:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80a73f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a743:	be 03 00 00 00       	mov    $0x3,%esi
  80a748:	48 89 c7             	mov    %rax,%rdi
  80a74b:	48 b8 bd ae 80 00 00 	movabs $0x80aebd,%rax
  80a752:	00 00 00 
  80a755:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a757:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a75b:	ba 02 00 00 00       	mov    $0x2,%edx
  80a760:	be 39 00 00 00       	mov    $0x39,%esi
  80a765:	48 89 c7             	mov    %rax,%rdi
  80a768:	48 b8 08 ae 80 00 00 	movabs $0x80ae08,%rax
  80a76f:	00 00 00 
  80a772:	ff d0                	callq  *%rax
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  80a774:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a778:	be 40 02 00 00       	mov    $0x240,%esi
  80a77d:	48 89 c7             	mov    %rax,%rdi
  80a780:	48 b8 35 af 80 00 00 	movabs $0x80af35,%rax
  80a787:	00 00 00 
  80a78a:	ff d0                	callq  *%rax
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  80a78c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a790:	48 89 c7             	mov    %rax,%rdi
  80a793:	48 b8 47 ba 80 00 00 	movabs $0x80ba47,%rax
  80a79a:	00 00 00 
  80a79d:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a79f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7a3:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a7a7:	66 05 f0 00          	add    $0xf0,%ax
  80a7ab:	0f b7 d0             	movzwl %ax,%edx
  80a7ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7b2:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a7b6:	89 d6                	mov    %edx,%esi
  80a7b8:	48 89 c7             	mov    %rax,%rdi
  80a7bb:	48 b8 1f d5 80 00 00 	movabs $0x80d51f,%rax
  80a7c2:	00 00 00 
  80a7c5:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  80a7c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7cb:	48 8d 48 48          	lea    0x48(%rax),%rcx
  80a7cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7d3:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a7d7:	ba 43 00 00 00       	mov    $0x43,%edx
  80a7dc:	48 89 ce             	mov    %rcx,%rsi
  80a7df:	48 89 c7             	mov    %rax,%rdi
  80a7e2:	48 b8 d9 53 81 00 00 	movabs $0x8153d9,%rax
  80a7e9:	00 00 00 
  80a7ec:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  80a7ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7f2:	48 8d 50 48          	lea    0x48(%rax),%rdx
  80a7f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a7fa:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a7fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a802:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a806:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80a80a:	49 89 c8             	mov    %rcx,%r8
  80a80d:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a812:	48 89 c7             	mov    %rax,%rdi
  80a815:	48 b8 e2 4f 81 00 00 	movabs $0x814fe2,%rax
  80a81c:	00 00 00 
  80a81f:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80a821:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a825:	48 89 c7             	mov    %rax,%rdi
  80a828:	48 b8 21 b9 80 00 00 	movabs $0x80b921,%rax
  80a82f:	00 00 00 
  80a832:	ff d0                	callq  *%rax

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80a834:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a838:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a83c:	8d 50 01             	lea    0x1(%rax),%edx
  80a83f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a843:	88 50 01             	mov    %dl,0x1(%rax)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  80a846:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a84a:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a84e:	3c 09                	cmp    $0x9,%al
  80a850:	77 12                	ja     80a864 <dhcp_renew+0x192>
  80a852:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a856:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80a85a:	0f b6 c0             	movzbl %al,%eax
  80a85d:	66 69 c0 d0 07       	imul   $0x7d0,%ax,%ax
  80a862:	eb 05                	jmp    80a869 <dhcp_renew+0x197>
  80a864:	b8 20 4e 00 00       	mov    $0x4e20,%eax
  80a869:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80a86d:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80a871:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80a877:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80a87c:	89 c8                	mov    %ecx,%eax
  80a87e:	f7 ea                	imul   %edx
  80a880:	c1 fa 05             	sar    $0x5,%edx
  80a883:	89 c8                	mov    %ecx,%eax
  80a885:	c1 f8 1f             	sar    $0x1f,%eax
  80a888:	89 d1                	mov    %edx,%ecx
  80a88a:	29 c1                	sub    %eax,%ecx
  80a88c:	89 c8                	mov    %ecx,%eax
  80a88e:	89 c2                	mov    %eax,%edx
  80a890:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a894:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80a898:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80a89c:	c9                   	leaveq 
  80a89d:	c3                   	retq   

000000000080a89e <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  80a89e:	55                   	push   %rbp
  80a89f:	48 89 e5             	mov    %rsp,%rbp
  80a8a2:	48 83 ec 20          	sub    $0x20,%rsp
  80a8a6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80a8aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a8ae:	48 8b 40 38          	mov    0x38(%rax),%rax
  80a8b2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  80a8b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a8ba:	be 04 00 00 00       	mov    $0x4,%esi
  80a8bf:	48 89 c7             	mov    %rax,%rdi
  80a8c2:	48 b8 d7 ad 80 00 00 	movabs $0x80add7,%rax
  80a8c9:	00 00 00 
  80a8cc:	ff d0                	callq  *%rax

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80a8ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a8d2:	48 89 c7             	mov    %rax,%rdi
  80a8d5:	48 b8 e4 b5 80 00 00 	movabs $0x80b5e4,%rax
  80a8dc:	00 00 00 
  80a8df:	ff d0                	callq  *%rax
  80a8e1:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80a8e4:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80a8e8:	0f 85 13 01 00 00    	jne    80aa01 <dhcp_rebind+0x163>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80a8ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a8f2:	ba 01 00 00 00       	mov    $0x1,%edx
  80a8f7:	be 35 00 00 00       	mov    $0x35,%esi
  80a8fc:	48 89 c7             	mov    %rax,%rdi
  80a8ff:	48 b8 08 ae 80 00 00 	movabs $0x80ae08,%rax
  80a906:	00 00 00 
  80a909:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80a90b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a90f:	be 03 00 00 00       	mov    $0x3,%esi
  80a914:	48 89 c7             	mov    %rax,%rdi
  80a917:	48 b8 bd ae 80 00 00 	movabs $0x80aebd,%rax
  80a91e:	00 00 00 
  80a921:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80a923:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a927:	ba 02 00 00 00       	mov    $0x2,%edx
  80a92c:	be 39 00 00 00       	mov    $0x39,%esi
  80a931:	48 89 c7             	mov    %rax,%rdi
  80a934:	48 b8 08 ae 80 00 00 	movabs $0x80ae08,%rax
  80a93b:	00 00 00 
  80a93e:	ff d0                	callq  *%rax
    dhcp_option_short(dhcp, 576);
  80a940:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a944:	be 40 02 00 00       	mov    $0x240,%esi
  80a949:	48 89 c7             	mov    %rax,%rdi
  80a94c:	48 b8 35 af 80 00 00 	movabs $0x80af35,%rax
  80a953:	00 00 00 
  80a956:	ff d0                	callq  *%rax

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  80a958:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a95c:	48 89 c7             	mov    %rax,%rdi
  80a95f:	48 b8 47 ba 80 00 00 	movabs $0x80ba47,%rax
  80a966:	00 00 00 
  80a969:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80a96b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a96f:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80a973:	66 05 f0 00          	add    $0xf0,%ax
  80a977:	0f b7 d0             	movzwl %ax,%edx
  80a97a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a97e:	48 8b 40 30          	mov    0x30(%rax),%rax
  80a982:	89 d6                	mov    %edx,%esi
  80a984:	48 89 c7             	mov    %rax,%rdi
  80a987:	48 b8 1f d5 80 00 00 	movabs $0x80d51f,%rax
  80a98e:	00 00 00 
  80a991:	ff d0                	callq  *%rax

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80a993:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a997:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a99b:	ba 43 00 00 00       	mov    $0x43,%edx
  80a9a0:	48 be a8 23 82 00 00 	movabs $0x8223a8,%rsi
  80a9a7:	00 00 00 
  80a9aa:	48 89 c7             	mov    %rax,%rdi
  80a9ad:	48 b8 d9 53 81 00 00 	movabs $0x8153d9,%rax
  80a9b4:	00 00 00 
  80a9b7:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80a9b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a9bd:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80a9c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80a9c5:	48 8b 40 08          	mov    0x8(%rax),%rax
  80a9c9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80a9cd:	49 89 d0             	mov    %rdx,%r8
  80a9d0:	b9 43 00 00 00       	mov    $0x43,%ecx
  80a9d5:	48 ba ac 23 82 00 00 	movabs $0x8223ac,%rdx
  80a9dc:	00 00 00 
  80a9df:	48 89 c7             	mov    %rax,%rdi
  80a9e2:	48 b8 e2 4f 81 00 00 	movabs $0x814fe2,%rax
  80a9e9:	00 00 00 
  80a9ec:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80a9ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80a9f2:	48 89 c7             	mov    %rax,%rdi
  80a9f5:	48 b8 21 b9 80 00 00 	movabs $0x80b921,%rax
  80a9fc:	00 00 00 
  80a9ff:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80aa01:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa05:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80aa09:	8d 50 01             	lea    0x1(%rax),%edx
  80aa0c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa10:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80aa13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa17:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80aa1b:	3c 09                	cmp    $0x9,%al
  80aa1d:	77 12                	ja     80aa31 <dhcp_rebind+0x193>
  80aa1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa23:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80aa27:	0f b6 c0             	movzbl %al,%eax
  80aa2a:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80aa2f:	eb 05                	jmp    80aa36 <dhcp_rebind+0x198>
  80aa31:	b8 10 27 00 00       	mov    $0x2710,%eax
  80aa36:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80aa3a:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80aa3e:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80aa44:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80aa49:	89 c8                	mov    %ecx,%eax
  80aa4b:	f7 ea                	imul   %edx
  80aa4d:	c1 fa 05             	sar    $0x5,%edx
  80aa50:	89 c8                	mov    %ecx,%eax
  80aa52:	c1 f8 1f             	sar    $0x1f,%eax
  80aa55:	89 d1                	mov    %edx,%ecx
  80aa57:	29 c1                	sub    %eax,%ecx
  80aa59:	89 c8                	mov    %ecx,%eax
  80aa5b:	89 c2                	mov    %eax,%edx
  80aa5d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa61:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
  80aa65:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80aa69:	c9                   	leaveq 
  80aa6a:	c3                   	retq   

000000000080aa6b <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  80aa6b:	55                   	push   %rbp
  80aa6c:	48 89 e5             	mov    %rsp,%rbp
  80aa6f:	48 83 ec 20          	sub    $0x20,%rsp
  80aa73:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80aa77:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aa7b:	48 8b 40 38          	mov    0x38(%rax),%rax
  80aa7f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  80aa83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa87:	be 0d 00 00 00       	mov    $0xd,%esi
  80aa8c:	48 89 c7             	mov    %rax,%rdi
  80aa8f:	48 b8 d7 ad 80 00 00 	movabs $0x80add7,%rax
  80aa96:	00 00 00 
  80aa99:	ff d0                	callq  *%rax
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  80aa9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aa9f:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%rax)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  80aaa6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aaaa:	c7 40 50 00 00 00 00 	movl   $0x0,0x50(%rax)
  80aab1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aab5:	8b 50 50             	mov    0x50(%rax),%edx
  80aab8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aabc:	89 50 4c             	mov    %edx,0x4c(%rax)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  80aabf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aac3:	c7 40 58 00 00 00 00 	movl   $0x0,0x58(%rax)
  80aaca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aace:	8b 50 58             	mov    0x58(%rax),%edx
  80aad1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aad5:	89 50 54             	mov    %edx,0x54(%rax)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  80aad8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aadc:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%rax)
  80aae3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aae7:	8b 50 70             	mov    0x70(%rax),%edx
  80aaea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aaee:	89 50 6c             	mov    %edx,0x6c(%rax)
  80aaf1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aaf5:	8b 50 6c             	mov    0x6c(%rax),%edx
  80aaf8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aafc:	89 50 68             	mov    %edx,0x68(%rax)
  dhcp->dns_count = 0;
  80aaff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab03:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80ab0a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ab0e:	48 89 c7             	mov    %rax,%rdi
  80ab11:	48 b8 e4 b5 80 00 00 	movabs $0x80b5e4,%rax
  80ab18:	00 00 00 
  80ab1b:	ff d0                	callq  *%rax
  80ab1d:	88 45 f7             	mov    %al,-0x9(%rbp)
  if (result == ERR_OK) {
  80ab20:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80ab24:	0f 85 dd 00 00 00    	jne    80ac07 <dhcp_release+0x19c>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80ab2a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab2e:	ba 01 00 00 00       	mov    $0x1,%edx
  80ab33:	be 35 00 00 00       	mov    $0x35,%esi
  80ab38:	48 89 c7             	mov    %rax,%rdi
  80ab3b:	48 b8 08 ae 80 00 00 	movabs $0x80ae08,%rax
  80ab42:	00 00 00 
  80ab45:	ff d0                	callq  *%rax
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  80ab47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab4b:	be 07 00 00 00       	mov    $0x7,%esi
  80ab50:	48 89 c7             	mov    %rax,%rdi
  80ab53:	48 b8 bd ae 80 00 00 	movabs $0x80aebd,%rax
  80ab5a:	00 00 00 
  80ab5d:	ff d0                	callq  *%rax

    dhcp_option_trailer(dhcp);
  80ab5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab63:	48 89 c7             	mov    %rax,%rdi
  80ab66:	48 b8 47 ba 80 00 00 	movabs $0x80ba47,%rax
  80ab6d:	00 00 00 
  80ab70:	ff d0                	callq  *%rax

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80ab72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab76:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80ab7a:	66 05 f0 00          	add    $0xf0,%ax
  80ab7e:	0f b7 d0             	movzwl %ax,%edx
  80ab81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab85:	48 8b 40 30          	mov    0x30(%rax),%rax
  80ab89:	89 d6                	mov    %edx,%esi
  80ab8b:	48 89 c7             	mov    %rax,%rdi
  80ab8e:	48 b8 1f d5 80 00 00 	movabs $0x80d51f,%rax
  80ab95:	00 00 00 
  80ab98:	ff d0                	callq  *%rax

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  80ab9a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ab9e:	48 8d 48 48          	lea    0x48(%rax),%rcx
  80aba2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aba6:	48 8b 40 08          	mov    0x8(%rax),%rax
  80abaa:	ba 43 00 00 00       	mov    $0x43,%edx
  80abaf:	48 89 ce             	mov    %rcx,%rsi
  80abb2:	48 89 c7             	mov    %rax,%rdi
  80abb5:	48 b8 d9 53 81 00 00 	movabs $0x8153d9,%rax
  80abbc:	00 00 00 
  80abbf:	ff d0                	callq  *%rax
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  80abc1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abc5:	48 8d 50 48          	lea    0x48(%rax),%rdx
  80abc9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abcd:	48 8b 70 30          	mov    0x30(%rax),%rsi
  80abd1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80abd5:	48 8b 40 08          	mov    0x8(%rax),%rax
  80abd9:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80abdd:	49 89 c8             	mov    %rcx,%r8
  80abe0:	b9 43 00 00 00       	mov    $0x43,%ecx
  80abe5:	48 89 c7             	mov    %rax,%rdi
  80abe8:	48 b8 e2 4f 81 00 00 	movabs $0x814fe2,%rax
  80abef:	00 00 00 
  80abf2:	ff d0                	callq  *%rax
    dhcp_delete_request(netif);
  80abf4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80abf8:	48 89 c7             	mov    %rax,%rdi
  80abfb:	48 b8 21 b9 80 00 00 	movabs $0x80b921,%rax
  80ac02:	00 00 00 
  80ac05:	ff d0                	callq  *%rax
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80ac07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac0b:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80ac0f:	8d 50 01             	lea    0x1(%rax),%edx
  80ac12:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac16:	88 50 01             	mov    %dl,0x1(%rax)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80ac19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac1d:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80ac21:	3c 09                	cmp    $0x9,%al
  80ac23:	77 12                	ja     80ac37 <dhcp_release+0x1cc>
  80ac25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac29:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  80ac2d:	0f b6 c0             	movzbl %al,%eax
  80ac30:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  80ac35:	eb 05                	jmp    80ac3c <dhcp_release+0x1d1>
  80ac37:	b8 10 27 00 00       	mov    $0x2710,%eax
  80ac3c:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80ac40:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80ac44:	8d 88 f3 01 00 00    	lea    0x1f3(%rax),%ecx
  80ac4a:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80ac4f:	89 c8                	mov    %ecx,%eax
  80ac51:	f7 ea                	imul   %edx
  80ac53:	c1 fa 05             	sar    $0x5,%edx
  80ac56:	89 c8                	mov    %ecx,%eax
  80ac58:	c1 f8 1f             	sar    $0x1f,%eax
  80ac5b:	89 d1                	mov    %edx,%ecx
  80ac5d:	29 c1                	sub    %eax,%ecx
  80ac5f:	89 c8                	mov    %ecx,%eax
  80ac61:	89 c2                	mov    %eax,%edx
  80ac63:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ac67:	66 89 50 42          	mov    %dx,0x42(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  80ac6b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ac6f:	48 89 c7             	mov    %rax,%rdi
  80ac72:	48 b8 ff cf 80 00 00 	movabs $0x80cfff,%rax
  80ac79:	00 00 00 
  80ac7c:	ff d0                	callq  *%rax
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  80ac7e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ac82:	48 be a8 23 82 00 00 	movabs $0x8223a8,%rsi
  80ac89:	00 00 00 
  80ac8c:	48 89 c7             	mov    %rax,%rdi
  80ac8f:	48 b8 17 ce 80 00 00 	movabs $0x80ce17,%rax
  80ac96:	00 00 00 
  80ac99:	ff d0                	callq  *%rax
  netif_set_gw(netif, IP_ADDR_ANY);
  80ac9b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ac9f:	48 be a8 23 82 00 00 	movabs $0x8223a8,%rsi
  80aca6:	00 00 00 
  80aca9:	48 89 c7             	mov    %rax,%rdi
  80acac:	48 b8 1d cf 80 00 00 	movabs $0x80cf1d,%rax
  80acb3:	00 00 00 
  80acb6:	ff d0                	callq  *%rax
  netif_set_netmask(netif, IP_ADDR_ANY);
  80acb8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80acbc:	48 be a8 23 82 00 00 	movabs $0x8223a8,%rsi
  80acc3:	00 00 00 
  80acc6:	48 89 c7             	mov    %rax,%rdi
  80acc9:	48 b8 4a cf 80 00 00 	movabs $0x80cf4a,%rax
  80acd0:	00 00 00 
  80acd3:	ff d0                	callq  *%rax
  
  /* TODO: netif_down(netif); */
  return result;
  80acd5:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
}
  80acd9:	c9                   	leaveq 
  80acda:	c3                   	retq   

000000000080acdb <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  80acdb:	55                   	push   %rbp
  80acdc:	48 89 e5             	mov    %rsp,%rbp
  80acdf:	48 83 ec 20          	sub    $0x20,%rsp
  80ace3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80ace7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80aceb:	48 8b 40 38          	mov    0x38(%rax),%rax
  80acef:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  80acf3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80acf8:	75 2a                	jne    80ad24 <dhcp_stop+0x49>
  80acfa:	48 ba fc 15 82 00 00 	movabs $0x8215fc,%rdx
  80ad01:	00 00 00 
  80ad04:	be 2c 04 00 00       	mov    $0x42c,%esi
  80ad09:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80ad10:	00 00 00 
  80ad13:	b8 00 00 00 00       	mov    $0x0,%eax
  80ad18:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80ad1f:	00 00 00 
  80ad22:	ff d1                	callq  *%rcx
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  80ad24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ad28:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80ad2c:	89 c2                	mov    %eax,%edx
  80ad2e:	83 e2 f7             	and    $0xfffffff7,%edx
  80ad31:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ad35:	88 50 4a             	mov    %dl,0x4a(%rax)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  80ad38:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ad3d:	0f 84 92 00 00 00    	je     80add5 <dhcp_stop+0xfa>
    if (dhcp->pcb != NULL) {
  80ad43:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad47:	48 8b 40 08          	mov    0x8(%rax),%rax
  80ad4b:	48 85 c0             	test   %rax,%rax
  80ad4e:	74 23                	je     80ad73 <dhcp_stop+0x98>
      udp_remove(dhcp->pcb);
  80ad50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad54:	48 8b 40 08          	mov    0x8(%rax),%rax
  80ad58:	48 89 c7             	mov    %rax,%rdi
  80ad5b:	48 b8 3f 55 81 00 00 	movabs $0x81553f,%rax
  80ad62:	00 00 00 
  80ad65:	ff d0                	callq  *%rax
      dhcp->pcb = NULL;
  80ad67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad6b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80ad72:	00 
    }
    if (dhcp->p != NULL) {
  80ad73:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad77:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ad7b:	48 85 c0             	test   %rax,%rax
  80ad7e:	74 23                	je     80ada3 <dhcp_stop+0xc8>
      pbuf_free(dhcp->p);
  80ad80:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad84:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ad88:	48 89 c7             	mov    %rax,%rdi
  80ad8b:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  80ad92:	00 00 00 
  80ad95:	ff d0                	callq  *%rax
      dhcp->p = NULL;
  80ad97:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ad9b:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80ada2:	00 
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  80ada3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ada7:	48 89 c7             	mov    %rax,%rdi
  80adaa:	48 b8 15 b3 80 00 00 	movabs $0x80b315,%rax
  80adb1:	00 00 00 
  80adb4:	ff d0                	callq  *%rax
    mem_free((void *)dhcp);
  80adb6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80adba:	48 89 c7             	mov    %rax,%rdi
  80adbd:	48 b8 d3 c0 80 00 00 	movabs $0x80c0d3,%rax
  80adc4:	00 00 00 
  80adc7:	ff d0                	callq  *%rax
    netif->dhcp = NULL;
  80adc9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80adcd:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80add4:	00 
  }
}
  80add5:	c9                   	leaveq 
  80add6:	c3                   	retq   

000000000080add7 <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  80add7:	55                   	push   %rbp
  80add8:	48 89 e5             	mov    %rsp,%rbp
  80addb:	48 83 ec 10          	sub    $0x10,%rsp
  80addf:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80ade3:	89 f0                	mov    %esi,%eax
  80ade5:	88 45 f4             	mov    %al,-0xc(%rbp)
  if (new_state != dhcp->state) {
  80ade8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80adec:	0f b6 00             	movzbl (%rax),%eax
  80adef:	3a 45 f4             	cmp    -0xc(%rbp),%al
  80adf2:	74 12                	je     80ae06 <dhcp_set_state+0x2f>
    dhcp->state = new_state;
  80adf4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80adf8:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  80adfc:	88 10                	mov    %dl,(%rax)
    dhcp->tries = 0;
  80adfe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae02:	c6 40 01 00          	movb   $0x0,0x1(%rax)
  }
}
  80ae06:	c9                   	leaveq 
  80ae07:	c3                   	retq   

000000000080ae08 <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  80ae08:	55                   	push   %rbp
  80ae09:	48 89 e5             	mov    %rsp,%rbp
  80ae0c:	48 83 ec 10          	sub    $0x10,%rsp
  80ae10:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80ae14:	89 f1                	mov    %esi,%ecx
  80ae16:	89 d0                	mov    %edx,%eax
  80ae18:	88 4d f4             	mov    %cl,-0xc(%rbp)
  80ae1b:	88 45 f0             	mov    %al,-0x10(%rbp)
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  80ae1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae22:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80ae26:	0f b7 d0             	movzwl %ax,%edx
  80ae29:	0f b6 45 f0          	movzbl -0x10(%rbp),%eax
  80ae2d:	01 d0                	add    %edx,%eax
  80ae2f:	83 c0 02             	add    $0x2,%eax
  80ae32:	83 f8 44             	cmp    $0x44,%eax
  80ae35:	76 2a                	jbe    80ae61 <dhcp_option+0x59>
  80ae37:	48 ba 18 16 82 00 00 	movabs $0x821618,%rdx
  80ae3e:	00 00 00 
  80ae41:	be 5a 04 00 00       	mov    $0x45a,%esi
  80ae46:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80ae4d:	00 00 00 
  80ae50:	b8 00 00 00 00       	mov    $0x0,%eax
  80ae55:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80ae5c:	00 00 00 
  80ae5f:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  80ae61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae65:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80ae69:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae6d:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80ae71:	0f b7 d0             	movzwl %ax,%edx
  80ae74:	48 63 d2             	movslq %edx,%rdx
  80ae77:	0f b6 75 f4          	movzbl -0xc(%rbp),%esi
  80ae7b:	40 88 b4 11 f0 00 00 	mov    %sil,0xf0(%rcx,%rdx,1)
  80ae82:	00 
  80ae83:	8d 50 01             	lea    0x1(%rax),%edx
  80ae86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae8a:	66 89 50 40          	mov    %dx,0x40(%rax)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  80ae8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae92:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80ae96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ae9a:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80ae9e:	0f b7 d0             	movzwl %ax,%edx
  80aea1:	48 63 d2             	movslq %edx,%rdx
  80aea4:	0f b6 75 f0          	movzbl -0x10(%rbp),%esi
  80aea8:	40 88 b4 11 f0 00 00 	mov    %sil,0xf0(%rcx,%rdx,1)
  80aeaf:	00 
  80aeb0:	8d 50 01             	lea    0x1(%rax),%edx
  80aeb3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aeb7:	66 89 50 40          	mov    %dx,0x40(%rax)
}
  80aebb:	c9                   	leaveq 
  80aebc:	c3                   	retq   

000000000080aebd <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  80aebd:	55                   	push   %rbp
  80aebe:	48 89 e5             	mov    %rsp,%rbp
  80aec1:	48 83 ec 10          	sub    $0x10,%rsp
  80aec5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80aec9:	89 f0                	mov    %esi,%eax
  80aecb:	88 45 f4             	mov    %al,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80aece:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aed2:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80aed6:	66 83 f8 43          	cmp    $0x43,%ax
  80aeda:	76 2a                	jbe    80af06 <dhcp_option_byte+0x49>
  80aedc:	48 ba 60 16 82 00 00 	movabs $0x821660,%rdx
  80aee3:	00 00 00 
  80aee6:	be 65 04 00 00       	mov    $0x465,%esi
  80aeeb:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80aef2:	00 00 00 
  80aef5:	b8 00 00 00 00       	mov    $0x0,%eax
  80aefa:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80af01:	00 00 00 
  80af04:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  80af06:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af0a:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80af0e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af12:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80af16:	0f b7 d0             	movzwl %ax,%edx
  80af19:	48 63 d2             	movslq %edx,%rdx
  80af1c:	0f b6 75 f4          	movzbl -0xc(%rbp),%esi
  80af20:	40 88 b4 11 f0 00 00 	mov    %sil,0xf0(%rcx,%rdx,1)
  80af27:	00 
  80af28:	8d 50 01             	lea    0x1(%rax),%edx
  80af2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af2f:	66 89 50 40          	mov    %dx,0x40(%rax)
}
  80af33:	c9                   	leaveq 
  80af34:	c3                   	retq   

000000000080af35 <dhcp_option_short>:

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  80af35:	55                   	push   %rbp
  80af36:	48 89 e5             	mov    %rsp,%rbp
  80af39:	48 83 ec 10          	sub    $0x10,%rsp
  80af3d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80af41:	89 f0                	mov    %esi,%eax
  80af43:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  80af47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af4b:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80af4f:	0f b7 c0             	movzwl %ax,%eax
  80af52:	83 c0 02             	add    $0x2,%eax
  80af55:	83 f8 44             	cmp    $0x44,%eax
  80af58:	76 2a                	jbe    80af84 <dhcp_option_short+0x4f>
  80af5a:	48 ba a0 16 82 00 00 	movabs $0x8216a0,%rdx
  80af61:	00 00 00 
  80af64:	be 6c 04 00 00       	mov    $0x46c,%esi
  80af69:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80af70:	00 00 00 
  80af73:	b8 00 00 00 00       	mov    $0x0,%eax
  80af78:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80af7f:	00 00 00 
  80af82:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  80af84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af88:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80af8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80af90:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80af94:	0f b7 d0             	movzwl %ax,%edx
  80af97:	0f b7 75 f4          	movzwl -0xc(%rbp),%esi
  80af9b:	66 c1 ee 08          	shr    $0x8,%si
  80af9f:	48 63 d2             	movslq %edx,%rdx
  80afa2:	40 88 b4 11 f0 00 00 	mov    %sil,0xf0(%rcx,%rdx,1)
  80afa9:	00 
  80afaa:	8d 50 01             	lea    0x1(%rax),%edx
  80afad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80afb1:	66 89 50 40          	mov    %dx,0x40(%rax)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  80afb5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80afb9:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80afbd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80afc1:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80afc5:	0f b7 d0             	movzwl %ax,%edx
  80afc8:	0f b7 75 f4          	movzwl -0xc(%rbp),%esi
  80afcc:	48 63 d2             	movslq %edx,%rdx
  80afcf:	40 88 b4 11 f0 00 00 	mov    %sil,0xf0(%rcx,%rdx,1)
  80afd6:	00 
  80afd7:	8d 50 01             	lea    0x1(%rax),%edx
  80afda:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80afde:	66 89 50 40          	mov    %dx,0x40(%rax)
}
  80afe2:	c9                   	leaveq 
  80afe3:	c3                   	retq   

000000000080afe4 <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  80afe4:	55                   	push   %rbp
  80afe5:	48 89 e5             	mov    %rsp,%rbp
  80afe8:	48 83 ec 10          	sub    $0x10,%rsp
  80afec:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80aff0:	89 75 f4             	mov    %esi,-0xc(%rbp)
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  80aff3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80aff7:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80affb:	0f b7 c0             	movzwl %ax,%eax
  80affe:	83 c0 04             	add    $0x4,%eax
  80b001:	83 f8 44             	cmp    $0x44,%eax
  80b004:	76 2a                	jbe    80b030 <dhcp_option_long+0x4c>
  80b006:	48 ba e8 16 82 00 00 	movabs $0x8216e8,%rdx
  80b00d:	00 00 00 
  80b010:	be 74 04 00 00       	mov    $0x474,%esi
  80b015:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80b01c:	00 00 00 
  80b01f:	b8 00 00 00 00       	mov    $0x0,%eax
  80b024:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80b02b:	00 00 00 
  80b02e:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  80b030:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b034:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80b038:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b03c:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b040:	0f b7 d0             	movzwl %ax,%edx
  80b043:	8b 75 f4             	mov    -0xc(%rbp),%esi
  80b046:	c1 ee 18             	shr    $0x18,%esi
  80b049:	48 63 d2             	movslq %edx,%rdx
  80b04c:	40 88 b4 11 f0 00 00 	mov    %sil,0xf0(%rcx,%rdx,1)
  80b053:	00 
  80b054:	8d 50 01             	lea    0x1(%rax),%edx
  80b057:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b05b:	66 89 50 40          	mov    %dx,0x40(%rax)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  80b05f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b063:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80b067:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b06b:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b06f:	0f b7 d0             	movzwl %ax,%edx
  80b072:	8b 75 f4             	mov    -0xc(%rbp),%esi
  80b075:	81 e6 00 00 ff 00    	and    $0xff0000,%esi
  80b07b:	48 c1 ee 10          	shr    $0x10,%rsi
  80b07f:	48 63 d2             	movslq %edx,%rdx
  80b082:	40 88 b4 11 f0 00 00 	mov    %sil,0xf0(%rcx,%rdx,1)
  80b089:	00 
  80b08a:	8d 50 01             	lea    0x1(%rax),%edx
  80b08d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b091:	66 89 50 40          	mov    %dx,0x40(%rax)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  80b095:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b099:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80b09d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b0a1:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b0a5:	0f b7 d0             	movzwl %ax,%edx
  80b0a8:	8b 75 f4             	mov    -0xc(%rbp),%esi
  80b0ab:	81 e6 00 ff 00 00    	and    $0xff00,%esi
  80b0b1:	48 c1 ee 08          	shr    $0x8,%rsi
  80b0b5:	48 63 d2             	movslq %edx,%rdx
  80b0b8:	40 88 b4 11 f0 00 00 	mov    %sil,0xf0(%rcx,%rdx,1)
  80b0bf:	00 
  80b0c0:	8d 50 01             	lea    0x1(%rax),%edx
  80b0c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b0c7:	66 89 50 40          	mov    %dx,0x40(%rax)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  80b0cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b0cf:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80b0d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b0d7:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80b0db:	0f b7 d0             	movzwl %ax,%edx
  80b0de:	8b 75 f4             	mov    -0xc(%rbp),%esi
  80b0e1:	48 63 d2             	movslq %edx,%rdx
  80b0e4:	40 88 b4 11 f0 00 00 	mov    %sil,0xf0(%rcx,%rdx,1)
  80b0eb:	00 
  80b0ec:	8d 50 01             	lea    0x1(%rax),%edx
  80b0ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b0f3:	66 89 50 40          	mov    %dx,0x40(%rax)
}
  80b0f7:	c9                   	leaveq 
  80b0f8:	c3                   	retq   

000000000080b0f9 <dhcp_unfold_reply>:
 * use that further on.
 *
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  80b0f9:	55                   	push   %rbp
  80b0fa:	48 89 e5             	mov    %rsp,%rbp
  80b0fd:	48 83 ec 20          	sub    $0x20,%rsp
  80b101:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  80b105:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80b10a:	75 2a                	jne    80b136 <dhcp_unfold_reply+0x3d>
  80b10c:	48 ba 28 17 82 00 00 	movabs $0x821728,%rdx
  80b113:	00 00 00 
  80b116:	be 89 04 00 00       	mov    $0x489,%esi
  80b11b:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80b122:	00 00 00 
  80b125:	b8 00 00 00 00       	mov    $0x0,%eax
  80b12a:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80b131:	00 00 00 
  80b134:	ff d1                	callq  *%rcx
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  80b136:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b13a:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b13e:	48 85 c0             	test   %rax,%rax
  80b141:	75 2a                	jne    80b16d <dhcp_unfold_reply+0x74>
  80b143:	48 ba 35 17 82 00 00 	movabs $0x821735,%rdx
  80b14a:	00 00 00 
  80b14d:	be 8a 04 00 00       	mov    $0x48a,%esi
  80b152:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80b159:	00 00 00 
  80b15c:	b8 00 00 00 00       	mov    $0x0,%eax
  80b161:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80b168:	00 00 00 
  80b16b:	ff d1                	callq  *%rcx
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  80b16d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b171:	48 89 c7             	mov    %rax,%rdi
  80b174:	48 b8 15 b3 80 00 00 	movabs $0x80b315,%rax
  80b17b:	00 00 00 
  80b17e:	ff d0                	callq  *%rax
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  80b180:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b184:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b188:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80b18c:	66 3d f0 00          	cmp    $0xf0,%ax
  80b190:	76 52                	jbe    80b1e4 <dhcp_unfold_reply+0xeb>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b192:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b196:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b19a:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80b19e:	8d 90 10 ff ff ff    	lea    -0xf0(%rax),%edx
  80b1a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b1a8:	66 89 50 28          	mov    %dx,0x28(%rax)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  80b1ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b1b0:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80b1b4:	0f b7 c0             	movzwl %ax,%eax
  80b1b7:	89 c7                	mov    %eax,%edi
  80b1b9:	48 b8 79 c5 80 00 00 	movabs $0x80c579,%rax
  80b1c0:	00 00 00 
  80b1c3:	ff d0                	callq  *%rax
  80b1c5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80b1c9:	48 89 42 20          	mov    %rax,0x20(%rdx)
    if (dhcp->options_in == NULL) {
  80b1cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b1d1:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b1d5:	48 85 c0             	test   %rax,%rax
  80b1d8:	75 0a                	jne    80b1e4 <dhcp_unfold_reply+0xeb>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
  80b1da:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80b1df:	e9 2f 01 00 00       	jmpq   80b313 <dhcp_unfold_reply+0x21a>
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b1e4:	bf f0 00 00 00       	mov    $0xf0,%edi
  80b1e9:	48 b8 79 c5 80 00 00 	movabs $0x80c579,%rax
  80b1f0:	00 00 00 
  80b1f3:	ff d0                	callq  *%rax
  80b1f5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80b1f9:	48 89 42 18          	mov    %rax,0x18(%rdx)
  if (dhcp->msg_in == NULL) {
  80b1fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b201:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b205:	48 85 c0             	test   %rax,%rax
  80b208:	75 2d                	jne    80b237 <dhcp_unfold_reply+0x13e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  80b20a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b20e:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b212:	48 89 c7             	mov    %rax,%rdi
  80b215:	48 b8 d3 c0 80 00 00 	movabs $0x80c0d3,%rax
  80b21c:	00 00 00 
  80b21f:	ff d0                	callq  *%rax
    dhcp->options_in = NULL;
  80b221:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b225:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  80b22c:	00 
    return ERR_MEM;
  80b22d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80b232:	e9 dc 00 00 00       	jmpq   80b313 <dhcp_unfold_reply+0x21a>
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  80b237:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b23b:	48 8b 70 18          	mov    0x18(%rax),%rsi
  80b23f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b243:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b247:	b9 00 00 00 00       	mov    $0x0,%ecx
  80b24c:	ba f0 00 00 00       	mov    $0xf0,%edx
  80b251:	48 89 c7             	mov    %rax,%rdi
  80b254:	48 b8 4b e0 80 00 00 	movabs $0x80e04b,%rax
  80b25b:	00 00 00 
  80b25e:	ff d0                	callq  *%rax
  80b260:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b264:	66 81 7d fe f0 00    	cmpw   $0xf0,-0x2(%rbp)
  80b26a:	74 2a                	je     80b296 <dhcp_unfold_reply+0x19d>
  80b26c:	48 ba 48 17 82 00 00 	movabs $0x821748,%rdx
  80b273:	00 00 00 
  80b276:	be a0 04 00 00       	mov    $0x4a0,%esi
  80b27b:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80b282:	00 00 00 
  80b285:	b8 00 00 00 00       	mov    $0x0,%eax
  80b28a:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80b291:	00 00 00 
  80b294:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  80b296:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b29a:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b29e:	48 85 c0             	test   %rax,%rax
  80b2a1:	74 6b                	je     80b30e <dhcp_unfold_reply+0x215>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80b2a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b2a7:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80b2ab:	0f b7 d0             	movzwl %ax,%edx
  80b2ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b2b2:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80b2b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b2ba:	48 8b 40 10          	mov    0x10(%rax),%rax
  80b2be:	b9 f0 00 00 00       	mov    $0xf0,%ecx
  80b2c3:	48 89 c7             	mov    %rax,%rdi
  80b2c6:	48 b8 4b e0 80 00 00 	movabs $0x80e04b,%rax
  80b2cd:	00 00 00 
  80b2d0:	ff d0                	callq  *%rax
  80b2d2:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  80b2d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b2da:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80b2de:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80b2e2:	74 2a                	je     80b30e <dhcp_unfold_reply+0x215>
  80b2e4:	48 ba 7a 17 82 00 00 	movabs $0x82177a,%rdx
  80b2eb:	00 00 00 
  80b2ee:	be a7 04 00 00       	mov    $0x4a7,%esi
  80b2f3:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80b2fa:	00 00 00 
  80b2fd:	b8 00 00 00 00       	mov    $0x0,%eax
  80b302:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80b309:	00 00 00 
  80b30c:	ff d1                	callq  *%rcx
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes to dhcp->options_in[]\n",
      dhcp->options_in_len));
  }
  LWIP_UNUSED_ARG(ret);
  return ERR_OK;
  80b30e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b313:	c9                   	leaveq 
  80b314:	c3                   	retq   

000000000080b315 <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  80b315:	55                   	push   %rbp
  80b316:	48 89 e5             	mov    %rsp,%rbp
  80b319:	48 83 ec 10          	sub    $0x10,%rsp
  80b31d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (dhcp->msg_in != NULL) {
  80b321:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b325:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b329:	48 85 c0             	test   %rax,%rax
  80b32c:	74 23                	je     80b351 <dhcp_free_reply+0x3c>
    mem_free((void *)dhcp->msg_in);
  80b32e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b332:	48 8b 40 18          	mov    0x18(%rax),%rax
  80b336:	48 89 c7             	mov    %rax,%rdi
  80b339:	48 b8 d3 c0 80 00 00 	movabs $0x80c0d3,%rax
  80b340:	00 00 00 
  80b343:	ff d0                	callq  *%rax
    dhcp->msg_in = NULL;
  80b345:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b349:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  80b350:	00 
  }
  if (dhcp->options_in) {
  80b351:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b355:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b359:	48 85 c0             	test   %rax,%rax
  80b35c:	74 2d                	je     80b38b <dhcp_free_reply+0x76>
    mem_free((void *)dhcp->options_in);
  80b35e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b362:	48 8b 40 20          	mov    0x20(%rax),%rax
  80b366:	48 89 c7             	mov    %rax,%rdi
  80b369:	48 b8 d3 c0 80 00 00 	movabs $0x80c0d3,%rax
  80b370:	00 00 00 
  80b373:	ff d0                	callq  *%rax
    dhcp->options_in = NULL;
  80b375:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b379:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  80b380:	00 
    dhcp->options_in_len = 0;
  80b381:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b385:	66 c7 40 28 00 00    	movw   $0x0,0x28(%rax)
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  80b38b:	c9                   	leaveq 
  80b38c:	c3                   	retq   

000000000080b38d <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  80b38d:	55                   	push   %rbp
  80b38e:	48 89 e5             	mov    %rsp,%rbp
  80b391:	48 83 ec 60          	sub    $0x60,%rsp
  80b395:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80b399:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80b39d:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80b3a1:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  80b3a5:	44 89 c0             	mov    %r8d,%eax
  80b3a8:	66 89 45 ac          	mov    %ax,-0x54(%rbp)
  struct netif *netif = (struct netif *)arg;
  80b3ac:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80b3b0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  struct dhcp *dhcp = netif->dhcp;
  80b3b4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b3b8:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b3bc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  80b3c0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80b3c4:	48 8b 40 08          	mov    0x8(%rax),%rax
  80b3c8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  80b3cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b3d0:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80b3d4:	48 89 50 10          	mov    %rdx,0x10(%rax)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  80b3d8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b3dc:	0f b6 00             	movzbl (%rax),%eax
  80b3df:	3c 02                	cmp    $0x2,%al
  80b3e1:	0f 85 cf 01 00 00    	jne    80b5b6 <dhcp_recv+0x229>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  80b3e7:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  80b3eb:	eb 2a                	jmp    80b417 <dhcp_recv+0x8a>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  80b3ed:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80b3f1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80b3f5:	48 98                	cltq   
  80b3f7:	0f b6 4c 02 41       	movzbl 0x41(%rdx,%rax,1),%ecx
  80b3fc:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  80b400:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80b404:	48 98                	cltq   
  80b406:	0f b6 44 02 1c       	movzbl 0x1c(%rdx,%rax,1),%eax
  80b40b:	38 c1                	cmp    %al,%cl
  80b40d:	0f 85 a6 01 00 00    	jne    80b5b9 <dhcp_recv+0x22c>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  80b413:	80 45 ff 01          	addb   $0x1,-0x1(%rbp)
  80b417:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b41b:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  80b41f:	3a 45 ff             	cmp    -0x1(%rbp),%al
  80b422:	77 c9                	ja     80b3ed <dhcp_recv+0x60>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  80b424:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b428:	8b 40 04             	mov    0x4(%rax),%eax
  80b42b:	89 c7                	mov    %eax,%edi
  80b42d:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  80b434:	00 00 00 
  80b437:	ff d0                	callq  *%rax
  80b439:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80b43d:	8b 52 04             	mov    0x4(%rdx),%edx
  80b440:	39 d0                	cmp    %edx,%eax
  80b442:	0f 85 74 01 00 00    	jne    80b5bc <dhcp_recv+0x22f>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
  }
  /* option fields could be unfold? */
  if (dhcp_unfold_reply(dhcp) != ERR_OK) {
  80b448:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b44c:	48 89 c7             	mov    %rax,%rdi
  80b44f:	48 b8 f9 b0 80 00 00 	movabs $0x80b0f9,%rax
  80b456:	00 00 00 
  80b459:	ff d0                	callq  *%rax
  80b45b:	84 c0                	test   %al,%al
  80b45d:	0f 85 5c 01 00 00    	jne    80b5bf <dhcp_recv+0x232>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  80b463:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b467:	be 35 00 00 00       	mov    $0x35,%esi
  80b46c:	48 89 c7             	mov    %rax,%rdi
  80b46f:	48 b8 a5 bb 80 00 00 	movabs $0x80bba5,%rax
  80b476:	00 00 00 
  80b479:	ff d0                	callq  *%rax
  80b47b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  if (options_ptr == NULL) {
  80b47f:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80b484:	0f 84 38 01 00 00    	je     80b5c2 <dhcp_recv+0x235>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  80b48a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b48e:	48 83 c0 02          	add    $0x2,%rax
  80b492:	48 89 c7             	mov    %rax,%rdi
  80b495:	48 b8 31 bd 80 00 00 	movabs $0x80bd31,%rax
  80b49c:	00 00 00 
  80b49f:	ff d0                	callq  *%rax
  80b4a1:	88 45 d7             	mov    %al,-0x29(%rbp)
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  80b4a4:	80 7d d7 05          	cmpb   $0x5,-0x29(%rbp)
  80b4a8:	0f 85 87 00 00 00    	jne    80b535 <dhcp_recv+0x1a8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  80b4ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b4b2:	0f b6 00             	movzbl (%rax),%eax
  80b4b5:	3c 01                	cmp    $0x1,%al
  80b4b7:	75 35                	jne    80b4ee <dhcp_recv+0x161>
      dhcp_handle_ack(netif);
  80b4b9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b4bd:	48 89 c7             	mov    %rax,%rdi
  80b4c0:	48 b8 1f 98 80 00 00 	movabs $0x80981f,%rax
  80b4c7:	00 00 00 
  80b4ca:	ff d0                	callq  *%rax
      dhcp->request_timeout = 0;
  80b4cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b4d0:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  80b4d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b4da:	48 89 c7             	mov    %rax,%rdi
  80b4dd:	48 b8 cf 90 80 00 00 	movabs $0x8090cf,%rax
  80b4e4:	00 00 00 
  80b4e7:	ff d0                	callq  *%rax
  80b4e9:	e9 d5 00 00 00       	jmpq   80b5c3 <dhcp_recv+0x236>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  80b4ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b4f2:	0f b6 00             	movzbl (%rax),%eax
  80b4f5:	3c 03                	cmp    $0x3,%al
  80b4f7:	74 1a                	je     80b513 <dhcp_recv+0x186>
  80b4f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b4fd:	0f b6 00             	movzbl (%rax),%eax
  80b500:	3c 04                	cmp    $0x4,%al
  80b502:	74 0f                	je     80b513 <dhcp_recv+0x186>
  80b504:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b508:	0f b6 00             	movzbl (%rax),%eax
  80b50b:	3c 05                	cmp    $0x5,%al
  80b50d:	0f 85 b0 00 00 00    	jne    80b5c3 <dhcp_recv+0x236>
      dhcp->request_timeout = 0;
  80b513:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b517:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
      dhcp_bind(netif);
  80b51d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b521:	48 89 c7             	mov    %rax,%rdi
  80b524:	48 b8 3e a4 80 00 00 	movabs $0x80a43e,%rax
  80b52b:	00 00 00 
  80b52e:	ff d0                	callq  *%rax
  80b530:	e9 8e 00 00 00       	jmpq   80b5c3 <dhcp_recv+0x236>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  80b535:	80 7d d7 06          	cmpb   $0x6,-0x29(%rbp)
  80b539:	75 4b                	jne    80b586 <dhcp_recv+0x1f9>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80b53b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b53f:	0f b6 00             	movzbl (%rax),%eax
      dhcp->request_timeout = 0;
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  80b542:	3c 03                	cmp    $0x3,%al
  80b544:	74 21                	je     80b567 <dhcp_recv+0x1da>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80b546:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b54a:	0f b6 00             	movzbl (%rax),%eax
  80b54d:	3c 01                	cmp    $0x1,%al
  80b54f:	74 16                	je     80b567 <dhcp_recv+0x1da>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  80b551:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b555:	0f b6 00             	movzbl (%rax),%eax
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  80b558:	3c 04                	cmp    $0x4,%al
  80b55a:	74 0b                	je     80b567 <dhcp_recv+0x1da>
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
  80b55c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b560:	0f b6 00             	movzbl (%rax),%eax
  80b563:	3c 05                	cmp    $0x5,%al
  80b565:	75 1f                	jne    80b586 <dhcp_recv+0x1f9>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  80b567:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b56b:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
    dhcp_handle_nak(netif);
  80b571:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b575:	48 89 c7             	mov    %rax,%rdi
  80b578:	48 b8 20 90 80 00 00 	movabs $0x809020,%rax
  80b57f:	00 00 00 
  80b582:	ff d0                	callq  *%rax
  80b584:	eb 3d                	jmp    80b5c3 <dhcp_recv+0x236>
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  80b586:	80 7d d7 02          	cmpb   $0x2,-0x29(%rbp)
  80b58a:	75 37                	jne    80b5c3 <dhcp_recv+0x236>
  80b58c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b590:	0f b6 00             	movzbl (%rax),%eax
  80b593:	3c 06                	cmp    $0x6,%al
  80b595:	75 2c                	jne    80b5c3 <dhcp_recv+0x236>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  80b597:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b59b:	66 c7 40 42 00 00    	movw   $0x0,0x42(%rax)
    /* remember offered lease */
    dhcp_handle_offer(netif);
  80b5a1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80b5a5:	48 89 c7             	mov    %rax,%rdi
  80b5a8:	48 b8 6a 91 80 00 00 	movabs $0x80916a,%rax
  80b5af:	00 00 00 
  80b5b2:	ff d0                	callq  *%rax
  80b5b4:	eb 0d                	jmp    80b5c3 <dhcp_recv+0x236>
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  80b5b6:	90                   	nop
  80b5b7:	eb 0a                	jmp    80b5c3 <dhcp_recv+0x236>
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("netif->hwaddr[%"U16_F"]==%02"X16_F" != reply_msg->chaddr[%"U16_F"]==%02"X16_F"\n",
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
  80b5b9:	90                   	nop
  80b5ba:	eb 07                	jmp    80b5c3 <dhcp_recv+0x236>
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n",ntohl(reply_msg->xid),dhcp->xid));
    goto free_pbuf_and_return;
  80b5bc:	90                   	nop
  80b5bd:	eb 04                	jmp    80b5c3 <dhcp_recv+0x236>
  }
  /* option fields could be unfold? */
  if (dhcp_unfold_reply(dhcp) != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("problem unfolding DHCP message - too short on memory?\n"));
    goto free_pbuf_and_return;
  80b5bf:	90                   	nop
  80b5c0:	eb 01                	jmp    80b5c3 <dhcp_recv+0x236>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  if (options_ptr == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  80b5c2:	90                   	nop
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  80b5c3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80b5c7:	48 89 c7             	mov    %rax,%rdi
  80b5ca:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  80b5d1:	00 00 00 
  80b5d4:	ff d0                	callq  *%rax
  dhcp->p = NULL;
  80b5d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b5da:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80b5e1:	00 
}
  80b5e2:	c9                   	leaveq 
  80b5e3:	c3                   	retq   

000000000080b5e4 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  80b5e4:	55                   	push   %rbp
  80b5e5:	48 89 e5             	mov    %rsp,%rbp
  80b5e8:	53                   	push   %rbx
  80b5e9:	48 83 ec 28          	sub    $0x28,%rsp
  80b5ed:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  80b5f1:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80b5f6:	75 2a                	jne    80b622 <dhcp_create_request+0x3e>
  80b5f8:	48 ba 98 17 82 00 00 	movabs $0x821798,%rdx
  80b5ff:	00 00 00 
  80b602:	be 2d 05 00 00       	mov    $0x52d,%esi
  80b607:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80b60e:	00 00 00 
  80b611:	b8 00 00 00 00       	mov    $0x0,%eax
  80b616:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80b61d:	00 00 00 
  80b620:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80b622:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b626:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b62a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  80b62e:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80b633:	75 2a                	jne    80b65f <dhcp_create_request+0x7b>
  80b635:	48 ba c0 17 82 00 00 	movabs $0x8217c0,%rdx
  80b63c:	00 00 00 
  80b63f:	be 2f 05 00 00       	mov    $0x52f,%esi
  80b644:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80b64b:	00 00 00 
  80b64e:	b8 00 00 00 00       	mov    $0x0,%eax
  80b653:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80b65a:	00 00 00 
  80b65d:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  80b65f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b663:	48 8b 40 30          	mov    0x30(%rax),%rax
  80b667:	48 85 c0             	test   %rax,%rax
  80b66a:	74 2a                	je     80b696 <dhcp_create_request+0xb2>
  80b66c:	48 ba e8 17 82 00 00 	movabs $0x8217e8,%rdx
  80b673:	00 00 00 
  80b676:	be 30 05 00 00       	mov    $0x530,%esi
  80b67b:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80b682:	00 00 00 
  80b685:	b8 00 00 00 00       	mov    $0x0,%eax
  80b68a:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80b691:	00 00 00 
  80b694:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  80b696:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b69a:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b69e:	48 85 c0             	test   %rax,%rax
  80b6a1:	74 2a                	je     80b6cd <dhcp_create_request+0xe9>
  80b6a3:	48 ba 18 18 82 00 00 	movabs $0x821818,%rdx
  80b6aa:	00 00 00 
  80b6ad:	be 31 05 00 00       	mov    $0x531,%esi
  80b6b2:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80b6b9:	00 00 00 
  80b6bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80b6c1:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80b6c8:	00 00 00 
  80b6cb:	ff d1                	callq  *%rcx
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  80b6cd:	ba 00 00 00 00       	mov    $0x0,%edx
  80b6d2:	be 34 01 00 00       	mov    $0x134,%esi
  80b6d7:	bf 00 00 00 00       	mov    $0x0,%edi
  80b6dc:	48 b8 4c d0 80 00 00 	movabs $0x80d04c,%rax
  80b6e3:	00 00 00 
  80b6e6:	ff d0                	callq  *%rax
  80b6e8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80b6ec:	48 89 42 30          	mov    %rax,0x30(%rdx)
  if (dhcp->p_out == NULL) {
  80b6f0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b6f4:	48 8b 40 30          	mov    0x30(%rax),%rax
  80b6f8:	48 85 c0             	test   %rax,%rax
  80b6fb:	75 0a                	jne    80b707 <dhcp_create_request+0x123>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  80b6fd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80b702:	e9 13 02 00 00       	jmpq   80b91a <dhcp_create_request+0x336>
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  80b707:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b70b:	48 8b 40 30          	mov    0x30(%rax),%rax
  80b70f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80b713:	66 3d 33 01          	cmp    $0x133,%ax
  80b717:	77 2a                	ja     80b743 <dhcp_create_request+0x15f>
  80b719:	48 ba 48 18 82 00 00 	movabs $0x821848,%rdx
  80b720:	00 00 00 
  80b723:	be 38 05 00 00       	mov    $0x538,%esi
  80b728:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80b72f:	00 00 00 
  80b732:	b8 00 00 00 00       	mov    $0x0,%eax
  80b737:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80b73e:	00 00 00 
  80b741:	ff d1                	callq  *%rcx
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  80b743:	48 b8 7c 81 82 00 00 	movabs $0x82817c,%rax
  80b74a:	00 00 00 
  80b74d:	8b 00                	mov    (%rax),%eax
  80b74f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80b753:	89 42 04             	mov    %eax,0x4(%rdx)
  80b756:	8d 50 01             	lea    0x1(%rax),%edx
  80b759:	48 b8 7c 81 82 00 00 	movabs $0x82817c,%rax
  80b760:	00 00 00 
  80b763:	89 10                	mov    %edx,(%rax)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  80b765:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b769:	48 8b 40 30          	mov    0x30(%rax),%rax
  80b76d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80b771:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b775:	48 89 50 38          	mov    %rdx,0x38(%rax)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  80b779:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b77d:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b781:	c6 00 01             	movb   $0x1,(%rax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  80b784:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b788:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b78c:	c6 40 01 01          	movb   $0x1,0x1(%rax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  80b790:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b794:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b798:	c6 40 02 06          	movb   $0x6,0x2(%rax)
  dhcp->msg_out->hops = 0;
  80b79c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b7a0:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b7a4:	c6 40 03 00          	movb   $0x0,0x3(%rax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  80b7a8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b7ac:	48 8b 58 38          	mov    0x38(%rax),%rbx
  80b7b0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b7b4:	8b 40 04             	mov    0x4(%rax),%eax
  80b7b7:	89 c7                	mov    %eax,%edi
  80b7b9:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  80b7c0:	00 00 00 
  80b7c3:	ff d0                	callq  *%rax
  80b7c5:	89 43 04             	mov    %eax,0x4(%rbx)
  dhcp->msg_out->secs = 0;
  80b7c8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b7cc:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b7d0:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
  dhcp->msg_out->flags = 0;
  80b7d6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b7da:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b7de:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  80b7e4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b7e8:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b7ec:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80b7f0:	8b 52 08             	mov    0x8(%rdx),%edx
  80b7f3:	89 50 0c             	mov    %edx,0xc(%rax)
  dhcp->msg_out->yiaddr.addr = 0;
  80b7f6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b7fa:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b7fe:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
  dhcp->msg_out->siaddr.addr = 0;
  80b805:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b809:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b80d:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%rax)
  dhcp->msg_out->giaddr.addr = 0;
  80b814:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b818:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b81c:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  80b823:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80b829:	eb 3f                	jmp    80b86a <dhcp_create_request+0x286>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  80b82b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b82f:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80b833:	0f b7 75 ee          	movzwl -0x12(%rbp),%esi
  80b837:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80b83b:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  80b83f:	0f b6 c0             	movzbl %al,%eax
  80b842:	66 3b 45 ee          	cmp    -0x12(%rbp),%ax
  80b846:	76 11                	jbe    80b859 <dhcp_create_request+0x275>
  80b848:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b84c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80b850:	48 98                	cltq   
  80b852:	0f b6 44 02 41       	movzbl 0x41(%rdx,%rax,1),%eax
  80b857:	eb 05                	jmp    80b85e <dhcp_create_request+0x27a>
  80b859:	b8 00 00 00 00       	mov    $0x0,%eax
  80b85e:	48 63 d6             	movslq %esi,%rdx
  80b861:	88 44 11 1c          	mov    %al,0x1c(%rcx,%rdx,1)
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  80b865:	66 83 45 ee 01       	addw   $0x1,-0x12(%rbp)
  80b86a:	66 83 7d ee 0f       	cmpw   $0xf,-0x12(%rbp)
  80b86f:	76 ba                	jbe    80b82b <dhcp_create_request+0x247>
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  80b871:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80b877:	eb 18                	jmp    80b891 <dhcp_create_request+0x2ad>
    dhcp->msg_out->sname[i] = 0;
  80b879:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b87d:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b881:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b885:	48 98                	cltq   
  80b887:	c6 44 02 2c 00       	movb   $0x0,0x2c(%rdx,%rax,1)
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  80b88c:	66 83 45 ee 01       	addw   $0x1,-0x12(%rbp)
  80b891:	66 83 7d ee 3f       	cmpw   $0x3f,-0x12(%rbp)
  80b896:	76 e1                	jbe    80b879 <dhcp_create_request+0x295>
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  80b898:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80b89e:	eb 18                	jmp    80b8b8 <dhcp_create_request+0x2d4>
    dhcp->msg_out->file[i] = 0;
  80b8a0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b8a4:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b8a8:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b8ac:	48 98                	cltq   
  80b8ae:	c6 44 02 6c 00       	movb   $0x0,0x6c(%rdx,%rax,1)
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  80b8b3:	66 83 45 ee 01       	addw   $0x1,-0x12(%rbp)
  80b8b8:	66 83 7d ee 7f       	cmpw   $0x7f,-0x12(%rbp)
  80b8bd:	76 e1                	jbe    80b8a0 <dhcp_create_request+0x2bc>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  80b8bf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b8c3:	48 8b 58 38          	mov    0x38(%rax),%rbx
  80b8c7:	bf 63 53 82 63       	mov    $0x63825363,%edi
  80b8cc:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  80b8d3:	00 00 00 
  80b8d6:	ff d0                	callq  *%rax
  80b8d8:	89 83 ec 00 00 00    	mov    %eax,0xec(%rbx)
  dhcp->options_out_len = 0;
  80b8de:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b8e2:	66 c7 40 40 00 00    	movw   $0x0,0x40(%rax)
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  80b8e8:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80b8ee:	eb 1e                	jmp    80b90e <dhcp_create_request+0x32a>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  80b8f0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80b8f4:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80b8f8:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80b8fc:	0f b7 4d ee          	movzwl -0x12(%rbp),%ecx
  80b900:	48 98                	cltq   
  80b902:	88 8c 02 f0 00 00 00 	mov    %cl,0xf0(%rdx,%rax,1)
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  80b909:	66 83 45 ee 01       	addw   $0x1,-0x12(%rbp)
  80b90e:	66 83 7d ee 43       	cmpw   $0x43,-0x12(%rbp)
  80b913:	76 db                	jbe    80b8f0 <dhcp_create_request+0x30c>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
  80b915:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b91a:	48 83 c4 28          	add    $0x28,%rsp
  80b91e:	5b                   	pop    %rbx
  80b91f:	5d                   	pop    %rbp
  80b920:	c3                   	retq   

000000000080b921 <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  80b921:	55                   	push   %rbp
  80b922:	48 89 e5             	mov    %rsp,%rbp
  80b925:	48 83 ec 20          	sub    $0x20,%rsp
  80b929:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  80b92d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80b932:	75 2a                	jne    80b95e <dhcp_delete_request+0x3d>
  80b934:	48 ba 90 18 82 00 00 	movabs $0x821890,%rdx
  80b93b:	00 00 00 
  80b93e:	be 69 05 00 00       	mov    $0x569,%esi
  80b943:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80b94a:	00 00 00 
  80b94d:	b8 00 00 00 00       	mov    $0x0,%eax
  80b952:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80b959:	00 00 00 
  80b95c:	ff d1                	callq  *%rcx
  dhcp = netif->dhcp;
  80b95e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80b962:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b966:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  80b96a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80b96f:	75 2a                	jne    80b99b <dhcp_delete_request+0x7a>
  80b971:	48 ba b8 18 82 00 00 	movabs $0x8218b8,%rdx
  80b978:	00 00 00 
  80b97b:	be 6b 05 00 00       	mov    $0x56b,%esi
  80b980:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80b987:	00 00 00 
  80b98a:	b8 00 00 00 00       	mov    $0x0,%eax
  80b98f:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80b996:	00 00 00 
  80b999:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  80b99b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b99f:	48 8b 40 30          	mov    0x30(%rax),%rax
  80b9a3:	48 85 c0             	test   %rax,%rax
  80b9a6:	75 2a                	jne    80b9d2 <dhcp_delete_request+0xb1>
  80b9a8:	48 ba e0 18 82 00 00 	movabs $0x8218e0,%rdx
  80b9af:	00 00 00 
  80b9b2:	be 6c 05 00 00       	mov    $0x56c,%esi
  80b9b7:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80b9be:	00 00 00 
  80b9c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80b9c6:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80b9cd:	00 00 00 
  80b9d0:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  80b9d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80b9d6:	48 8b 40 38          	mov    0x38(%rax),%rax
  80b9da:	48 85 c0             	test   %rax,%rax
  80b9dd:	75 2a                	jne    80ba09 <dhcp_delete_request+0xe8>
  80b9df:	48 ba 10 19 82 00 00 	movabs $0x821910,%rdx
  80b9e6:	00 00 00 
  80b9e9:	be 6d 05 00 00       	mov    $0x56d,%esi
  80b9ee:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80b9f5:	00 00 00 
  80b9f8:	b8 00 00 00 00       	mov    $0x0,%eax
  80b9fd:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80ba04:	00 00 00 
  80ba07:	ff d1                	callq  *%rcx
  if (dhcp->p_out != NULL) {
  80ba09:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ba0d:	48 8b 40 30          	mov    0x30(%rax),%rax
  80ba11:	48 85 c0             	test   %rax,%rax
  80ba14:	74 17                	je     80ba2d <dhcp_delete_request+0x10c>
    pbuf_free(dhcp->p_out);
  80ba16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ba1a:	48 8b 40 30          	mov    0x30(%rax),%rax
  80ba1e:	48 89 c7             	mov    %rax,%rdi
  80ba21:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  80ba28:	00 00 00 
  80ba2b:	ff d0                	callq  *%rax
  }
  dhcp->p_out = NULL;
  80ba2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ba31:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  80ba38:	00 
  dhcp->msg_out = NULL;
  80ba39:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ba3d:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80ba44:	00 
}
  80ba45:	c9                   	leaveq 
  80ba46:	c3                   	retq   

000000000080ba47 <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  80ba47:	55                   	push   %rbp
  80ba48:	48 89 e5             	mov    %rsp,%rbp
  80ba4b:	48 83 ec 10          	sub    $0x10,%rsp
  80ba4f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  80ba53:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ba58:	75 2a                	jne    80ba84 <dhcp_option_trailer+0x3d>
  80ba5a:	48 ba 40 19 82 00 00 	movabs $0x821940,%rdx
  80ba61:	00 00 00 
  80ba64:	be 80 05 00 00       	mov    $0x580,%esi
  80ba69:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80ba70:	00 00 00 
  80ba73:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba78:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80ba7f:	00 00 00 
  80ba82:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  80ba84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ba88:	48 8b 40 38          	mov    0x38(%rax),%rax
  80ba8c:	48 85 c0             	test   %rax,%rax
  80ba8f:	75 2a                	jne    80babb <dhcp_option_trailer+0x74>
  80ba91:	48 ba 68 19 82 00 00 	movabs $0x821968,%rdx
  80ba98:	00 00 00 
  80ba9b:	be 81 05 00 00       	mov    $0x581,%esi
  80baa0:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80baa7:	00 00 00 
  80baaa:	b8 00 00 00 00       	mov    $0x0,%eax
  80baaf:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80bab6:	00 00 00 
  80bab9:	ff d1                	callq  *%rcx
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80babb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80babf:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bac3:	66 83 f8 43          	cmp    $0x43,%ax
  80bac7:	76 2a                	jbe    80baf3 <dhcp_option_trailer+0xac>
  80bac9:	48 ba 98 19 82 00 00 	movabs $0x821998,%rdx
  80bad0:	00 00 00 
  80bad3:	be 82 05 00 00       	mov    $0x582,%esi
  80bad8:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80badf:	00 00 00 
  80bae2:	b8 00 00 00 00       	mov    $0x0,%eax
  80bae7:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80baee:	00 00 00 
  80baf1:	ff d1                	callq  *%rcx
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  80baf3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80baf7:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80bafb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80baff:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bb03:	0f b7 d0             	movzwl %ax,%edx
  80bb06:	48 63 d2             	movslq %edx,%rdx
  80bb09:	c6 84 11 f0 00 00 00 	movb   $0xff,0xf0(%rcx,%rdx,1)
  80bb10:	ff 
  80bb11:	8d 50 01             	lea    0x1(%rax),%edx
  80bb14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bb18:	66 89 50 40          	mov    %dx,0x40(%rax)
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  80bb1c:	eb 61                	jmp    80bb7f <dhcp_option_trailer+0x138>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  80bb1e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bb22:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bb26:	66 83 f8 43          	cmp    $0x43,%ax
  80bb2a:	76 2a                	jbe    80bb56 <dhcp_option_trailer+0x10f>
  80bb2c:	48 ba 98 19 82 00 00 	movabs $0x821998,%rdx
  80bb33:	00 00 00 
  80bb36:	be 87 05 00 00       	mov    $0x587,%esi
  80bb3b:	48 bf b6 15 82 00 00 	movabs $0x8215b6,%rdi
  80bb42:	00 00 00 
  80bb45:	b8 00 00 00 00       	mov    $0x0,%eax
  80bb4a:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80bb51:	00 00 00 
  80bb54:	ff d1                	callq  *%rcx
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  80bb56:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bb5a:	48 8b 48 38          	mov    0x38(%rax),%rcx
  80bb5e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bb62:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bb66:	0f b7 d0             	movzwl %ax,%edx
  80bb69:	48 63 d2             	movslq %edx,%rdx
  80bb6c:	c6 84 11 f0 00 00 00 	movb   $0x0,0xf0(%rcx,%rdx,1)
  80bb73:	00 
  80bb74:	8d 50 01             	lea    0x1(%rax),%edx
  80bb77:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bb7b:	66 89 50 40          	mov    %dx,0x40(%rax)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  80bb7f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bb83:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bb87:	66 83 f8 43          	cmp    $0x43,%ax
  80bb8b:	76 91                	jbe    80bb1e <dhcp_option_trailer+0xd7>
  80bb8d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bb91:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80bb95:	0f b7 c0             	movzwl %ax,%eax
  80bb98:	83 e0 03             	and    $0x3,%eax
  80bb9b:	85 c0                	test   %eax,%eax
  80bb9d:	0f 85 7b ff ff ff    	jne    80bb1e <dhcp_option_trailer+0xd7>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  80bba3:	c9                   	leaveq 
  80bba4:	c3                   	retq   

000000000080bba5 <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  80bba5:	55                   	push   %rbp
  80bba6:	48 89 e5             	mov    %rsp,%rbp
  80bba9:	48 83 ec 30          	sub    $0x30,%rsp
  80bbad:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80bbb1:	89 f0                	mov    %esi,%eax
  80bbb3:	88 45 d4             	mov    %al,-0x2c(%rbp)
  u8_t overload = DHCP_OVERLOAD_NONE;
  80bbb6:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  80bbba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bbbe:	48 8b 40 20          	mov    0x20(%rax),%rax
  80bbc2:	48 85 c0             	test   %rax,%rax
  80bbc5:	0f 84 5f 01 00 00    	je     80bd2a <dhcp_get_option_ptr+0x185>
  80bbcb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bbcf:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80bbd3:	66 85 c0             	test   %ax,%ax
  80bbd6:	0f 84 4e 01 00 00    	je     80bd2a <dhcp_get_option_ptr+0x185>
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
  80bbdc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bbe0:	48 8b 40 20          	mov    0x20(%rax),%rax
  80bbe4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    u16_t offset = 0;
  80bbe8:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  80bbee:	eb 64                	jmp    80bc54 <dhcp_get_option_ptr+0xaf>
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  80bbf0:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bbf4:	48 03 45 f0          	add    -0x10(%rbp),%rax
  80bbf8:	0f b6 00             	movzbl (%rax),%eax
  80bbfb:	3c 34                	cmp    $0x34,%al
  80bbfd:	75 1a                	jne    80bc19 <dhcp_get_option_ptr+0x74>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  80bbff:	66 83 45 ee 02       	addw   $0x2,-0x12(%rbp)
        overload = options[offset++];
  80bc04:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bc08:	48 03 45 f0          	add    -0x10(%rbp),%rax
  80bc0c:	0f b6 00             	movzbl (%rax),%eax
  80bc0f:	88 45 ff             	mov    %al,-0x1(%rbp)
  80bc12:	66 83 45 ee 01       	addw   $0x1,-0x12(%rbp)
  80bc17:	eb 3b                	jmp    80bc54 <dhcp_get_option_ptr+0xaf>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  80bc19:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bc1d:	48 03 45 f0          	add    -0x10(%rbp),%rax
  80bc21:	0f b6 00             	movzbl (%rax),%eax
  80bc24:	3a 45 d4             	cmp    -0x2c(%rbp),%al
  80bc27:	75 0d                	jne    80bc36 <dhcp_get_option_ptr+0x91>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("option found at offset %"U16_F" in options\n", offset));
        return &options[offset];
  80bc29:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bc2d:	48 03 45 f0          	add    -0x10(%rbp),%rax
  80bc31:	e9 f9 00 00 00       	jmpq   80bd2f <dhcp_get_option_ptr+0x18a>
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
  80bc36:	66 83 45 ee 01       	addw   $0x1,-0x12(%rbp)
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  80bc3b:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bc3f:	48 03 45 f0          	add    -0x10(%rbp),%rax
  80bc43:	0f b6 00             	movzbl (%rax),%eax
  80bc46:	0f b6 c0             	movzbl %al,%eax
  80bc49:	66 03 45 ee          	add    -0x12(%rbp),%ax
  80bc4d:	83 c0 01             	add    $0x1,%eax
  80bc50:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  80bc54:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bc58:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80bc5c:	66 3b 45 ee          	cmp    -0x12(%rbp),%ax
  80bc60:	76 13                	jbe    80bc75 <dhcp_get_option_ptr+0xd0>
  80bc62:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bc66:	48 03 45 f0          	add    -0x10(%rbp),%rax
  80bc6a:	0f b6 00             	movzbl (%rax),%eax
  80bc6d:	3c ff                	cmp    $0xff,%al
  80bc6f:	0f 85 7b ff ff ff    	jne    80bbf0 <dhcp_get_option_ptr+0x4b>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  80bc75:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80bc79:	0f 84 ab 00 00 00    	je     80bd2a <dhcp_get_option_ptr+0x185>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  80bc7f:	80 7d ff 01          	cmpb   $0x1,-0x1(%rbp)
  80bc83:	75 18                	jne    80bc9d <dhcp_get_option_ptr+0xf8>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  80bc85:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bc89:	48 8b 40 18          	mov    0x18(%rax),%rax
  80bc8d:	48 83 c0 6c          	add    $0x6c,%rax
  80bc91:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_FILE_LEN;
  80bc95:	66 c7 45 ec 80 00    	movw   $0x80,-0x14(%rbp)
  80bc9b:	eb 34                	jmp    80bcd1 <dhcp_get_option_ptr+0x12c>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  80bc9d:	80 7d ff 02          	cmpb   $0x2,-0x1(%rbp)
  80bca1:	75 18                	jne    80bcbb <dhcp_get_option_ptr+0x116>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  80bca3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bca7:	48 8b 40 18          	mov    0x18(%rax),%rax
  80bcab:	48 83 c0 2c          	add    $0x2c,%rax
  80bcaf:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_SNAME_LEN;
  80bcb3:	66 c7 45 ec 40 00    	movw   $0x40,-0x14(%rbp)
  80bcb9:	eb 16                	jmp    80bcd1 <dhcp_get_option_ptr+0x12c>
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  80bcbb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bcbf:	48 8b 40 18          	mov    0x18(%rax),%rax
  80bcc3:	48 83 c0 2c          	add    $0x2c,%rax
  80bcc7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  80bccb:	66 c7 45 ec c0 00    	movw   $0xc0,-0x14(%rbp)
      }
      offset = 0;
  80bcd1:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  80bcd7:	eb 38                	jmp    80bd11 <dhcp_get_option_ptr+0x16c>
        if (options[offset] == option_type) {
  80bcd9:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bcdd:	48 03 45 f0          	add    -0x10(%rbp),%rax
  80bce1:	0f b6 00             	movzbl (%rax),%eax
  80bce4:	3a 45 d4             	cmp    -0x2c(%rbp),%al
  80bce7:	75 0a                	jne    80bcf3 <dhcp_get_option_ptr+0x14e>
           LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("option found at offset=%"U16_F"\n", offset));
          return &options[offset];
  80bce9:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bced:	48 03 45 f0          	add    -0x10(%rbp),%rax
  80bcf1:	eb 3c                	jmp    80bd2f <dhcp_get_option_ptr+0x18a>
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
  80bcf3:	66 83 45 ee 01       	addw   $0x1,-0x12(%rbp)
          offset += 1 + options[offset];
  80bcf8:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bcfc:	48 03 45 f0          	add    -0x10(%rbp),%rax
  80bd00:	0f b6 00             	movzbl (%rax),%eax
  80bd03:	0f b6 c0             	movzbl %al,%eax
  80bd06:	66 03 45 ee          	add    -0x12(%rbp),%ax
  80bd0a:	83 c0 01             	add    $0x1,%eax
  80bd0d:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  80bd11:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bd15:	66 3b 45 ec          	cmp    -0x14(%rbp),%ax
  80bd19:	73 0f                	jae    80bd2a <dhcp_get_option_ptr+0x185>
  80bd1b:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80bd1f:	48 03 45 f0          	add    -0x10(%rbp),%rax
  80bd23:	0f b6 00             	movzbl (%rax),%eax
  80bd26:	3c ff                	cmp    $0xff,%al
  80bd28:	75 af                	jne    80bcd9 <dhcp_get_option_ptr+0x134>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  80bd2a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80bd2f:	c9                   	leaveq 
  80bd30:	c3                   	retq   

000000000080bd31 <dhcp_get_option_byte>:
 *
 * @return byte value at the given address.
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  80bd31:	55                   	push   %rbp
  80bd32:	48 89 e5             	mov    %rsp,%rbp
  80bd35:	48 83 ec 08          	sub    $0x8,%rsp
  80bd39:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
  80bd3d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80bd41:	0f b6 00             	movzbl (%rax),%eax
}
  80bd44:	c9                   	leaveq 
  80bd45:	c3                   	retq   

000000000080bd46 <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  80bd46:	55                   	push   %rbp
  80bd47:	48 89 e5             	mov    %rsp,%rbp
  80bd4a:	48 83 ec 18          	sub    $0x18,%rsp
  80bd4e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  80bd52:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bd56:	0f b6 00             	movzbl (%rax),%eax
  80bd59:	0f b6 c0             	movzbl %al,%eax
  80bd5c:	c1 e0 18             	shl    $0x18,%eax
  80bd5f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80bd62:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  value |= (u32_t)(*ptr++) << 16;
  80bd67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bd6b:	0f b6 00             	movzbl (%rax),%eax
  80bd6e:	0f b6 c0             	movzbl %al,%eax
  80bd71:	c1 e0 10             	shl    $0x10,%eax
  80bd74:	09 45 fc             	or     %eax,-0x4(%rbp)
  80bd77:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  value |= (u32_t)(*ptr++) << 8;
  80bd7c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bd80:	0f b6 00             	movzbl (%rax),%eax
  80bd83:	0f b6 c0             	movzbl %al,%eax
  80bd86:	c1 e0 08             	shl    $0x8,%eax
  80bd89:	09 45 fc             	or     %eax,-0x4(%rbp)
  80bd8c:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  value |= (u32_t)(*ptr++);
  80bd91:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bd95:	0f b6 00             	movzbl (%rax),%eax
  80bd98:	0f b6 c0             	movzbl %al,%eax
  80bd9b:	09 45 fc             	or     %eax,-0x4(%rbp)
  80bd9e:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
  80bda3:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80bda6:	c9                   	leaveq 
  80bda7:	c3                   	retq   

000000000080bda8 <plug_holes>:
 * This assumes access to the heap is protected by the calling function
 * already.
 */
static void
plug_holes(struct mem *mem)
{
  80bda8:	55                   	push   %rbp
  80bda9:	48 89 e5             	mov    %rsp,%rbp
  80bdac:	53                   	push   %rbx
  80bdad:	48 83 ec 28          	sub    $0x28,%rsp
  80bdb1:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  80bdb5:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80bdbc:	00 00 00 
  80bdbf:	48 8b 00             	mov    (%rax),%rax
  80bdc2:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80bdc6:	73 2a                	jae    80bdf2 <plug_holes+0x4a>
  80bdc8:	48 ba d8 19 82 00 00 	movabs $0x8219d8,%rdx
  80bdcf:	00 00 00 
  80bdd2:	be e3 00 00 00       	mov    $0xe3,%esi
  80bdd7:	48 bf ef 19 82 00 00 	movabs $0x8219ef,%rdi
  80bdde:	00 00 00 
  80bde1:	b8 00 00 00 00       	mov    $0x0,%eax
  80bde6:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80bded:	00 00 00 
  80bdf0:	ff d1                	callq  *%rcx
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  80bdf2:	48 b8 68 95 a4 00 00 	movabs $0xa49568,%rax
  80bdf9:	00 00 00 
  80bdfc:	48 8b 00             	mov    (%rax),%rax
  80bdff:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80be03:	72 2a                	jb     80be2f <plug_holes+0x87>
  80be05:	48 ba 03 1a 82 00 00 	movabs $0x821a03,%rdx
  80be0c:	00 00 00 
  80be0f:	be e4 00 00 00       	mov    $0xe4,%esi
  80be14:	48 bf ef 19 82 00 00 	movabs $0x8219ef,%rdi
  80be1b:	00 00 00 
  80be1e:	b8 00 00 00 00       	mov    $0x0,%eax
  80be23:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80be2a:	00 00 00 
  80be2d:	ff d1                	callq  *%rcx
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
  80be2f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80be33:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80be37:	84 c0                	test   %al,%al
  80be39:	74 2a                	je     80be65 <plug_holes+0xbd>
  80be3b:	48 ba 1d 1a 82 00 00 	movabs $0x821a1d,%rdx
  80be42:	00 00 00 
  80be45:	be e5 00 00 00       	mov    $0xe5,%esi
  80be4a:	48 bf ef 19 82 00 00 	movabs $0x8219ef,%rdi
  80be51:	00 00 00 
  80be54:	b8 00 00 00 00       	mov    $0x0,%eax
  80be59:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80be60:	00 00 00 
  80be63:	ff d1                	callq  *%rcx

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  80be65:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80be69:	8b 00                	mov    (%rax),%eax
  80be6b:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80be70:	76 2a                	jbe    80be9c <plug_holes+0xf4>
  80be72:	48 ba 38 1a 82 00 00 	movabs $0x821a38,%rdx
  80be79:	00 00 00 
  80be7c:	be e8 00 00 00       	mov    $0xe8,%esi
  80be81:	48 bf ef 19 82 00 00 	movabs $0x8219ef,%rdi
  80be88:	00 00 00 
  80be8b:	b8 00 00 00 00       	mov    $0x0,%eax
  80be90:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80be97:	00 00 00 
  80be9a:	ff d1                	callq  *%rcx

  nmem = (struct mem *)&ram[mem->next];
  80be9c:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80bea3:	00 00 00 
  80bea6:	48 8b 10             	mov    (%rax),%rdx
  80bea9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bead:	8b 00                	mov    (%rax),%eax
  80beaf:	89 c0                	mov    %eax,%eax
  80beb1:	48 01 d0             	add    %rdx,%rax
  80beb4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  80beb8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bebc:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80bec0:	0f 84 84 00 00 00    	je     80bf4a <plug_holes+0x1a2>
  80bec6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80beca:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80bece:	84 c0                	test   %al,%al
  80bed0:	75 78                	jne    80bf4a <plug_holes+0x1a2>
  80bed2:	48 b8 68 95 a4 00 00 	movabs $0xa49568,%rax
  80bed9:	00 00 00 
  80bedc:	48 8b 00             	mov    (%rax),%rax
  80bedf:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80bee3:	74 65                	je     80bf4a <plug_holes+0x1a2>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  80bee5:	48 b8 70 95 a4 00 00 	movabs $0xa49570,%rax
  80beec:	00 00 00 
  80beef:	48 8b 00             	mov    (%rax),%rax
  80bef2:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80bef6:	75 11                	jne    80bf09 <plug_holes+0x161>
      lfree = mem;
  80bef8:	48 b8 70 95 a4 00 00 	movabs $0xa49570,%rax
  80beff:	00 00 00 
  80bf02:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80bf06:	48 89 10             	mov    %rdx,(%rax)
    }
    mem->next = nmem->next;
  80bf09:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bf0d:	8b 10                	mov    (%rax),%edx
  80bf0f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bf13:	89 10                	mov    %edx,(%rax)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  80bf15:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80bf1c:	00 00 00 
  80bf1f:	48 8b 10             	mov    (%rax),%rdx
  80bf22:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80bf26:	8b 00                	mov    (%rax),%eax
  80bf28:	89 c0                	mov    %eax,%eax
  80bf2a:	48 01 c2             	add    %rax,%rdx
  80bf2d:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80bf31:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80bf38:	00 00 00 
  80bf3b:	48 8b 00             	mov    (%rax),%rax
  80bf3e:	48 89 cb             	mov    %rcx,%rbx
  80bf41:	48 29 c3             	sub    %rax,%rbx
  80bf44:	48 89 d8             	mov    %rbx,%rax
  80bf47:	89 42 04             	mov    %eax,0x4(%rdx)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  80bf4a:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80bf51:	00 00 00 
  80bf54:	48 8b 10             	mov    (%rax),%rdx
  80bf57:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bf5b:	8b 40 04             	mov    0x4(%rax),%eax
  80bf5e:	89 c0                	mov    %eax,%eax
  80bf60:	48 01 d0             	add    %rdx,%rax
  80bf63:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  if (pmem != mem && pmem->used == 0) {
  80bf67:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bf6b:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80bf6f:	74 71                	je     80bfe2 <plug_holes+0x23a>
  80bf71:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bf75:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80bf79:	84 c0                	test   %al,%al
  80bf7b:	75 65                	jne    80bfe2 <plug_holes+0x23a>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  80bf7d:	48 b8 70 95 a4 00 00 	movabs $0xa49570,%rax
  80bf84:	00 00 00 
  80bf87:	48 8b 00             	mov    (%rax),%rax
  80bf8a:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80bf8e:	75 11                	jne    80bfa1 <plug_holes+0x1f9>
      lfree = pmem;
  80bf90:	48 b8 70 95 a4 00 00 	movabs $0xa49570,%rax
  80bf97:	00 00 00 
  80bf9a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80bf9e:	48 89 10             	mov    %rdx,(%rax)
    }
    pmem->next = mem->next;
  80bfa1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bfa5:	8b 10                	mov    (%rax),%edx
  80bfa7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80bfab:	89 10                	mov    %edx,(%rax)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  80bfad:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80bfb4:	00 00 00 
  80bfb7:	48 8b 10             	mov    (%rax),%rdx
  80bfba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80bfbe:	8b 00                	mov    (%rax),%eax
  80bfc0:	89 c0                	mov    %eax,%eax
  80bfc2:	48 01 c2             	add    %rax,%rdx
  80bfc5:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  80bfc9:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80bfd0:	00 00 00 
  80bfd3:	48 8b 00             	mov    (%rax),%rax
  80bfd6:	48 89 cb             	mov    %rcx,%rbx
  80bfd9:	48 29 c3             	sub    %rax,%rbx
  80bfdc:	48 89 d8             	mov    %rbx,%rax
  80bfdf:	89 42 04             	mov    %eax,0x4(%rdx)
  }
}
  80bfe2:	48 83 c4 28          	add    $0x28,%rsp
  80bfe6:	5b                   	pop    %rbx
  80bfe7:	5d                   	pop    %rbp
  80bfe8:	c3                   	retq   

000000000080bfe9 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  80bfe9:	55                   	push   %rbp
  80bfea:	48 89 e5             	mov    %rsp,%rbp
  80bfed:	48 83 ec 10          	sub    $0x10,%rsp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  80bff1:	48 b8 40 95 82 00 00 	movabs $0x829540,%rax
  80bff8:	00 00 00 
  80bffb:	48 83 c0 03          	add    $0x3,%rax
  80bfff:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80c003:	48 89 c2             	mov    %rax,%rdx
  80c006:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80c00d:	00 00 00 
  80c010:	48 89 10             	mov    %rdx,(%rax)
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  80c013:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80c01a:	00 00 00 
  80c01d:	48 8b 00             	mov    (%rax),%rax
  80c020:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  mem->next = MEM_SIZE_ALIGNED;
  80c024:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c028:	c7 00 00 00 22 00    	movl   $0x220000,(%rax)
  mem->prev = 0;
  80c02e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c032:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  mem->used = 0;
  80c039:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c03d:	c6 40 08 00          	movb   $0x0,0x8(%rax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  80c041:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80c048:	00 00 00 
  80c04b:	48 8b 00             	mov    (%rax),%rax
  80c04e:	48 8d 90 00 00 22 00 	lea    0x220000(%rax),%rdx
  80c055:	48 b8 68 95 a4 00 00 	movabs $0xa49568,%rax
  80c05c:	00 00 00 
  80c05f:	48 89 10             	mov    %rdx,(%rax)
  ram_end->used = 1;
  80c062:	48 b8 68 95 a4 00 00 	movabs $0xa49568,%rax
  80c069:	00 00 00 
  80c06c:	48 8b 00             	mov    (%rax),%rax
  80c06f:	c6 40 08 01          	movb   $0x1,0x8(%rax)
  ram_end->next = MEM_SIZE_ALIGNED;
  80c073:	48 b8 68 95 a4 00 00 	movabs $0xa49568,%rax
  80c07a:	00 00 00 
  80c07d:	48 8b 00             	mov    (%rax),%rax
  80c080:	c7 00 00 00 22 00    	movl   $0x220000,(%rax)
  ram_end->prev = MEM_SIZE_ALIGNED;
  80c086:	48 b8 68 95 a4 00 00 	movabs $0xa49568,%rax
  80c08d:	00 00 00 
  80c090:	48 8b 00             	mov    (%rax),%rax
  80c093:	c7 40 04 00 00 22 00 	movl   $0x220000,0x4(%rax)

  mem_sem = sys_sem_new(1);
  80c09a:	bf 01 00 00 00       	mov    $0x1,%edi
  80c09f:	48 b8 e2 79 81 00 00 	movabs $0x8179e2,%rax
  80c0a6:	00 00 00 
  80c0a9:	ff d0                	callq  *%rax
  80c0ab:	48 ba 78 95 a4 00 00 	movabs $0xa49578,%rdx
  80c0b2:	00 00 00 
  80c0b5:	89 02                	mov    %eax,(%rdx)

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  80c0b7:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80c0be:	00 00 00 
  80c0c1:	48 8b 10             	mov    (%rax),%rdx
  80c0c4:	48 b8 70 95 a4 00 00 	movabs $0xa49570,%rax
  80c0cb:	00 00 00 
  80c0ce:	48 89 10             	mov    %rdx,(%rax)

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  80c0d1:	c9                   	leaveq 
  80c0d2:	c3                   	retq   

000000000080c0d3 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  80c0d3:	55                   	push   %rbp
  80c0d4:	48 89 e5             	mov    %rsp,%rbp
  80c0d7:	48 83 ec 20          	sub    $0x20,%rsp
  80c0db:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  80c0df:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80c0e4:	0f 84 70 01 00 00    	je     80c25a <mem_free+0x187>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  80c0ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c0ee:	83 e0 03             	and    $0x3,%eax
  80c0f1:	48 85 c0             	test   %rax,%rax
  80c0f4:	74 2a                	je     80c120 <mem_free+0x4d>
  80c0f6:	48 ba 68 1a 82 00 00 	movabs $0x821a68,%rdx
  80c0fd:	00 00 00 
  80c100:	be 30 01 00 00       	mov    $0x130,%esi
  80c105:	48 bf ef 19 82 00 00 	movabs $0x8219ef,%rdi
  80c10c:	00 00 00 
  80c10f:	b8 00 00 00 00       	mov    $0x0,%eax
  80c114:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80c11b:	00 00 00 
  80c11e:	ff d1                	callq  *%rcx

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80c120:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80c127:	00 00 00 
  80c12a:	48 8b 00             	mov    (%rax),%rax
  80c12d:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c131:	72 13                	jb     80c146 <mem_free+0x73>
  80c133:	48 b8 68 95 a4 00 00 	movabs $0xa49568,%rax
  80c13a:	00 00 00 
  80c13d:	48 8b 00             	mov    (%rax),%rax
  80c140:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c144:	72 2a                	jb     80c170 <mem_free+0x9d>
  80c146:	48 ba 89 1a 82 00 00 	movabs $0x821a89,%rdx
  80c14d:	00 00 00 
  80c150:	be 33 01 00 00       	mov    $0x133,%esi
  80c155:	48 bf ef 19 82 00 00 	movabs $0x8219ef,%rdi
  80c15c:	00 00 00 
  80c15f:	b8 00 00 00 00       	mov    $0x0,%eax
  80c164:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80c16b:	00 00 00 
  80c16e:	ff d1                	callq  *%rcx
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
  80c170:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80c177:	00 00 00 
  80c17a:	48 8b 00             	mov    (%rax),%rax
  80c17d:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c181:	0f 82 d6 00 00 00    	jb     80c25d <mem_free+0x18a>
  80c187:	48 b8 68 95 a4 00 00 	movabs $0xa49568,%rax
  80c18e:	00 00 00 
  80c191:	48 8b 00             	mov    (%rax),%rax
  80c194:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c198:	0f 83 bf 00 00 00    	jae    80c25d <mem_free+0x18a>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80c19e:	48 b8 78 95 a4 00 00 	movabs $0xa49578,%rax
  80c1a5:	00 00 00 
  80c1a8:	8b 00                	mov    (%rax),%eax
  80c1aa:	be 00 00 00 00       	mov    $0x0,%esi
  80c1af:	89 c7                	mov    %eax,%edi
  80c1b1:	48 b8 46 7d 81 00 00 	movabs $0x817d46,%rax
  80c1b8:	00 00 00 
  80c1bb:	ff d0                	callq  *%rax
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80c1bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c1c1:	48 83 e8 0c          	sub    $0xc,%rax
  80c1c5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  80c1c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c1cd:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c1d1:	84 c0                	test   %al,%al
  80c1d3:	75 2a                	jne    80c1ff <mem_free+0x12c>
  80c1d5:	48 ba a0 1a 82 00 00 	movabs $0x821aa0,%rdx
  80c1dc:	00 00 00 
  80c1df:	be 43 01 00 00       	mov    $0x143,%esi
  80c1e4:	48 bf ef 19 82 00 00 	movabs $0x8219ef,%rdi
  80c1eb:	00 00 00 
  80c1ee:	b8 00 00 00 00       	mov    $0x0,%eax
  80c1f3:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80c1fa:	00 00 00 
  80c1fd:	ff d1                	callq  *%rcx
  /* ... and is now unused. */
  mem->used = 0;
  80c1ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c203:	c6 40 08 00          	movb   $0x0,0x8(%rax)

  if (mem < lfree) {
  80c207:	48 b8 70 95 a4 00 00 	movabs $0xa49570,%rax
  80c20e:	00 00 00 
  80c211:	48 8b 00             	mov    (%rax),%rax
  80c214:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80c218:	73 11                	jae    80c22b <mem_free+0x158>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  80c21a:	48 b8 70 95 a4 00 00 	movabs $0xa49570,%rax
  80c221:	00 00 00 
  80c224:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80c228:	48 89 10             	mov    %rdx,(%rax)
  }

  MEM_STATS_DEC_USED(used, mem->next - ((u8_t *)mem - ram));

  /* finally, see if prev or next are free also */
  plug_holes(mem);
  80c22b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c22f:	48 89 c7             	mov    %rax,%rdi
  80c232:	48 b8 a8 bd 80 00 00 	movabs $0x80bda8,%rax
  80c239:	00 00 00 
  80c23c:	ff d0                	callq  *%rax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80c23e:	48 b8 78 95 a4 00 00 	movabs $0xa49578,%rax
  80c245:	00 00 00 
  80c248:	8b 00                	mov    (%rax),%eax
  80c24a:	89 c7                	mov    %eax,%edi
  80c24c:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  80c253:	00 00 00 
  80c256:	ff d0                	callq  *%rax
  80c258:	eb 04                	jmp    80c25e <mem_free+0x18b>
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  80c25a:	90                   	nop
  80c25b:	eb 01                	jmp    80c25e <mem_free+0x18b>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  80c25d:	90                   	nop
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
  80c25e:	c9                   	leaveq 
  80c25f:	c3                   	retq   

000000000080c260 <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  80c260:	55                   	push   %rbp
  80c261:	48 89 e5             	mov    %rsp,%rbp
  80c264:	48 83 ec 30          	sub    $0x30,%rsp
  80c268:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80c26c:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  80c26f:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c272:	83 c0 03             	add    $0x3,%eax
  80c275:	83 e0 fc             	and    $0xfffffffc,%eax
  80c278:	89 45 d4             	mov    %eax,-0x2c(%rbp)

  if(newsize < MIN_SIZE_ALIGNED) {
  80c27b:	83 7d d4 0b          	cmpl   $0xb,-0x2c(%rbp)
  80c27f:	77 07                	ja     80c288 <mem_realloc+0x28>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  80c281:	c7 45 d4 0c 00 00 00 	movl   $0xc,-0x2c(%rbp)
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  80c288:	81 7d d4 00 00 22 00 	cmpl   $0x220000,-0x2c(%rbp)
  80c28f:	76 0a                	jbe    80c29b <mem_realloc+0x3b>
    return NULL;
  80c291:	b8 00 00 00 00       	mov    $0x0,%eax
  80c296:	e9 dc 02 00 00       	jmpq   80c577 <mem_realloc+0x317>
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  80c29b:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80c2a2:	00 00 00 
  80c2a5:	48 8b 00             	mov    (%rax),%rax
  80c2a8:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c2ac:	72 13                	jb     80c2c1 <mem_realloc+0x61>
  80c2ae:	48 b8 68 95 a4 00 00 	movabs $0xa49568,%rax
  80c2b5:	00 00 00 
  80c2b8:	48 8b 00             	mov    (%rax),%rax
  80c2bb:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c2bf:	72 2a                	jb     80c2eb <mem_realloc+0x8b>
  80c2c1:	48 ba b4 1a 82 00 00 	movabs $0x821ab4,%rdx
  80c2c8:	00 00 00 
  80c2cb:	be 79 01 00 00       	mov    $0x179,%esi
  80c2d0:	48 bf ef 19 82 00 00 	movabs $0x8219ef,%rdi
  80c2d7:	00 00 00 
  80c2da:	b8 00 00 00 00       	mov    $0x0,%eax
  80c2df:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80c2e6:	00 00 00 
  80c2e9:	ff d1                	callq  *%rcx
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
  80c2eb:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80c2f2:	00 00 00 
  80c2f5:	48 8b 00             	mov    (%rax),%rax
  80c2f8:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c2fc:	72 13                	jb     80c311 <mem_realloc+0xb1>
  80c2fe:	48 b8 68 95 a4 00 00 	movabs $0xa49568,%rax
  80c305:	00 00 00 
  80c308:	48 8b 00             	mov    (%rax),%rax
  80c30b:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80c30f:	72 09                	jb     80c31a <mem_realloc+0xba>
    LWIP_DEBUGF(MEM_DEBUG | 3, ("mem_realloc: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  80c311:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c315:	e9 5d 02 00 00       	jmpq   80c577 <mem_realloc+0x317>
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80c31a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c31e:	48 83 e8 0c          	sub    $0xc,%rax
  80c322:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  80c326:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80c32a:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80c331:	00 00 00 
  80c334:	48 8b 00             	mov    (%rax),%rax
  80c337:	48 89 d1             	mov    %rdx,%rcx
  80c33a:	48 29 c1             	sub    %rax,%rcx
  80c33d:	48 89 c8             	mov    %rcx,%rax
  80c340:	89 45 f4             	mov    %eax,-0xc(%rbp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  80c343:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c347:	8b 00                	mov    (%rax),%eax
  80c349:	2b 45 f4             	sub    -0xc(%rbp),%eax
  80c34c:	83 e8 0c             	sub    $0xc,%eax
  80c34f:	89 45 f0             	mov    %eax,-0x10(%rbp)
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  80c352:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c355:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80c358:	76 2a                	jbe    80c384 <mem_realloc+0x124>
  80c35a:	48 ba d0 1a 82 00 00 	movabs $0x821ad0,%rdx
  80c361:	00 00 00 
  80c364:	be 8a 01 00 00       	mov    $0x18a,%esi
  80c369:	48 bf ef 19 82 00 00 	movabs $0x8219ef,%rdi
  80c370:	00 00 00 
  80c373:	b8 00 00 00 00       	mov    $0x0,%eax
  80c378:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80c37f:	00 00 00 
  80c382:	ff d1                	callq  *%rcx
  if (newsize > size) {
  80c384:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c387:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80c38a:	76 0a                	jbe    80c396 <mem_realloc+0x136>
    /* not supported */
    return NULL;
  80c38c:	b8 00 00 00 00       	mov    $0x0,%eax
  80c391:	e9 e1 01 00 00       	jmpq   80c577 <mem_realloc+0x317>
  }
  if (newsize == size) {
  80c396:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c399:	3b 45 f0             	cmp    -0x10(%rbp),%eax
  80c39c:	75 09                	jne    80c3a7 <mem_realloc+0x147>
    /* No change in size, simply return */
    return rmem;
  80c39e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80c3a2:	e9 d0 01 00 00       	jmpq   80c577 <mem_realloc+0x317>
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80c3a7:	48 b8 78 95 a4 00 00 	movabs $0xa49578,%rax
  80c3ae:	00 00 00 
  80c3b1:	8b 00                	mov    (%rax),%eax
  80c3b3:	be 00 00 00 00       	mov    $0x0,%esi
  80c3b8:	89 c7                	mov    %eax,%edi
  80c3ba:	48 b8 46 7d 81 00 00 	movabs $0x817d46,%rax
  80c3c1:	00 00 00 
  80c3c4:	ff d0                	callq  *%rax

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  80c3c6:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80c3cd:	00 00 00 
  80c3d0:	48 8b 10             	mov    (%rax),%rdx
  80c3d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c3d7:	8b 00                	mov    (%rax),%eax
  80c3d9:	89 c0                	mov    %eax,%eax
  80c3db:	48 01 d0             	add    %rdx,%rax
  80c3de:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if(mem2->used == 0) {
  80c3e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c3e6:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c3ea:	84 c0                	test   %al,%al
  80c3ec:	0f 85 b9 00 00 00    	jne    80c4ab <mem_realloc+0x24b>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  80c3f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c3f6:	8b 00                	mov    (%rax),%eax
  80c3f8:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80c3fb:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c3fe:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c401:	01 d0                	add    %edx,%eax
  80c403:	83 c0 0c             	add    $0xc,%eax
  80c406:	89 45 e0             	mov    %eax,-0x20(%rbp)
    if (lfree == mem2) {
  80c409:	48 b8 70 95 a4 00 00 	movabs $0xa49570,%rax
  80c410:	00 00 00 
  80c413:	48 8b 00             	mov    (%rax),%rax
  80c416:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80c41a:	75 20                	jne    80c43c <mem_realloc+0x1dc>
      lfree = (struct mem *)&ram[ptr2];
  80c41c:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80c423:	00 00 00 
  80c426:	48 8b 10             	mov    (%rax),%rdx
  80c429:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c42c:	48 01 c2             	add    %rax,%rdx
  80c42f:	48 b8 70 95 a4 00 00 	movabs $0xa49570,%rax
  80c436:	00 00 00 
  80c439:	48 89 10             	mov    %rdx,(%rax)
    }
    mem2 = (struct mem *)&ram[ptr2];
  80c43c:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80c443:	00 00 00 
  80c446:	48 8b 10             	mov    (%rax),%rdx
  80c449:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c44c:	48 01 d0             	add    %rdx,%rax
  80c44f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    mem2->used = 0;
  80c453:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c457:	c6 40 08 00          	movb   $0x0,0x8(%rax)
    /* restore the next pointer */
    mem2->next = next;
  80c45b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c45f:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80c462:	89 10                	mov    %edx,(%rax)
    /* link it back to mem */
    mem2->prev = ptr;
  80c464:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c468:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c46b:	89 50 04             	mov    %edx,0x4(%rax)
    /* link mem to it */
    mem->next = ptr2;
  80c46e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c472:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80c475:	89 10                	mov    %edx,(%rax)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80c477:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c47b:	8b 00                	mov    (%rax),%eax
  80c47d:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80c482:	0f 84 d1 00 00 00    	je     80c559 <mem_realloc+0x2f9>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80c488:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80c48f:	00 00 00 
  80c492:	48 8b 10             	mov    (%rax),%rdx
  80c495:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c499:	8b 00                	mov    (%rax),%eax
  80c49b:	89 c0                	mov    %eax,%eax
  80c49d:	48 01 c2             	add    %rax,%rdx
  80c4a0:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c4a3:	89 42 04             	mov    %eax,0x4(%rdx)
  80c4a6:	e9 ae 00 00 00       	jmpq   80c559 <mem_realloc+0x2f9>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  80c4ab:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c4ae:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80c4b2:	8b 45 f0             	mov    -0x10(%rbp),%eax
  80c4b5:	48 39 c2             	cmp    %rax,%rdx
  80c4b8:	0f 87 9b 00 00 00    	ja     80c559 <mem_realloc+0x2f9>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  80c4be:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80c4c1:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c4c4:	01 d0                	add    %edx,%eax
  80c4c6:	83 c0 0c             	add    $0xc,%eax
  80c4c9:	89 45 e0             	mov    %eax,-0x20(%rbp)
    mem2 = (struct mem *)&ram[ptr2];
  80c4cc:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80c4d3:	00 00 00 
  80c4d6:	48 8b 10             	mov    (%rax),%rdx
  80c4d9:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c4dc:	48 01 d0             	add    %rdx,%rax
  80c4df:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (mem2 < lfree) {
  80c4e3:	48 b8 70 95 a4 00 00 	movabs $0xa49570,%rax
  80c4ea:	00 00 00 
  80c4ed:	48 8b 00             	mov    (%rax),%rax
  80c4f0:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80c4f4:	73 11                	jae    80c507 <mem_realloc+0x2a7>
      lfree = mem2;
  80c4f6:	48 b8 70 95 a4 00 00 	movabs $0xa49570,%rax
  80c4fd:	00 00 00 
  80c500:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80c504:	48 89 10             	mov    %rdx,(%rax)
    }
    mem2->used = 0;
  80c507:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c50b:	c6 40 08 00          	movb   $0x0,0x8(%rax)
    mem2->next = mem->next;
  80c50f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c513:	8b 10                	mov    (%rax),%edx
  80c515:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c519:	89 10                	mov    %edx,(%rax)
    mem2->prev = ptr;
  80c51b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c51f:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80c522:	89 50 04             	mov    %edx,0x4(%rax)
    mem->next = ptr2;
  80c525:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c529:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80c52c:	89 10                	mov    %edx,(%rax)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  80c52e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c532:	8b 00                	mov    (%rax),%eax
  80c534:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80c539:	74 1e                	je     80c559 <mem_realloc+0x2f9>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80c53b:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80c542:	00 00 00 
  80c545:	48 8b 10             	mov    (%rax),%rdx
  80c548:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80c54c:	8b 00                	mov    (%rax),%eax
  80c54e:	89 c0                	mov    %eax,%eax
  80c550:	48 01 c2             	add    %rax,%rdx
  80c553:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80c556:	89 42 04             	mov    %eax,0x4(%rdx)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80c559:	48 b8 78 95 a4 00 00 	movabs $0xa49578,%rax
  80c560:	00 00 00 
  80c563:	8b 00                	mov    (%rax),%eax
  80c565:	89 c7                	mov    %eax,%edi
  80c567:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  80c56e:	00 00 00 
  80c571:	ff d0                	callq  *%rax
  return rmem;
  80c573:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
}
  80c577:	c9                   	leaveq 
  80c578:	c3                   	retq   

000000000080c579 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  80c579:	55                   	push   %rbp
  80c57a:	48 89 e5             	mov    %rsp,%rbp
  80c57d:	48 83 ec 30          	sub    $0x30,%rsp
  80c581:	89 7d dc             	mov    %edi,-0x24(%rbp)
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  80c584:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80c588:	75 0a                	jne    80c594 <mem_malloc+0x1b>
    return NULL;
  80c58a:	b8 00 00 00 00       	mov    $0x0,%eax
  80c58f:	e9 74 03 00 00       	jmpq   80c908 <mem_malloc+0x38f>
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  80c594:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80c597:	83 c0 03             	add    $0x3,%eax
  80c59a:	83 e0 fc             	and    $0xfffffffc,%eax
  80c59d:	89 45 dc             	mov    %eax,-0x24(%rbp)

  if(size < MIN_SIZE_ALIGNED) {
  80c5a0:	83 7d dc 0b          	cmpl   $0xb,-0x24(%rbp)
  80c5a4:	77 07                	ja     80c5ad <mem_malloc+0x34>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  80c5a6:	c7 45 dc 0c 00 00 00 	movl   $0xc,-0x24(%rbp)
  }

  if (size > MEM_SIZE_ALIGNED) {
  80c5ad:	81 7d dc 00 00 22 00 	cmpl   $0x220000,-0x24(%rbp)
  80c5b4:	76 0a                	jbe    80c5c0 <mem_malloc+0x47>
    return NULL;
  80c5b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80c5bb:	e9 48 03 00 00       	jmpq   80c908 <mem_malloc+0x38f>
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  80c5c0:	48 b8 78 95 a4 00 00 	movabs $0xa49578,%rax
  80c5c7:	00 00 00 
  80c5ca:	8b 00                	mov    (%rax),%eax
  80c5cc:	be 00 00 00 00       	mov    $0x0,%esi
  80c5d1:	89 c7                	mov    %eax,%edi
  80c5d3:	48 b8 46 7d 81 00 00 	movabs $0x817d46,%rax
  80c5da:	00 00 00 
  80c5dd:	ff d0                	callq  *%rax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80c5df:	48 b8 70 95 a4 00 00 	movabs $0xa49570,%rax
  80c5e6:	00 00 00 
  80c5e9:	48 8b 00             	mov    (%rax),%rax
  80c5ec:	48 89 c2             	mov    %rax,%rdx
  80c5ef:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80c5f6:	00 00 00 
  80c5f9:	48 8b 00             	mov    (%rax),%rax
  80c5fc:	48 89 d1             	mov    %rdx,%rcx
  80c5ff:	48 29 c1             	sub    %rax,%rcx
  80c602:	48 89 c8             	mov    %rcx,%rax
  80c605:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80c608:	e9 cb 02 00 00       	jmpq   80c8d8 <mem_malloc+0x35f>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  80c60d:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80c614:	00 00 00 
  80c617:	48 8b 10             	mov    (%rax),%rdx
  80c61a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80c61d:	48 01 d0             	add    %rdx,%rax
  80c620:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80c624:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c628:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c62c:	84 c0                	test   %al,%al
  80c62e:	0f 85 8c 02 00 00    	jne    80c8c0 <mem_malloc+0x347>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  80c634:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c638:	8b 00                	mov    (%rax),%eax
  80c63a:	89 c2                	mov    %eax,%edx
  80c63c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80c63f:	48 89 d1             	mov    %rdx,%rcx
  80c642:	48 29 c1             	sub    %rax,%rcx
  80c645:	48 89 c8             	mov    %rcx,%rax
  80c648:	48 8d 50 f4          	lea    -0xc(%rax),%rdx
  80c64c:	8b 45 dc             	mov    -0x24(%rbp),%eax
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80c64f:	48 39 c2             	cmp    %rax,%rdx
  80c652:	0f 82 68 02 00 00    	jb     80c8c0 <mem_malloc+0x347>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  80c658:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c65c:	8b 00                	mov    (%rax),%eax
  80c65e:	89 c2                	mov    %eax,%edx
  80c660:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80c663:	48 89 d1             	mov    %rdx,%rcx
  80c666:	48 29 c1             	sub    %rax,%rcx
  80c669:	48 89 c8             	mov    %rcx,%rax
  80c66c:	48 8d 50 f4          	lea    -0xc(%rax),%rdx
  80c670:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80c673:	48 83 c0 18          	add    $0x18,%rax
  80c677:	48 39 c2             	cmp    %rax,%rdx
  80c67a:	0f 82 81 00 00 00    	jb     80c701 <mem_malloc+0x188>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  80c680:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80c683:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80c686:	01 d0                	add    %edx,%eax
  80c688:	83 c0 0c             	add    $0xc,%eax
  80c68b:	89 45 ec             	mov    %eax,-0x14(%rbp)
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  80c68e:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80c695:	00 00 00 
  80c698:	48 8b 10             	mov    (%rax),%rdx
  80c69b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80c69e:	48 01 d0             	add    %rdx,%rax
  80c6a1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          mem2->used = 0;
  80c6a5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c6a9:	c6 40 08 00          	movb   $0x0,0x8(%rax)
          mem2->next = mem->next;
  80c6ad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c6b1:	8b 10                	mov    (%rax),%edx
  80c6b3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c6b7:	89 10                	mov    %edx,(%rax)
          mem2->prev = ptr;
  80c6b9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c6bd:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80c6c0:	89 50 04             	mov    %edx,0x4(%rax)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  80c6c3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c6c7:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80c6ca:	89 10                	mov    %edx,(%rax)
          mem->used = 1;
  80c6cc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c6d0:	c6 40 08 01          	movb   $0x1,0x8(%rax)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  80c6d4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c6d8:	8b 00                	mov    (%rax),%eax
  80c6da:	3d 00 00 22 00       	cmp    $0x220000,%eax
  80c6df:	74 28                	je     80c709 <mem_malloc+0x190>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80c6e1:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80c6e8:	00 00 00 
  80c6eb:	48 8b 10             	mov    (%rax),%rdx
  80c6ee:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80c6f2:	8b 00                	mov    (%rax),%eax
  80c6f4:	89 c0                	mov    %eax,%eax
  80c6f6:	48 01 c2             	add    %rax,%rdx
  80c6f9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80c6fc:	89 42 04             	mov    %eax,0x4(%rdx)
  80c6ff:	eb 08                	jmp    80c709 <mem_malloc+0x190>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  80c701:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c705:	c6 40 08 01          	movb   $0x1,0x8(%rax)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  80c709:	48 b8 70 95 a4 00 00 	movabs $0xa49570,%rax
  80c710:	00 00 00 
  80c713:	48 8b 00             	mov    (%rax),%rax
  80c716:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  80c71a:	0f 85 c2 00 00 00    	jne    80c7e2 <mem_malloc+0x269>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  80c720:	eb 2e                	jmp    80c750 <mem_malloc+0x1d7>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  80c722:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80c729:	00 00 00 
  80c72c:	48 8b 10             	mov    (%rax),%rdx
  80c72f:	48 b8 70 95 a4 00 00 	movabs $0xa49570,%rax
  80c736:	00 00 00 
  80c739:	48 8b 00             	mov    (%rax),%rax
  80c73c:	8b 00                	mov    (%rax),%eax
  80c73e:	89 c0                	mov    %eax,%eax
  80c740:	48 01 c2             	add    %rax,%rdx
  80c743:	48 b8 70 95 a4 00 00 	movabs $0xa49570,%rax
  80c74a:	00 00 00 
  80c74d:	48 89 10             	mov    %rdx,(%rax)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  80c750:	48 b8 70 95 a4 00 00 	movabs $0xa49570,%rax
  80c757:	00 00 00 
  80c75a:	48 8b 00             	mov    (%rax),%rax
  80c75d:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c761:	84 c0                	test   %al,%al
  80c763:	74 1f                	je     80c784 <mem_malloc+0x20b>
  80c765:	48 b8 70 95 a4 00 00 	movabs $0xa49570,%rax
  80c76c:	00 00 00 
  80c76f:	48 8b 10             	mov    (%rax),%rdx
  80c772:	48 b8 68 95 a4 00 00 	movabs $0xa49568,%rax
  80c779:	00 00 00 
  80c77c:	48 8b 00             	mov    (%rax),%rax
  80c77f:	48 39 c2             	cmp    %rax,%rdx
  80c782:	75 9e                	jne    80c722 <mem_malloc+0x1a9>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
  80c784:	48 b8 70 95 a4 00 00 	movabs $0xa49570,%rax
  80c78b:	00 00 00 
  80c78e:	48 8b 10             	mov    (%rax),%rdx
  80c791:	48 b8 68 95 a4 00 00 	movabs $0xa49568,%rax
  80c798:	00 00 00 
  80c79b:	48 8b 00             	mov    (%rax),%rax
  80c79e:	48 39 c2             	cmp    %rax,%rdx
  80c7a1:	74 3f                	je     80c7e2 <mem_malloc+0x269>
  80c7a3:	48 b8 70 95 a4 00 00 	movabs $0xa49570,%rax
  80c7aa:	00 00 00 
  80c7ad:	48 8b 00             	mov    (%rax),%rax
  80c7b0:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  80c7b4:	84 c0                	test   %al,%al
  80c7b6:	74 2a                	je     80c7e2 <mem_malloc+0x269>
  80c7b8:	48 ba f3 1a 82 00 00 	movabs $0x821af3,%rdx
  80c7bf:	00 00 00 
  80c7c2:	be 46 02 00 00       	mov    $0x246,%esi
  80c7c7:	48 bf ef 19 82 00 00 	movabs $0x8219ef,%rdi
  80c7ce:	00 00 00 
  80c7d1:	b8 00 00 00 00       	mov    $0x0,%eax
  80c7d6:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80c7dd:	00 00 00 
  80c7e0:	ff d1                	callq  *%rcx
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  80c7e2:	48 b8 78 95 a4 00 00 	movabs $0xa49578,%rax
  80c7e9:	00 00 00 
  80c7ec:	8b 00                	mov    (%rax),%eax
  80c7ee:	89 c7                	mov    %eax,%edi
  80c7f0:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  80c7f7:	00 00 00 
  80c7fa:	ff d0                	callq  *%rax
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  80c7fc:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80c7ff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c803:	48 01 d0             	add    %rdx,%rax
  80c806:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  80c80a:	48 b8 68 95 a4 00 00 	movabs $0xa49568,%rax
  80c811:	00 00 00 
  80c814:	48 8b 00             	mov    (%rax),%rax
  80c817:	48 39 c2             	cmp    %rax,%rdx
  80c81a:	76 2a                	jbe    80c846 <mem_malloc+0x2cd>
  80c81c:	48 ba 10 1b 82 00 00 	movabs $0x821b10,%rdx
  80c823:	00 00 00 
  80c826:	be 4b 02 00 00       	mov    $0x24b,%esi
  80c82b:	48 bf ef 19 82 00 00 	movabs $0x8219ef,%rdi
  80c832:	00 00 00 
  80c835:	b8 00 00 00 00       	mov    $0x0,%eax
  80c83a:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80c841:	00 00 00 
  80c844:	ff d1                	callq  *%rcx
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  80c846:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c84a:	48 83 c0 0c          	add    $0xc,%rax
  80c84e:	83 e0 03             	and    $0x3,%eax
  80c851:	48 85 c0             	test   %rax,%rax
  80c854:	74 2a                	je     80c880 <mem_malloc+0x307>
  80c856:	48 ba 40 1b 82 00 00 	movabs $0x821b40,%rdx
  80c85d:	00 00 00 
  80c860:	be 4d 02 00 00       	mov    $0x24d,%esi
  80c865:	48 bf ef 19 82 00 00 	movabs $0x8219ef,%rdi
  80c86c:	00 00 00 
  80c86f:	b8 00 00 00 00       	mov    $0x0,%eax
  80c874:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80c87b:	00 00 00 
  80c87e:	ff d1                	callq  *%rcx
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  80c880:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c884:	83 e0 03             	and    $0x3,%eax
  80c887:	48 85 c0             	test   %rax,%rax
  80c88a:	74 2a                	je     80c8b6 <mem_malloc+0x33d>
  80c88c:	48 ba 70 1b 82 00 00 	movabs $0x821b70,%rdx
  80c893:	00 00 00 
  80c896:	be 4f 02 00 00       	mov    $0x24f,%esi
  80c89b:	48 bf ef 19 82 00 00 	movabs $0x8219ef,%rdi
  80c8a2:	00 00 00 
  80c8a5:	b8 00 00 00 00       	mov    $0x0,%eax
  80c8aa:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80c8b1:	00 00 00 
  80c8b4:	ff d1                	callq  *%rcx
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
  80c8b6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80c8ba:	48 83 c0 0c          	add    $0xc,%rax
  80c8be:	eb 48                	jmp    80c908 <mem_malloc+0x38f>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  80c8c0:	48 b8 60 95 a4 00 00 	movabs $0xa49560,%rax
  80c8c7:	00 00 00 
  80c8ca:	48 8b 10             	mov    (%rax),%rdx
  80c8cd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80c8d0:	48 01 d0             	add    %rdx,%rax
  80c8d3:	8b 00                	mov    (%rax),%eax
  80c8d5:	89 45 fc             	mov    %eax,-0x4(%rbp)
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80c8d8:	b8 00 00 22 00       	mov    $0x220000,%eax
  80c8dd:	2b 45 dc             	sub    -0x24(%rbp),%eax
  80c8e0:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80c8e3:	0f 87 24 fd ff ff    	ja     80c60d <mem_malloc+0x94>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  80c8e9:	48 b8 78 95 a4 00 00 	movabs $0xa49578,%rax
  80c8f0:	00 00 00 
  80c8f3:	8b 00                	mov    (%rax),%eax
  80c8f5:	89 c7                	mov    %eax,%edi
  80c8f7:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  80c8fe:	00 00 00 
  80c901:	ff d0                	callq  *%rax
  return NULL;
  80c903:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80c908:	c9                   	leaveq 
  80c909:	c3                   	retq   

000000000080c90a <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  80c90a:	55                   	push   %rbp
  80c90b:	48 89 e5             	mov    %rsp,%rbp
  80c90e:	48 83 ec 20          	sub    $0x20,%rsp
  80c912:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80c915:	89 75 e8             	mov    %esi,-0x18(%rbp)
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  80c918:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80c91b:	0f af 45 e8          	imul   -0x18(%rbp),%eax
  80c91f:	89 c7                	mov    %eax,%edi
  80c921:	48 b8 79 c5 80 00 00 	movabs $0x80c579,%rax
  80c928:	00 00 00 
  80c92b:	ff d0                	callq  *%rax
  80c92d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (p) {
  80c931:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80c936:	74 21                	je     80c959 <mem_calloc+0x4f>
    /* zero the memory */
    memset(p, 0, count * size);
  80c938:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80c93b:	0f af 45 e8          	imul   -0x18(%rbp),%eax
  80c93f:	89 c2                	mov    %eax,%edx
  80c941:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c945:	be 00 00 00 00       	mov    $0x0,%esi
  80c94a:	48 89 c7             	mov    %rax,%rdi
  80c94d:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  80c954:	00 00 00 
  80c957:	ff d0                	callq  *%rax
  }
  return p;
  80c959:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80c95d:	c9                   	leaveq 
  80c95e:	c3                   	retq   
	...

000000000080c960 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  80c960:	55                   	push   %rbp
  80c961:	48 89 e5             	mov    %rsp,%rbp
  80c964:	48 83 ec 10          	sub    $0x10,%rsp
  struct memp *memp;
  u16_t i, j;

  for (i = 0; i < MEMP_MAX; ++i) {
  80c968:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)
  80c96e:	eb 05                	jmp    80c975 <memp_init+0x15>
  80c970:	66 83 45 f6 01       	addw   $0x1,-0xa(%rbp)
  80c975:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%rbp)
  80c97a:	76 f4                	jbe    80c970 <memp_init+0x10>
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  80c97c:	48 b8 00 96 a4 00 00 	movabs $0xa49600,%rax
  80c983:	00 00 00 
  80c986:	48 83 c0 03          	add    $0x3,%rax
  80c98a:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80c98e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  80c992:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)
  80c998:	e9 97 00 00 00       	jmpq   80ca34 <memp_init+0xd4>
    memp_tab[i] = NULL;
  80c99d:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80c9a1:	48 b8 80 95 a4 00 00 	movabs $0xa49580,%rax
  80c9a8:	00 00 00 
  80c9ab:	48 63 d2             	movslq %edx,%rdx
  80c9ae:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  80c9b5:	00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  80c9b6:	66 c7 45 f4 00 00    	movw   $0x0,-0xc(%rbp)
  80c9bc:	eb 56                	jmp    80ca14 <memp_init+0xb4>
      memp->next = memp_tab[i];
  80c9be:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80c9c2:	48 b8 80 95 a4 00 00 	movabs $0xa49580,%rax
  80c9c9:	00 00 00 
  80c9cc:	48 63 d2             	movslq %edx,%rdx
  80c9cf:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  80c9d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80c9d7:	48 89 10             	mov    %rdx,(%rax)
      memp_tab[i] = memp;
  80c9da:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80c9de:	48 b8 80 95 a4 00 00 	movabs $0xa49580,%rax
  80c9e5:	00 00 00 
  80c9e8:	48 63 d2             	movslq %edx,%rdx
  80c9eb:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80c9ef:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  80c9f3:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80c9f7:	48 b8 a0 1b 82 00 00 	movabs $0x821ba0,%rax
  80c9fe:	00 00 00 
  80ca01:	48 63 d2             	movslq %edx,%rdx
  80ca04:	0f b7 04 50          	movzwl (%rax,%rdx,2),%eax
  80ca08:	0f b7 c0             	movzwl %ax,%eax
  80ca0b:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  80ca0f:	66 83 45 f4 01       	addw   $0x1,-0xc(%rbp)
  80ca14:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80ca18:	48 b8 c0 1b 82 00 00 	movabs $0x821bc0,%rax
  80ca1f:	00 00 00 
  80ca22:	48 63 d2             	movslq %edx,%rdx
  80ca25:	0f b7 04 50          	movzwl (%rax,%rdx,2),%eax
  80ca29:	66 3b 45 f4          	cmp    -0xc(%rbp),%ax
  80ca2d:	77 8f                	ja     80c9be <memp_init+0x5e>
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  80ca2f:	66 83 45 f6 01       	addw   $0x1,-0xa(%rbp)
  80ca34:	66 83 7d f6 0d       	cmpw   $0xd,-0xa(%rbp)
  80ca39:	0f 86 5e ff ff ff    	jbe    80c99d <memp_init+0x3d>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  80ca3f:	c9                   	leaveq 
  80ca40:	c3                   	retq   

000000000080ca41 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  80ca41:	55                   	push   %rbp
  80ca42:	48 89 e5             	mov    %rsp,%rbp
  80ca45:	48 83 ec 20          	sub    $0x20,%rsp
  80ca49:	89 7d ec             	mov    %edi,-0x14(%rbp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  80ca4c:	83 7d ec 0d          	cmpl   $0xd,-0x14(%rbp)
  80ca50:	76 2a                	jbe    80ca7c <memp_malloc+0x3b>
  80ca52:	48 ba 6f 1c 82 00 00 	movabs $0x821c6f,%rdx
  80ca59:	00 00 00 
  80ca5c:	be 2d 01 00 00       	mov    $0x12d,%esi
  80ca61:	48 bf 8c 1c 82 00 00 	movabs $0x821c8c,%rdi
  80ca68:	00 00 00 
  80ca6b:	b8 00 00 00 00       	mov    $0x0,%eax
  80ca70:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80ca77:	00 00 00 
  80ca7a:	ff d1                	callq  *%rcx
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  80ca7c:	48 b8 80 95 a4 00 00 	movabs $0xa49580,%rax
  80ca83:	00 00 00 
  80ca86:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80ca89:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80ca8d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
  if (memp != NULL) {    
  80ca91:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ca96:	74 4e                	je     80cae6 <memp_malloc+0xa5>
    memp_tab[type] = memp->next;    
  80ca98:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ca9c:	48 8b 08             	mov    (%rax),%rcx
  80ca9f:	48 b8 80 95 a4 00 00 	movabs $0xa49580,%rax
  80caa6:	00 00 00 
  80caa9:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80caac:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  80cab0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cab4:	83 e0 03             	and    $0x3,%eax
  80cab7:	48 85 c0             	test   %rax,%rax
  80caba:	74 2a                	je     80cae6 <memp_malloc+0xa5>
  80cabc:	48 ba a8 1c 82 00 00 	movabs $0x821ca8,%rdx
  80cac3:	00 00 00 
  80cac6:	be 3f 01 00 00       	mov    $0x13f,%esi
  80cacb:	48 bf 8c 1c 82 00 00 	movabs $0x821c8c,%rdi
  80cad2:	00 00 00 
  80cad5:	b8 00 00 00 00       	mov    $0x0,%eax
  80cada:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80cae1:	00 00 00 
  80cae4:	ff d1                	callq  *%rcx
    MEMP_STATS_INC(err, type);
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
  80cae6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80caea:	c9                   	leaveq 
  80caeb:	c3                   	retq   

000000000080caec <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  80caec:	55                   	push   %rbp
  80caed:	48 89 e5             	mov    %rsp,%rbp
  80caf0:	48 83 ec 20          	sub    $0x20,%rsp
  80caf4:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80caf7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  80cafb:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80cb00:	74 6d                	je     80cb6f <memp_free+0x83>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  80cb02:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cb06:	83 e0 03             	and    $0x3,%eax
  80cb09:	48 85 c0             	test   %rax,%rax
  80cb0c:	74 2a                	je     80cb38 <memp_free+0x4c>
  80cb0e:	48 ba d0 1c 82 00 00 	movabs $0x821cd0,%rdx
  80cb15:	00 00 00 
  80cb18:	be 5b 01 00 00       	mov    $0x15b,%esi
  80cb1d:	48 bf 8c 1c 82 00 00 	movabs $0x821c8c,%rdi
  80cb24:	00 00 00 
  80cb27:	b8 00 00 00 00       	mov    $0x0,%eax
  80cb2c:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80cb33:	00 00 00 
  80cb36:	ff d1                	callq  *%rcx
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  memp = (struct memp *)((u8_t*)mem - MEMP_SIZE);
  80cb38:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80cb3c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  80cb40:	48 b8 80 95 a4 00 00 	movabs $0xa49580,%rax
  80cb47:	00 00 00 
  80cb4a:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80cb4d:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  80cb51:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cb55:	48 89 10             	mov    %rdx,(%rax)
  memp_tab[type] = memp;
  80cb58:	48 b8 80 95 a4 00 00 	movabs $0xa49580,%rax
  80cb5f:	00 00 00 
  80cb62:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80cb65:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  80cb69:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)
  80cb6d:	eb 01                	jmp    80cb70 <memp_free+0x84>
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    return;
  80cb6f:	90                   	nop
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  80cb70:	c9                   	leaveq 
  80cb71:	c3                   	retq   
	...

000000000080cb74 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  80cb74:	55                   	push   %rbp
  80cb75:	48 89 e5             	mov    %rsp,%rbp
  80cb78:	48 83 ec 30          	sub    $0x30,%rsp
  80cb7c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80cb80:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80cb84:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80cb88:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  80cb8c:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  80cb90:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  80cb94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cb98:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
  netif->netmask.addr = 0;
  80cb9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cba3:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
  netif->gw.addr = 0;
  80cbaa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cbae:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
  netif->flags = 0;
  80cbb5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cbb9:	c6 40 4a 00          	movb   $0x0,0x4a(%rax)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  80cbbd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cbc1:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
  80cbc8:	00 
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  80cbc9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cbcd:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80cbd1:	48 89 50 30          	mov    %rdx,0x30(%rax)
  netif->num = netifnum++;
  80cbd5:	48 b8 ac b0 b4 00 00 	movabs $0xb4b0ac,%rax
  80cbdc:	00 00 00 
  80cbdf:	0f b6 00             	movzbl (%rax),%eax
  80cbe2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80cbe6:	88 42 4d             	mov    %al,0x4d(%rdx)
  80cbe9:	8d 50 01             	lea    0x1(%rax),%edx
  80cbec:	48 b8 ac b0 b4 00 00 	movabs $0xb4b0ac,%rax
  80cbf3:	00 00 00 
  80cbf6:	88 10                	mov    %dl,(%rax)
  netif->input = input;
  80cbf8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cbfc:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80cc00:	48 89 50 18          	mov    %rdx,0x18(%rax)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  80cc04:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  80cc08:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80cc0c:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  80cc10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc14:	48 89 c7             	mov    %rax,%rdi
  80cc17:	48 b8 66 cc 80 00 00 	movabs $0x80cc66,%rax
  80cc1e:	00 00 00 
  80cc21:	ff d0                	callq  *%rax

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  80cc23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc27:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80cc2b:	48 89 c7             	mov    %rax,%rdi
  80cc2e:	ff d2                	callq  *%rdx
  80cc30:	84 c0                	test   %al,%al
  80cc32:	74 07                	je     80cc3b <netif_add+0xc7>
    return NULL;
  80cc34:	b8 00 00 00 00       	mov    $0x0,%eax
  80cc39:	eb 29                	jmp    80cc64 <netif_add+0xf0>
  }

  /* add this netif to the list */
  netif->next = netif_list;
  80cc3b:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80cc42:	00 00 00 
  80cc45:	48 8b 10             	mov    (%rax),%rdx
  80cc48:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc4c:	48 89 10             	mov    %rdx,(%rax)
  netif_list = netif;
  80cc4f:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80cc56:	00 00 00 
  80cc59:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80cc5d:	48 89 10             	mov    %rdx,(%rax)
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  80cc60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80cc64:	c9                   	leaveq 
  80cc65:	c3                   	retq   

000000000080cc66 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  80cc66:	55                   	push   %rbp
  80cc67:	48 89 e5             	mov    %rsp,%rbp
  80cc6a:	48 83 ec 20          	sub    $0x20,%rsp
  80cc6e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80cc72:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80cc76:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80cc7a:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  netif_set_ipaddr(netif, ipaddr);
  80cc7e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80cc82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cc86:	48 89 d6             	mov    %rdx,%rsi
  80cc89:	48 89 c7             	mov    %rax,%rdi
  80cc8c:	48 b8 17 ce 80 00 00 	movabs $0x80ce17,%rax
  80cc93:	00 00 00 
  80cc96:	ff d0                	callq  *%rax
  netif_set_netmask(netif, netmask);
  80cc98:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80cc9c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cca0:	48 89 d6             	mov    %rdx,%rsi
  80cca3:	48 89 c7             	mov    %rax,%rdi
  80cca6:	48 b8 4a cf 80 00 00 	movabs $0x80cf4a,%rax
  80ccad:	00 00 00 
  80ccb0:	ff d0                	callq  *%rax
  netif_set_gw(netif, gw);
  80ccb2:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80ccb6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ccba:	48 89 d6             	mov    %rdx,%rsi
  80ccbd:	48 89 c7             	mov    %rax,%rdi
  80ccc0:	48 b8 1d cf 80 00 00 	movabs $0x80cf1d,%rax
  80ccc7:	00 00 00 
  80ccca:	ff d0                	callq  *%rax
}
  80cccc:	c9                   	leaveq 
  80cccd:	c3                   	retq   

000000000080ccce <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  80ccce:	55                   	push   %rbp
  80cccf:	48 89 e5             	mov    %rsp,%rbp
  80ccd2:	48 83 ec 20          	sub    $0x20,%rsp
  80ccd6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if ( netif == NULL ) return;
  80ccda:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80ccdf:	0f 84 98 00 00 00    	je     80cd7d <netif_remove+0xaf>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  80cce5:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80ccec:	00 00 00 
  80ccef:	48 8b 00             	mov    (%rax),%rax
  80ccf2:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80ccf6:	75 16                	jne    80cd0e <netif_remove+0x40>
    netif_list = netif->next;
  80ccf8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ccfc:	48 8b 10             	mov    (%rax),%rdx
  80ccff:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80cd06:	00 00 00 
  80cd09:	48 89 10             	mov    %rdx,(%rax)
  80cd0c:	eb 49                	jmp    80cd57 <netif_remove+0x89>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  80cd0e:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80cd15:	00 00 00 
  80cd18:	48 8b 00             	mov    (%rax),%rax
  80cd1b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80cd1f:	eb 28                	jmp    80cd49 <netif_remove+0x7b>
      if (tmpNetif->next == netif) {
  80cd21:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cd25:	48 8b 00             	mov    (%rax),%rax
  80cd28:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80cd2c:	75 10                	jne    80cd3e <netif_remove+0x70>
        tmpNetif->next = netif->next;
  80cd2e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80cd32:	48 8b 10             	mov    (%rax),%rdx
  80cd35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cd39:	48 89 10             	mov    %rdx,(%rax)
        snmp_dec_iflist();
        break;
  80cd3c:	eb 12                	jmp    80cd50 <netif_remove+0x82>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  80cd3e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cd42:	48 8b 00             	mov    (%rax),%rax
  80cd45:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80cd49:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80cd4e:	75 d1                	jne    80cd21 <netif_remove+0x53>
        tmpNetif->next = netif->next;
        snmp_dec_iflist();
        break;
      }
    }
    if (tmpNetif == NULL)
  80cd50:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80cd55:	74 29                	je     80cd80 <netif_remove+0xb2>
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  80cd57:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  80cd5e:	00 00 00 
  80cd61:	48 8b 00             	mov    (%rax),%rax
  80cd64:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80cd68:	75 17                	jne    80cd81 <netif_remove+0xb3>
    /* reset default netif */
    netif_set_default(NULL);
  80cd6a:	bf 00 00 00 00       	mov    $0x0,%edi
  80cd6f:	48 b8 77 cf 80 00 00 	movabs $0x80cf77,%rax
  80cd76:	00 00 00 
  80cd79:	ff d0                	callq  *%rax
  80cd7b:	eb 04                	jmp    80cd81 <netif_remove+0xb3>
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  if ( netif == NULL ) return;
  80cd7d:	90                   	nop
  80cd7e:	eb 01                	jmp    80cd81 <netif_remove+0xb3>
        snmp_dec_iflist();
        break;
      }
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  80cd80:	90                   	nop
  /* this netif is default? */
  if (netif_default == netif)
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  80cd81:	c9                   	leaveq 
  80cd82:	c3                   	retq   

000000000080cd83 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  80cd83:	55                   	push   %rbp
  80cd84:	48 89 e5             	mov    %rsp,%rbp
  80cd87:	48 83 ec 18          	sub    $0x18,%rsp
  80cd8b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  80cd8f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80cd94:	75 07                	jne    80cd9d <netif_find+0x1a>
    return NULL;
  80cd96:	b8 00 00 00 00       	mov    $0x0,%eax
  80cd9b:	eb 78                	jmp    80ce15 <netif_find+0x92>
  }

  num = name[2] - '0';
  80cd9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80cda1:	48 83 c0 02          	add    $0x2,%rax
  80cda5:	0f b6 00             	movzbl (%rax),%eax
  80cda8:	83 e8 30             	sub    $0x30,%eax
  80cdab:	88 45 f7             	mov    %al,-0x9(%rbp)

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80cdae:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  80cdb5:	00 00 00 
  80cdb8:	48 8b 00             	mov    (%rax),%rax
  80cdbb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80cdbf:	eb 48                	jmp    80ce09 <netif_find+0x86>
    if (num == netif->num &&
  80cdc1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cdc5:	0f b6 40 4d          	movzbl 0x4d(%rax),%eax
  80cdc9:	3a 45 f7             	cmp    -0x9(%rbp),%al
  80cdcc:	75 30                	jne    80cdfe <netif_find+0x7b>
       name[0] == netif->name[0] &&
  80cdce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80cdd2:	0f b6 10             	movzbl (%rax),%edx
  80cdd5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cdd9:	0f b6 40 4b          	movzbl 0x4b(%rax),%eax
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
  80cddd:	38 c2                	cmp    %al,%dl
  80cddf:	75 1d                	jne    80cdfe <netif_find+0x7b>
       name[0] == netif->name[0] &&
       name[1] == netif->name[1]) {
  80cde1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80cde5:	48 83 c0 01          	add    $0x1,%rax
  80cde9:	0f b6 10             	movzbl (%rax),%edx
  80cdec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cdf0:	0f b6 40 4c          	movzbl 0x4c(%rax),%eax

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
    if (num == netif->num &&
       name[0] == netif->name[0] &&
  80cdf4:	38 c2                	cmp    %al,%dl
  80cdf6:	75 06                	jne    80cdfe <netif_find+0x7b>
       name[1] == netif->name[1]) {
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
  80cdf8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cdfc:	eb 17                	jmp    80ce15 <netif_find+0x92>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80cdfe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ce02:	48 8b 00             	mov    (%rax),%rax
  80ce05:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ce09:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ce0e:	75 b1                	jne    80cdc1 <netif_find+0x3e>
      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
  80ce10:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ce15:	c9                   	leaveq 
  80ce16:	c3                   	retq   

000000000080ce17 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  80ce17:	55                   	push   %rbp
  80ce18:	48 89 e5             	mov    %rsp,%rbp
  80ce1b:	48 83 ec 30          	sub    $0x30,%rsp
  80ce1f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80ce23:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  80ce27:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80ce2b:	8b 10                	mov    (%rax),%edx
  80ce2d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80ce31:	8b 40 08             	mov    0x8(%rax),%eax
  80ce34:	39 c2                	cmp    %eax,%edx
  80ce36:	0f 84 c4 00 00 00    	je     80cf00 <netif_set_ipaddr+0xe9>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  80ce3c:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80ce43:	00 00 00 
  80ce46:	48 8b 00             	mov    (%rax),%rax
  80ce49:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (pcb != NULL) {
  80ce4d:	eb 46                	jmp    80ce95 <netif_set_ipaddr+0x7e>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  80ce4f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ce53:	8b 10                	mov    (%rax),%edx
  80ce55:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80ce59:	8b 40 08             	mov    0x8(%rax),%eax
  80ce5c:	39 c2                	cmp    %eax,%edx
  80ce5e:	75 29                	jne    80ce89 <netif_set_ipaddr+0x72>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  80ce60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ce64:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ce68:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  80ce6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ce70:	48 89 c7             	mov    %rax,%rdi
  80ce73:	48 b8 11 eb 80 00 00 	movabs $0x80eb11,%rax
  80ce7a:	00 00 00 
  80ce7d:	ff d0                	callq  *%rax
        pcb = next;
  80ce7f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ce83:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ce87:	eb 0c                	jmp    80ce95 <netif_set_ipaddr+0x7e>
      } else {
        pcb = pcb->next;
  80ce89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ce8d:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ce91:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  80ce95:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ce9a:	75 b3                	jne    80ce4f <netif_set_ipaddr+0x38>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80ce9c:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80cea3:	00 00 00 
  80cea6:	48 8b 00             	mov    (%rax),%rax
  80cea9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80cead:	eb 4a                	jmp    80cef9 <netif_set_ipaddr+0xe2>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  80ceaf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80ceb3:	48 85 c0             	test   %rax,%rax
  80ceb6:	74 35                	je     80ceed <netif_set_ipaddr+0xd6>
  80ceb8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cebc:	8b 00                	mov    (%rax),%eax
  80cebe:	85 c0                	test   %eax,%eax
  80cec0:	74 2b                	je     80ceed <netif_set_ipaddr+0xd6>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
  80cec2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cec6:	8b 10                	mov    (%rax),%edx
  80cec8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80cecc:	8b 40 08             	mov    0x8(%rax),%eax
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  80cecf:	39 c2                	cmp    %eax,%edx
  80ced1:	75 1a                	jne    80ceed <netif_set_ipaddr+0xd6>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  80ced3:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80ced8:	74 08                	je     80cee2 <netif_set_ipaddr+0xcb>
  80ceda:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80cede:	8b 00                	mov    (%rax),%eax
  80cee0:	eb 05                	jmp    80cee7 <netif_set_ipaddr+0xd0>
  80cee2:	b8 00 00 00 00       	mov    $0x0,%eax
  80cee7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80ceeb:	89 02                	mov    %eax,(%rdx)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80ceed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cef1:	48 8b 40 10          	mov    0x10(%rax),%rax
  80cef5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80cef9:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80cefe:	75 af                	jne    80ceaf <netif_set_ipaddr+0x98>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  80cf00:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80cf05:	74 08                	je     80cf0f <netif_set_ipaddr+0xf8>
  80cf07:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80cf0b:	8b 00                	mov    (%rax),%eax
  80cf0d:	eb 05                	jmp    80cf14 <netif_set_ipaddr+0xfd>
  80cf0f:	b8 00 00 00 00       	mov    $0x0,%eax
  80cf14:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80cf18:	89 42 08             	mov    %eax,0x8(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  80cf1b:	c9                   	leaveq 
  80cf1c:	c3                   	retq   

000000000080cf1d <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  80cf1d:	55                   	push   %rbp
  80cf1e:	48 89 e5             	mov    %rsp,%rbp
  80cf21:	48 83 ec 10          	sub    $0x10,%rsp
  80cf25:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80cf29:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&(netif->gw), gw);
  80cf2d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80cf32:	74 08                	je     80cf3c <netif_set_gw+0x1f>
  80cf34:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cf38:	8b 00                	mov    (%rax),%eax
  80cf3a:	eb 05                	jmp    80cf41 <netif_set_gw+0x24>
  80cf3c:	b8 00 00 00 00       	mov    $0x0,%eax
  80cf41:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80cf45:	89 42 10             	mov    %eax,0x10(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  80cf48:	c9                   	leaveq 
  80cf49:	c3                   	retq   

000000000080cf4a <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  80cf4a:	55                   	push   %rbp
  80cf4b:	48 89 e5             	mov    %rsp,%rbp
  80cf4e:	48 83 ec 10          	sub    $0x10,%rsp
  80cf52:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80cf56:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  80cf5a:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80cf5f:	74 08                	je     80cf69 <netif_set_netmask+0x1f>
  80cf61:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80cf65:	8b 00                	mov    (%rax),%eax
  80cf67:	eb 05                	jmp    80cf6e <netif_set_netmask+0x24>
  80cf69:	b8 00 00 00 00       	mov    $0x0,%eax
  80cf6e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80cf72:	89 42 0c             	mov    %eax,0xc(%rdx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  80cf75:	c9                   	leaveq 
  80cf76:	c3                   	retq   

000000000080cf77 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  80cf77:	55                   	push   %rbp
  80cf78:	48 89 e5             	mov    %rsp,%rbp
  80cf7b:	48 83 ec 08          	sub    $0x8,%rsp
  80cf7f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  80cf83:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  80cf8a:	00 00 00 
  80cf8d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80cf91:	48 89 10             	mov    %rdx,(%rax)
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  80cf94:	c9                   	leaveq 
  80cf95:	c3                   	retq   

000000000080cf96 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  80cf96:	55                   	push   %rbp
  80cf97:	48 89 e5             	mov    %rsp,%rbp
  80cf9a:	48 83 ec 10          	sub    $0x10,%rsp
  80cf9e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  80cfa2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfa6:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80cfaa:	0f b6 c0             	movzbl %al,%eax
  80cfad:	83 e0 01             	and    $0x1,%eax
  80cfb0:	85 c0                	test   %eax,%eax
  80cfb2:	75 49                	jne    80cffd <netif_set_up+0x67>
    netif->flags |= NETIF_FLAG_UP;
  80cfb4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfb8:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80cfbc:	89 c2                	mov    %eax,%edx
  80cfbe:	83 ca 01             	or     $0x1,%edx
  80cfc1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfc5:	88 50 4a             	mov    %dl,0x4a(%rax)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  80cfc8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfcc:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80cfd0:	0f b6 c0             	movzbl %al,%eax
  80cfd3:	83 e0 20             	and    $0x20,%eax
  80cfd6:	85 c0                	test   %eax,%eax
  80cfd8:	74 23                	je     80cffd <netif_set_up+0x67>
      etharp_query(netif, &(netif->ip_addr), NULL);
  80cfda:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfde:	48 8d 48 08          	lea    0x8(%rax),%rcx
  80cfe2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80cfe6:	ba 00 00 00 00       	mov    $0x0,%edx
  80cfeb:	48 89 ce             	mov    %rcx,%rsi
  80cfee:	48 89 c7             	mov    %rax,%rdi
  80cff1:	48 b8 7b 68 81 00 00 	movabs $0x81687b,%rax
  80cff8:	00 00 00 
  80cffb:	ff d0                	callq  *%rax
    }
#endif /* LWIP_ARP */
    
  }
}
  80cffd:	c9                   	leaveq 
  80cffe:	c3                   	retq   

000000000080cfff <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  80cfff:	55                   	push   %rbp
  80d000:	48 89 e5             	mov    %rsp,%rbp
  80d003:	48 83 ec 08          	sub    $0x8,%rsp
  80d007:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if ( netif->flags & NETIF_FLAG_UP )
  80d00b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d00f:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d013:	0f b6 c0             	movzbl %al,%eax
  80d016:	83 e0 01             	and    $0x1,%eax
  80d019:	84 c0                	test   %al,%al
  80d01b:	74 14                	je     80d031 <netif_set_down+0x32>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  80d01d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d021:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d025:	89 c2                	mov    %eax,%edx
  80d027:	83 e2 fe             	and    $0xfffffffe,%edx
  80d02a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d02e:	88 50 4a             	mov    %dl,0x4a(%rax)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  80d031:	c9                   	leaveq 
  80d032:	c3                   	retq   

000000000080d033 <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  80d033:	55                   	push   %rbp
  80d034:	48 89 e5             	mov    %rsp,%rbp
  80d037:	48 83 ec 08          	sub    $0x8,%rsp
  80d03b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  80d03f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d043:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  80d047:	83 e0 01             	and    $0x1,%eax
}
  80d04a:	c9                   	leaveq 
  80d04b:	c3                   	retq   

000000000080d04c <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  80d04c:	55                   	push   %rbp
  80d04d:	48 89 e5             	mov    %rsp,%rbp
  80d050:	48 83 ec 30          	sub    $0x30,%rsp
  80d054:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80d057:	89 f0                	mov    %esi,%eax
  80d059:	89 55 d4             	mov    %edx,-0x2c(%rbp)
  80d05c:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  80d060:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  switch (layer) {
  80d066:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80d069:	83 f8 01             	cmp    $0x1,%eax
  80d06c:	74 16                	je     80d084 <pbuf_alloc+0x38>
  80d06e:	83 f8 01             	cmp    $0x1,%eax
  80d071:	72 0c                	jb     80d07f <pbuf_alloc+0x33>
  80d073:	83 f8 02             	cmp    $0x2,%eax
  80d076:	74 11                	je     80d089 <pbuf_alloc+0x3d>
  80d078:	83 f8 03             	cmp    $0x3,%eax
  80d07b:	74 3d                	je     80d0ba <pbuf_alloc+0x6e>
  80d07d:	eb 11                	jmp    80d090 <pbuf_alloc+0x44>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
  80d07f:	66 83 45 ee 14       	addw   $0x14,-0x12(%rbp)
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  80d084:	66 83 45 ee 14       	addw   $0x14,-0x12(%rbp)
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  80d089:	66 83 45 ee 0e       	addw   $0xe,-0x12(%rbp)
    break;
  80d08e:	eb 2b                	jmp    80d0bb <pbuf_alloc+0x6f>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  80d090:	48 ba f0 1c 82 00 00 	movabs $0x821cf0,%rdx
  80d097:	00 00 00 
  80d09a:	be 8a 00 00 00       	mov    $0x8a,%esi
  80d09f:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80d0a6:	00 00 00 
  80d0a9:	b8 00 00 00 00       	mov    $0x0,%eax
  80d0ae:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80d0b5:	00 00 00 
  80d0b8:	ff d1                	callq  *%rcx
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
    break;
  case PBUF_RAW:
    break;
  80d0ba:	90                   	nop
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
  80d0bb:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d0be:	83 f8 02             	cmp    $0x2,%eax
  80d0c1:	77 0e                	ja     80d0d1 <pbuf_alloc+0x85>
  80d0c3:	83 f8 01             	cmp    $0x1,%eax
  80d0c6:	0f 83 a9 03 00 00    	jae    80d475 <pbuf_alloc+0x429>
  80d0cc:	e9 d9 02 00 00       	jmpq   80d3aa <pbuf_alloc+0x35e>
  80d0d1:	83 f8 03             	cmp    $0x3,%eax
  80d0d4:	0f 85 02 04 00 00    	jne    80d4dc <pbuf_alloc+0x490>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  80d0da:	bf 0d 00 00 00       	mov    $0xd,%edi
  80d0df:	48 b8 41 ca 80 00 00 	movabs $0x80ca41,%rax
  80d0e6:	00 00 00 
  80d0e9:	ff d0                	callq  *%rax
  80d0eb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  80d0ef:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d0f4:	75 0a                	jne    80d100 <pbuf_alloc+0xb4>
      return NULL;
  80d0f6:	b8 00 00 00 00       	mov    $0x0,%eax
  80d0fb:	e9 1d 04 00 00       	jmpq   80d51d <pbuf_alloc+0x4d1>
    }
    p->type = type;
  80d100:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d103:	89 c2                	mov    %eax,%edx
  80d105:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d109:	88 50 14             	mov    %dl,0x14(%rax)
    p->next = NULL;
  80d10c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d110:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  80d117:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d11b:	48 83 c0 18          	add    $0x18,%rax
  80d11f:	48 03 45 f8          	add    -0x8(%rbp),%rax
  80d123:	48 83 c0 03          	add    $0x3,%rax
  80d127:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80d12b:	48 89 c2             	mov    %rax,%rdx
  80d12e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d132:	48 89 50 08          	mov    %rdx,0x8(%rax)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
  80d136:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d13a:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d13e:	83 e0 03             	and    $0x3,%eax
  80d141:	48 85 c0             	test   %rax,%rax
  80d144:	74 2a                	je     80d170 <pbuf_alloc+0x124>
  80d146:	48 ba 20 1d 82 00 00 	movabs $0x821d20,%rdx
  80d14d:	00 00 00 
  80d150:	be 9c 00 00 00       	mov    $0x9c,%esi
  80d155:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80d15c:	00 00 00 
  80d15f:	b8 00 00 00 00       	mov    $0x0,%eax
  80d164:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80d16b:	00 00 00 
  80d16e:	ff d1                	callq  *%rcx
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  80d170:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d174:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d178:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  80d17c:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d180:	83 c0 03             	add    $0x3,%eax
  80d183:	89 c2                	mov    %eax,%edx
  80d185:	83 e2 fc             	and    $0xfffffffc,%edx
  80d188:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  80d18d:	89 c1                	mov    %eax,%ecx
  80d18f:	29 d1                	sub    %edx,%ecx
  80d191:	89 ca                	mov    %ecx,%edx
  80d193:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  80d197:	39 c2                	cmp    %eax,%edx
  80d199:	0f 4e c2             	cmovle %edx,%eax
  80d19c:	89 c2                	mov    %eax,%edx
  80d19e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d1a2:	66 89 50 12          	mov    %dx,0x12(%rax)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  80d1a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d1aa:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80d1ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d1b2:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d1b6:	0f b7 c0             	movzwl %ax,%eax
  80d1b9:	48 01 c2             	add    %rax,%rdx
  80d1bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d1c0:	48 05 e8 07 00 00    	add    $0x7e8,%rax
  80d1c6:	48 39 c2             	cmp    %rax,%rdx
  80d1c9:	76 2a                	jbe    80d1f5 <pbuf_alloc+0x1a9>
  80d1cb:	48 ba 50 1d 82 00 00 	movabs $0x821d50,%rdx
  80d1d2:	00 00 00 
  80d1d5:	be a3 00 00 00       	mov    $0xa3,%esi
  80d1da:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80d1e1:	00 00 00 
  80d1e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80d1e9:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80d1f0:	00 00 00 
  80d1f3:	ff d1                	callq  *%rcx
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  80d1f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d1f9:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
  80d1ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d203:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* remaining length to be allocated */
    rem_len = length - p->len;
  80d207:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d20b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d20f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d213:	0f b7 c0             	movzwl %ax,%eax
  80d216:	89 d1                	mov    %edx,%ecx
  80d218:	29 c1                	sub    %eax,%ecx
  80d21a:	89 c8                	mov    %ecx,%eax
  80d21c:	89 45 e8             	mov    %eax,-0x18(%rbp)
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  80d21f:	e9 77 01 00 00       	jmpq   80d39b <pbuf_alloc+0x34f>
      q = memp_malloc(MEMP_PBUF_POOL);
  80d224:	bf 0d 00 00 00       	mov    $0xd,%edi
  80d229:	48 b8 41 ca 80 00 00 	movabs $0x80ca41,%rax
  80d230:	00 00 00 
  80d233:	ff d0                	callq  *%rax
  80d235:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      if (q == NULL) {
  80d239:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80d23e:	75 1d                	jne    80d25d <pbuf_alloc+0x211>
        /* free chain so far allocated */
        pbuf_free(p);
  80d240:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d244:	48 89 c7             	mov    %rax,%rdi
  80d247:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  80d24e:	00 00 00 
  80d251:	ff d0                	callq  *%rax
        /* bail out unsuccesfully */
        return NULL;
  80d253:	b8 00 00 00 00       	mov    $0x0,%eax
  80d258:	e9 c0 02 00 00       	jmpq   80d51d <pbuf_alloc+0x4d1>
      }
      q->type = type;
  80d25d:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d260:	89 c2                	mov    %eax,%edx
  80d262:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d266:	88 50 14             	mov    %dl,0x14(%rax)
      q->flags = 0;
  80d269:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d26d:	c6 40 15 00          	movb   $0x0,0x15(%rax)
      q->next = NULL;
  80d271:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d275:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  80d27c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80d280:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80d284:	48 89 10             	mov    %rdx,(%rax)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  80d287:	81 7d e8 fe ff 00 00 	cmpl   $0xfffe,-0x18(%rbp)
  80d28e:	7e 2a                	jle    80d2ba <pbuf_alloc+0x26e>
  80d290:	48 ba 81 1d 82 00 00 	movabs $0x821d81,%rdx
  80d297:	00 00 00 
  80d29a:	be bc 00 00 00       	mov    $0xbc,%esi
  80d29f:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80d2a6:	00 00 00 
  80d2a9:	b8 00 00 00 00       	mov    $0x0,%eax
  80d2ae:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80d2b5:	00 00 00 
  80d2b8:	ff d1                	callq  *%rcx
      q->tot_len = (u16_t)rem_len;
  80d2ba:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80d2bd:	89 c2                	mov    %eax,%edx
  80d2bf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d2c3:	66 89 50 10          	mov    %dx,0x10(%rax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  80d2c7:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80d2ca:	66 3d cf 07          	cmp    $0x7cf,%ax
  80d2ce:	77 05                	ja     80d2d5 <pbuf_alloc+0x289>
  80d2d0:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80d2d3:	eb 05                	jmp    80d2da <pbuf_alloc+0x28e>
  80d2d5:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  80d2da:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80d2de:	66 89 42 12          	mov    %ax,0x12(%rdx)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  80d2e2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d2e6:	48 8d 50 18          	lea    0x18(%rax),%rdx
  80d2ea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d2ee:	48 89 50 08          	mov    %rdx,0x8(%rax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  80d2f2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d2f6:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d2fa:	83 e0 03             	and    $0x3,%eax
  80d2fd:	48 85 c0             	test   %rax,%rax
  80d300:	74 2a                	je     80d32c <pbuf_alloc+0x2e0>
  80d302:	48 ba 98 1d 82 00 00 	movabs $0x821d98,%rdx
  80d309:	00 00 00 
  80d30c:	be c2 00 00 00       	mov    $0xc2,%esi
  80d311:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80d318:	00 00 00 
  80d31b:	b8 00 00 00 00       	mov    $0x0,%eax
  80d320:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80d327:	00 00 00 
  80d32a:	ff d1                	callq  *%rcx
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  80d32c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d330:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80d334:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d338:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d33c:	0f b7 c0             	movzwl %ax,%eax
  80d33f:	48 01 c2             	add    %rax,%rdx
  80d342:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d346:	48 05 e8 07 00 00    	add    $0x7e8,%rax
  80d34c:	48 39 c2             	cmp    %rax,%rdx
  80d34f:	76 2a                	jbe    80d37b <pbuf_alloc+0x32f>
  80d351:	48 ba 50 1d 82 00 00 	movabs $0x821d50,%rdx
  80d358:	00 00 00 
  80d35b:	be c5 00 00 00       	mov    $0xc5,%esi
  80d360:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80d367:	00 00 00 
  80d36a:	b8 00 00 00 00       	mov    $0x0,%eax
  80d36f:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80d376:	00 00 00 
  80d379:	ff d1                	callq  *%rcx
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  80d37b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d37f:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  80d385:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d389:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d38d:	0f b7 c0             	movzwl %ax,%eax
  80d390:	29 45 e8             	sub    %eax,-0x18(%rbp)
      /* remember this pbuf for linkage in next iteration */
      r = q;
  80d393:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80d397:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  80d39b:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80d39f:	0f 8f 7f fe ff ff    	jg     80d224 <pbuf_alloc+0x1d8>
      r = q;
    }
    /* end of chain */
    /*r->next = NULL;*/

    break;
  80d3a5:	e9 5d 01 00 00       	jmpq   80d507 <pbuf_alloc+0x4bb>
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  80d3aa:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d3ae:	83 c0 1b             	add    $0x1b,%eax
  80d3b1:	89 c2                	mov    %eax,%edx
  80d3b3:	83 e2 fc             	and    $0xfffffffc,%edx
  80d3b6:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  80d3ba:	83 c0 03             	add    $0x3,%eax
  80d3bd:	83 e0 fc             	and    $0xfffffffc,%eax
  80d3c0:	01 d0                	add    %edx,%eax
  80d3c2:	89 c7                	mov    %eax,%edi
  80d3c4:	48 b8 79 c5 80 00 00 	movabs $0x80c579,%rax
  80d3cb:	00 00 00 
  80d3ce:	ff d0                	callq  *%rax
  80d3d0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (p == NULL) {
  80d3d4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d3d9:	75 0a                	jne    80d3e5 <pbuf_alloc+0x399>
      return NULL;
  80d3db:	b8 00 00 00 00       	mov    $0x0,%eax
  80d3e0:	e9 38 01 00 00       	jmpq   80d51d <pbuf_alloc+0x4d1>
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  80d3e5:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80d3e9:	48 83 c0 18          	add    $0x18,%rax
  80d3ed:	48 03 45 f8          	add    -0x8(%rbp),%rax
  80d3f1:	48 83 c0 03          	add    $0x3,%rax
  80d3f5:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  80d3f9:	48 89 c2             	mov    %rax,%rdx
  80d3fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d400:	48 89 50 08          	mov    %rdx,0x8(%rax)
    p->len = p->tot_len = length;
  80d404:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d408:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d40c:	66 89 50 10          	mov    %dx,0x10(%rax)
  80d410:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d414:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d418:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d41c:	66 89 50 12          	mov    %dx,0x12(%rax)
    p->next = NULL;
  80d420:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d424:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    p->type = type;
  80d42b:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d42e:	89 c2                	mov    %eax,%edx
  80d430:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d434:	88 50 14             	mov    %dl,0x14(%rax)

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
  80d437:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d43b:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d43f:	83 e0 03             	and    $0x3,%eax
  80d442:	48 85 c0             	test   %rax,%rax
  80d445:	0f 84 bb 00 00 00    	je     80d506 <pbuf_alloc+0x4ba>
  80d44b:	48 ba c8 1d 82 00 00 	movabs $0x821dc8,%rdx
  80d452:	00 00 00 
  80d455:	be dd 00 00 00       	mov    $0xdd,%esi
  80d45a:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80d461:	00 00 00 
  80d464:	b8 00 00 00 00       	mov    $0x0,%eax
  80d469:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80d470:	00 00 00 
  80d473:	ff d1                	callq  *%rcx
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  80d475:	bf 0c 00 00 00       	mov    $0xc,%edi
  80d47a:	48 b8 41 ca 80 00 00 	movabs $0x80ca41,%rax
  80d481:	00 00 00 
  80d484:	ff d0                	callq  *%rax
  80d486:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (p == NULL) {
  80d48a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d48f:	75 0a                	jne    80d49b <pbuf_alloc+0x44f>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
  80d491:	b8 00 00 00 00       	mov    $0x0,%eax
  80d496:	e9 82 00 00 00       	jmpq   80d51d <pbuf_alloc+0x4d1>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  80d49b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d49f:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80d4a6:	00 
    p->len = p->tot_len = length;
  80d4a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d4ab:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  80d4af:	66 89 50 10          	mov    %dx,0x10(%rax)
  80d4b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d4b7:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d4bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d4bf:	66 89 50 12          	mov    %dx,0x12(%rax)
    p->next = NULL;
  80d4c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d4c7:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    p->type = type;
  80d4ce:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  80d4d1:	89 c2                	mov    %eax,%edx
  80d4d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d4d7:	88 50 14             	mov    %dl,0x14(%rax)
    break;
  80d4da:	eb 2b                	jmp    80d507 <pbuf_alloc+0x4bb>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  80d4dc:	48 ba f3 1d 82 00 00 	movabs $0x821df3,%rdx
  80d4e3:	00 00 00 
  80d4e6:	be f1 00 00 00       	mov    $0xf1,%esi
  80d4eb:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80d4f2:	00 00 00 
  80d4f5:	b8 00 00 00 00       	mov    $0x0,%eax
  80d4fa:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80d501:	00 00 00 
  80d504:	ff d1                	callq  *%rcx
    p->next = NULL;
    p->type = type;

    LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
           ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    break;
  80d506:	90                   	nop
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  80d507:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d50b:	66 c7 40 16 01 00    	movw   $0x1,0x16(%rax)
  /* set flags */
  p->flags = 0;
  80d511:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d515:	c6 40 15 00          	movb   $0x0,0x15(%rax)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
  80d519:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80d51d:	c9                   	leaveq 
  80d51e:	c3                   	retq   

000000000080d51f <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  80d51f:	55                   	push   %rbp
  80d520:	48 89 e5             	mov    %rsp,%rbp
  80d523:	48 83 ec 20          	sub    $0x20,%rsp
  80d527:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80d52b:	89 f0                	mov    %esi,%eax
  80d52d:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  80d531:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d536:	75 2a                	jne    80d562 <pbuf_realloc+0x43>
  80d538:	48 ba 0e 1e 82 00 00 	movabs $0x821e0e,%rdx
  80d53f:	00 00 00 
  80d542:	be 13 01 00 00       	mov    $0x113,%esi
  80d547:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80d54e:	00 00 00 
  80d551:	b8 00 00 00 00       	mov    $0x0,%eax
  80d556:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80d55d:	00 00 00 
  80d560:	ff d1                	callq  *%rcx
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  80d562:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d566:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d56a:	3c 03                	cmp    $0x3,%al
  80d56c:	74 4e                	je     80d5bc <pbuf_realloc+0x9d>
  80d56e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d572:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d576:	3c 01                	cmp    $0x1,%al
  80d578:	74 42                	je     80d5bc <pbuf_realloc+0x9d>
  80d57a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d57e:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d582:	84 c0                	test   %al,%al
  80d584:	74 36                	je     80d5bc <pbuf_realloc+0x9d>
  80d586:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d58a:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d58e:	3c 02                	cmp    $0x2,%al
  80d590:	74 2a                	je     80d5bc <pbuf_realloc+0x9d>
  80d592:	48 ba 26 1e 82 00 00 	movabs $0x821e26,%rdx
  80d599:	00 00 00 
  80d59c:	be 17 01 00 00       	mov    $0x117,%esi
  80d5a1:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80d5a8:	00 00 00 
  80d5ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80d5b0:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80d5b7:	00 00 00 
  80d5ba:	ff d1                	callq  *%rcx
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  80d5bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d5c0:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80d5c4:	66 3b 45 e4          	cmp    -0x1c(%rbp),%ax
  80d5c8:	0f 86 9e 01 00 00    	jbe    80d76c <pbuf_realloc+0x24d>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  80d5ce:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  80d5d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d5d6:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80d5da:	0f b7 c0             	movzwl %ax,%eax
  80d5dd:	89 d1                	mov    %edx,%ecx
  80d5df:	29 c1                	sub    %eax,%ecx
  80d5e1:	89 c8                	mov    %ecx,%eax
  80d5e3:	89 45 f0             	mov    %eax,-0x10(%rbp)

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  80d5e6:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80d5ea:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  q = p;
  80d5ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d5f2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  80d5f6:	e9 90 00 00 00       	jmpq   80d68b <pbuf_realloc+0x16c>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  80d5fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d5ff:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d603:	66 29 45 f6          	sub    %ax,-0xa(%rbp)
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  80d607:	81 7d f0 fe ff 00 00 	cmpl   $0xfffe,-0x10(%rbp)
  80d60e:	7e 2a                	jle    80d63a <pbuf_realloc+0x11b>
  80d610:	48 ba 41 1e 82 00 00 	movabs $0x821e41,%rdx
  80d617:	00 00 00 
  80d61a:	be 2b 01 00 00       	mov    $0x12b,%esi
  80d61f:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80d626:	00 00 00 
  80d629:	b8 00 00 00 00       	mov    $0x0,%eax
  80d62e:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80d635:	00 00 00 
  80d638:	ff d1                	callq  *%rcx
    q->tot_len += (u16_t)grow;
  80d63a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d63e:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d642:	8b 45 f0             	mov    -0x10(%rbp),%eax
  80d645:	01 c2                	add    %eax,%edx
  80d647:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d64b:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* proceed to next pbuf in chain */
    q = q->next;
  80d64f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d653:	48 8b 00             	mov    (%rax),%rax
  80d656:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  80d65a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d65f:	75 2a                	jne    80d68b <pbuf_realloc+0x16c>
  80d661:	48 ba 52 1e 82 00 00 	movabs $0x821e52,%rdx
  80d668:	00 00 00 
  80d66b:	be 2f 01 00 00       	mov    $0x12f,%esi
  80d670:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80d677:	00 00 00 
  80d67a:	b8 00 00 00 00       	mov    $0x0,%eax
  80d67f:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80d686:	00 00 00 
  80d689:	ff d1                	callq  *%rcx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  80d68b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d68f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d693:	66 3b 45 f6          	cmp    -0xa(%rbp),%ax
  80d697:	0f 82 5e ff ff ff    	jb     80d5fb <pbuf_realloc+0xdc>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  80d69d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d6a1:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d6a5:	84 c0                	test   %al,%al
  80d6a7:	75 78                	jne    80d721 <pbuf_realloc+0x202>
  80d6a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d6ad:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d6b1:	66 3b 45 f6          	cmp    -0xa(%rbp),%ax
  80d6b5:	74 6a                	je     80d721 <pbuf_realloc+0x202>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  80d6b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d6bb:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d6bf:	48 89 c2             	mov    %rax,%rdx
  80d6c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d6c6:	48 89 d1             	mov    %rdx,%rcx
  80d6c9:	48 29 c1             	sub    %rax,%rcx
  80d6cc:	48 89 c8             	mov    %rcx,%rax
  80d6cf:	89 c2                	mov    %eax,%edx
  80d6d1:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  80d6d5:	01 c2                	add    %eax,%edx
  80d6d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d6db:	89 d6                	mov    %edx,%esi
  80d6dd:	48 89 c7             	mov    %rax,%rdi
  80d6e0:	48 b8 60 c2 80 00 00 	movabs $0x80c260,%rax
  80d6e7:	00 00 00 
  80d6ea:	ff d0                	callq  *%rax
  80d6ec:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  80d6f0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80d6f5:	75 2a                	jne    80d721 <pbuf_realloc+0x202>
  80d6f7:	48 ba 6a 1e 82 00 00 	movabs $0x821e6a,%rdx
  80d6fe:	00 00 00 
  80d701:	be 39 01 00 00       	mov    $0x139,%esi
  80d706:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80d70d:	00 00 00 
  80d710:	b8 00 00 00 00       	mov    $0x0,%eax
  80d715:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80d71c:	00 00 00 
  80d71f:	ff d1                	callq  *%rcx
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  80d721:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d725:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  80d729:	66 89 50 12          	mov    %dx,0x12(%rax)
  q->tot_len = q->len;
  80d72d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d731:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80d735:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d739:	66 89 50 10          	mov    %dx,0x10(%rax)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  80d73d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d741:	48 8b 00             	mov    (%rax),%rax
  80d744:	48 85 c0             	test   %rax,%rax
  80d747:	74 16                	je     80d75f <pbuf_realloc+0x240>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  80d749:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d74d:	48 8b 00             	mov    (%rax),%rax
  80d750:	48 89 c7             	mov    %rax,%rdi
  80d753:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  80d75a:	00 00 00 
  80d75d:	ff d0                	callq  *%rax
  }
  /* q is last packet in chain */
  q->next = NULL;
  80d75f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80d763:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  80d76a:	eb 01                	jmp    80d76d <pbuf_realloc+0x24e>
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
    /* enlarging not yet supported */
    return;
  80d76c:	90                   	nop
    pbuf_free(q->next);
  }
  /* q is last packet in chain */
  q->next = NULL;

}
  80d76d:	c9                   	leaveq 
  80d76e:	c3                   	retq   

000000000080d76f <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  80d76f:	55                   	push   %rbp
  80d770:	48 89 e5             	mov    %rsp,%rbp
  80d773:	48 83 ec 20          	sub    $0x20,%rsp
  80d777:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80d77b:	89 f0                	mov    %esi,%eax
  80d77d:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  80d781:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d786:	75 2a                	jne    80d7b2 <pbuf_header+0x43>
  80d788:	48 ba 85 1e 82 00 00 	movabs $0x821e85,%rdx
  80d78f:	00 00 00 
  80d792:	be 64 01 00 00       	mov    $0x164,%esi
  80d797:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80d79e:	00 00 00 
  80d7a1:	b8 00 00 00 00       	mov    $0x0,%eax
  80d7a6:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80d7ad:	00 00 00 
  80d7b0:	ff d1                	callq  *%rcx
  if ((header_size_increment == 0) || (p == NULL))
  80d7b2:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80d7b7:	74 07                	je     80d7c0 <pbuf_header+0x51>
  80d7b9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80d7be:	75 0a                	jne    80d7ca <pbuf_header+0x5b>
    return 0;
  80d7c0:	b8 00 00 00 00       	mov    $0x0,%eax
  80d7c5:	e9 66 01 00 00       	jmpq   80d930 <pbuf_header+0x1c1>
 
  if (header_size_increment < 0){
  80d7ca:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80d7cf:	79 42                	jns    80d813 <pbuf_header+0xa4>
    increment_magnitude = -header_size_increment;
  80d7d1:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80d7d5:	f7 d8                	neg    %eax
  80d7d7:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  80d7db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d7df:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d7e3:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80d7e7:	73 32                	jae    80d81b <pbuf_header+0xac>
  80d7e9:	48 ba 8f 1e 82 00 00 	movabs $0x821e8f,%rdx
  80d7f0:	00 00 00 
  80d7f3:	be 6b 01 00 00       	mov    $0x16b,%esi
  80d7f8:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80d7ff:	00 00 00 
  80d802:	b8 00 00 00 00       	mov    $0x0,%eax
  80d807:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80d80e:	00 00 00 
  80d811:	ff d1                	callq  *%rcx
  } else {
    increment_magnitude = header_size_increment;
  80d813:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80d817:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  80d81b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d81f:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d823:	0f b6 c0             	movzbl %al,%eax
  80d826:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  /* remember current payload pointer */
  payload = p->payload;
  80d82a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d82e:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d832:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  80d836:	66 83 7d fc 00       	cmpw   $0x0,-0x4(%rbp)
  80d83b:	74 07                	je     80d844 <pbuf_header+0xd5>
  80d83d:	66 83 7d fc 03       	cmpw   $0x3,-0x4(%rbp)
  80d842:	75 4a                	jne    80d88e <pbuf_header+0x11f>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  80d844:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d848:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d84c:	48 0f bf 55 e4       	movswq -0x1c(%rbp),%rdx
  80d851:	48 f7 da             	neg    %rdx
  80d854:	48 01 c2             	add    %rax,%rdx
  80d857:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d85b:	48 89 50 08          	mov    %rdx,0x8(%rax)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  80d85f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d863:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d867:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80d86b:	48 83 c2 18          	add    $0x18,%rdx
  80d86f:	48 39 d0             	cmp    %rdx,%rax
  80d872:	0f 83 87 00 00 00    	jae    80d8ff <pbuf_header+0x190>
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
  80d878:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d87c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80d880:	48 89 50 08          	mov    %rdx,0x8(%rax)
      /* bail out unsuccesfully */
      return 1;
  80d884:	b8 01 00 00 00       	mov    $0x1,%eax
  80d889:	e9 a2 00 00 00       	jmpq   80d930 <pbuf_header+0x1c1>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  80d88e:	66 83 7d fc 02       	cmpw   $0x2,-0x4(%rbp)
  80d893:	74 07                	je     80d89c <pbuf_header+0x12d>
  80d895:	66 83 7d fc 01       	cmpw   $0x1,-0x4(%rbp)
  80d89a:	75 39                	jne    80d8d5 <pbuf_header+0x166>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  80d89c:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%rbp)
  80d8a1:	79 2b                	jns    80d8ce <pbuf_header+0x15f>
  80d8a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d8a7:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80d8ab:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  80d8af:	72 1d                	jb     80d8ce <pbuf_header+0x15f>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  80d8b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d8b5:	48 8b 40 08          	mov    0x8(%rax),%rax
  80d8b9:	48 0f bf 55 e4       	movswq -0x1c(%rbp),%rdx
  80d8be:	48 f7 da             	neg    %rdx
  80d8c1:	48 01 c2             	add    %rax,%rdx
  80d8c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d8c8:	48 89 50 08          	mov    %rdx,0x8(%rax)
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  80d8cc:	eb 31                	jmp    80d8ff <pbuf_header+0x190>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  80d8ce:	b8 01 00 00 00       	mov    $0x1,%eax
  80d8d3:	eb 5b                	jmp    80d930 <pbuf_header+0x1c1>
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  80d8d5:	48 ba ad 1e 82 00 00 	movabs $0x821ead,%rdx
  80d8dc:	00 00 00 
  80d8df:	be 9a 01 00 00       	mov    $0x19a,%esi
  80d8e4:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80d8eb:	00 00 00 
  80d8ee:	b8 00 00 00 00       	mov    $0x0,%eax
  80d8f3:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80d8fa:	00 00 00 
  80d8fd:	ff d1                	callq  *%rcx
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  80d8ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d903:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80d907:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80d90b:	01 c2                	add    %eax,%edx
  80d90d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d911:	66 89 50 12          	mov    %dx,0x12(%rax)
  p->tot_len += header_size_increment;
  80d915:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d919:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80d91d:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80d921:	01 c2                	add    %eax,%edx
  80d923:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80d927:	66 89 50 10          	mov    %dx,0x10(%rax)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  80d92b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80d930:	c9                   	leaveq 
  80d931:	c3                   	retq   

000000000080d932 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  80d932:	55                   	push   %rbp
  80d933:	48 89 e5             	mov    %rsp,%rbp
  80d936:	48 83 ec 30          	sub    $0x30,%rsp
  80d93a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  80d93e:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80d943:	75 3b                	jne    80d980 <pbuf_free+0x4e>
    LWIP_ASSERT("p != NULL", p != NULL);
  80d945:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80d94a:	75 2a                	jne    80d976 <pbuf_free+0x44>
  80d94c:	48 ba 85 1e 82 00 00 	movabs $0x821e85,%rdx
  80d953:	00 00 00 
  80d956:	be d0 01 00 00       	mov    $0x1d0,%esi
  80d95b:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80d962:	00 00 00 
  80d965:	b8 00 00 00 00       	mov    $0x0,%eax
  80d96a:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80d971:	00 00 00 
  80d974:	ff d1                	callq  *%rcx
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_free(p == NULL) was called.\n"));
    return 0;
  80d976:	b8 00 00 00 00       	mov    $0x0,%eax
  80d97b:	e9 5f 01 00 00       	jmpq   80dadf <pbuf_free+0x1ad>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  80d980:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d984:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d988:	84 c0                	test   %al,%al
  80d98a:	74 4e                	je     80d9da <pbuf_free+0xa8>
  80d98c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d990:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d994:	3c 01                	cmp    $0x1,%al
  80d996:	74 42                	je     80d9da <pbuf_free+0xa8>
  80d998:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d99c:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d9a0:	3c 02                	cmp    $0x2,%al
  80d9a2:	74 36                	je     80d9da <pbuf_free+0xa8>
  80d9a4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d9a8:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80d9ac:	3c 03                	cmp    $0x3,%al
  80d9ae:	74 2a                	je     80d9da <pbuf_free+0xa8>
  80d9b0:	48 ba bb 1e 82 00 00 	movabs $0x821ebb,%rdx
  80d9b7:	00 00 00 
  80d9ba:	be db 01 00 00       	mov    $0x1db,%esi
  80d9bf:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80d9c6:	00 00 00 
  80d9c9:	b8 00 00 00 00       	mov    $0x0,%eax
  80d9ce:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80d9d5:	00 00 00 
  80d9d8:	ff d1                	callq  *%rcx
    p->type == PBUF_RAM || p->type == PBUF_ROM ||
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  80d9da:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  80d9de:	e9 ed 00 00 00       	jmpq   80dad0 <pbuf_free+0x19e>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  80d9e3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80d9e7:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80d9eb:	66 85 c0             	test   %ax,%ax
  80d9ee:	75 2a                	jne    80da1a <pbuf_free+0xe8>
  80d9f0:	48 ba d0 1e 82 00 00 	movabs $0x821ed0,%rdx
  80d9f7:	00 00 00 
  80d9fa:	be e8 01 00 00       	mov    $0x1e8,%esi
  80d9ff:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80da06:	00 00 00 
  80da09:	b8 00 00 00 00       	mov    $0x0,%eax
  80da0e:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80da15:	00 00 00 
  80da18:	ff d1                	callq  *%rcx
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  80da1a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80da1e:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80da22:	8d 50 ff             	lea    -0x1(%rax),%edx
  80da25:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80da29:	66 89 50 16          	mov    %dx,0x16(%rax)
  80da2d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80da31:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80da35:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  80da39:	66 83 7d fc 00       	cmpw   $0x0,-0x4(%rbp)
  80da3e:	0f 85 84 00 00 00    	jne    80dac8 <pbuf_free+0x196>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  80da44:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80da48:	48 8b 00             	mov    (%rax),%rax
  80da4b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  80da4f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80da53:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  80da57:	0f b6 c0             	movzbl %al,%eax
  80da5a:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  80da5e:	66 83 7d ee 03       	cmpw   $0x3,-0x12(%rbp)
  80da63:	75 1a                	jne    80da7f <pbuf_free+0x14d>
        memp_free(MEMP_PBUF_POOL, p);
  80da65:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80da69:	48 89 c6             	mov    %rax,%rsi
  80da6c:	bf 0d 00 00 00       	mov    $0xd,%edi
  80da71:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  80da78:	00 00 00 
  80da7b:	ff d0                	callq  *%rax
  80da7d:	eb 3b                	jmp    80daba <pbuf_free+0x188>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  80da7f:	66 83 7d ee 01       	cmpw   $0x1,-0x12(%rbp)
  80da84:	74 07                	je     80da8d <pbuf_free+0x15b>
  80da86:	66 83 7d ee 02       	cmpw   $0x2,-0x12(%rbp)
  80da8b:	75 1a                	jne    80daa7 <pbuf_free+0x175>
        memp_free(MEMP_PBUF, p);
  80da8d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80da91:	48 89 c6             	mov    %rax,%rsi
  80da94:	bf 0c 00 00 00       	mov    $0xc,%edi
  80da99:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  80daa0:	00 00 00 
  80daa3:	ff d0                	callq  *%rax
  80daa5:	eb 13                	jmp    80daba <pbuf_free+0x188>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  80daa7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80daab:	48 89 c7             	mov    %rax,%rdi
  80daae:	48 b8 d3 c0 80 00 00 	movabs $0x80c0d3,%rax
  80dab5:	00 00 00 
  80dab8:	ff d0                	callq  *%rax
      }
      count++;
  80daba:	80 45 ff 01          	addb   $0x1,-0x1(%rbp)
      /* proceed to next pbuf */
      p = q;
  80dabe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dac2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80dac6:	eb 08                	jmp    80dad0 <pbuf_free+0x19e>
    /* p->ref > 0, this pbuf is still referenced to */
    /* (and so the remaining pbufs in chain as well) */
    } else {
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
      /* stop walking through the chain */
      p = NULL;
  80dac8:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  80dacf:	00 
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  80dad0:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80dad5:	0f 85 08 ff ff ff    	jne    80d9e3 <pbuf_free+0xb1>
      p = NULL;
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
  80dadb:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80dadf:	c9                   	leaveq 
  80dae0:	c3                   	retq   

000000000080dae1 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  80dae1:	55                   	push   %rbp
  80dae2:	48 89 e5             	mov    %rsp,%rbp
  80dae5:	48 83 ec 18          	sub    $0x18,%rsp
  80dae9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t len;

  len = 0;
  80daed:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  while (p != NULL) {
  80daf1:	eb 0f                	jmp    80db02 <pbuf_clen+0x21>
    ++len;
  80daf3:	80 45 ff 01          	addb   $0x1,-0x1(%rbp)
    p = p->next;
  80daf7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80dafb:	48 8b 00             	mov    (%rax),%rax
  80dafe:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  80db02:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80db07:	75 ea                	jne    80daf3 <pbuf_clen+0x12>
    ++len;
    p = p->next;
  }
  return len;
  80db09:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80db0d:	c9                   	leaveq 
  80db0e:	c3                   	retq   

000000000080db0f <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  80db0f:	55                   	push   %rbp
  80db10:	48 89 e5             	mov    %rsp,%rbp
  80db13:	48 83 ec 08          	sub    $0x8,%rsp
  80db17:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  80db1b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80db20:	74 13                	je     80db35 <pbuf_ref+0x26>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  80db22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80db26:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  80db2a:	8d 50 01             	lea    0x1(%rax),%edx
  80db2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80db31:	66 89 50 16          	mov    %dx,0x16(%rax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  80db35:	c9                   	leaveq 
  80db36:	c3                   	retq   

000000000080db37 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  80db37:	55                   	push   %rbp
  80db38:	48 89 e5             	mov    %rsp,%rbp
  80db3b:	48 83 ec 20          	sub    $0x20,%rsp
  80db3f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80db43:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  80db47:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80db4c:	74 07                	je     80db55 <pbuf_cat+0x1e>
  80db4e:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80db53:	75 2a                	jne    80db7f <pbuf_cat+0x48>
  80db55:	48 ba e8 1e 82 00 00 	movabs $0x821ee8,%rdx
  80db5c:	00 00 00 
  80db5f:	be 42 02 00 00       	mov    $0x242,%esi
  80db64:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80db6b:	00 00 00 
  80db6e:	b8 00 00 00 00       	mov    $0x0,%eax
  80db73:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80db7a:	00 00 00 
  80db7d:	ff d1                	callq  *%rcx
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  80db7f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80db83:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80db87:	eb 25                	jmp    80dbae <pbuf_cat+0x77>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  80db89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80db8d:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80db91:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80db95:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80db99:	01 c2                	add    %eax,%edx
  80db9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80db9f:	66 89 50 10          	mov    %dx,0x10(%rax)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  80dba3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dba7:	48 8b 00             	mov    (%rax),%rax
  80dbaa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80dbae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dbb2:	48 8b 00             	mov    (%rax),%rax
  80dbb5:	48 85 c0             	test   %rax,%rax
  80dbb8:	75 cf                	jne    80db89 <pbuf_cat+0x52>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  80dbba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dbbe:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80dbc2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dbc6:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dbca:	66 39 c2             	cmp    %ax,%dx
  80dbcd:	74 2a                	je     80dbf9 <pbuf_cat+0xc2>
  80dbcf:	48 ba 20 1f 82 00 00 	movabs $0x821f20,%rdx
  80dbd6:	00 00 00 
  80dbd9:	be 4a 02 00 00       	mov    $0x24a,%esi
  80dbde:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80dbe5:	00 00 00 
  80dbe8:	b8 00 00 00 00       	mov    $0x0,%eax
  80dbed:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80dbf4:	00 00 00 
  80dbf7:	ff d1                	callq  *%rcx
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  80dbf9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dbfd:	48 8b 00             	mov    (%rax),%rax
  80dc00:	48 85 c0             	test   %rax,%rax
  80dc03:	74 2a                	je     80dc2f <pbuf_cat+0xf8>
  80dc05:	48 ba 4d 1f 82 00 00 	movabs $0x821f4d,%rdx
  80dc0c:	00 00 00 
  80dc0f:	be 4b 02 00 00       	mov    $0x24b,%esi
  80dc14:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80dc1b:	00 00 00 
  80dc1e:	b8 00 00 00 00       	mov    $0x0,%eax
  80dc23:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80dc2a:	00 00 00 
  80dc2d:	ff d1                	callq  *%rcx
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  80dc2f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dc33:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80dc37:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80dc3b:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80dc3f:	01 c2                	add    %eax,%edx
  80dc41:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dc45:	66 89 50 10          	mov    %dx,0x10(%rax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  80dc49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dc4d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80dc51:	48 89 10             	mov    %rdx,(%rax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  80dc54:	c9                   	leaveq 
  80dc55:	c3                   	retq   

000000000080dc56 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  80dc56:	55                   	push   %rbp
  80dc57:	48 89 e5             	mov    %rsp,%rbp
  80dc5a:	48 83 ec 10          	sub    $0x10,%rsp
  80dc5e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80dc62:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pbuf_cat(h, t);
  80dc66:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80dc6a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80dc6e:	48 89 d6             	mov    %rdx,%rsi
  80dc71:	48 89 c7             	mov    %rax,%rdi
  80dc74:	48 b8 37 db 80 00 00 	movabs $0x80db37,%rax
  80dc7b:	00 00 00 
  80dc7e:	ff d0                	callq  *%rax
  /* t is now referenced by h */
  pbuf_ref(t);
  80dc80:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80dc84:	48 89 c7             	mov    %rax,%rdi
  80dc87:	48 b8 0f db 80 00 00 	movabs $0x80db0f,%rax
  80dc8e:	00 00 00 
  80dc91:	ff d0                	callq  *%rax
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  80dc93:	c9                   	leaveq 
  80dc94:	c3                   	retq   

000000000080dc95 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  80dc95:	55                   	push   %rbp
  80dc96:	48 89 e5             	mov    %rsp,%rbp
  80dc99:	53                   	push   %rbx
  80dc9a:	48 83 ec 28          	sub    $0x28,%rsp
  80dc9e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct pbuf *q;
  u8_t tail_gone = 1;
  80dca2:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
  /* tail */
  q = p->next;
  80dca6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dcaa:	48 8b 00             	mov    (%rax),%rax
  80dcad:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  /* pbuf has successor in chain? */
  if (q != NULL) {
  80dcb1:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80dcb6:	0f 84 a1 00 00 00    	je     80dd5d <pbuf_dechain+0xc8>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  80dcbc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80dcc0:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80dcc4:	0f b7 d0             	movzwl %ax,%edx
  80dcc7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dccb:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80dccf:	0f b7 c8             	movzwl %ax,%ecx
  80dcd2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dcd6:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dcda:	0f b7 c0             	movzwl %ax,%eax
  80dcdd:	89 cb                	mov    %ecx,%ebx
  80dcdf:	29 c3                	sub    %eax,%ebx
  80dce1:	89 d8                	mov    %ebx,%eax
  80dce3:	39 c2                	cmp    %eax,%edx
  80dce5:	74 2a                	je     80dd11 <pbuf_dechain+0x7c>
  80dce7:	48 ba 60 1f 82 00 00 	movabs $0x821f60,%rdx
  80dcee:	00 00 00 
  80dcf1:	be 80 02 00 00       	mov    $0x280,%esi
  80dcf6:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80dcfd:	00 00 00 
  80dd00:	b8 00 00 00 00       	mov    $0x0,%eax
  80dd05:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80dd0c:	00 00 00 
  80dd0f:	ff d1                	callq  *%rcx
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  80dd11:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dd15:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80dd19:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dd1d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dd21:	66 29 c2             	sub    %ax,%dx
  80dd24:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80dd28:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* decouple pbuf from remainder */
    p->next = NULL;
  80dd2c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dd30:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  80dd37:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dd3b:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80dd3f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dd43:	66 89 50 10          	mov    %dx,0x10(%rax)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  80dd47:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80dd4b:	48 89 c7             	mov    %rax,%rdi
  80dd4e:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  80dd55:	00 00 00 
  80dd58:	ff d0                	callq  *%rax
  80dd5a:	88 45 ef             	mov    %al,-0x11(%rbp)
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  80dd5d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dd61:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80dd65:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dd69:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80dd6d:	66 39 c2             	cmp    %ax,%dx
  80dd70:	74 2a                	je     80dd9c <pbuf_dechain+0x107>
  80dd72:	48 ba 82 1f 82 00 00 	movabs $0x821f82,%rdx
  80dd79:	00 00 00 
  80dd7c:	be 91 02 00 00       	mov    $0x291,%esi
  80dd81:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80dd88:	00 00 00 
  80dd8b:	b8 00 00 00 00       	mov    $0x0,%eax
  80dd90:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80dd97:	00 00 00 
  80dd9a:	ff d1                	callq  *%rcx
  return ((tail_gone > 0) ? NULL : q);
  80dd9c:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  80dda0:	75 06                	jne    80dda8 <pbuf_dechain+0x113>
  80dda2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80dda6:	eb 05                	jmp    80ddad <pbuf_dechain+0x118>
  80dda8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ddad:	48 83 c4 28          	add    $0x28,%rsp
  80ddb1:	5b                   	pop    %rbx
  80ddb2:	5d                   	pop    %rbp
  80ddb3:	c3                   	retq   

000000000080ddb4 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  80ddb4:	55                   	push   %rbp
  80ddb5:	48 89 e5             	mov    %rsp,%rbp
  80ddb8:	53                   	push   %rbx
  80ddb9:	48 83 ec 28          	sub    $0x28,%rsp
  80ddbd:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80ddc1:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  u16_t offset_to=0, offset_from=0, len;
  80ddc5:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
  80ddcb:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%rbp)

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  80ddd1:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80ddd6:	74 1c                	je     80ddf4 <pbuf_copy+0x40>
  80ddd8:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80dddd:	74 15                	je     80ddf4 <pbuf_copy+0x40>
  80dddf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dde3:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  80dde7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80ddeb:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80ddef:	66 39 c2             	cmp    %ax,%dx
  80ddf2:	73 2a                	jae    80de1e <pbuf_copy+0x6a>
  80ddf4:	48 ba 98 1f 82 00 00 	movabs $0x821f98,%rdx
  80ddfb:	00 00 00 
  80ddfe:	be b1 02 00 00       	mov    $0x2b1,%esi
  80de03:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80de0a:	00 00 00 
  80de0d:	b8 00 00 00 00       	mov    $0x0,%eax
  80de12:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80de19:	00 00 00 
  80de1c:	ff d1                	callq  *%rcx
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  80de1e:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80de23:	75 2a                	jne    80de4f <pbuf_copy+0x9b>
  80de25:	48 ba c8 1f 82 00 00 	movabs $0x821fc8,%rdx
  80de2c:	00 00 00 
  80de2f:	be b6 02 00 00       	mov    $0x2b6,%esi
  80de34:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80de3b:	00 00 00 
  80de3e:	b8 00 00 00 00       	mov    $0x0,%eax
  80de43:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80de4a:	00 00 00 
  80de4d:	ff d1                	callq  *%rcx
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  80de4f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de53:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80de57:	0f b7 d0             	movzwl %ax,%edx
  80de5a:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80de5e:	89 d1                	mov    %edx,%ecx
  80de60:	29 c1                	sub    %eax,%ecx
  80de62:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80de66:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80de6a:	0f b7 d0             	movzwl %ax,%edx
  80de6d:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  80de71:	89 d3                	mov    %edx,%ebx
  80de73:	29 c3                	sub    %eax,%ebx
  80de75:	89 d8                	mov    %ebx,%eax
  80de77:	39 c1                	cmp    %eax,%ecx
  80de79:	7c 12                	jl     80de8d <pbuf_copy+0xd9>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  80de7b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80de7f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80de83:	66 2b 45 ec          	sub    -0x14(%rbp),%ax
  80de87:	66 89 45 ea          	mov    %ax,-0x16(%rbp)
  80de8b:	eb 10                	jmp    80de9d <pbuf_copy+0xe9>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
  80de8d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80de91:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80de95:	66 2b 45 ee          	sub    -0x12(%rbp),%ax
  80de99:	66 89 45 ea          	mov    %ax,-0x16(%rbp)
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  80de9d:	0f b7 45 ea          	movzwl -0x16(%rbp),%eax
  80dea1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80dea5:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80dea9:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
  80dead:	48 8d 34 11          	lea    (%rcx,%rdx,1),%rsi
  80deb1:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80deb5:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80deb9:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  80debd:	48 01 d1             	add    %rdx,%rcx
  80dec0:	48 89 c2             	mov    %rax,%rdx
  80dec3:	48 89 cf             	mov    %rcx,%rdi
  80dec6:	48 b8 fd 22 80 00 00 	movabs $0x8022fd,%rax
  80decd:	00 00 00 
  80ded0:	ff d0                	callq  *%rax
    offset_to += len;
  80ded2:	0f b7 45 ea          	movzwl -0x16(%rbp),%eax
  80ded6:	66 01 45 ee          	add    %ax,-0x12(%rbp)
    offset_from += len;
  80deda:	0f b7 45 ea          	movzwl -0x16(%rbp),%eax
  80dede:	66 01 45 ec          	add    %ax,-0x14(%rbp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  80dee2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dee6:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80deea:	66 3b 45 ee          	cmp    -0x12(%rbp),%ax
  80deee:	73 2a                	jae    80df1a <pbuf_copy+0x166>
  80def0:	48 ba d5 1f 82 00 00 	movabs $0x821fd5,%rdx
  80def7:	00 00 00 
  80defa:	be c2 02 00 00       	mov    $0x2c2,%esi
  80deff:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80df06:	00 00 00 
  80df09:	b8 00 00 00 00       	mov    $0x0,%eax
  80df0e:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80df15:	00 00 00 
  80df18:	ff d1                	callq  *%rcx
    if (offset_to == p_to->len) {
  80df1a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80df1e:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80df22:	66 3b 45 ee          	cmp    -0x12(%rbp),%ax
  80df26:	75 11                	jne    80df39 <pbuf_copy+0x185>
      /* on to next p_to (if any) */
      offset_to = 0;
  80df28:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
      p_to = p_to->next;
  80df2e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80df32:	48 8b 00             	mov    (%rax),%rax
  80df35:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  80df39:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80df3d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80df41:	66 3b 45 ec          	cmp    -0x14(%rbp),%ax
  80df45:	73 2a                	jae    80df71 <pbuf_copy+0x1bd>
  80df47:	48 ba ec 1f 82 00 00 	movabs $0x821fec,%rdx
  80df4e:	00 00 00 
  80df51:	be c8 02 00 00       	mov    $0x2c8,%esi
  80df56:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80df5d:	00 00 00 
  80df60:	b8 00 00 00 00       	mov    $0x0,%eax
  80df65:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80df6c:	00 00 00 
  80df6f:	ff d1                	callq  *%rcx
    if (offset_from >= p_from->len) {
  80df71:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80df75:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80df79:	66 3b 45 ec          	cmp    -0x14(%rbp),%ax
  80df7d:	77 11                	ja     80df90 <pbuf_copy+0x1dc>
      /* on to next p_from (if any) */
      offset_from = 0;
  80df7f:	66 c7 45 ec 00 00    	movw   $0x0,-0x14(%rbp)
      p_from = p_from->next;
  80df85:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80df89:	48 8b 00             	mov    (%rax),%rax
  80df8c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  80df90:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80df95:	74 4b                	je     80dfe2 <pbuf_copy+0x22e>
  80df97:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80df9b:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80df9f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80dfa3:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80dfa7:	66 39 c2             	cmp    %ax,%dx
  80dfaa:	75 36                	jne    80dfe2 <pbuf_copy+0x22e>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80dfac:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80dfb0:	48 8b 00             	mov    (%rax),%rax
  80dfb3:	48 85 c0             	test   %rax,%rax
  80dfb6:	74 2a                	je     80dfe2 <pbuf_copy+0x22e>
  80dfb8:	48 ba 08 20 82 00 00 	movabs $0x822008,%rdx
  80dfbf:	00 00 00 
  80dfc2:	be d2 02 00 00       	mov    $0x2d2,%esi
  80dfc7:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80dfce:	00 00 00 
  80dfd1:	b8 00 00 00 00       	mov    $0x0,%eax
  80dfd6:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80dfdd:	00 00 00 
  80dfe0:	ff d1                	callq  *%rcx
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  80dfe2:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80dfe7:	74 4b                	je     80e034 <pbuf_copy+0x280>
  80dfe9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dfed:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  80dff1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80dff5:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  80dff9:	66 39 c2             	cmp    %ax,%dx
  80dffc:	75 36                	jne    80e034 <pbuf_copy+0x280>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80dffe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e002:	48 8b 00             	mov    (%rax),%rax
  80e005:	48 85 c0             	test   %rax,%rax
  80e008:	74 2a                	je     80e034 <pbuf_copy+0x280>
  80e00a:	48 ba 08 20 82 00 00 	movabs $0x822008,%rdx
  80e011:	00 00 00 
  80e014:	be d7 02 00 00       	mov    $0x2d7,%esi
  80e019:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80e020:	00 00 00 
  80e023:	b8 00 00 00 00       	mov    $0x0,%eax
  80e028:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80e02f:	00 00 00 
  80e032:	ff d1                	callq  *%rcx
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  80e034:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80e039:	0f 85 df fd ff ff    	jne    80de1e <pbuf_copy+0x6a>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
  80e03f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80e044:	48 83 c4 28          	add    $0x28,%rsp
  80e048:	5b                   	pop    %rbx
  80e049:	5d                   	pop    %rbp
  80e04a:	c3                   	retq   

000000000080e04b <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  80e04b:	55                   	push   %rbp
  80e04c:	48 89 e5             	mov    %rsp,%rbp
  80e04f:	48 83 ec 30          	sub    $0x30,%rsp
  80e053:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80e057:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80e05b:	89 c8                	mov    %ecx,%eax
  80e05d:	66 89 55 dc          	mov    %dx,-0x24(%rbp)
  80e061:	66 89 45 d8          	mov    %ax,-0x28(%rbp)
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;
  80e065:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%rbp)

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  80e06b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e070:	75 2a                	jne    80e09c <pbuf_copy_partial+0x51>
  80e072:	48 ba 38 20 82 00 00 	movabs $0x822038,%rdx
  80e079:	00 00 00 
  80e07c:	be ef 02 00 00       	mov    $0x2ef,%esi
  80e081:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80e088:	00 00 00 
  80e08b:	b8 00 00 00 00       	mov    $0x0,%eax
  80e090:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80e097:	00 00 00 
  80e09a:	ff d1                	callq  *%rcx
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  80e09c:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e0a1:	75 2a                	jne    80e0cd <pbuf_copy_partial+0x82>
  80e0a3:	48 ba 60 20 82 00 00 	movabs $0x822060,%rdx
  80e0aa:	00 00 00 
  80e0ad:	be f0 02 00 00       	mov    $0x2f0,%esi
  80e0b2:	48 bf 0b 1d 82 00 00 	movabs $0x821d0b,%rdi
  80e0b9:	00 00 00 
  80e0bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80e0c1:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80e0c8:	00 00 00 
  80e0cb:	ff d1                	callq  *%rcx

  left = 0;
  80e0cd:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%rbp)

  if((buf == NULL) || (dataptr == NULL)) {
  80e0d3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e0d8:	74 07                	je     80e0e1 <pbuf_copy_partial+0x96>
  80e0da:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e0df:	75 0a                	jne    80e0eb <pbuf_copy_partial+0xa0>
    return 0;
  80e0e1:	b8 00 00 00 00       	mov    $0x0,%eax
  80e0e6:	e9 be 00 00 00       	jmpq   80e1a9 <pbuf_copy_partial+0x15e>
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80e0eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e0ef:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e0f3:	e9 9b 00 00 00       	jmpq   80e193 <pbuf_copy_partial+0x148>
    if ((offset != 0) && (offset >= p->len)) {
  80e0f8:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%rbp)
  80e0fd:	74 1c                	je     80e11b <pbuf_copy_partial+0xd0>
  80e0ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e103:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e107:	66 3b 45 d8          	cmp    -0x28(%rbp),%ax
  80e10b:	77 0e                	ja     80e11b <pbuf_copy_partial+0xd0>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  80e10d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e111:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e115:	66 29 45 d8          	sub    %ax,-0x28(%rbp)
  80e119:	eb 6d                	jmp    80e188 <pbuf_copy_partial+0x13d>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  80e11b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e11f:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  80e123:	66 2b 45 d8          	sub    -0x28(%rbp),%ax
  80e127:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
      if (buf_copy_len > len)
  80e12b:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e12f:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80e133:	76 08                	jbe    80e13d <pbuf_copy_partial+0xf2>
          buf_copy_len = len;
  80e135:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  80e139:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  80e13d:	0f b7 55 f4          	movzwl -0xc(%rbp),%edx
  80e141:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e145:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80e149:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  80e14d:	48 01 c1             	add    %rax,%rcx
  80e150:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  80e154:	48 03 45 e0          	add    -0x20(%rbp),%rax
  80e158:	48 89 ce             	mov    %rcx,%rsi
  80e15b:	48 89 c7             	mov    %rax,%rdi
  80e15e:	48 b8 fd 22 80 00 00 	movabs $0x8022fd,%rax
  80e165:	00 00 00 
  80e168:	ff d0                	callq  *%rax
      copied_total += buf_copy_len;
  80e16a:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e16e:	66 01 45 f2          	add    %ax,-0xe(%rbp)
      left += buf_copy_len;
  80e172:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e176:	66 01 45 f6          	add    %ax,-0xa(%rbp)
      len -= buf_copy_len;
  80e17a:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80e17e:	66 29 45 dc          	sub    %ax,-0x24(%rbp)
      offset = 0;
  80e182:	66 c7 45 d8 00 00    	movw   $0x0,-0x28(%rbp)
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80e188:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e18c:	48 8b 00             	mov    (%rax),%rax
  80e18f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e193:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  80e198:	74 0b                	je     80e1a5 <pbuf_copy_partial+0x15a>
  80e19a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80e19f:	0f 85 53 ff ff ff    	jne    80e0f8 <pbuf_copy_partial+0xad>
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
  80e1a5:	0f b7 45 f2          	movzwl -0xe(%rbp),%eax
}
  80e1a9:	c9                   	leaveq 
  80e1aa:	c3                   	retq   
	...

000000000080e1ac <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  80e1ac:	55                   	push   %rbp
  80e1ad:	48 89 e5             	mov    %rsp,%rbp
  80e1b0:	48 83 ec 40          	sub    $0x40,%rsp
  80e1b4:	89 7d cc             	mov    %edi,-0x34(%rbp)
  80e1b7:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80e1bb:	eb 01                	jmp    80e1be <sys_mbox_fetch+0x12>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  80e1bd:	90                   	nop
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  80e1be:	48 b8 59 84 81 00 00 	movabs $0x818459,%rax
  80e1c5:	00 00 00 
  80e1c8:	ff d0                	callq  *%rax
  80e1ca:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  if (!timeouts || !timeouts->next) {
  80e1ce:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e1d3:	74 0c                	je     80e1e1 <sys_mbox_fetch+0x35>
  80e1d5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e1d9:	48 8b 00             	mov    (%rax),%rax
  80e1dc:	48 85 c0             	test   %rax,%rax
  80e1df:	75 25                	jne    80e206 <sys_mbox_fetch+0x5a>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  80e1e1:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80e1e5:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e1e8:	ba 00 00 00 00       	mov    $0x0,%edx
  80e1ed:	48 89 ce             	mov    %rcx,%rsi
  80e1f0:	89 c7                	mov    %eax,%edi
  80e1f2:	48 b8 70 7f 81 00 00 	movabs $0x817f70,%rax
  80e1f9:	00 00 00 
  80e1fc:	ff d0                	callq  *%rax
  80e1fe:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80e201:	e9 e0 00 00 00       	jmpq   80e2e6 <sys_mbox_fetch+0x13a>
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  80e206:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e20a:	48 8b 00             	mov    (%rax),%rax
  80e20d:	8b 40 08             	mov    0x8(%rax),%eax
  80e210:	85 c0                	test   %eax,%eax
  80e212:	74 27                	je     80e23b <sys_mbox_fetch+0x8f>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  80e214:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e218:	48 8b 00             	mov    (%rax),%rax
  80e21b:	8b 50 08             	mov    0x8(%rax),%edx
  80e21e:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80e222:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e225:	48 89 ce             	mov    %rcx,%rsi
  80e228:	89 c7                	mov    %eax,%edi
  80e22a:	48 b8 70 7f 81 00 00 	movabs $0x817f70,%rax
  80e231:	00 00 00 
  80e234:	ff d0                	callq  *%rax
  80e236:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80e239:	eb 07                	jmp    80e242 <sys_mbox_fetch+0x96>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
  80e23b:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80e242:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80e246:	75 68                	jne    80e2b0 <sys_mbox_fetch+0x104>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80e248:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e24c:	48 8b 00             	mov    (%rax),%rax
  80e24f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      timeouts->next = tmptimeout->next;
  80e253:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e257:	48 8b 10             	mov    (%rax),%rdx
  80e25a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e25e:	48 89 10             	mov    %rdx,(%rax)
      h   = tmptimeout->h;
  80e261:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e265:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e269:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      arg = tmptimeout->arg;
  80e26d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e271:	48 8b 40 18          	mov    0x18(%rax),%rax
  80e275:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80e279:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e27d:	48 89 c6             	mov    %rax,%rsi
  80e280:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e285:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  80e28c:	00 00 00 
  80e28f:	ff d0                	callq  *%rax
      if (h != NULL) {
  80e291:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e295:	48 85 c0             	test   %rax,%rax
  80e298:	0f 84 1f ff ff ff    	je     80e1bd <sys_mbox_fetch+0x11>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  80e29e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80e2a2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e2a6:	48 89 c7             	mov    %rax,%rdi
  80e2a9:	ff d2                	callq  *%rdx
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  80e2ab:	e9 0d ff ff ff       	jmpq   80e1bd <sys_mbox_fetch+0x11>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  80e2b0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e2b4:	48 8b 00             	mov    (%rax),%rax
  80e2b7:	8b 40 08             	mov    0x8(%rax),%eax
  80e2ba:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80e2bd:	76 19                	jbe    80e2d8 <sys_mbox_fetch+0x12c>
        timeouts->next->time -= time_needed;
  80e2bf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e2c3:	48 8b 00             	mov    (%rax),%rax
  80e2c6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e2ca:	48 8b 12             	mov    (%rdx),%rdx
  80e2cd:	8b 52 08             	mov    0x8(%rdx),%edx
  80e2d0:	2b 55 fc             	sub    -0x4(%rbp),%edx
  80e2d3:	89 50 08             	mov    %edx,0x8(%rax)
  80e2d6:	eb 0e                	jmp    80e2e6 <sys_mbox_fetch+0x13a>
      } else {
        timeouts->next->time = 0;
  80e2d8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e2dc:	48 8b 00             	mov    (%rax),%rax
  80e2df:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
      }
    }
  }
}
  80e2e6:	c9                   	leaveq 
  80e2e7:	c3                   	retq   

000000000080e2e8 <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  80e2e8:	55                   	push   %rbp
  80e2e9:	48 89 e5             	mov    %rsp,%rbp
  80e2ec:	48 83 ec 40          	sub    $0x40,%rsp
  80e2f0:	89 7d cc             	mov    %edi,-0x34(%rbp)
  80e2f3:	eb 01                	jmp    80e2f6 <sys_sem_wait+0xe>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  80e2f5:	90                   	nop
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  80e2f6:	48 b8 59 84 81 00 00 	movabs $0x818459,%rax
  80e2fd:	00 00 00 
  80e300:	ff d0                	callq  *%rax
  80e302:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  if (!timeouts || !timeouts->next) {
  80e306:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e30b:	74 0c                	je     80e319 <sys_sem_wait+0x31>
  80e30d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e311:	48 8b 00             	mov    (%rax),%rax
  80e314:	48 85 c0             	test   %rax,%rax
  80e317:	75 1b                	jne    80e334 <sys_sem_wait+0x4c>
    sys_arch_sem_wait(sem, 0);
  80e319:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e31c:	be 00 00 00 00       	mov    $0x0,%esi
  80e321:	89 c7                	mov    %eax,%edi
  80e323:	48 b8 46 7d 81 00 00 	movabs $0x817d46,%rax
  80e32a:	00 00 00 
  80e32d:	ff d0                	callq  *%rax
  80e32f:	e9 db 00 00 00       	jmpq   80e40f <sys_sem_wait+0x127>
  } else {
    if (timeouts->next->time > 0) {
  80e334:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e338:	48 8b 00             	mov    (%rax),%rax
  80e33b:	8b 40 08             	mov    0x8(%rax),%eax
  80e33e:	85 c0                	test   %eax,%eax
  80e340:	74 22                	je     80e364 <sys_sem_wait+0x7c>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  80e342:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e346:	48 8b 00             	mov    (%rax),%rax
  80e349:	8b 50 08             	mov    0x8(%rax),%edx
  80e34c:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80e34f:	89 d6                	mov    %edx,%esi
  80e351:	89 c7                	mov    %eax,%edi
  80e353:	48 b8 46 7d 81 00 00 	movabs $0x817d46,%rax
  80e35a:	00 00 00 
  80e35d:	ff d0                	callq  *%rax
  80e35f:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80e362:	eb 07                	jmp    80e36b <sys_sem_wait+0x83>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
  80e364:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80e36b:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  80e36f:	75 68                	jne    80e3d9 <sys_sem_wait+0xf1>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80e371:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e375:	48 8b 00             	mov    (%rax),%rax
  80e378:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      timeouts->next = tmptimeout->next;
  80e37c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e380:	48 8b 10             	mov    (%rax),%rdx
  80e383:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e387:	48 89 10             	mov    %rdx,(%rax)
      h = tmptimeout->h;
  80e38a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e38e:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e392:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      arg = tmptimeout->arg;
  80e396:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e39a:	48 8b 40 18          	mov    0x18(%rax),%rax
  80e39e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80e3a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e3a6:	48 89 c6             	mov    %rax,%rsi
  80e3a9:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e3ae:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  80e3b5:	00 00 00 
  80e3b8:	ff d0                	callq  *%rax
      if (h != NULL) {
  80e3ba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e3be:	48 85 c0             	test   %rax,%rax
  80e3c1:	0f 84 2e ff ff ff    	je     80e2f5 <sys_sem_wait+0xd>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  80e3c7:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80e3cb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e3cf:	48 89 c7             	mov    %rax,%rdi
  80e3d2:	ff d2                	callq  *%rdx
      }

      /* We try again to fetch a message from the mbox. */
      goto again;
  80e3d4:	e9 1c ff ff ff       	jmpq   80e2f5 <sys_sem_wait+0xd>
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  80e3d9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e3dd:	48 8b 00             	mov    (%rax),%rax
  80e3e0:	8b 40 08             	mov    0x8(%rax),%eax
  80e3e3:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80e3e6:	76 19                	jbe    80e401 <sys_sem_wait+0x119>
        timeouts->next->time -= time_needed;
  80e3e8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e3ec:	48 8b 00             	mov    (%rax),%rax
  80e3ef:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e3f3:	48 8b 12             	mov    (%rdx),%rdx
  80e3f6:	8b 52 08             	mov    0x8(%rdx),%edx
  80e3f9:	2b 55 fc             	sub    -0x4(%rbp),%edx
  80e3fc:	89 50 08             	mov    %edx,0x8(%rax)
  80e3ff:	eb 0e                	jmp    80e40f <sys_sem_wait+0x127>
      } else {
        timeouts->next->time = 0;
  80e401:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e405:	48 8b 00             	mov    (%rax),%rax
  80e408:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
      }
    }
  }
}
  80e40f:	c9                   	leaveq 
  80e410:	c3                   	retq   

000000000080e411 <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  80e411:	55                   	push   %rbp
  80e412:	48 89 e5             	mov    %rsp,%rbp
  80e415:	53                   	push   %rbx
  80e416:	48 83 ec 48          	sub    $0x48,%rsp
  80e41a:	89 7d cc             	mov    %edi,-0x34(%rbp)
  80e41d:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80e421:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  80e425:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e42a:	48 b8 41 ca 80 00 00 	movabs $0x80ca41,%rax
  80e431:	00 00 00 
  80e434:	ff d0                	callq  *%rax
  80e436:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  if (timeout == NULL) {
  80e43a:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e43f:	75 35                	jne    80e476 <sys_timeout+0x65>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  80e441:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80e446:	0f 85 ab 01 00 00    	jne    80e5f7 <sys_timeout+0x1e6>
  80e44c:	48 ba 88 20 82 00 00 	movabs $0x822088,%rdx
  80e453:	00 00 00 
  80e456:	be c3 00 00 00       	mov    $0xc3,%esi
  80e45b:	48 bf a5 20 82 00 00 	movabs $0x8220a5,%rdi
  80e462:	00 00 00 
  80e465:	b8 00 00 00 00       	mov    $0x0,%eax
  80e46a:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80e471:	00 00 00 
  80e474:	ff d1                	callq  *%rcx
    return;
  }
  timeout->next = NULL;
  80e476:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e47a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  timeout->h = h;
  80e481:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80e485:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e489:	48 89 50 10          	mov    %rdx,0x10(%rax)
  timeout->arg = arg;
  80e48d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e491:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80e495:	48 89 50 18          	mov    %rdx,0x18(%rax)
  timeout->time = msecs;
  80e499:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e49d:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80e4a0:	89 50 08             	mov    %edx,0x8(%rax)

  timeouts = sys_arch_timeouts();
  80e4a3:	48 b8 59 84 81 00 00 	movabs $0x818459,%rax
  80e4aa:	00 00 00 
  80e4ad:	ff d0                	callq  *%rax
  80e4af:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  80e4b3:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80e4b8:	75 35                	jne    80e4ef <sys_timeout+0xde>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  80e4ba:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80e4bf:	0f 85 35 01 00 00    	jne    80e5fa <sys_timeout+0x1e9>
  80e4c5:	48 ba b9 20 82 00 00 	movabs $0x8220b9,%rdx
  80e4cc:	00 00 00 
  80e4cf:	be d1 00 00 00       	mov    $0xd1,%esi
  80e4d4:	48 bf a5 20 82 00 00 	movabs $0x8220a5,%rdi
  80e4db:	00 00 00 
  80e4de:	b8 00 00 00 00       	mov    $0x0,%eax
  80e4e3:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80e4ea:	00 00 00 
  80e4ed:	ff d1                	callq  *%rcx
    return;
  }

  if (timeouts->next == NULL) {
  80e4ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e4f3:	48 8b 00             	mov    (%rax),%rax
  80e4f6:	48 85 c0             	test   %rax,%rax
  80e4f9:	75 10                	jne    80e50b <sys_timeout+0xfa>
    timeouts->next = timeout;
  80e4fb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e4ff:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e503:	48 89 10             	mov    %rdx,(%rax)
    return;
  80e506:	e9 f0 00 00 00       	jmpq   80e5fb <sys_timeout+0x1ea>
  }

  if (timeouts->next->time > msecs) {
  80e50b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e50f:	48 8b 00             	mov    (%rax),%rax
  80e512:	8b 40 08             	mov    0x8(%rax),%eax
  80e515:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  80e518:	76 35                	jbe    80e54f <sys_timeout+0x13e>
    timeouts->next->time -= msecs;
  80e51a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e51e:	48 8b 00             	mov    (%rax),%rax
  80e521:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80e525:	48 8b 12             	mov    (%rdx),%rdx
  80e528:	8b 52 08             	mov    0x8(%rdx),%edx
  80e52b:	2b 55 cc             	sub    -0x34(%rbp),%edx
  80e52e:	89 50 08             	mov    %edx,0x8(%rax)
    timeout->next = timeouts->next;
  80e531:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e535:	48 8b 10             	mov    (%rax),%rdx
  80e538:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e53c:	48 89 10             	mov    %rdx,(%rax)
    timeouts->next = timeout;
  80e53f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e543:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e547:	48 89 10             	mov    %rdx,(%rax)
  80e54a:	e9 ac 00 00 00       	jmpq   80e5fb <sys_timeout+0x1ea>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
  80e54f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80e553:	48 8b 00             	mov    (%rax),%rax
  80e556:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80e55a:	e9 8b 00 00 00       	jmpq   80e5ea <sys_timeout+0x1d9>
      timeout->time -= t->time;
  80e55f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e563:	8b 50 08             	mov    0x8(%rax),%edx
  80e566:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e56a:	8b 40 08             	mov    0x8(%rax),%eax
  80e56d:	29 c2                	sub    %eax,%edx
  80e56f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e573:	89 50 08             	mov    %edx,0x8(%rax)
      if (t->next == NULL || t->next->time > timeout->time) {
  80e576:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e57a:	48 8b 00             	mov    (%rax),%rax
  80e57d:	48 85 c0             	test   %rax,%rax
  80e580:	74 15                	je     80e597 <sys_timeout+0x186>
  80e582:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e586:	48 8b 00             	mov    (%rax),%rax
  80e589:	8b 50 08             	mov    0x8(%rax),%edx
  80e58c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e590:	8b 40 08             	mov    0x8(%rax),%eax
  80e593:	39 c2                	cmp    %eax,%edx
  80e595:	76 48                	jbe    80e5df <sys_timeout+0x1ce>
        if (t->next != NULL) {
  80e597:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e59b:	48 8b 00             	mov    (%rax),%rax
  80e59e:	48 85 c0             	test   %rax,%rax
  80e5a1:	74 21                	je     80e5c4 <sys_timeout+0x1b3>
          t->next->time -= timeout->time;
  80e5a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e5a7:	48 8b 00             	mov    (%rax),%rax
  80e5aa:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80e5ae:	48 8b 12             	mov    (%rdx),%rdx
  80e5b1:	8b 4a 08             	mov    0x8(%rdx),%ecx
  80e5b4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e5b8:	8b 52 08             	mov    0x8(%rdx),%edx
  80e5bb:	89 cb                	mov    %ecx,%ebx
  80e5bd:	29 d3                	sub    %edx,%ebx
  80e5bf:	89 da                	mov    %ebx,%edx
  80e5c1:	89 50 08             	mov    %edx,0x8(%rax)
        }
        timeout->next = t->next;
  80e5c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e5c8:	48 8b 10             	mov    (%rax),%rdx
  80e5cb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80e5cf:	48 89 10             	mov    %rdx,(%rax)
        t->next = timeout;
  80e5d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e5d6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80e5da:	48 89 10             	mov    %rdx,(%rax)
        break;
  80e5dd:	eb 1c                	jmp    80e5fb <sys_timeout+0x1ea>
  if (timeouts->next->time > msecs) {
    timeouts->next->time -= msecs;
    timeout->next = timeouts->next;
    timeouts->next = timeout;
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
  80e5df:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e5e3:	48 8b 00             	mov    (%rax),%rax
  80e5e6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80e5ea:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e5ef:	0f 85 6a ff ff ff    	jne    80e55f <sys_timeout+0x14e>
  80e5f5:	eb 04                	jmp    80e5fb <sys_timeout+0x1ea>
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  if (timeout == NULL) {
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
    return;
  80e5f7:	90                   	nop
  80e5f8:	eb 01                	jmp    80e5fb <sys_timeout+0x1ea>
  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
    return;
  80e5fa:	90                   	nop
        t->next = timeout;
        break;
      }
    }
  }
}
  80e5fb:	48 83 c4 48          	add    $0x48,%rsp
  80e5ff:	5b                   	pop    %rbx
  80e600:	5d                   	pop    %rbp
  80e601:	c3                   	retq   

000000000080e602 <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  80e602:	55                   	push   %rbp
  80e603:	48 89 e5             	mov    %rsp,%rbp
  80e606:	48 83 ec 30          	sub    $0x30,%rsp
  80e60a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80e60e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  80e612:	48 b8 59 84 81 00 00 	movabs $0x818459,%rax
  80e619:	00 00 00 
  80e61c:	ff d0                	callq  *%rax
  80e61e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  if (timeouts == NULL) {
  80e622:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e627:	75 35                	jne    80e65e <sys_untimeout+0x5c>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  80e629:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80e62e:	0f 85 f6 00 00 00    	jne    80e72a <sys_untimeout+0x128>
  80e634:	48 ba d8 20 82 00 00 	movabs $0x8220d8,%rdx
  80e63b:	00 00 00 
  80e63e:	be 00 01 00 00       	mov    $0x100,%esi
  80e643:	48 bf a5 20 82 00 00 	movabs $0x8220a5,%rdi
  80e64a:	00 00 00 
  80e64d:	b8 00 00 00 00       	mov    $0x0,%eax
  80e652:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80e659:	00 00 00 
  80e65c:	ff d1                	callq  *%rcx
    return;
  }
  if (timeouts->next == NULL) {
  80e65e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e662:	48 8b 00             	mov    (%rax),%rax
  80e665:	48 85 c0             	test   %rax,%rax
  80e668:	0f 84 bf 00 00 00    	je     80e72d <sys_untimeout+0x12b>
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  80e66e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e672:	48 8b 00             	mov    (%rax),%rax
  80e675:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80e679:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80e680:	00 
  80e681:	e9 97 00 00 00       	jmpq   80e71d <sys_untimeout+0x11b>
    if ((t->h == h) && (t->arg == arg)) {
  80e686:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e68a:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e68e:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80e692:	75 76                	jne    80e70a <sys_untimeout+0x108>
  80e694:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e698:	48 8b 40 18          	mov    0x18(%rax),%rax
  80e69c:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80e6a0:	75 68                	jne    80e70a <sys_untimeout+0x108>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  80e6a2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80e6a7:	75 10                	jne    80e6b9 <sys_untimeout+0xb7>
        timeouts->next = t->next;
  80e6a9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e6ad:	48 8b 10             	mov    (%rax),%rdx
  80e6b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e6b4:	48 89 10             	mov    %rdx,(%rax)
  80e6b7:	eb 0e                	jmp    80e6c7 <sys_untimeout+0xc5>
      else
        prev_t->next = t->next;
  80e6b9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e6bd:	48 8b 10             	mov    (%rax),%rdx
  80e6c0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e6c4:	48 89 10             	mov    %rdx,(%rax)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  80e6c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e6cb:	48 8b 00             	mov    (%rax),%rax
  80e6ce:	48 85 c0             	test   %rax,%rax
  80e6d1:	74 1d                	je     80e6f0 <sys_untimeout+0xee>
        t->next->time += t->time;
  80e6d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e6d7:	48 8b 00             	mov    (%rax),%rax
  80e6da:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e6de:	48 8b 12             	mov    (%rdx),%rdx
  80e6e1:	8b 4a 08             	mov    0x8(%rdx),%ecx
  80e6e4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80e6e8:	8b 52 08             	mov    0x8(%rdx),%edx
  80e6eb:	01 ca                	add    %ecx,%edx
  80e6ed:	89 50 08             	mov    %edx,0x8(%rax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  80e6f0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e6f4:	48 89 c6             	mov    %rax,%rsi
  80e6f7:	bf 0b 00 00 00       	mov    $0xb,%edi
  80e6fc:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  80e703:	00 00 00 
  80e706:	ff d0                	callq  *%rax
      return;
  80e708:	eb 24                	jmp    80e72e <sys_untimeout+0x12c>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  80e70a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e70e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80e712:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80e716:	48 8b 00             	mov    (%rax),%rax
  80e719:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80e71d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80e722:	0f 85 5e ff ff ff    	jne    80e686 <sys_untimeout+0x84>
        t->next->time += t->time;
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
  80e728:	eb 04                	jmp    80e72e <sys_untimeout+0x12c>

  timeouts = sys_arch_timeouts();

  if (timeouts == NULL) {
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
    return;
  80e72a:	90                   	nop
  80e72b:	eb 01                	jmp    80e72e <sys_untimeout+0x12c>
  }
  if (timeouts->next == NULL) {
    return;
  80e72d:	90                   	nop
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
  80e72e:	c9                   	leaveq 
  80e72f:	c3                   	retq   

000000000080e730 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  80e730:	55                   	push   %rbp
  80e731:	48 89 e5             	mov    %rsp,%rbp
  80e734:	48 83 ec 20          	sub    $0x20,%rsp
  80e738:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;
  80e73c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e740:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  80e744:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e748:	66 c7 00 01 00       	movw   $0x1,(%rax)
  sys_sem_signal(*(sswt_cb->psem));
  80e74d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80e751:	48 8b 40 08          	mov    0x8(%rax),%rax
  80e755:	8b 00                	mov    (%rax),%eax
  80e757:	89 c7                	mov    %eax,%edi
  80e759:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  80e760:	00 00 00 
  80e763:	ff d0                	callq  *%rax
}
  80e765:	c9                   	leaveq 
  80e766:	c3                   	retq   

000000000080e767 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  80e767:	55                   	push   %rbp
  80e768:	48 89 e5             	mov    %rsp,%rbp
  80e76b:	48 83 ec 20          	sub    $0x20,%rsp
  80e76f:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80e772:	89 75 e8             	mov    %esi,-0x18(%rbp)
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  80e775:	48 8d 45 ec          	lea    -0x14(%rbp),%rax
  80e779:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  sswt_cb.timeflag = 0;
  80e77d:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%rbp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  80e783:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  80e787:	74 1f                	je     80e7a8 <sys_sem_wait_timeout+0x41>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  80e789:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  80e78d:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80e790:	48 be 30 e7 80 00 00 	movabs $0x80e730,%rsi
  80e797:	00 00 00 
  80e79a:	89 c7                	mov    %eax,%edi
  80e79c:	48 b8 11 e4 80 00 00 	movabs $0x80e411,%rax
  80e7a3:	00 00 00 
  80e7a6:	ff d0                	callq  *%rax
  }
  sys_sem_wait(sem);
  80e7a8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80e7ab:	89 c7                	mov    %eax,%edi
  80e7ad:	48 b8 e8 e2 80 00 00 	movabs $0x80e2e8,%rax
  80e7b4:	00 00 00 
  80e7b7:	ff d0                	callq  *%rax
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  80e7b9:	0f b7 45 f0          	movzwl -0x10(%rbp),%eax
  80e7bd:	66 85 c0             	test   %ax,%ax
  80e7c0:	74 07                	je     80e7c9 <sys_sem_wait_timeout+0x62>
    /* timeout */
    return 0;
  80e7c2:	b8 00 00 00 00       	mov    $0x0,%eax
  80e7c7:	eb 22                	jmp    80e7eb <sys_sem_wait_timeout+0x84>
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  80e7c9:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  80e7cd:	48 89 c6             	mov    %rax,%rsi
  80e7d0:	48 bf 30 e7 80 00 00 	movabs $0x80e730,%rdi
  80e7d7:	00 00 00 
  80e7da:	48 b8 02 e6 80 00 00 	movabs $0x80e602,%rax
  80e7e1:	00 00 00 
  80e7e4:	ff d0                	callq  *%rax
    return 1;
  80e7e6:	b8 01 00 00 00       	mov    $0x1,%eax
  }
}
  80e7eb:	c9                   	leaveq 
  80e7ec:	c3                   	retq   

000000000080e7ed <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  80e7ed:	55                   	push   %rbp
  80e7ee:	48 89 e5             	mov    %rsp,%rbp
  80e7f1:	48 83 ec 20          	sub    $0x20,%rsp
  80e7f5:	89 7d ec             	mov    %edi,-0x14(%rbp)
  sys_sem_t delaysem = sys_sem_new(0);
  80e7f8:	bf 00 00 00 00       	mov    $0x0,%edi
  80e7fd:	48 b8 e2 79 81 00 00 	movabs $0x8179e2,%rax
  80e804:	00 00 00 
  80e807:	ff d0                	callq  *%rax
  80e809:	89 45 fc             	mov    %eax,-0x4(%rbp)

  sys_sem_wait_timeout(delaysem, ms);
  80e80c:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80e80f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80e812:	89 d6                	mov    %edx,%esi
  80e814:	89 c7                	mov    %eax,%edi
  80e816:	48 b8 67 e7 80 00 00 	movabs $0x80e767,%rax
  80e81d:	00 00 00 
  80e820:	ff d0                	callq  *%rax

  sys_sem_free(delaysem);
  80e822:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80e825:	89 c7                	mov    %eax,%edi
  80e827:	48 b8 e3 7a 81 00 00 	movabs $0x817ae3,%rax
  80e82e:	00 00 00 
  80e831:	ff d0                	callq  *%rax
}
  80e833:	c9                   	leaveq 
  80e834:	c3                   	retq   
  80e835:	00 00                	add    %al,(%rax)
	...

000000000080e838 <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  80e838:	55                   	push   %rbp
  80e839:	48 89 e5             	mov    %rsp,%rbp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  80e83c:	48 b8 4e ff 80 00 00 	movabs $0x80ff4e,%rax
  80e843:	00 00 00 
  80e846:	ff d0                	callq  *%rax

  if (++tcp_timer & 1) {
  80e848:	48 b8 b0 b0 b4 00 00 	movabs $0xb4b0b0,%rax
  80e84f:	00 00 00 
  80e852:	0f b6 00             	movzbl (%rax),%eax
  80e855:	8d 50 01             	lea    0x1(%rax),%edx
  80e858:	48 b8 b0 b0 b4 00 00 	movabs $0xb4b0b0,%rax
  80e85f:	00 00 00 
  80e862:	88 10                	mov    %dl,(%rax)
  80e864:	48 b8 b0 b0 b4 00 00 	movabs $0xb4b0b0,%rax
  80e86b:	00 00 00 
  80e86e:	0f b6 00             	movzbl (%rax),%eax
  80e871:	0f b6 c0             	movzbl %al,%eax
  80e874:	83 e0 01             	and    $0x1,%eax
  80e877:	84 c0                	test   %al,%al
  80e879:	74 0c                	je     80e887 <tcp_tmr+0x4f>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  80e87b:	48 b8 ee f6 80 00 00 	movabs $0x80f6ee,%rax
  80e882:	00 00 00 
  80e885:	ff d0                	callq  *%rax
  }
}
  80e887:	5d                   	pop    %rbp
  80e888:	c3                   	retq   

000000000080e889 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  80e889:	55                   	push   %rbp
  80e88a:	48 89 e5             	mov    %rsp,%rbp
  80e88d:	48 83 ec 20          	sub    $0x20,%rsp
  80e891:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  80e895:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e899:	8b 40 18             	mov    0x18(%rax),%eax
  80e89c:	83 f8 07             	cmp    $0x7,%eax
  80e89f:	0f 87 31 02 00 00    	ja     80ead6 <tcp_close+0x24d>
  80e8a5:	89 c0                	mov    %eax,%eax
  80e8a7:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80e8ae:	00 
  80e8af:	48 b8 10 21 82 00 00 	movabs $0x822110,%rax
  80e8b6:	00 00 00 
  80e8b9:	48 01 d0             	add    %rdx,%rax
  80e8bc:	48 8b 00             	mov    (%rax),%rax
  80e8bf:	ff e0                	jmpq   *%rax
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
  80e8c1:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    TCP_RMV(&tcp_bound_pcbs, pcb);
  80e8c5:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80e8cc:	00 00 00 
  80e8cf:	48 8b 00             	mov    (%rax),%rax
  80e8d2:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80e8d6:	75 23                	jne    80e8fb <tcp_close+0x72>
  80e8d8:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80e8df:	00 00 00 
  80e8e2:	48 8b 00             	mov    (%rax),%rax
  80e8e5:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80e8e9:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80e8f0:	00 00 00 
  80e8f3:	48 89 10             	mov    %rdx,(%rax)
  80e8f6:	e9 94 00 00 00       	jmpq   80e98f <tcp_close+0x106>
  80e8fb:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80e902:	00 00 00 
  80e905:	48 8b 10             	mov    (%rax),%rdx
  80e908:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80e90f:	00 00 00 
  80e912:	48 89 10             	mov    %rdx,(%rax)
  80e915:	eb 66                	jmp    80e97d <tcp_close+0xf4>
  80e917:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80e91e:	00 00 00 
  80e921:	48 8b 00             	mov    (%rax),%rax
  80e924:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e928:	48 85 c0             	test   %rax,%rax
  80e92b:	74 32                	je     80e95f <tcp_close+0xd6>
  80e92d:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80e934:	00 00 00 
  80e937:	48 8b 00             	mov    (%rax),%rax
  80e93a:	48 8b 40 10          	mov    0x10(%rax),%rax
  80e93e:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80e942:	75 1b                	jne    80e95f <tcp_close+0xd6>
  80e944:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80e94b:	00 00 00 
  80e94e:	48 8b 00             	mov    (%rax),%rax
  80e951:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80e955:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80e959:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80e95d:	eb 30                	jmp    80e98f <tcp_close+0x106>
  80e95f:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80e966:	00 00 00 
  80e969:	48 8b 00             	mov    (%rax),%rax
  80e96c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80e970:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80e977:	00 00 00 
  80e97a:	48 89 10             	mov    %rdx,(%rax)
  80e97d:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80e984:	00 00 00 
  80e987:	48 8b 00             	mov    (%rax),%rax
  80e98a:	48 85 c0             	test   %rax,%rax
  80e98d:	75 88                	jne    80e917 <tcp_close+0x8e>
  80e98f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e993:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80e99a:	00 
    memp_free(MEMP_TCP_PCB, pcb);
  80e99b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e99f:	48 89 c6             	mov    %rax,%rsi
  80e9a2:	bf 02 00 00 00       	mov    $0x2,%edi
  80e9a7:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  80e9ae:	00 00 00 
  80e9b1:	ff d0                	callq  *%rax
    pcb = NULL;
  80e9b3:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80e9ba:	00 
    break;
  80e9bb:	e9 2b 01 00 00       	jmpq   80eaeb <tcp_close+0x262>
  case LISTEN:
    err = ERR_OK;
  80e9c0:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  80e9c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e9c8:	48 89 c6             	mov    %rax,%rsi
  80e9cb:	48 bf 28 b0 b5 00 00 	movabs $0xb5b028,%rdi
  80e9d2:	00 00 00 
  80e9d5:	48 b8 e8 06 81 00 00 	movabs $0x8106e8,%rax
  80e9dc:	00 00 00 
  80e9df:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  80e9e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80e9e5:	48 89 c6             	mov    %rax,%rsi
  80e9e8:	bf 03 00 00 00       	mov    $0x3,%edi
  80e9ed:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  80e9f4:	00 00 00 
  80e9f7:	ff d0                	callq  *%rax
    pcb = NULL;
  80e9f9:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80ea00:	00 
    break;
  80ea01:	e9 e5 00 00 00       	jmpq   80eaeb <tcp_close+0x262>
  case SYN_SENT:
    err = ERR_OK;
  80ea06:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80ea0a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ea0e:	48 89 c6             	mov    %rax,%rsi
  80ea11:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  80ea18:	00 00 00 
  80ea1b:	48 b8 e8 06 81 00 00 	movabs $0x8106e8,%rax
  80ea22:	00 00 00 
  80ea25:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB, pcb);
  80ea27:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ea2b:	48 89 c6             	mov    %rax,%rsi
  80ea2e:	bf 02 00 00 00       	mov    $0x2,%edi
  80ea33:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  80ea3a:	00 00 00 
  80ea3d:	ff d0                	callq  *%rax
    pcb = NULL;
  80ea3f:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80ea46:	00 
    snmp_inc_tcpattemptfails();
    break;
  80ea47:	e9 9f 00 00 00       	jmpq   80eaeb <tcp_close+0x262>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80ea4c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ea50:	be 01 00 00 00       	mov    $0x1,%esi
  80ea55:	48 89 c7             	mov    %rax,%rdi
  80ea58:	48 b8 20 2d 81 00 00 	movabs $0x812d20,%rax
  80ea5f:	00 00 00 
  80ea62:	ff d0                	callq  *%rax
  80ea64:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80ea67:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80ea6b:	75 77                	jne    80eae4 <tcp_close+0x25b>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  80ea6d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ea71:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%rax)
    }
    break;
  80ea78:	eb 6a                	jmp    80eae4 <tcp_close+0x25b>
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80ea7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ea7e:	be 01 00 00 00       	mov    $0x1,%esi
  80ea83:	48 89 c7             	mov    %rax,%rdi
  80ea86:	48 b8 20 2d 81 00 00 	movabs $0x812d20,%rax
  80ea8d:	00 00 00 
  80ea90:	ff d0                	callq  *%rax
  80ea92:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80ea95:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80ea99:	75 4c                	jne    80eae7 <tcp_close+0x25e>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  80ea9b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ea9f:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%rax)
    }
    break;
  80eaa6:	eb 3f                	jmp    80eae7 <tcp_close+0x25e>
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80eaa8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eaac:	be 01 00 00 00       	mov    $0x1,%esi
  80eab1:	48 89 c7             	mov    %rax,%rdi
  80eab4:	48 b8 20 2d 81 00 00 	movabs $0x812d20,%rax
  80eabb:	00 00 00 
  80eabe:	ff d0                	callq  *%rax
  80eac0:	88 45 ff             	mov    %al,-0x1(%rbp)
    if (err == ERR_OK) {
  80eac3:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80eac7:	75 21                	jne    80eaea <tcp_close+0x261>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  80eac9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eacd:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
    }
    break;
  80ead4:	eb 14                	jmp    80eaea <tcp_close+0x261>
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
  80ead6:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
    pcb = NULL;
  80eada:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80eae1:	00 
    break;
  80eae2:	eb 07                	jmp    80eaeb <tcp_close+0x262>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
    }
    break;
  80eae4:	90                   	nop
  80eae5:	eb 04                	jmp    80eaeb <tcp_close+0x262>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    }
    break;
  80eae7:	90                   	nop
  80eae8:	eb 01                	jmp    80eaeb <tcp_close+0x262>
    err = tcp_send_ctrl(pcb, TCP_FIN);
    if (err == ERR_OK) {
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
    }
    break;
  80eaea:	90                   	nop
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  80eaeb:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80eaf0:	74 19                	je     80eb0b <tcp_close+0x282>
  80eaf2:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  80eaf6:	75 13                	jne    80eb0b <tcp_close+0x282>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  80eaf8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eafc:	48 89 c7             	mov    %rax,%rdi
  80eaff:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  80eb06:	00 00 00 
  80eb09:	ff d0                	callq  *%rax
  }
  return err;
  80eb0b:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  80eb0f:	c9                   	leaveq 
  80eb10:	c3                   	retq   

000000000080eb11 <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  80eb11:	55                   	push   %rbp
  80eb12:	48 89 e5             	mov    %rsp,%rbp
  80eb15:	48 83 ec 50          	sub    $0x50,%rsp
  80eb19:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  80eb1d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80eb21:	8b 40 18             	mov    0x18(%rax),%eax
  80eb24:	83 f8 0a             	cmp    $0xa,%eax
  80eb27:	75 3a                	jne    80eb63 <tcp_abort+0x52>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  80eb29:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80eb2d:	48 89 c6             	mov    %rax,%rsi
  80eb30:	48 bf 40 b0 b5 00 00 	movabs $0xb5b040,%rdi
  80eb37:	00 00 00 
  80eb3a:	48 b8 e8 06 81 00 00 	movabs $0x8106e8,%rax
  80eb41:	00 00 00 
  80eb44:	ff d0                	callq  *%rax
    memp_free(MEMP_TCP_PCB, pcb);
  80eb46:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80eb4a:	48 89 c6             	mov    %rax,%rsi
  80eb4d:	bf 02 00 00 00       	mov    $0x2,%edi
  80eb52:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  80eb59:	00 00 00 
  80eb5c:	ff d0                	callq  *%rax
  80eb5e:	e9 75 01 00 00       	jmpq   80ecd8 <tcp_abort+0x1c7>
  } else {
    seqno = pcb->snd_nxt;
  80eb63:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80eb67:	8b 40 60             	mov    0x60(%rax),%eax
  80eb6a:	89 45 fc             	mov    %eax,-0x4(%rbp)
    ackno = pcb->rcv_nxt;
  80eb6d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80eb71:	8b 40 30             	mov    0x30(%rax),%eax
  80eb74:	89 45 f8             	mov    %eax,-0x8(%rbp)
    ip_addr_set(&local_ip, &(pcb->local_ip));
  80eb77:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80eb7b:	48 85 c0             	test   %rax,%rax
  80eb7e:	74 08                	je     80eb88 <tcp_abort+0x77>
  80eb80:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80eb84:	8b 00                	mov    (%rax),%eax
  80eb86:	eb 05                	jmp    80eb8d <tcp_abort+0x7c>
  80eb88:	b8 00 00 00 00       	mov    $0x0,%eax
  80eb8d:	89 45 c0             	mov    %eax,-0x40(%rbp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  80eb90:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80eb94:	48 83 c0 04          	add    $0x4,%rax
  80eb98:	48 85 c0             	test   %rax,%rax
  80eb9b:	74 09                	je     80eba6 <tcp_abort+0x95>
  80eb9d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80eba1:	8b 40 04             	mov    0x4(%rax),%eax
  80eba4:	eb 05                	jmp    80ebab <tcp_abort+0x9a>
  80eba6:	b8 00 00 00 00       	mov    $0x0,%eax
  80ebab:	89 45 d0             	mov    %eax,-0x30(%rbp)
    local_port = pcb->local_port;
  80ebae:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ebb2:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80ebb6:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    remote_port = pcb->remote_port;
  80ebba:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ebbe:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  80ebc2:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  80ebc6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ebca:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  80ebd1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  80ebd5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ebd9:	48 8b 40 20          	mov    0x20(%rax),%rax
  80ebdd:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80ebe1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ebe5:	48 89 c6             	mov    %rax,%rsi
  80ebe8:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  80ebef:	00 00 00 
  80ebf2:	48 b8 e8 06 81 00 00 	movabs $0x8106e8,%rax
  80ebf9:	00 00 00 
  80ebfc:	ff d0                	callq  *%rax
    if (pcb->unacked != NULL) {
  80ebfe:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ec02:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80ec09:	48 85 c0             	test   %rax,%rax
  80ec0c:	74 1a                	je     80ec28 <tcp_abort+0x117>
      tcp_segs_free(pcb->unacked);
  80ec0e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ec12:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80ec19:	48 89 c7             	mov    %rax,%rdi
  80ec1c:	48 b8 6b 00 81 00 00 	movabs $0x81006b,%rax
  80ec23:	00 00 00 
  80ec26:	ff d0                	callq  *%rax
    }
    if (pcb->unsent != NULL) {
  80ec28:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ec2c:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80ec33:	48 85 c0             	test   %rax,%rax
  80ec36:	74 1a                	je     80ec52 <tcp_abort+0x141>
      tcp_segs_free(pcb->unsent);
  80ec38:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ec3c:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80ec43:	48 89 c7             	mov    %rax,%rdi
  80ec46:	48 b8 6b 00 81 00 00 	movabs $0x81006b,%rax
  80ec4d:	00 00 00 
  80ec50:	ff d0                	callq  *%rax
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  80ec52:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ec56:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80ec5d:	48 85 c0             	test   %rax,%rax
  80ec60:	74 1a                	je     80ec7c <tcp_abort+0x16b>
      tcp_segs_free(pcb->ooseq);
  80ec62:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ec66:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80ec6d:	48 89 c7             	mov    %rax,%rdi
  80ec70:	48 b8 6b 00 81 00 00 	movabs $0x81006b,%rax
  80ec77:	00 00 00 
  80ec7a:	ff d0                	callq  *%rax
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  80ec7c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80ec80:	48 89 c6             	mov    %rax,%rsi
  80ec83:	bf 02 00 00 00       	mov    $0x2,%edi
  80ec88:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  80ec8f:	00 00 00 
  80ec92:	ff d0                	callq  *%rax
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  80ec94:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80ec99:	74 12                	je     80ecad <tcp_abort+0x19c>
  80ec9b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ec9f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80eca3:	be fb ff ff ff       	mov    $0xfffffffb,%esi
  80eca8:	48 89 c7             	mov    %rax,%rdi
  80ecab:	ff d2                	callq  *%rdx
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  80ecad:	44 0f b7 45 f4       	movzwl -0xc(%rbp),%r8d
  80ecb2:	0f b7 7d f6          	movzwl -0xa(%rbp),%edi
  80ecb6:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80ecba:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
  80ecbe:	8b 75 f8             	mov    -0x8(%rbp),%esi
  80ecc1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80ecc4:	45 89 c1             	mov    %r8d,%r9d
  80ecc7:	41 89 f8             	mov    %edi,%r8d
  80ecca:	89 c7                	mov    %eax,%edi
  80eccc:	48 b8 d9 41 81 00 00 	movabs $0x8141d9,%rax
  80ecd3:	00 00 00 
  80ecd6:	ff d0                	callq  *%rax
  }
}
  80ecd8:	c9                   	leaveq 
  80ecd9:	c3                   	retq   

000000000080ecda <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80ecda:	55                   	push   %rbp
  80ecdb:	48 89 e5             	mov    %rsp,%rbp
  80ecde:	48 83 ec 30          	sub    $0x30,%rsp
  80ece2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80ece6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80ecea:	89 d0                	mov    %edx,%eax
  80ecec:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80ecf0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ecf4:	8b 40 18             	mov    0x18(%rax),%eax
  80ecf7:	85 c0                	test   %eax,%eax
  80ecf9:	74 2a                	je     80ed25 <tcp_bind+0x4b>
  80ecfb:	48 ba 50 21 82 00 00 	movabs $0x822150,%rdx
  80ed02:	00 00 00 
  80ed05:	be 05 01 00 00       	mov    $0x105,%esi
  80ed0a:	48 bf 7b 21 82 00 00 	movabs $0x82217b,%rdi
  80ed11:	00 00 00 
  80ed14:	b8 00 00 00 00       	mov    $0x0,%eax
  80ed19:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80ed20:	00 00 00 
  80ed23:	ff d1                	callq  *%rcx

  if (port == 0) {
  80ed25:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  80ed2a:	75 10                	jne    80ed3c <tcp_bind+0x62>
    port = tcp_new_port();
  80ed2c:	48 b8 eb f2 80 00 00 	movabs $0x80f2eb,%rax
  80ed33:	00 00 00 
  80ed36:	ff d0                	callq  *%rax
  80ed38:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80ed3c:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80ed43:	00 00 00 
  80ed46:	48 8b 00             	mov    (%rax),%rax
  80ed49:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ed4d:	eb 58                	jmp    80eda7 <tcp_bind+0xcd>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  80ed4f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ed53:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80ed57:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80ed5b:	75 3e                	jne    80ed9b <tcp_bind+0xc1>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80ed5d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ed61:	48 85 c0             	test   %rax,%rax
  80ed64:	74 2b                	je     80ed91 <tcp_bind+0xb7>
  80ed66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ed6a:	8b 00                	mov    (%rax),%eax
  80ed6c:	85 c0                	test   %eax,%eax
  80ed6e:	74 21                	je     80ed91 <tcp_bind+0xb7>
  80ed70:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80ed75:	74 1a                	je     80ed91 <tcp_bind+0xb7>
          ip_addr_isany(ipaddr) ||
  80ed77:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ed7b:	8b 00                	mov    (%rax),%eax
  80ed7d:	85 c0                	test   %eax,%eax
  80ed7f:	74 10                	je     80ed91 <tcp_bind+0xb7>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80ed81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ed85:	8b 10                	mov    (%rax),%edx
  80ed87:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ed8b:	8b 00                	mov    (%rax),%eax
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
  80ed8d:	39 c2                	cmp    %eax,%edx
  80ed8f:	75 0a                	jne    80ed9b <tcp_bind+0xc1>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80ed91:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80ed96:	e9 a2 01 00 00       	jmpq   80ef3d <tcp_bind+0x263>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  80ed9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ed9f:	48 8b 40 10          	mov    0x10(%rax),%rax
  80eda3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80eda7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80edac:	75 a1                	jne    80ed4f <tcp_bind+0x75>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  80edae:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80edb5:	00 00 00 
  80edb8:	48 8b 00             	mov    (%rax),%rax
  80edbb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80edbf:	eb 58                	jmp    80ee19 <tcp_bind+0x13f>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  80edc1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80edc5:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80edc9:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80edcd:	75 3e                	jne    80ee0d <tcp_bind+0x133>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80edcf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80edd3:	48 85 c0             	test   %rax,%rax
  80edd6:	74 2b                	je     80ee03 <tcp_bind+0x129>
  80edd8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eddc:	8b 00                	mov    (%rax),%eax
  80edde:	85 c0                	test   %eax,%eax
  80ede0:	74 21                	je     80ee03 <tcp_bind+0x129>
  80ede2:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80ede7:	74 1a                	je     80ee03 <tcp_bind+0x129>
          ip_addr_isany(ipaddr) ||
  80ede9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80eded:	8b 00                	mov    (%rax),%eax
  80edef:	85 c0                	test   %eax,%eax
  80edf1:	74 10                	je     80ee03 <tcp_bind+0x129>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80edf3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80edf7:	8b 10                	mov    (%rax),%edx
  80edf9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80edfd:	8b 00                	mov    (%rax),%eax
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
  80edff:	39 c2                	cmp    %eax,%edx
  80ee01:	75 0a                	jne    80ee0d <tcp_bind+0x133>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80ee03:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80ee08:	e9 30 01 00 00       	jmpq   80ef3d <tcp_bind+0x263>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  80ee0d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ee11:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ee15:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  80ee19:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ee1e:	75 a1                	jne    80edc1 <tcp_bind+0xe7>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80ee20:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80ee27:	00 00 00 
  80ee2a:	48 8b 00             	mov    (%rax),%rax
  80ee2d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ee31:	eb 58                	jmp    80ee8b <tcp_bind+0x1b1>
    if (cpcb->local_port == port) {
  80ee33:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ee37:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80ee3b:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80ee3f:	75 3e                	jne    80ee7f <tcp_bind+0x1a5>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80ee41:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ee45:	48 85 c0             	test   %rax,%rax
  80ee48:	74 2b                	je     80ee75 <tcp_bind+0x19b>
  80ee4a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ee4e:	8b 00                	mov    (%rax),%eax
  80ee50:	85 c0                	test   %eax,%eax
  80ee52:	74 21                	je     80ee75 <tcp_bind+0x19b>
  80ee54:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80ee59:	74 1a                	je     80ee75 <tcp_bind+0x19b>
          ip_addr_isany(ipaddr) ||
  80ee5b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ee5f:	8b 00                	mov    (%rax),%eax
  80ee61:	85 c0                	test   %eax,%eax
  80ee63:	74 10                	je     80ee75 <tcp_bind+0x19b>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80ee65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ee69:	8b 10                	mov    (%rax),%edx
  80ee6b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ee6f:	8b 00                	mov    (%rax),%eax
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
  80ee71:	39 c2                	cmp    %eax,%edx
  80ee73:	75 0a                	jne    80ee7f <tcp_bind+0x1a5>
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80ee75:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80ee7a:	e9 be 00 00 00       	jmpq   80ef3d <tcp_bind+0x263>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80ee7f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ee83:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ee87:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ee8b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ee90:	75 a1                	jne    80ee33 <tcp_bind+0x159>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80ee92:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80ee99:	00 00 00 
  80ee9c:	48 8b 00             	mov    (%rax),%rax
  80ee9f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80eea3:	eb 31                	jmp    80eed6 <tcp_bind+0x1fc>
    if (cpcb->local_port == port) {
  80eea5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eea9:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80eead:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  80eeb1:	75 17                	jne    80eeca <tcp_bind+0x1f0>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80eeb3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eeb7:	8b 10                	mov    (%rax),%edx
  80eeb9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80eebd:	8b 00                	mov    (%rax),%eax
  80eebf:	39 c2                	cmp    %eax,%edx
  80eec1:	75 07                	jne    80eeca <tcp_bind+0x1f0>
        return ERR_USE;
  80eec3:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80eec8:	eb 73                	jmp    80ef3d <tcp_bind+0x263>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80eeca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eece:	48 8b 40 10          	mov    0x10(%rax),%rax
  80eed2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80eed6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80eedb:	75 c8                	jne    80eea5 <tcp_bind+0x1cb>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  80eedd:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80eee2:	74 16                	je     80eefa <tcp_bind+0x220>
  80eee4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80eee8:	8b 00                	mov    (%rax),%eax
  80eeea:	85 c0                	test   %eax,%eax
  80eeec:	74 0c                	je     80eefa <tcp_bind+0x220>
    pcb->local_ip = *ipaddr;
  80eeee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eef2:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80eef6:	8b 12                	mov    (%rdx),%edx
  80eef8:	89 10                	mov    %edx,(%rax)
  }
  pcb->local_port = port;
  80eefa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eefe:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  80ef02:	66 89 50 28          	mov    %dx,0x28(%rax)
  TCP_REG(&tcp_bound_pcbs, pcb);
  80ef06:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80ef0d:	00 00 00 
  80ef10:	48 8b 10             	mov    (%rax),%rdx
  80ef13:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ef17:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80ef1b:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80ef22:	00 00 00 
  80ef25:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80ef29:	48 89 10             	mov    %rdx,(%rax)
  80ef2c:	48 b8 d4 82 80 00 00 	movabs $0x8082d4,%rax
  80ef33:	00 00 00 
  80ef36:	ff d0                	callq  *%rax
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  80ef38:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80ef3d:	c9                   	leaveq 
  80ef3e:	c3                   	retq   

000000000080ef3f <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80ef3f:	55                   	push   %rbp
  80ef40:	48 89 e5             	mov    %rsp,%rbp
  80ef43:	48 83 ec 18          	sub    $0x18,%rsp
  80ef47:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80ef4b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  80ef4f:	89 d0                	mov    %edx,%eax
  80ef51:	88 45 ec             	mov    %al,-0x14(%rbp)
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
  80ef54:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
}
  80ef59:	c9                   	leaveq 
  80ef5a:	c3                   	retq   

000000000080ef5b <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  80ef5b:	55                   	push   %rbp
  80ef5c:	48 89 e5             	mov    %rsp,%rbp
  80ef5f:	48 83 ec 20          	sub    $0x20,%rsp
  80ef63:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80ef67:	89 f0                	mov    %esi,%eax
  80ef69:	88 45 e4             	mov    %al,-0x1c(%rbp)
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  80ef6c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80ef70:	8b 40 18             	mov    0x18(%rax),%eax
  80ef73:	85 c0                	test   %eax,%eax
  80ef75:	74 2a                	je     80efa1 <tcp_listen_with_backlog+0x46>
  80ef77:	48 ba 90 21 82 00 00 	movabs $0x822190,%rdx
  80ef7e:	00 00 00 
  80ef81:	be 60 01 00 00       	mov    $0x160,%esi
  80ef86:	48 bf 7b 21 82 00 00 	movabs $0x82217b,%rdi
  80ef8d:	00 00 00 
  80ef90:	b8 00 00 00 00       	mov    $0x0,%eax
  80ef95:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80ef9c:	00 00 00 
  80ef9f:	ff d1                	callq  *%rcx

  /* already listening? */
  if (pcb->state == LISTEN) {
  80efa1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80efa5:	8b 40 18             	mov    0x18(%rax),%eax
  80efa8:	83 f8 01             	cmp    $0x1,%eax
  80efab:	75 09                	jne    80efb6 <tcp_listen_with_backlog+0x5b>
    return pcb;
  80efad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80efb1:	e9 e6 01 00 00       	jmpq   80f19c <tcp_listen_with_backlog+0x241>
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  80efb6:	bf 03 00 00 00       	mov    $0x3,%edi
  80efbb:	48 b8 41 ca 80 00 00 	movabs $0x80ca41,%rax
  80efc2:	00 00 00 
  80efc5:	ff d0                	callq  *%rax
  80efc7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (lpcb == NULL) {
  80efcb:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80efd0:	75 0a                	jne    80efdc <tcp_listen_with_backlog+0x81>
    return NULL;
  80efd2:	b8 00 00 00 00       	mov    $0x0,%eax
  80efd7:	e9 c0 01 00 00       	jmpq   80f19c <tcp_listen_with_backlog+0x241>
  }
  lpcb->callback_arg = pcb->callback_arg;
  80efdc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80efe0:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80efe4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80efe8:	48 89 50 20          	mov    %rdx,0x20(%rax)
  lpcb->local_port = pcb->local_port;
  80efec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80eff0:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80eff4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80eff8:	66 89 50 28          	mov    %dx,0x28(%rax)
  lpcb->state = LISTEN;
  80effc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f000:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%rax)
  lpcb->so_options = pcb->so_options;
  80f007:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f00b:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  80f00f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f013:	66 89 50 08          	mov    %dx,0x8(%rax)
  lpcb->so_options |= SOF_ACCEPTCONN;
  80f017:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f01b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80f01f:	89 c2                	mov    %eax,%edx
  80f021:	83 ca 02             	or     $0x2,%edx
  80f024:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f028:	66 89 50 08          	mov    %dx,0x8(%rax)
  lpcb->ttl = pcb->ttl;
  80f02c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f030:	0f b6 50 0b          	movzbl 0xb(%rax),%edx
  80f034:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f038:	88 50 0b             	mov    %dl,0xb(%rax)
  lpcb->tos = pcb->tos;
  80f03b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f03f:	0f b6 50 0a          	movzbl 0xa(%rax),%edx
  80f043:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f047:	88 50 0a             	mov    %dl,0xa(%rax)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  80f04a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f04e:	48 85 c0             	test   %rax,%rax
  80f051:	74 08                	je     80f05b <tcp_listen_with_backlog+0x100>
  80f053:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f057:	8b 00                	mov    (%rax),%eax
  80f059:	eb 05                	jmp    80f060 <tcp_listen_with_backlog+0x105>
  80f05b:	b8 00 00 00 00       	mov    $0x0,%eax
  80f060:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80f064:	89 02                	mov    %eax,(%rdx)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80f066:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f06d:	00 00 00 
  80f070:	48 8b 00             	mov    (%rax),%rax
  80f073:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80f077:	75 23                	jne    80f09c <tcp_listen_with_backlog+0x141>
  80f079:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f080:	00 00 00 
  80f083:	48 8b 00             	mov    (%rax),%rax
  80f086:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f08a:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f091:	00 00 00 
  80f094:	48 89 10             	mov    %rdx,(%rax)
  80f097:	e9 94 00 00 00       	jmpq   80f130 <tcp_listen_with_backlog+0x1d5>
  80f09c:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f0a3:	00 00 00 
  80f0a6:	48 8b 10             	mov    (%rax),%rdx
  80f0a9:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f0b0:	00 00 00 
  80f0b3:	48 89 10             	mov    %rdx,(%rax)
  80f0b6:	eb 66                	jmp    80f11e <tcp_listen_with_backlog+0x1c3>
  80f0b8:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f0bf:	00 00 00 
  80f0c2:	48 8b 00             	mov    (%rax),%rax
  80f0c5:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f0c9:	48 85 c0             	test   %rax,%rax
  80f0cc:	74 32                	je     80f100 <tcp_listen_with_backlog+0x1a5>
  80f0ce:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f0d5:	00 00 00 
  80f0d8:	48 8b 00             	mov    (%rax),%rax
  80f0db:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f0df:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80f0e3:	75 1b                	jne    80f100 <tcp_listen_with_backlog+0x1a5>
  80f0e5:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f0ec:	00 00 00 
  80f0ef:	48 8b 00             	mov    (%rax),%rax
  80f0f2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f0f6:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80f0fa:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f0fe:	eb 30                	jmp    80f130 <tcp_listen_with_backlog+0x1d5>
  80f100:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f107:	00 00 00 
  80f10a:	48 8b 00             	mov    (%rax),%rax
  80f10d:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f111:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f118:	00 00 00 
  80f11b:	48 89 10             	mov    %rdx,(%rax)
  80f11e:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f125:	00 00 00 
  80f128:	48 8b 00             	mov    (%rax),%rax
  80f12b:	48 85 c0             	test   %rax,%rax
  80f12e:	75 88                	jne    80f0b8 <tcp_listen_with_backlog+0x15d>
  80f130:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f134:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80f13b:	00 
  memp_free(MEMP_TCP_PCB, pcb);
  80f13c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f140:	48 89 c6             	mov    %rax,%rsi
  80f143:	bf 02 00 00 00       	mov    $0x2,%edi
  80f148:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  80f14f:	00 00 00 
  80f152:	ff d0                	callq  *%rax
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  80f154:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f158:	48 ba 3f ef 80 00 00 	movabs $0x80ef3f,%rdx
  80f15f:	00 00 00 
  80f162:	48 89 50 30          	mov    %rdx,0x30(%rax)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  80f166:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80f16d:	00 00 00 
  80f170:	48 8b 10             	mov    (%rax),%rdx
  80f173:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f177:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f17b:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80f182:	00 00 00 
  80f185:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80f189:	48 89 10             	mov    %rdx,(%rax)
  80f18c:	48 b8 d4 82 80 00 00 	movabs $0x8082d4,%rax
  80f193:	00 00 00 
  80f196:	ff d0                	callq  *%rax
  return (struct tcp_pcb *)lpcb;
  80f198:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80f19c:	c9                   	leaveq 
  80f19d:	c3                   	retq   

000000000080f19e <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  80f19e:	55                   	push   %rbp
  80f19f:	48 89 e5             	mov    %rsp,%rbp
  80f1a2:	48 83 ec 10          	sub    $0x10,%rsp
  80f1a6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  80f1aa:	89 f0                	mov    %esi,%eax
  80f1ac:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  80f1b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1b4:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  80f1b8:	0f b7 d0             	movzwl %ax,%edx
  80f1bb:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
  80f1bf:	01 d0                	add    %edx,%eax
  80f1c1:	3d c0 5d 00 00       	cmp    $0x5dc0,%eax
  80f1c6:	76 16                	jbe    80f1de <tcp_recved+0x40>
    pcb->rcv_wnd = TCP_WND;
  80f1c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1cc:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
    pcb->rcv_ann_wnd = TCP_WND;
  80f1d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1d6:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
  80f1dc:	eb 3b                	jmp    80f219 <tcp_recved+0x7b>
  } else {
    pcb->rcv_wnd += len;
  80f1de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1e2:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  80f1e6:	89 c2                	mov    %eax,%edx
  80f1e8:	66 03 55 f4          	add    -0xc(%rbp),%dx
  80f1ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1f0:	66 89 50 34          	mov    %dx,0x34(%rax)
    if (pcb->rcv_wnd >= pcb->mss) {
  80f1f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f1f8:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  80f1fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f200:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80f204:	66 39 c2             	cmp    %ax,%dx
  80f207:	72 10                	jb     80f219 <tcp_recved+0x7b>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  80f209:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f20d:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  80f211:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f215:	66 89 50 36          	mov    %dx,0x36(%rax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  80f219:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f21d:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f221:	0f b6 c0             	movzbl %al,%eax
  80f224:	83 e0 01             	and    $0x1,%eax
  80f227:	85 c0                	test   %eax,%eax
  80f229:	75 77                	jne    80f2a2 <tcp_recved+0x104>
     !(pcb->flags & TF_ACK_NOW)) {
  80f22b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f22f:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f233:	0f b6 c0             	movzbl %al,%eax
  80f236:	83 e0 02             	and    $0x2,%eax
    if (pcb->rcv_wnd >= pcb->mss) {
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  80f239:	85 c0                	test   %eax,%eax
  80f23b:	75 65                	jne    80f2a2 <tcp_recved+0x104>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  80f23d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f241:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f245:	0f b6 c0             	movzbl %al,%eax
  80f248:	83 e0 01             	and    $0x1,%eax
  80f24b:	84 c0                	test   %al,%al
  80f24d:	74 3d                	je     80f28c <tcp_recved+0xee>
  80f24f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f253:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f257:	89 c2                	mov    %eax,%edx
  80f259:	83 e2 fe             	and    $0xfffffffe,%edx
  80f25c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f260:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f263:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f267:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f26b:	89 c2                	mov    %eax,%edx
  80f26d:	83 ca 02             	or     $0x2,%edx
  80f270:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f274:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f277:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f27b:	48 89 c7             	mov    %rax,%rdi
  80f27e:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  80f285:	00 00 00 
  80f288:	ff d0                	callq  *%rax
  80f28a:	eb 5d                	jmp    80f2e9 <tcp_recved+0x14b>
  80f28c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f290:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f294:	89 c2                	mov    %eax,%edx
  80f296:	83 ca 01             	or     $0x1,%edx
  80f299:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f29d:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f2a0:	eb 47                	jmp    80f2e9 <tcp_recved+0x14b>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  80f2a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2a6:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f2aa:	0f b6 c0             	movzbl %al,%eax
  80f2ad:	83 e0 01             	and    $0x1,%eax
  80f2b0:	84 c0                	test   %al,%al
  80f2b2:	74 35                	je     80f2e9 <tcp_recved+0x14b>
  80f2b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2b8:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  80f2bc:	66 3d df 2e          	cmp    $0x2edf,%ax
  80f2c0:	76 27                	jbe    80f2e9 <tcp_recved+0x14b>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  80f2c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2c6:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  80f2ca:	89 c2                	mov    %eax,%edx
  80f2cc:	83 ca 02             	or     $0x2,%edx
  80f2cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2d3:	88 50 2c             	mov    %dl,0x2c(%rax)
  80f2d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f2da:	48 89 c7             	mov    %rax,%rdi
  80f2dd:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  80f2e4:	00 00 00 
  80f2e7:	ff d0                	callq  *%rax
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  80f2e9:	c9                   	leaveq 
  80f2ea:	c3                   	retq   

000000000080f2eb <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80f2eb:	55                   	push   %rbp
  80f2ec:	48 89 e5             	mov    %rsp,%rbp
  80f2ef:	48 83 ec 10          	sub    $0x10,%rsp
  80f2f3:	eb 07                	jmp    80f2fc <tcp_new_port+0x11>
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
  80f2f5:	90                   	nop
  80f2f6:	eb 04                	jmp    80f2fc <tcp_new_port+0x11>
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
  80f2f8:	90                   	nop
  80f2f9:	eb 01                	jmp    80f2fc <tcp_new_port+0x11>
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
  80f2fb:	90                   	nop
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  80f2fc:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  80f303:	00 00 00 
  80f306:	0f b7 00             	movzwl (%rax),%eax
  80f309:	8d 50 01             	lea    0x1(%rax),%edx
  80f30c:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  80f313:	00 00 00 
  80f316:	66 89 10             	mov    %dx,(%rax)
  80f319:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  80f320:	00 00 00 
  80f323:	0f b7 00             	movzwl (%rax),%eax
  80f326:	66 85 c0             	test   %ax,%ax
  80f329:	79 0f                	jns    80f33a <tcp_new_port+0x4f>
    port = TCP_LOCAL_PORT_RANGE_START;
  80f32b:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  80f332:	00 00 00 
  80f335:	66 c7 00 00 10       	movw   $0x1000,(%rax)
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80f33a:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80f341:	00 00 00 
  80f344:	48 8b 00             	mov    (%rax),%rax
  80f347:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f34b:	eb 26                	jmp    80f373 <tcp_new_port+0x88>
    if (pcb->local_port == port) {
  80f34d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f351:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f355:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  80f35c:	00 00 00 
  80f35f:	0f b7 00             	movzwl (%rax),%eax
  80f362:	66 39 c2             	cmp    %ax,%dx
  80f365:	74 8e                	je     80f2f5 <tcp_new_port+0xa>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80f367:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f36b:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f36f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f373:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f378:	75 d3                	jne    80f34d <tcp_new_port+0x62>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80f37a:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80f381:	00 00 00 
  80f384:	48 8b 00             	mov    (%rax),%rax
  80f387:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f38b:	eb 2a                	jmp    80f3b7 <tcp_new_port+0xcc>
    if (pcb->local_port == port) {
  80f38d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f391:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f395:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  80f39c:	00 00 00 
  80f39f:	0f b7 00             	movzwl (%rax),%eax
  80f3a2:	66 39 c2             	cmp    %ax,%dx
  80f3a5:	0f 84 4d ff ff ff    	je     80f2f8 <tcp_new_port+0xd>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80f3ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f3af:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f3b3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f3b7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f3bc:	75 cf                	jne    80f38d <tcp_new_port+0xa2>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80f3be:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  80f3c5:	00 00 00 
  80f3c8:	48 8b 00             	mov    (%rax),%rax
  80f3cb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f3cf:	eb 2a                	jmp    80f3fb <tcp_new_port+0x110>
    if (pcb->local_port == port) {
  80f3d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f3d5:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  80f3d9:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  80f3e0:	00 00 00 
  80f3e3:	0f b7 00             	movzwl (%rax),%eax
  80f3e6:	66 39 c2             	cmp    %ax,%dx
  80f3e9:	0f 84 0c ff ff ff    	je     80f2fb <tcp_new_port+0x10>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80f3ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f3f3:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f3f7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80f3fb:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80f400:	75 cf                	jne    80f3d1 <tcp_new_port+0xe6>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
  80f402:	48 b8 f4 81 82 00 00 	movabs $0x8281f4,%rax
  80f409:	00 00 00 
  80f40c:	0f b7 00             	movzwl (%rax),%eax
}
  80f40f:	c9                   	leaveq 
  80f410:	c3                   	retq   

000000000080f411 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  80f411:	55                   	push   %rbp
  80f412:	48 89 e5             	mov    %rsp,%rbp
  80f415:	48 83 ec 40          	sub    $0x40,%rsp
  80f419:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80f41d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80f421:	89 d0                	mov    %edx,%eax
  80f423:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  80f427:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80f42b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f42f:	8b 40 18             	mov    0x18(%rax),%eax
  80f432:	85 c0                	test   %eax,%eax
  80f434:	74 2a                	je     80f460 <tcp_connect+0x4f>
  80f436:	48 ba b8 21 82 00 00 	movabs $0x8221b8,%rdx
  80f43d:	00 00 00 
  80f440:	be ec 01 00 00       	mov    $0x1ec,%esi
  80f445:	48 bf 7b 21 82 00 00 	movabs $0x82217b,%rdi
  80f44c:	00 00 00 
  80f44f:	b8 00 00 00 00       	mov    $0x0,%eax
  80f454:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80f45b:	00 00 00 
  80f45e:	ff d1                	callq  *%rcx

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  80f460:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80f465:	74 28                	je     80f48f <tcp_connect+0x7e>
    pcb->remote_ip = *ipaddr;
  80f467:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f46b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80f46f:	8b 12                	mov    (%rdx),%edx
  80f471:	89 50 04             	mov    %edx,0x4(%rax)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  80f474:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f478:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  80f47c:	66 89 50 2a          	mov    %dx,0x2a(%rax)
  if (pcb->local_port == 0) {
  80f480:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f484:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80f488:	66 85 c0             	test   %ax,%ax
  80f48b:	74 0c                	je     80f499 <tcp_connect+0x88>
  80f48d:	eb 1e                	jmp    80f4ad <tcp_connect+0x9c>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
  80f48f:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80f494:	e9 53 02 00 00       	jmpq   80f6ec <tcp_connect+0x2db>
  }
  pcb->remote_port = port;
  if (pcb->local_port == 0) {
    pcb->local_port = tcp_new_port();
  80f499:	48 b8 eb f2 80 00 00 	movabs $0x80f2eb,%rax
  80f4a0:	00 00 00 
  80f4a3:	ff d0                	callq  *%rax
  80f4a5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f4a9:	66 89 42 28          	mov    %ax,0x28(%rdx)
  }
  iss = tcp_next_iss();
  80f4ad:	48 b8 e5 08 81 00 00 	movabs $0x8108e5,%rax
  80f4b4:	00 00 00 
  80f4b7:	ff d0                	callq  *%rax
  80f4b9:	89 45 fc             	mov    %eax,-0x4(%rbp)
  pcb->rcv_nxt = 0;
  80f4bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f4c0:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
  pcb->snd_nxt = iss;
  80f4c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f4cb:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80f4ce:	89 50 60             	mov    %edx,0x60(%rax)
  pcb->lastack = iss - 1;
  80f4d1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80f4d4:	8d 50 ff             	lea    -0x1(%rax),%edx
  80f4d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f4db:	89 50 54             	mov    %edx,0x54(%rax)
  pcb->snd_lbb = iss - 1;
  80f4de:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80f4e1:	8d 50 ff             	lea    -0x1(%rax),%edx
  80f4e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f4e8:	89 50 74             	mov    %edx,0x74(%rax)
  pcb->rcv_wnd = TCP_WND;
  80f4eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f4ef:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
  pcb->rcv_ann_wnd = TCP_WND;
  80f4f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f4f9:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
  pcb->snd_wnd = TCP_WND;
  80f4ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f503:	66 c7 40 68 c0 5d    	movw   $0x5dc0,0x68(%rax)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80f509:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f50d:	66 c7 40 40 18 02    	movw   $0x218,0x40(%rax)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  80f513:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f517:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80f51b:	0f b7 c0             	movzwl %ax,%eax
  80f51e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80f522:	48 89 d6             	mov    %rdx,%rsi
  80f525:	89 c7                	mov    %eax,%edi
  80f527:	48 b8 1d 09 81 00 00 	movabs $0x81091d,%rax
  80f52e:	00 00 00 
  80f531:	ff d0                	callq  *%rax
  80f533:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f537:	66 89 42 40          	mov    %ax,0x40(%rdx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  80f53b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f53f:	66 c7 40 5a 01 00    	movw   $0x1,0x5a(%rax)
  pcb->ssthresh = pcb->mss * 10;
  80f545:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f549:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  80f54d:	89 d0                	mov    %edx,%eax
  80f54f:	c1 e0 02             	shl    $0x2,%eax
  80f552:	01 d0                	add    %edx,%eax
  80f554:	01 c0                	add    %eax,%eax
  80f556:	89 c2                	mov    %eax,%edx
  80f558:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f55c:	66 89 50 5c          	mov    %dx,0x5c(%rax)
  pcb->state = SYN_SENT;
  80f560:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f564:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%rax)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  80f56b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f56f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80f573:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80f57a:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f581:	00 00 00 
  80f584:	48 8b 00             	mov    (%rax),%rax
  80f587:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80f58b:	75 23                	jne    80f5b0 <tcp_connect+0x19f>
  80f58d:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f594:	00 00 00 
  80f597:	48 8b 00             	mov    (%rax),%rax
  80f59a:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f59e:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f5a5:	00 00 00 
  80f5a8:	48 89 10             	mov    %rdx,(%rax)
  80f5ab:	e9 94 00 00 00       	jmpq   80f644 <tcp_connect+0x233>
  80f5b0:	48 b8 38 b0 b5 00 00 	movabs $0xb5b038,%rax
  80f5b7:	00 00 00 
  80f5ba:	48 8b 10             	mov    (%rax),%rdx
  80f5bd:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f5c4:	00 00 00 
  80f5c7:	48 89 10             	mov    %rdx,(%rax)
  80f5ca:	eb 66                	jmp    80f632 <tcp_connect+0x221>
  80f5cc:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f5d3:	00 00 00 
  80f5d6:	48 8b 00             	mov    (%rax),%rax
  80f5d9:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f5dd:	48 85 c0             	test   %rax,%rax
  80f5e0:	74 32                	je     80f614 <tcp_connect+0x203>
  80f5e2:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f5e9:	00 00 00 
  80f5ec:	48 8b 00             	mov    (%rax),%rax
  80f5ef:	48 8b 40 10          	mov    0x10(%rax),%rax
  80f5f3:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80f5f7:	75 1b                	jne    80f614 <tcp_connect+0x203>
  80f5f9:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f600:	00 00 00 
  80f603:	48 8b 00             	mov    (%rax),%rax
  80f606:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f60a:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80f60e:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f612:	eb 30                	jmp    80f644 <tcp_connect+0x233>
  80f614:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f61b:	00 00 00 
  80f61e:	48 8b 00             	mov    (%rax),%rax
  80f621:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80f625:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f62c:	00 00 00 
  80f62f:	48 89 10             	mov    %rdx,(%rax)
  80f632:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  80f639:	00 00 00 
  80f63c:	48 8b 00             	mov    (%rax),%rax
  80f63f:	48 85 c0             	test   %rax,%rax
  80f642:	75 88                	jne    80f5cc <tcp_connect+0x1bb>
  80f644:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f648:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  80f64f:	00 
  TCP_REG(&tcp_active_pcbs, pcb);
  80f650:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80f657:	00 00 00 
  80f65a:	48 8b 10             	mov    (%rax),%rdx
  80f65d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f661:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80f665:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80f66c:	00 00 00 
  80f66f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80f673:	48 89 10             	mov    %rdx,(%rax)
  80f676:	48 b8 d4 82 80 00 00 	movabs $0x8082d4,%rax
  80f67d:	00 00 00 
  80f680:	ff d0                	callq  *%rax

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  80f682:	bf b4 05 04 02       	mov    $0x20405b4,%edi
  80f687:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  80f68e:	00 00 00 
  80f691:	ff d0                	callq  *%rax
  80f693:	89 45 f4             	mov    %eax,-0xc(%rbp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  80f696:	48 8d 55 f4          	lea    -0xc(%rbp),%rdx
  80f69a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f69e:	c7 04 24 04 00 00 00 	movl   $0x4,(%rsp)
  80f6a5:	49 89 d1             	mov    %rdx,%r9
  80f6a8:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80f6ae:	b9 02 00 00 00       	mov    $0x2,%ecx
  80f6b3:	ba 00 00 00 00       	mov    $0x0,%edx
  80f6b8:	be 00 00 00 00       	mov    $0x0,%esi
  80f6bd:	48 89 c7             	mov    %rax,%rdi
  80f6c0:	48 b8 fd 2d 81 00 00 	movabs $0x812dfd,%rax
  80f6c7:	00 00 00 
  80f6ca:	ff d0                	callq  *%rax
  80f6cc:	88 45 fb             	mov    %al,-0x5(%rbp)
  if (ret == ERR_OK) { 
  80f6cf:	80 7d fb 00          	cmpb   $0x0,-0x5(%rbp)
  80f6d3:	75 13                	jne    80f6e8 <tcp_connect+0x2d7>
    tcp_output(pcb);
  80f6d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80f6d9:	48 89 c7             	mov    %rax,%rdi
  80f6dc:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  80f6e3:	00 00 00 
  80f6e6:	ff d0                	callq  *%rax
  }
  return ret;
  80f6e8:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
} 
  80f6ec:	c9                   	leaveq 
  80f6ed:	c3                   	retq   

000000000080f6ee <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  80f6ee:	55                   	push   %rbp
  80f6ef:	48 89 e5             	mov    %rsp,%rbp
  80f6f2:	48 83 ec 30          	sub    $0x30,%rsp
  struct tcp_pcb *pcb, *pcb2, *prev;
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
  80f6f6:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)

  ++tcp_ticks;
  80f6fa:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80f701:	00 00 00 
  80f704:	8b 00                	mov    (%rax),%eax
  80f706:	8d 50 01             	lea    0x1(%rax),%edx
  80f709:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80f710:	00 00 00 
  80f713:	89 10                	mov    %edx,(%rax)

  /* Steps through all of the active PCBs. */
  prev = NULL;
  80f715:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80f71c:	00 
  pcb = tcp_active_pcbs;
  80f71d:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80f724:	00 00 00 
  80f727:	48 8b 00             	mov    (%rax),%rax
  80f72a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  80f72e:	e9 80 06 00 00       	jmpq   80fdb3 <tcp_slowtmr+0x6c5>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  80f733:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f737:	8b 40 18             	mov    0x18(%rax),%eax
  80f73a:	85 c0                	test   %eax,%eax
  80f73c:	75 2a                	jne    80f768 <tcp_slowtmr+0x7a>
  80f73e:	48 ba f0 21 82 00 00 	movabs $0x8221f0,%rdx
  80f745:	00 00 00 
  80f748:	be 36 02 00 00       	mov    $0x236,%esi
  80f74d:	48 bf 7b 21 82 00 00 	movabs $0x82217b,%rdi
  80f754:	00 00 00 
  80f757:	b8 00 00 00 00       	mov    $0x0,%eax
  80f75c:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80f763:	00 00 00 
  80f766:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  80f768:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f76c:	8b 40 18             	mov    0x18(%rax),%eax
  80f76f:	83 f8 01             	cmp    $0x1,%eax
  80f772:	75 2a                	jne    80f79e <tcp_slowtmr+0xb0>
  80f774:	48 ba 20 22 82 00 00 	movabs $0x822220,%rdx
  80f77b:	00 00 00 
  80f77e:	be 37 02 00 00       	mov    $0x237,%esi
  80f783:	48 bf 7b 21 82 00 00 	movabs $0x82217b,%rdi
  80f78a:	00 00 00 
  80f78d:	b8 00 00 00 00       	mov    $0x0,%eax
  80f792:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80f799:	00 00 00 
  80f79c:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  80f79e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7a2:	8b 40 18             	mov    0x18(%rax),%eax
  80f7a5:	83 f8 0a             	cmp    $0xa,%eax
  80f7a8:	75 2a                	jne    80f7d4 <tcp_slowtmr+0xe6>
  80f7aa:	48 ba 50 22 82 00 00 	movabs $0x822250,%rdx
  80f7b1:	00 00 00 
  80f7b4:	be 38 02 00 00       	mov    $0x238,%esi
  80f7b9:	48 bf 7b 21 82 00 00 	movabs $0x82217b,%rdi
  80f7c0:	00 00 00 
  80f7c3:	b8 00 00 00 00       	mov    $0x0,%eax
  80f7c8:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80f7cf:	00 00 00 
  80f7d2:	ff d1                	callq  *%rcx

    pcb_remove = 0;
  80f7d4:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  80f7d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7dc:	8b 40 18             	mov    0x18(%rax),%eax
  80f7df:	83 f8 02             	cmp    $0x2,%eax
  80f7e2:	75 15                	jne    80f7f9 <tcp_slowtmr+0x10b>
  80f7e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7e8:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80f7ec:	3c 06                	cmp    $0x6,%al
  80f7ee:	75 09                	jne    80f7f9 <tcp_slowtmr+0x10b>
      ++pcb_remove;
  80f7f0:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
  80f7f4:	e9 e6 01 00 00       	jmpq   80f9df <tcp_slowtmr+0x2f1>
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  80f7f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f7fd:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80f801:	3c 0c                	cmp    $0xc,%al
  80f803:	75 09                	jne    80f80e <tcp_slowtmr+0x120>
      ++pcb_remove;
  80f805:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
  80f809:	e9 d1 01 00 00       	jmpq   80f9df <tcp_slowtmr+0x2f1>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  80f80e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f812:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80f819:	84 c0                	test   %al,%al
  80f81b:	0f 84 9a 00 00 00    	je     80f8bb <tcp_slowtmr+0x1cd>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  80f821:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f825:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80f82b:	8d 50 01             	lea    0x1(%rax),%edx
  80f82e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f832:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  80f838:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f83c:	8b 88 d4 00 00 00    	mov    0xd4(%rax),%ecx
  80f842:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f846:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80f84d:	0f b6 c0             	movzbl %al,%eax
  80f850:	83 e8 01             	sub    $0x1,%eax
  80f853:	48 ba 05 21 82 00 00 	movabs $0x822105,%rdx
  80f85a:	00 00 00 
  80f85d:	48 98                	cltq   
  80f85f:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80f863:	0f b6 c0             	movzbl %al,%eax
  80f866:	39 c1                	cmp    %eax,%ecx
  80f868:	0f 82 71 01 00 00    	jb     80f9df <tcp_slowtmr+0x2f1>
          pcb->persist_cnt = 0;
  80f86e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f872:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  80f879:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  80f87c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f880:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80f887:	3c 06                	cmp    $0x6,%al
  80f889:	77 18                	ja     80f8a3 <tcp_slowtmr+0x1b5>
            pcb->persist_backoff++;
  80f88b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f88f:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  80f896:	8d 50 01             	lea    0x1(%rax),%edx
  80f899:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f89d:	88 90 d8 00 00 00    	mov    %dl,0xd8(%rax)
          }
          tcp_zero_window_probe(pcb);
  80f8a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f8a7:	48 89 c7             	mov    %rax,%rdi
  80f8aa:	48 b8 b3 47 81 00 00 	movabs $0x8147b3,%rax
  80f8b1:	00 00 00 
  80f8b4:	ff d0                	callq  *%rax
  80f8b6:	e9 24 01 00 00       	jmpq   80f9df <tcp_slowtmr+0x2f1>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  80f8bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f8bf:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  80f8c3:	66 85 c0             	test   %ax,%ax
  80f8c6:	78 13                	js     80f8db <tcp_slowtmr+0x1ed>
          ++pcb->rtime;
  80f8c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f8cc:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  80f8d0:	8d 50 01             	lea    0x1(%rax),%edx
  80f8d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f8d7:	66 89 50 3e          	mov    %dx,0x3e(%rax)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  80f8db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f8df:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80f8e6:	48 85 c0             	test   %rax,%rax
  80f8e9:	0f 84 f0 00 00 00    	je     80f9df <tcp_slowtmr+0x2f1>
  80f8ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f8f3:	0f b7 50 3e          	movzwl 0x3e(%rax),%edx
  80f8f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f8fb:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  80f8ff:	66 39 c2             	cmp    %ax,%dx
  80f902:	0f 8c d7 00 00 00    	jl     80f9df <tcp_slowtmr+0x2f1>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  80f908:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f90c:	8b 40 18             	mov    0x18(%rax),%eax
  80f90f:	83 f8 02             	cmp    $0x2,%eax
  80f912:	74 4b                	je     80f95f <tcp_slowtmr+0x271>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  80f914:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f918:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80f91c:	66 c1 f8 03          	sar    $0x3,%ax
  80f920:	0f bf d0             	movswl %ax,%edx
  80f923:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f927:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  80f92b:	98                   	cwtl   
  80f92c:	8d 34 02             	lea    (%rdx,%rax,1),%esi
  80f92f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f933:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  80f937:	0f b6 c0             	movzbl %al,%eax
  80f93a:	48 ba f8 20 82 00 00 	movabs $0x8220f8,%rdx
  80f941:	00 00 00 
  80f944:	48 98                	cltq   
  80f946:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80f94a:	0f b6 c0             	movzbl %al,%eax
  80f94d:	89 f2                	mov    %esi,%edx
  80f94f:	89 c1                	mov    %eax,%ecx
  80f951:	d3 e2                	shl    %cl,%edx
  80f953:	89 d0                	mov    %edx,%eax
  80f955:	89 c2                	mov    %eax,%edx
  80f957:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f95b:	66 89 50 50          	mov    %dx,0x50(%rax)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  80f95f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f963:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  80f969:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f96d:	0f b7 50 68          	movzwl 0x68(%rax),%edx
  80f971:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f975:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  80f979:	66 39 c2             	cmp    %ax,%dx
  80f97c:	0f 46 c2             	cmovbe %edx,%eax
  80f97f:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
          pcb->ssthresh = eff_wnd >> 1;
  80f983:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  80f987:	89 c2                	mov    %eax,%edx
  80f989:	66 d1 ea             	shr    %dx
  80f98c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f990:	66 89 50 5c          	mov    %dx,0x5c(%rax)
          if (pcb->ssthresh < pcb->mss) {
  80f994:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f998:	0f b7 50 5c          	movzwl 0x5c(%rax),%edx
  80f99c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f9a0:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80f9a4:	66 39 c2             	cmp    %ax,%dx
  80f9a7:	73 13                	jae    80f9bc <tcp_slowtmr+0x2ce>
            pcb->ssthresh = pcb->mss * 2;
  80f9a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f9ad:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  80f9b1:	8d 14 00             	lea    (%rax,%rax,1),%edx
  80f9b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f9b8:	66 89 50 5c          	mov    %dx,0x5c(%rax)
          }
          pcb->cwnd = pcb->mss;
  80f9bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f9c0:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  80f9c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f9c8:	66 89 50 5a          	mov    %dx,0x5a(%rax)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  80f9cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f9d0:	48 89 c7             	mov    %rax,%rdi
  80f9d3:	48 b8 e5 43 81 00 00 	movabs $0x8143e5,%rax
  80f9da:	00 00 00 
  80f9dd:	ff d0                	callq  *%rax
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  80f9df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f9e3:	8b 40 18             	mov    0x18(%rax),%eax
  80f9e6:	83 f8 06             	cmp    $0x6,%eax
  80f9e9:	75 22                	jne    80fa0d <tcp_slowtmr+0x31f>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  80f9eb:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80f9f2:	00 00 00 
  80f9f5:	8b 10                	mov    (%rax),%edx
  80f9f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80f9fb:	8b 40 38             	mov    0x38(%rax),%eax
  80f9fe:	89 d1                	mov    %edx,%ecx
  80fa00:	29 c1                	sub    %eax,%ecx
  80fa02:	89 c8                	mov    %ecx,%eax
  80fa04:	83 f8 28             	cmp    $0x28,%eax
  80fa07:	76 04                	jbe    80fa0d <tcp_slowtmr+0x31f>
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  80fa09:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  80fa0d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa11:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80fa15:	0f b7 c0             	movzwl %ax,%eax
  80fa18:	83 e0 08             	and    $0x8,%eax
  80fa1b:	85 c0                	test   %eax,%eax
  80fa1d:	0f 84 1b 01 00 00    	je     80fb3e <tcp_slowtmr+0x450>
       ((pcb->state == ESTABLISHED) || 
  80fa23:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa27:	8b 40 18             	mov    0x18(%rax),%eax
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  80fa2a:	83 f8 04             	cmp    $0x4,%eax
  80fa2d:	74 10                	je     80fa3f <tcp_slowtmr+0x351>
       ((pcb->state == ESTABLISHED) || 
        (pcb->state == CLOSE_WAIT))) {
  80fa2f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa33:	8b 40 18             	mov    0x18(%rax),%eax
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
       ((pcb->state == ESTABLISHED) || 
  80fa36:	83 f8 07             	cmp    $0x7,%eax
  80fa39:	0f 85 ff 00 00 00    	jne    80fb3e <tcp_slowtmr+0x450>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80fa3f:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fa46:	00 00 00 
  80fa49:	8b 10                	mov    (%rax),%edx
  80fa4b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa4f:	8b 40 38             	mov    0x38(%rax),%eax
  80fa52:	89 d1                	mov    %edx,%ecx
  80fa54:	29 c1                	sub    %eax,%ecx
  80fa56:	89 c8                	mov    %ecx,%eax
  80fa58:	89 c1                	mov    %eax,%ecx
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  80fa5a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa5e:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  80fa64:	89 c0                	mov    %eax,%eax
  80fa66:	48 05 b8 4c 0a 00    	add    $0xa4cb8,%rax
  80fa6c:	48 89 c2             	mov    %rax,%rdx
  80fa6f:	48 c1 ea 02          	shr    $0x2,%rdx
  80fa73:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80fa77:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  80fa7e:	9b c4 20 
  80fa81:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80fa85:	48 f7 e2             	mul    %rdx
  80fa88:	48 89 d0             	mov    %rdx,%rax
  80fa8b:	48 c1 e8 04          	shr    $0x4,%rax
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80fa8f:	48 39 c1             	cmp    %rax,%rcx
  80fa92:	76 18                	jbe    80faac <tcp_slowtmr+0x3be>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  80fa94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fa98:	48 89 c7             	mov    %rax,%rdi
  80fa9b:	48 b8 11 eb 80 00 00 	movabs $0x80eb11,%rax
  80faa2:	00 00 00 
  80faa5:	ff d0                	callq  *%rax
  80faa7:	e9 92 00 00 00       	jmpq   80fb3e <tcp_slowtmr+0x450>
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  80faac:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fab3:	00 00 00 
  80fab6:	8b 10                	mov    (%rax),%edx
  80fab8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fabc:	8b 40 38             	mov    0x38(%rax),%eax
  80fabf:	89 d1                	mov    %edx,%ecx
  80fac1:	29 c1                	sub    %eax,%ecx
  80fac3:	89 c8                	mov    %ecx,%eax
  80fac5:	89 c1                	mov    %eax,%ecx
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  80fac7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80facb:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  80fad1:	89 c2                	mov    %eax,%edx
  80fad3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fad7:	0f b6 80 d9 00 00 00 	movzbl 0xd9(%rax),%eax
  80fade:	0f b6 c0             	movzbl %al,%eax
  80fae1:	48 69 c0 f8 24 01 00 	imul   $0x124f8,%rax,%rax
  80fae8:	48 01 d0             	add    %rdx,%rax
              / TCP_SLOW_INTERVAL)
  80faeb:	48 89 c2             	mov    %rax,%rdx
  80faee:	48 c1 ea 02          	shr    $0x2,%rdx
  80faf2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80faf6:	48 ba cf f7 53 e3 a5 	movabs $0x20c49ba5e353f7cf,%rdx
  80fafd:	9b c4 20 
  80fb00:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80fb04:	48 f7 e2             	mul    %rdx
  80fb07:	48 89 d0             	mov    %rdx,%rax
  80fb0a:	48 c1 e8 04          	shr    $0x4,%rax
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  80fb0e:	48 39 c1             	cmp    %rax,%rcx
  80fb11:	76 2b                	jbe    80fb3e <tcp_slowtmr+0x450>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  80fb13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb17:	48 89 c7             	mov    %rax,%rdi
  80fb1a:	48 b8 8c 45 81 00 00 	movabs $0x81458c,%rax
  80fb21:	00 00 00 
  80fb24:	ff d0                	callq  *%rax
        pcb->keep_cnt_sent++;
  80fb26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb2a:	0f b6 80 d9 00 00 00 	movzbl 0xd9(%rax),%eax
  80fb31:	8d 50 01             	lea    0x1(%rax),%edx
  80fb34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb38:	88 90 d9 00 00 00    	mov    %dl,0xd9(%rax)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  80fb3e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb42:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80fb49:	48 85 c0             	test   %rax,%rax
  80fb4c:	74 57                	je     80fba5 <tcp_slowtmr+0x4b7>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  80fb4e:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fb55:	00 00 00 
  80fb58:	8b 10                	mov    (%rax),%edx
  80fb5a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb5e:	8b 40 38             	mov    0x38(%rax),%eax
  80fb61:	89 d1                	mov    %edx,%ecx
  80fb63:	29 c1                	sub    %eax,%ecx
  80fb65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb69:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  80fb6d:	0f bf d0             	movswl %ax,%edx
  80fb70:	89 d0                	mov    %edx,%eax
  80fb72:	01 c0                	add    %eax,%eax
  80fb74:	01 d0                	add    %edx,%eax
  80fb76:	01 c0                	add    %eax,%eax

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  80fb78:	39 c1                	cmp    %eax,%ecx
  80fb7a:	72 29                	jb     80fba5 <tcp_slowtmr+0x4b7>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
  80fb7c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb80:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  80fb87:	48 89 c7             	mov    %rax,%rdi
  80fb8a:	48 b8 6b 00 81 00 00 	movabs $0x81006b,%rax
  80fb91:	00 00 00 
  80fb94:	ff d0                	callq  *%rax
      pcb->ooseq = NULL;
  80fb96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fb9a:	48 c7 80 90 00 00 00 	movq   $0x0,0x90(%rax)
  80fba1:	00 00 00 00 
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  80fba5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fba9:	8b 40 18             	mov    0x18(%rax),%eax
  80fbac:	83 f8 03             	cmp    $0x3,%eax
  80fbaf:	75 22                	jne    80fbd3 <tcp_slowtmr+0x4e5>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  80fbb1:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fbb8:	00 00 00 
  80fbbb:	8b 10                	mov    (%rax),%edx
  80fbbd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbc1:	8b 40 38             	mov    0x38(%rax),%eax
  80fbc4:	89 d1                	mov    %edx,%ecx
  80fbc6:	29 c1                	sub    %eax,%ecx
  80fbc8:	89 c8                	mov    %ecx,%eax
  80fbca:	83 f8 28             	cmp    $0x28,%eax
  80fbcd:	76 04                	jbe    80fbd3 <tcp_slowtmr+0x4e5>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  80fbcf:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  80fbd3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbd7:	8b 40 18             	mov    0x18(%rax),%eax
  80fbda:	83 f8 09             	cmp    $0x9,%eax
  80fbdd:	75 24                	jne    80fc03 <tcp_slowtmr+0x515>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  80fbdf:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fbe6:	00 00 00 
  80fbe9:	8b 10                	mov    (%rax),%edx
  80fbeb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fbef:	8b 40 38             	mov    0x38(%rax),%eax
  80fbf2:	89 d1                	mov    %edx,%ecx
  80fbf4:	29 c1                	sub    %eax,%ecx
  80fbf6:	89 c8                	mov    %ecx,%eax
  80fbf8:	3d f0 00 00 00       	cmp    $0xf0,%eax
  80fbfd:	76 04                	jbe    80fc03 <tcp_slowtmr+0x515>
        ++pcb_remove;
  80fbff:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  80fc03:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  80fc07:	0f 84 19 01 00 00    	je     80fd26 <tcp_slowtmr+0x638>
      tcp_pcb_purge(pcb);      
  80fc0d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc11:	48 89 c7             	mov    %rax,%rdi
  80fc14:	48 b8 e6 05 81 00 00 	movabs $0x8105e6,%rax
  80fc1b:	00 00 00 
  80fc1e:	ff d0                	callq  *%rax
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  80fc20:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80fc25:	74 4f                	je     80fc76 <tcp_slowtmr+0x588>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  80fc27:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80fc2e:	00 00 00 
  80fc31:	48 8b 00             	mov    (%rax),%rax
  80fc34:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80fc38:	75 2a                	jne    80fc64 <tcp_slowtmr+0x576>
  80fc3a:	48 ba 80 22 82 00 00 	movabs $0x822280,%rdx
  80fc41:	00 00 00 
  80fc44:	be c1 02 00 00       	mov    $0x2c1,%esi
  80fc49:	48 bf 7b 21 82 00 00 	movabs $0x82217b,%rdi
  80fc50:	00 00 00 
  80fc53:	b8 00 00 00 00       	mov    $0x0,%eax
  80fc58:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80fc5f:	00 00 00 
  80fc62:	ff d1                	callq  *%rcx
        prev->next = pcb->next;
  80fc64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fc68:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80fc6c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80fc70:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80fc74:	eb 52                	jmp    80fcc8 <tcp_slowtmr+0x5da>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  80fc76:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80fc7d:	00 00 00 
  80fc80:	48 8b 00             	mov    (%rax),%rax
  80fc83:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80fc87:	74 2a                	je     80fcb3 <tcp_slowtmr+0x5c5>
  80fc89:	48 ba b0 22 82 00 00 	movabs $0x8222b0,%rdx
  80fc90:	00 00 00 
  80fc93:	be c5 02 00 00       	mov    $0x2c5,%esi
  80fc98:	48 bf 7b 21 82 00 00 	movabs $0x82217b,%rdi
  80fc9f:	00 00 00 
  80fca2:	b8 00 00 00 00       	mov    $0x0,%eax
  80fca7:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80fcae:	00 00 00 
  80fcb1:	ff d1                	callq  *%rcx
        tcp_active_pcbs = pcb->next;
  80fcb3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcb7:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80fcbb:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80fcc2:	00 00 00 
  80fcc5:	48 89 10             	mov    %rdx,(%rax)
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  80fcc8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fccc:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  80fcd3:	48 85 c0             	test   %rax,%rax
  80fcd6:	74 1d                	je     80fcf5 <tcp_slowtmr+0x607>
  80fcd8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcdc:	48 8b 90 c8 00 00 00 	mov    0xc8(%rax),%rdx
  80fce3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fce7:	48 8b 40 20          	mov    0x20(%rax),%rax
  80fceb:	be fb ff ff ff       	mov    $0xfffffffb,%esi
  80fcf0:	48 89 c7             	mov    %rax,%rdi
  80fcf3:	ff d2                	callq  *%rdx

      pcb2 = pcb->next;
  80fcf5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fcf9:	48 8b 40 10          	mov    0x10(%rax),%rax
  80fcfd:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_TCP_PCB, pcb);
  80fd01:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd05:	48 89 c6             	mov    %rax,%rsi
  80fd08:	bf 02 00 00 00       	mov    $0x2,%edi
  80fd0d:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  80fd14:	00 00 00 
  80fd17:	ff d0                	callq  *%rax
      pcb = pcb2;
  80fd19:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80fd1d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80fd21:	e9 8d 00 00 00       	jmpq   80fdb3 <tcp_slowtmr+0x6c5>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  80fd26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd2a:	0f b6 40 3c          	movzbl 0x3c(%rax),%eax
  80fd2e:	8d 50 01             	lea    0x1(%rax),%edx
  80fd31:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd35:	88 50 3c             	mov    %dl,0x3c(%rax)
      if (pcb->polltmr >= pcb->pollinterval) {
  80fd38:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd3c:	0f b6 50 3c          	movzbl 0x3c(%rax),%edx
  80fd40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd44:	0f b6 40 3d          	movzbl 0x3d(%rax),%eax
  80fd48:	38 c2                	cmp    %al,%dl
  80fd4a:	72 53                	jb     80fd9f <tcp_slowtmr+0x6b1>
        pcb->polltmr = 0;
  80fd4c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd50:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  80fd54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd58:	48 8b 80 c0 00 00 00 	mov    0xc0(%rax),%rax
  80fd5f:	48 85 c0             	test   %rax,%rax
  80fd62:	74 22                	je     80fd86 <tcp_slowtmr+0x698>
  80fd64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd68:	48 8b 88 c0 00 00 00 	mov    0xc0(%rax),%rcx
  80fd6f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd73:	48 8b 40 20          	mov    0x20(%rax),%rax
  80fd77:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80fd7b:	48 89 d6             	mov    %rdx,%rsi
  80fd7e:	48 89 c7             	mov    %rax,%rdi
  80fd81:	ff d1                	callq  *%rcx
  80fd83:	88 45 ee             	mov    %al,-0x12(%rbp)
        if (err == ERR_OK) {
  80fd86:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  80fd8a:	75 13                	jne    80fd9f <tcp_slowtmr+0x6b1>
          tcp_output(pcb);
  80fd8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fd90:	48 89 c7             	mov    %rax,%rdi
  80fd93:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  80fd9a:	00 00 00 
  80fd9d:	ff d0                	callq  *%rax
        }
      }
      
      prev = pcb;
  80fd9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fda3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb = pcb->next;
  80fda7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fdab:	48 8b 40 10          	mov    0x10(%rax),%rax
  80fdaf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  80fdb3:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80fdb8:	0f 85 75 f9 ff ff    	jne    80f733 <tcp_slowtmr+0x45>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  80fdbe:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80fdc5:	00 
  pcb = tcp_tw_pcbs;
  80fdc6:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80fdcd:	00 00 00 
  80fdd0:	48 8b 00             	mov    (%rax),%rax
  80fdd3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  while (pcb != NULL) {
  80fdd7:	e9 65 01 00 00       	jmpq   80ff41 <tcp_slowtmr+0x853>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80fddc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fde0:	8b 40 18             	mov    0x18(%rax),%eax
  80fde3:	83 f8 0a             	cmp    $0xa,%eax
  80fde6:	74 2a                	je     80fe12 <tcp_slowtmr+0x724>
  80fde8:	48 ba e0 22 82 00 00 	movabs $0x8222e0,%rdx
  80fdef:	00 00 00 
  80fdf2:	be e5 02 00 00       	mov    $0x2e5,%esi
  80fdf7:	48 bf 7b 21 82 00 00 	movabs $0x82217b,%rdi
  80fdfe:	00 00 00 
  80fe01:	b8 00 00 00 00       	mov    $0x0,%eax
  80fe06:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80fe0d:	00 00 00 
  80fe10:	ff d1                	callq  *%rcx
    pcb_remove = 0;
  80fe12:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  80fe16:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  80fe1d:	00 00 00 
  80fe20:	8b 10                	mov    (%rax),%edx
  80fe22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe26:	8b 40 38             	mov    0x38(%rax),%eax
  80fe29:	89 d1                	mov    %edx,%ecx
  80fe2b:	29 c1                	sub    %eax,%ecx
  80fe2d:	89 c8                	mov    %ecx,%eax
  80fe2f:	3d f0 00 00 00       	cmp    $0xf0,%eax
  80fe34:	76 04                	jbe    80fe3a <tcp_slowtmr+0x74c>
      ++pcb_remove;
  80fe36:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  80fe3a:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  80fe3e:	0f 84 e9 00 00 00    	je     80ff2d <tcp_slowtmr+0x83f>
      tcp_pcb_purge(pcb);      
  80fe44:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe48:	48 89 c7             	mov    %rax,%rdi
  80fe4b:	48 b8 e6 05 81 00 00 	movabs $0x8105e6,%rax
  80fe52:	00 00 00 
  80fe55:	ff d0                	callq  *%rax
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  80fe57:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80fe5c:	74 4f                	je     80fead <tcp_slowtmr+0x7bf>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  80fe5e:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80fe65:	00 00 00 
  80fe68:	48 8b 00             	mov    (%rax),%rax
  80fe6b:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80fe6f:	75 2a                	jne    80fe9b <tcp_slowtmr+0x7ad>
  80fe71:	48 ba 10 23 82 00 00 	movabs $0x822310,%rdx
  80fe78:	00 00 00 
  80fe7b:	be f4 02 00 00       	mov    $0x2f4,%esi
  80fe80:	48 bf 7b 21 82 00 00 	movabs $0x82217b,%rdi
  80fe87:	00 00 00 
  80fe8a:	b8 00 00 00 00       	mov    $0x0,%eax
  80fe8f:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80fe96:	00 00 00 
  80fe99:	ff d1                	callq  *%rcx
        prev->next = pcb->next;
  80fe9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fe9f:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80fea3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80fea7:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80feab:	eb 52                	jmp    80feff <tcp_slowtmr+0x811>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  80fead:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80feb4:	00 00 00 
  80feb7:	48 8b 00             	mov    (%rax),%rax
  80feba:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80febe:	74 2a                	je     80feea <tcp_slowtmr+0x7fc>
  80fec0:	48 ba 38 23 82 00 00 	movabs $0x822338,%rdx
  80fec7:	00 00 00 
  80feca:	be f8 02 00 00       	mov    $0x2f8,%esi
  80fecf:	48 bf 7b 21 82 00 00 	movabs $0x82217b,%rdi
  80fed6:	00 00 00 
  80fed9:	b8 00 00 00 00       	mov    $0x0,%eax
  80fede:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  80fee5:	00 00 00 
  80fee8:	ff d1                	callq  *%rcx
        tcp_tw_pcbs = pcb->next;
  80feea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80feee:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80fef2:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  80fef9:	00 00 00 
  80fefc:	48 89 10             	mov    %rdx,(%rax)
      }
      pcb2 = pcb->next;
  80feff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff03:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ff07:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      memp_free(MEMP_TCP_PCB, pcb);
  80ff0b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff0f:	48 89 c6             	mov    %rax,%rsi
  80ff12:	bf 02 00 00 00       	mov    $0x2,%edi
  80ff17:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  80ff1e:	00 00 00 
  80ff21:	ff d0                	callq  *%rax
      pcb = pcb2;
  80ff23:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80ff27:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ff2b:	eb 14                	jmp    80ff41 <tcp_slowtmr+0x853>
    } else {
      prev = pcb;
  80ff2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff31:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb = pcb->next;
  80ff35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff39:	48 8b 40 10          	mov    0x10(%rax),%rax
  80ff3d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  80ff41:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80ff46:	0f 85 90 fe ff ff    	jne    80fddc <tcp_slowtmr+0x6ee>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  80ff4c:	c9                   	leaveq 
  80ff4d:	c3                   	retq   

000000000080ff4e <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  80ff4e:	55                   	push   %rbp
  80ff4f:	48 89 e5             	mov    %rsp,%rbp
  80ff52:	48 83 ec 10          	sub    $0x10,%rsp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80ff56:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  80ff5d:	00 00 00 
  80ff60:	48 8b 00             	mov    (%rax),%rax
  80ff63:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80ff67:	e9 f2 00 00 00       	jmpq   81005e <tcp_fasttmr+0x110>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  80ff6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff70:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  80ff77:	48 85 c0             	test   %rax,%rax
  80ff7a:	0f 84 85 00 00 00    	je     810005 <tcp_fasttmr+0xb7>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80ff80:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff84:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  80ff8b:	48 85 c0             	test   %rax,%rax
  80ff8e:	74 32                	je     80ffc2 <tcp_fasttmr+0x74>
  80ff90:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff94:	4c 8b 80 a8 00 00 00 	mov    0xa8(%rax),%r8
  80ff9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ff9f:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  80ffa6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ffaa:	48 8b 40 20          	mov    0x20(%rax),%rax
  80ffae:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  80ffb2:	b9 00 00 00 00       	mov    $0x0,%ecx
  80ffb7:	48 89 c7             	mov    %rax,%rdi
  80ffba:	41 ff d0             	callq  *%r8
  80ffbd:	88 45 f7             	mov    %al,-0x9(%rbp)
  80ffc0:	eb 2e                	jmp    80fff0 <tcp_fasttmr+0xa2>
  80ffc2:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  80ffc6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ffca:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  80ffd1:	48 85 c0             	test   %rax,%rax
  80ffd4:	74 1a                	je     80fff0 <tcp_fasttmr+0xa2>
  80ffd6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80ffda:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  80ffe1:	48 89 c7             	mov    %rax,%rdi
  80ffe4:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  80ffeb:	00 00 00 
  80ffee:	ff d0                	callq  *%rax
      if (err == ERR_OK) {
  80fff0:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80fff4:	75 0f                	jne    810005 <tcp_fasttmr+0xb7>
        pcb->refused_data = NULL;
  80fff6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80fffa:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  810001:	00 00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  810005:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810009:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81000d:	0f b6 c0             	movzbl %al,%eax
  810010:	83 e0 01             	and    $0x1,%eax
  810013:	84 c0                	test   %al,%al
  810015:	74 3b                	je     810052 <tcp_fasttmr+0x104>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  810017:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81001b:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81001f:	89 c2                	mov    %eax,%edx
  810021:	83 ca 02             	or     $0x2,%edx
  810024:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810028:	88 50 2c             	mov    %dl,0x2c(%rax)
  81002b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81002f:	48 89 c7             	mov    %rax,%rdi
  810032:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  810039:	00 00 00 
  81003c:	ff d0                	callq  *%rax
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  81003e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810042:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  810046:	89 c2                	mov    %eax,%edx
  810048:	83 e2 fc             	and    $0xfffffffc,%edx
  81004b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81004f:	88 50 2c             	mov    %dl,0x2c(%rax)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  810052:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810056:	48 8b 40 10          	mov    0x10(%rax),%rax
  81005a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81005e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810063:	0f 85 03 ff ff ff    	jne    80ff6c <tcp_fasttmr+0x1e>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  810069:	c9                   	leaveq 
  81006a:	c3                   	retq   

000000000081006b <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  81006b:	55                   	push   %rbp
  81006c:	48 89 e5             	mov    %rsp,%rbp
  81006f:	48 83 ec 20          	sub    $0x20,%rsp
  810073:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t count = 0;
  810077:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  struct tcp_seg *next;
  while (seg != NULL) {
  81007b:	eb 29                	jmp    8100a6 <tcp_segs_free+0x3b>
    next = seg->next;
  81007d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810081:	48 8b 00             	mov    (%rax),%rax
  810084:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    count += tcp_seg_free(seg);
  810088:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81008c:	48 89 c7             	mov    %rax,%rdi
  81008f:	48 b8 b3 00 81 00 00 	movabs $0x8100b3,%rax
  810096:	00 00 00 
  810099:	ff d0                	callq  *%rax
  81009b:	00 45 ff             	add    %al,-0x1(%rbp)
    seg = next;
  81009e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8100a2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  8100a6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8100ab:	75 d0                	jne    81007d <tcp_segs_free+0x12>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
  8100ad:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  8100b1:	c9                   	leaveq 
  8100b2:	c3                   	retq   

00000000008100b3 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  8100b3:	55                   	push   %rbp
  8100b4:	48 89 e5             	mov    %rsp,%rbp
  8100b7:	48 83 ec 20          	sub    $0x20,%rsp
  8100bb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  u8_t count = 0;
  8100bf:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  
  if (seg != NULL) {
  8100c3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8100c8:	74 3f                	je     810109 <tcp_seg_free+0x56>
    if (seg->p != NULL) {
  8100ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8100ce:	48 8b 40 08          	mov    0x8(%rax),%rax
  8100d2:	48 85 c0             	test   %rax,%rax
  8100d5:	74 1a                	je     8100f1 <tcp_seg_free+0x3e>
      count = pbuf_free(seg->p);
  8100d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8100db:	48 8b 40 08          	mov    0x8(%rax),%rax
  8100df:	48 89 c7             	mov    %rax,%rdi
  8100e2:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  8100e9:	00 00 00 
  8100ec:	ff d0                	callq  *%rax
  8100ee:	88 45 ff             	mov    %al,-0x1(%rbp)
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  8100f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8100f5:	48 89 c6             	mov    %rax,%rsi
  8100f8:	bf 04 00 00 00       	mov    $0x4,%edi
  8100fd:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  810104:	00 00 00 
  810107:	ff d0                	callq  *%rax
  }
  return count;
  810109:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  81010d:	c9                   	leaveq 
  81010e:	c3                   	retq   

000000000081010f <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  81010f:	55                   	push   %rbp
  810110:	48 89 e5             	mov    %rsp,%rbp
  810113:	48 83 ec 10          	sub    $0x10,%rsp
  810117:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81011b:	89 f0                	mov    %esi,%eax
  81011d:	88 45 f4             	mov    %al,-0xc(%rbp)
  pcb->prio = prio;
  810120:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810124:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  810128:	88 50 1c             	mov    %dl,0x1c(%rax)
}
  81012b:	c9                   	leaveq 
  81012c:	c3                   	retq   

000000000081012d <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  81012d:	55                   	push   %rbp
  81012e:	48 89 e5             	mov    %rsp,%rbp
  810131:	48 83 ec 20          	sub    $0x20,%rsp
  810135:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  810139:	bf 04 00 00 00       	mov    $0x4,%edi
  81013e:	48 b8 41 ca 80 00 00 	movabs $0x80ca41,%rax
  810145:	00 00 00 
  810148:	ff d0                	callq  *%rax
  81014a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (cseg == NULL) {
  81014e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810153:	75 07                	jne    81015c <tcp_seg_copy+0x2f>
    return NULL;
  810155:	b8 00 00 00 00       	mov    $0x0,%eax
  81015a:	eb 3a                	jmp    810196 <tcp_seg_copy+0x69>
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  81015c:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  810160:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810164:	ba 28 00 00 00       	mov    $0x28,%edx
  810169:	48 89 ce             	mov    %rcx,%rsi
  81016c:	48 89 c7             	mov    %rax,%rdi
  81016f:	48 b8 fd 22 80 00 00 	movabs $0x8022fd,%rax
  810176:	00 00 00 
  810179:	ff d0                	callq  *%rax
  pbuf_ref(cseg->p);
  81017b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81017f:	48 8b 40 08          	mov    0x8(%rax),%rax
  810183:	48 89 c7             	mov    %rax,%rdi
  810186:	48 b8 0f db 80 00 00 	movabs $0x80db0f,%rax
  81018d:	00 00 00 
  810190:	ff d0                	callq  *%rax
  return cseg;
  810192:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  810196:	c9                   	leaveq 
  810197:	c3                   	retq   

0000000000810198 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  810198:	55                   	push   %rbp
  810199:	48 89 e5             	mov    %rsp,%rbp
  81019c:	48 83 ec 20          	sub    $0x20,%rsp
  8101a0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8101a4:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8101a8:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8101ac:	89 c8                	mov    %ecx,%eax
  8101ae:	88 45 e4             	mov    %al,-0x1c(%rbp)
  arg = arg;
  if (p != NULL) {
  8101b1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8101b6:	74 15                	je     8101cd <tcp_recv_null+0x35>
    pbuf_free(p);
  8101b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8101bc:	48 89 c7             	mov    %rax,%rdi
  8101bf:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  8101c6:	00 00 00 
  8101c9:	ff d0                	callq  *%rax
  8101cb:	eb 1b                	jmp    8101e8 <tcp_recv_null+0x50>
  } else if (err == ERR_OK) {
  8101cd:	80 7d e4 00          	cmpb   $0x0,-0x1c(%rbp)
  8101d1:	75 15                	jne    8101e8 <tcp_recv_null+0x50>
    return tcp_close(pcb);
  8101d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8101d7:	48 89 c7             	mov    %rax,%rdi
  8101da:	48 b8 89 e8 80 00 00 	movabs $0x80e889,%rax
  8101e1:	00 00 00 
  8101e4:	ff d0                	callq  *%rax
  8101e6:	eb 05                	jmp    8101ed <tcp_recv_null+0x55>
  }
  return ERR_OK;
  8101e8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8101ed:	c9                   	leaveq 
  8101ee:	c3                   	retq   

00000000008101ef <tcp_kill_prio>:
 *
 * @param prio minimum priority
 */
static void
tcp_kill_prio(u8_t prio)
{
  8101ef:	55                   	push   %rbp
  8101f0:	48 89 e5             	mov    %rsp,%rbp
  8101f3:	48 83 ec 30          	sub    $0x30,%rsp
  8101f7:	89 f8                	mov    %edi,%eax
  8101f9:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
  8101fc:	c6 45 eb 7f          	movb   $0x7f,-0x15(%rbp)
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  810200:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  inactive = NULL;
  810207:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  81020e:	00 
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  81020f:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  810216:	00 00 00 
  810219:	48 8b 00             	mov    (%rax),%rax
  81021c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810220:	eb 73                	jmp    810295 <tcp_kill_prio+0xa6>
    if (pcb->prio <= prio &&
  810222:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810226:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  81022a:	3a 45 dc             	cmp    -0x24(%rbp),%al
  81022d:	77 5a                	ja     810289 <tcp_kill_prio+0x9a>
       pcb->prio <= mprio &&
  81022f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810233:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  810237:	3a 45 eb             	cmp    -0x15(%rbp),%al
  81023a:	77 4d                	ja     810289 <tcp_kill_prio+0x9a>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  81023c:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  810243:	00 00 00 
  810246:	8b 10                	mov    (%rax),%edx
  810248:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81024c:	8b 40 38             	mov    0x38(%rax),%eax
  81024f:	89 d1                	mov    %edx,%ecx
  810251:	29 c1                	sub    %eax,%ecx
  810253:	89 c8                	mov    %ecx,%eax
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
  810255:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  810258:	72 2f                	jb     810289 <tcp_kill_prio+0x9a>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
  81025a:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  810261:	00 00 00 
  810264:	8b 10                	mov    (%rax),%edx
  810266:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81026a:	8b 40 38             	mov    0x38(%rax),%eax
  81026d:	89 d1                	mov    %edx,%ecx
  81026f:	29 c1                	sub    %eax,%ecx
  810271:	89 c8                	mov    %ecx,%eax
  810273:	89 45 ec             	mov    %eax,-0x14(%rbp)
      inactive = pcb;
  810276:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81027a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      mprio = pcb->prio;
  81027e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810282:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  810286:	88 45 eb             	mov    %al,-0x15(%rbp)
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  810289:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81028d:	48 8b 40 10          	mov    0x10(%rax),%rax
  810291:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810295:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81029a:	75 86                	jne    810222 <tcp_kill_prio+0x33>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  81029c:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8102a1:	74 13                	je     8102b6 <tcp_kill_prio+0xc7>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  8102a3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8102a7:	48 89 c7             	mov    %rax,%rdi
  8102aa:	48 b8 11 eb 80 00 00 	movabs $0x80eb11,%rax
  8102b1:	00 00 00 
  8102b4:	ff d0                	callq  *%rax
  }      
}
  8102b6:	c9                   	leaveq 
  8102b7:	c3                   	retq   

00000000008102b8 <tcp_kill_timewait>:
 * Kills the oldest connection that is in TIME_WAIT state.
 * Called from tcp_alloc() if no more connections are available.
 */
static void
tcp_kill_timewait(void)
{
  8102b8:	55                   	push   %rbp
  8102b9:	48 89 e5             	mov    %rsp,%rbp
  8102bc:	48 83 ec 20          	sub    $0x20,%rsp
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  8102c0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  inactive = NULL;
  8102c7:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8102ce:	00 
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8102cf:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  8102d6:	00 00 00 
  8102d9:	48 8b 00             	mov    (%rax),%rax
  8102dc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8102e0:	eb 4e                	jmp    810330 <tcp_kill_timewait+0x78>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8102e2:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  8102e9:	00 00 00 
  8102ec:	8b 10                	mov    (%rax),%edx
  8102ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8102f2:	8b 40 38             	mov    0x38(%rax),%eax
  8102f5:	89 d1                	mov    %edx,%ecx
  8102f7:	29 c1                	sub    %eax,%ecx
  8102f9:	89 c8                	mov    %ecx,%eax
  8102fb:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8102fe:	72 24                	jb     810324 <tcp_kill_timewait+0x6c>
      inactivity = tcp_ticks - pcb->tmr;
  810300:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  810307:	00 00 00 
  81030a:	8b 10                	mov    (%rax),%edx
  81030c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810310:	8b 40 38             	mov    0x38(%rax),%eax
  810313:	89 d1                	mov    %edx,%ecx
  810315:	29 c1                	sub    %eax,%ecx
  810317:	89 c8                	mov    %ecx,%eax
  810319:	89 45 ec             	mov    %eax,-0x14(%rbp)
      inactive = pcb;
  81031c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810320:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  810324:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810328:	48 8b 40 10          	mov    0x10(%rax),%rax
  81032c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810330:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810335:	75 ab                	jne    8102e2 <tcp_kill_timewait+0x2a>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  810337:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81033c:	74 13                	je     810351 <tcp_kill_timewait+0x99>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  81033e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810342:	48 89 c7             	mov    %rax,%rdi
  810345:	48 b8 11 eb 80 00 00 	movabs $0x80eb11,%rax
  81034c:	00 00 00 
  81034f:	ff d0                	callq  *%rax
  }      
}
  810351:	c9                   	leaveq 
  810352:	c3                   	retq   

0000000000810353 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  810353:	55                   	push   %rbp
  810354:	48 89 e5             	mov    %rsp,%rbp
  810357:	48 83 ec 20          	sub    $0x20,%rsp
  81035b:	89 f8                	mov    %edi,%eax
  81035d:	88 45 ec             	mov    %al,-0x14(%rbp)
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  810360:	bf 02 00 00 00       	mov    $0x2,%edi
  810365:	48 b8 41 ca 80 00 00 	movabs $0x80ca41,%rax
  81036c:	00 00 00 
  81036f:	ff d0                	callq  *%rax
  810371:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (pcb == NULL) {
  810375:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81037a:	75 4f                	jne    8103cb <tcp_alloc+0x78>
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
  81037c:	48 b8 b8 02 81 00 00 	movabs $0x8102b8,%rax
  810383:	00 00 00 
  810386:	ff d0                	callq  *%rax
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  810388:	bf 02 00 00 00       	mov    $0x2,%edi
  81038d:	48 b8 41 ca 80 00 00 	movabs $0x80ca41,%rax
  810394:	00 00 00 
  810397:	ff d0                	callq  *%rax
  810399:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (pcb == NULL) {
  81039d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8103a2:	75 27                	jne    8103cb <tcp_alloc+0x78>
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
  8103a4:	0f b6 45 ec          	movzbl -0x14(%rbp),%eax
  8103a8:	89 c7                	mov    %eax,%edi
  8103aa:	48 b8 ef 01 81 00 00 	movabs $0x8101ef,%rax
  8103b1:	00 00 00 
  8103b4:	ff d0                	callq  *%rax
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  8103b6:	bf 02 00 00 00       	mov    $0x2,%edi
  8103bb:	48 b8 41 ca 80 00 00 	movabs $0x80ca41,%rax
  8103c2:	00 00 00 
  8103c5:	ff d0                	callq  *%rax
  8103c7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    }
  }
  if (pcb != NULL) {
  8103cb:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8103d0:	0f 84 23 01 00 00    	je     8104f9 <tcp_alloc+0x1a6>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  8103d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103da:	ba e0 00 00 00       	mov    $0xe0,%edx
  8103df:	be 00 00 00 00       	mov    $0x0,%esi
  8103e4:	48 89 c7             	mov    %rax,%rdi
  8103e7:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  8103ee:	00 00 00 
  8103f1:	ff d0                	callq  *%rax
    pcb->prio = TCP_PRIO_NORMAL;
  8103f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103f7:	c6 40 1c 40          	movb   $0x40,0x1c(%rax)
    pcb->snd_buf = TCP_SND_BUF;
  8103fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8103ff:	66 c7 40 7a 40 5b    	movw   $0x5b40,0x7a(%rax)
    pcb->snd_queuelen = 0;
  810405:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810409:	66 c7 40 7c 00 00    	movw   $0x0,0x7c(%rax)
    pcb->rcv_wnd = TCP_WND;
  81040f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810413:	66 c7 40 34 c0 5d    	movw   $0x5dc0,0x34(%rax)
    pcb->rcv_ann_wnd = TCP_WND;
  810419:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81041d:	66 c7 40 36 c0 5d    	movw   $0x5dc0,0x36(%rax)
    pcb->tos = 0;
  810423:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810427:	c6 40 0a 00          	movb   $0x0,0xa(%rax)
    pcb->ttl = TCP_TTL;
  81042b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81042f:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  810433:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810437:	66 c7 40 40 18 02    	movw   $0x218,0x40(%rax)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  81043d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810441:	66 c7 40 50 06 00    	movw   $0x6,0x50(%rax)
    pcb->sa = 0;
  810447:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81044b:	66 c7 40 4c 00 00    	movw   $0x0,0x4c(%rax)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  810451:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810455:	66 c7 40 4e 06 00    	movw   $0x6,0x4e(%rax)
    pcb->rtime = -1;
  81045b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81045f:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
    pcb->cwnd = 1;
  810465:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810469:	66 c7 40 5a 01 00    	movw   $0x1,0x5a(%rax)
    iss = tcp_next_iss();
  81046f:	48 b8 e5 08 81 00 00 	movabs $0x8108e5,%rax
  810476:	00 00 00 
  810479:	ff d0                	callq  *%rax
  81047b:	89 45 f4             	mov    %eax,-0xc(%rbp)
    pcb->snd_wl2 = iss;
  81047e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810482:	8b 55 f4             	mov    -0xc(%rbp),%edx
  810485:	89 50 70             	mov    %edx,0x70(%rax)
    pcb->snd_nxt = iss;
  810488:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81048c:	8b 55 f4             	mov    -0xc(%rbp),%edx
  81048f:	89 50 60             	mov    %edx,0x60(%rax)
    pcb->snd_max = iss;
  810492:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810496:	8b 55 f4             	mov    -0xc(%rbp),%edx
  810499:	89 50 64             	mov    %edx,0x64(%rax)
    pcb->lastack = iss;
  81049c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104a0:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8104a3:	89 50 54             	mov    %edx,0x54(%rax)
    pcb->snd_lbb = iss;   
  8104a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104aa:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8104ad:	89 50 74             	mov    %edx,0x74(%rax)
    pcb->tmr = tcp_ticks;
  8104b0:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  8104b7:	00 00 00 
  8104ba:	8b 10                	mov    (%rax),%edx
  8104bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104c0:	89 50 38             	mov    %edx,0x38(%rax)

    pcb->polltmr = 0;
  8104c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104c7:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  8104cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104cf:	48 ba 98 01 81 00 00 	movabs $0x810198,%rdx
  8104d6:	00 00 00 
  8104d9:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  8104e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104e4:	c7 80 d0 00 00 00 00 	movl   $0x6ddd00,0xd0(%rax)
  8104eb:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  8104ee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8104f2:	c6 80 d9 00 00 00 00 	movb   $0x0,0xd9(%rax)
  }
  return pcb;
  8104f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8104fd:	c9                   	leaveq 
  8104fe:	c3                   	retq   

00000000008104ff <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  8104ff:	55                   	push   %rbp
  810500:	48 89 e5             	mov    %rsp,%rbp
  return tcp_alloc(TCP_PRIO_NORMAL);
  810503:	bf 40 00 00 00       	mov    $0x40,%edi
  810508:	48 b8 53 03 81 00 00 	movabs $0x810353,%rax
  81050f:	00 00 00 
  810512:	ff d0                	callq  *%rax
}
  810514:	5d                   	pop    %rbp
  810515:	c3                   	retq   

0000000000810516 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  810516:	55                   	push   %rbp
  810517:	48 89 e5             	mov    %rsp,%rbp
  81051a:	48 83 ec 10          	sub    $0x10,%rsp
  81051e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810522:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->callback_arg = arg;
  810526:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81052a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81052e:	48 89 50 20          	mov    %rdx,0x20(%rax)
}
  810532:	c9                   	leaveq 
  810533:	c3                   	retq   

0000000000810534 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  810534:	55                   	push   %rbp
  810535:	48 89 e5             	mov    %rsp,%rbp
  810538:	48 83 ec 10          	sub    $0x10,%rsp
  81053c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810540:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->recv = recv;
  810544:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810548:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81054c:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
}
  810553:	c9                   	leaveq 
  810554:	c3                   	retq   

0000000000810555 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  810555:	55                   	push   %rbp
  810556:	48 89 e5             	mov    %rsp,%rbp
  810559:	48 83 ec 10          	sub    $0x10,%rsp
  81055d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810561:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->sent = sent;
  810565:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810569:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81056d:	48 89 90 a0 00 00 00 	mov    %rdx,0xa0(%rax)
}
  810574:	c9                   	leaveq 
  810575:	c3                   	retq   

0000000000810576 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  810576:	55                   	push   %rbp
  810577:	48 89 e5             	mov    %rsp,%rbp
  81057a:	48 83 ec 10          	sub    $0x10,%rsp
  81057e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  810582:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pcb->errf = errf;
  810586:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81058a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81058e:	48 89 90 c8 00 00 00 	mov    %rdx,0xc8(%rax)
}
  810595:	c9                   	leaveq 
  810596:	c3                   	retq   

0000000000810597 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  810597:	55                   	push   %rbp
  810598:	48 89 e5             	mov    %rsp,%rbp
  81059b:	48 83 ec 10          	sub    $0x10,%rsp
  81059f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8105a3:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  8105a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8105ab:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8105af:	48 89 50 30          	mov    %rdx,0x30(%rax)
}
  8105b3:	c9                   	leaveq 
  8105b4:	c3                   	retq   

00000000008105b5 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  8105b5:	55                   	push   %rbp
  8105b6:	48 89 e5             	mov    %rsp,%rbp
  8105b9:	48 83 ec 18          	sub    $0x18,%rsp
  8105bd:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8105c1:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8105c5:	89 d0                	mov    %edx,%eax
  8105c7:	88 45 ec             	mov    %al,-0x14(%rbp)
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  8105ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8105ce:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8105d2:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  8105d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8105dd:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  8105e1:	88 50 3d             	mov    %dl,0x3d(%rax)
}
  8105e4:	c9                   	leaveq 
  8105e5:	c3                   	retq   

00000000008105e6 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  8105e6:	55                   	push   %rbp
  8105e7:	48 89 e5             	mov    %rsp,%rbp
  8105ea:	48 83 ec 10          	sub    $0x10,%rsp
  8105ee:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (pcb->state != CLOSED &&
  8105f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8105f6:	8b 40 18             	mov    0x18(%rax),%eax
  8105f9:	85 c0                	test   %eax,%eax
  8105fb:	0f 84 e5 00 00 00    	je     8106e6 <tcp_pcb_purge+0x100>
     pcb->state != TIME_WAIT &&
  810601:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810605:	8b 40 18             	mov    0x18(%rax),%eax
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
  810608:	83 f8 0a             	cmp    $0xa,%eax
  81060b:	0f 84 d5 00 00 00    	je     8106e6 <tcp_pcb_purge+0x100>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {
  810611:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810615:	8b 40 18             	mov    0x18(%rax),%eax
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
     pcb->state != TIME_WAIT &&
  810618:	83 f8 01             	cmp    $0x1,%eax
  81061b:	0f 84 c5 00 00 00    	je     8106e6 <tcp_pcb_purge+0x100>
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  810621:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810625:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81062c:	48 85 c0             	test   %rax,%rax
  81062f:	74 29                	je     81065a <tcp_pcb_purge+0x74>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  810631:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810635:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81063c:	48 89 c7             	mov    %rax,%rdi
  81063f:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  810646:	00 00 00 
  810649:	ff d0                	callq  *%rax
      pcb->refused_data = NULL;
  81064b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81064f:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  810656:	00 00 00 00 
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  81065a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81065e:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)

    tcp_segs_free(pcb->ooseq);
  810664:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810668:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81066f:	48 89 c7             	mov    %rax,%rdi
  810672:	48 b8 6b 00 81 00 00 	movabs $0x81006b,%rax
  810679:	00 00 00 
  81067c:	ff d0                	callq  *%rax
    pcb->ooseq = NULL;
  81067e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810682:	48 c7 80 90 00 00 00 	movq   $0x0,0x90(%rax)
  810689:	00 00 00 00 
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  81068d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810691:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  810698:	48 89 c7             	mov    %rax,%rdi
  81069b:	48 b8 6b 00 81 00 00 	movabs $0x81006b,%rax
  8106a2:	00 00 00 
  8106a5:	ff d0                	callq  *%rax
    tcp_segs_free(pcb->unacked);
  8106a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106ab:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8106b2:	48 89 c7             	mov    %rax,%rdi
  8106b5:	48 b8 6b 00 81 00 00 	movabs $0x81006b,%rax
  8106bc:	00 00 00 
  8106bf:	ff d0                	callq  *%rax
    pcb->unacked = pcb->unsent = NULL;
  8106c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106c5:	48 c7 80 80 00 00 00 	movq   $0x0,0x80(%rax)
  8106cc:	00 00 00 00 
  8106d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106d4:	48 8b 90 80 00 00 00 	mov    0x80(%rax),%rdx
  8106db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106df:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
  }
}
  8106e6:	c9                   	leaveq 
  8106e7:	c3                   	retq   

00000000008106e8 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  8106e8:	55                   	push   %rbp
  8106e9:	48 89 e5             	mov    %rsp,%rbp
  8106ec:	48 83 ec 10          	sub    $0x10,%rsp
  8106f0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8106f4:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  TCP_RMV(pcblist, pcb);
  8106f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8106fc:	48 8b 00             	mov    (%rax),%rax
  8106ff:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  810703:	75 17                	jne    81071c <tcp_pcb_remove+0x34>
  810705:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810709:	48 8b 00             	mov    (%rax),%rax
  81070c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  810710:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810714:	48 89 10             	mov    %rdx,(%rax)
  810717:	e9 8e 00 00 00       	jmpq   8107aa <tcp_pcb_remove+0xc2>
  81071c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810720:	48 8b 10             	mov    (%rax),%rdx
  810723:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81072a:	00 00 00 
  81072d:	48 89 10             	mov    %rdx,(%rax)
  810730:	eb 66                	jmp    810798 <tcp_pcb_remove+0xb0>
  810732:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810739:	00 00 00 
  81073c:	48 8b 00             	mov    (%rax),%rax
  81073f:	48 8b 40 10          	mov    0x10(%rax),%rax
  810743:	48 85 c0             	test   %rax,%rax
  810746:	74 32                	je     81077a <tcp_pcb_remove+0x92>
  810748:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81074f:	00 00 00 
  810752:	48 8b 00             	mov    (%rax),%rax
  810755:	48 8b 40 10          	mov    0x10(%rax),%rax
  810759:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  81075d:	75 1b                	jne    81077a <tcp_pcb_remove+0x92>
  81075f:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810766:	00 00 00 
  810769:	48 8b 00             	mov    (%rax),%rax
  81076c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  810770:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  810774:	48 89 50 10          	mov    %rdx,0x10(%rax)
  810778:	eb 30                	jmp    8107aa <tcp_pcb_remove+0xc2>
  81077a:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810781:	00 00 00 
  810784:	48 8b 00             	mov    (%rax),%rax
  810787:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81078b:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  810792:	00 00 00 
  810795:	48 89 10             	mov    %rdx,(%rax)
  810798:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81079f:	00 00 00 
  8107a2:	48 8b 00             	mov    (%rax),%rax
  8107a5:	48 85 c0             	test   %rax,%rax
  8107a8:	75 88                	jne    810732 <tcp_pcb_remove+0x4a>
  8107aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8107ae:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8107b5:	00 

  tcp_pcb_purge(pcb);
  8107b6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8107ba:	48 89 c7             	mov    %rax,%rdi
  8107bd:	48 b8 e6 05 81 00 00 	movabs $0x8105e6,%rax
  8107c4:	00 00 00 
  8107c7:	ff d0                	callq  *%rax
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  8107c9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8107cd:	8b 40 18             	mov    0x18(%rax),%eax
  8107d0:	83 f8 0a             	cmp    $0xa,%eax
  8107d3:	74 45                	je     81081a <tcp_pcb_remove+0x132>
     pcb->state != LISTEN &&
  8107d5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8107d9:	8b 40 18             	mov    0x18(%rax),%eax
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  8107dc:	83 f8 01             	cmp    $0x1,%eax
  8107df:	74 39                	je     81081a <tcp_pcb_remove+0x132>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  8107e1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8107e5:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
  8107e9:	0f b6 c0             	movzbl %al,%eax
  8107ec:	83 e0 01             	and    $0x1,%eax
  8107ef:	84 c0                	test   %al,%al
  8107f1:	74 27                	je     81081a <tcp_pcb_remove+0x132>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  8107f3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8107f7:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  8107fb:	89 c2                	mov    %eax,%edx
  8107fd:	83 ca 02             	or     $0x2,%edx
  810800:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810804:	88 50 2c             	mov    %dl,0x2c(%rax)
    tcp_output(pcb);
  810807:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81080b:	48 89 c7             	mov    %rax,%rdi
  81080e:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  810815:	00 00 00 
  810818:	ff d0                	callq  *%rax
  }

  if (pcb->state != LISTEN) {
  81081a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81081e:	8b 40 18             	mov    0x18(%rax),%eax
  810821:	83 f8 01             	cmp    $0x1,%eax
  810824:	0f 84 ae 00 00 00    	je     8108d8 <tcp_pcb_remove+0x1f0>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  81082a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81082e:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  810835:	48 85 c0             	test   %rax,%rax
  810838:	74 2a                	je     810864 <tcp_pcb_remove+0x17c>
  81083a:	48 ba 5e 23 82 00 00 	movabs $0x82235e,%rdx
  810841:	00 00 00 
  810844:	be b4 04 00 00       	mov    $0x4b4,%esi
  810849:	48 bf 7b 21 82 00 00 	movabs $0x82217b,%rdi
  810850:	00 00 00 
  810853:	b8 00 00 00 00       	mov    $0x0,%eax
  810858:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81085f:	00 00 00 
  810862:	ff d1                	callq  *%rcx
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  810864:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  810868:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81086f:	48 85 c0             	test   %rax,%rax
  810872:	74 2a                	je     81089e <tcp_pcb_remove+0x1b6>
  810874:	48 ba 76 23 82 00 00 	movabs $0x822376,%rdx
  81087b:	00 00 00 
  81087e:	be b5 04 00 00       	mov    $0x4b5,%esi
  810883:	48 bf 7b 21 82 00 00 	movabs $0x82217b,%rdi
  81088a:	00 00 00 
  81088d:	b8 00 00 00 00       	mov    $0x0,%eax
  810892:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  810899:	00 00 00 
  81089c:	ff d1                	callq  *%rcx
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  81089e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8108a2:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  8108a9:	48 85 c0             	test   %rax,%rax
  8108ac:	74 2a                	je     8108d8 <tcp_pcb_remove+0x1f0>
  8108ae:	48 ba 8f 23 82 00 00 	movabs $0x82238f,%rdx
  8108b5:	00 00 00 
  8108b8:	be b7 04 00 00       	mov    $0x4b7,%esi
  8108bd:	48 bf 7b 21 82 00 00 	movabs $0x82217b,%rdi
  8108c4:	00 00 00 
  8108c7:	b8 00 00 00 00       	mov    $0x0,%eax
  8108cc:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8108d3:	00 00 00 
  8108d6:	ff d1                	callq  *%rcx
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  8108d8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8108dc:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  8108e3:	c9                   	leaveq 
  8108e4:	c3                   	retq   

00000000008108e5 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  8108e5:	55                   	push   %rbp
  8108e6:	48 89 e5             	mov    %rsp,%rbp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  8108e9:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  8108f0:	00 00 00 
  8108f3:	8b 10                	mov    (%rax),%edx
  8108f5:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  8108fc:	00 00 00 
  8108ff:	8b 00                	mov    (%rax),%eax
  810901:	01 c2                	add    %eax,%edx
  810903:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  81090a:	00 00 00 
  81090d:	89 10                	mov    %edx,(%rax)
  return iss;
  81090f:	48 b8 f0 81 82 00 00 	movabs $0x8281f0,%rax
  810916:	00 00 00 
  810919:	8b 00                	mov    (%rax),%eax
}
  81091b:	5d                   	pop    %rbp
  81091c:	c3                   	retq   

000000000081091d <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  81091d:	55                   	push   %rbp
  81091e:	48 89 e5             	mov    %rsp,%rbp
  810921:	48 83 ec 20          	sub    $0x20,%rsp
  810925:	89 f8                	mov    %edi,%eax
  810927:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81092b:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  81092f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810933:	48 89 c7             	mov    %rax,%rdi
  810936:	48 b8 20 0a 81 00 00 	movabs $0x810a20,%rax
  81093d:	00 00 00 
  810940:	ff d0                	callq  *%rax
  810942:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if ((outif != NULL) && (outif->mtu != 0)) {
  810946:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81094b:	74 2d                	je     81097a <tcp_eff_send_mss+0x5d>
  81094d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810951:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  810955:	66 85 c0             	test   %ax,%ax
  810958:	74 20                	je     81097a <tcp_eff_send_mss+0x5d>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  81095a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81095e:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  810962:	83 e8 28             	sub    $0x28,%eax
  810965:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  810969:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  81096d:	66 39 45 f6          	cmp    %ax,-0xa(%rbp)
  810971:	66 0f 46 45 f6       	cmovbe -0xa(%rbp),%ax
  810976:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
  }
  return sendmss;
  81097a:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
}
  81097e:	c9                   	leaveq 
  81097f:	c3                   	retq   

0000000000810980 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  810980:	55                   	push   %rbp
  810981:	48 89 e5             	mov    %rsp,%rbp
  810984:	48 83 ec 20          	sub    $0x20,%rsp
  810988:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81098c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  u32_t addr2test;

  addr2test = addr->addr;
  810990:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810994:	8b 00                	mov    (%rax),%eax
  810996:	89 45 fc             	mov    %eax,-0x4(%rbp)
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  810999:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  81099d:	74 06                	je     8109a5 <ip_addr_isbroadcast+0x25>
  81099f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8109a3:	75 07                	jne    8109ac <ip_addr_isbroadcast+0x2c>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  8109a5:	b8 01 00 00 00       	mov    $0x1,%eax
  8109aa:	eb 6f                	jmp    810a1b <ip_addr_isbroadcast+0x9b>
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  8109ac:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8109b0:	0f b6 40 4a          	movzbl 0x4a(%rax),%eax
  8109b4:	0f b6 c0             	movzbl %al,%eax
  8109b7:	83 e0 02             	and    $0x2,%eax
  8109ba:	85 c0                	test   %eax,%eax
  8109bc:	75 07                	jne    8109c5 <ip_addr_isbroadcast+0x45>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  8109be:	b8 00 00 00 00       	mov    $0x0,%eax
  8109c3:	eb 56                	jmp    810a1b <ip_addr_isbroadcast+0x9b>
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  8109c5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8109c9:	8b 40 08             	mov    0x8(%rax),%eax
  8109cc:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8109cf:	75 07                	jne    8109d8 <ip_addr_isbroadcast+0x58>
    return 0;
  8109d1:	b8 00 00 00 00       	mov    $0x0,%eax
  8109d6:	eb 43                	jmp    810a1b <ip_addr_isbroadcast+0x9b>
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  8109d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8109dc:	8b 10                	mov    (%rax),%edx
  8109de:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8109e2:	8b 40 08             	mov    0x8(%rax),%eax
  8109e5:	31 c2                	xor    %eax,%edx
  8109e7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8109eb:	8b 40 0c             	mov    0xc(%rax),%eax
  8109ee:	21 d0                	and    %edx,%eax
  8109f0:	85 c0                	test   %eax,%eax
  8109f2:	75 22                	jne    810a16 <ip_addr_isbroadcast+0x96>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  8109f4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8109f8:	8b 40 0c             	mov    0xc(%rax),%eax
  8109fb:	f7 d0                	not    %eax
  8109fd:	89 c2                	mov    %eax,%edx
  8109ff:	23 55 fc             	and    -0x4(%rbp),%edx
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
  810a02:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810a06:	8b 40 0c             	mov    0xc(%rax),%eax
  810a09:	f7 d0                	not    %eax
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  810a0b:	39 c2                	cmp    %eax,%edx
  810a0d:	75 07                	jne    810a16 <ip_addr_isbroadcast+0x96>
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  810a0f:	b8 01 00 00 00       	mov    $0x1,%eax
  810a14:	eb 05                	jmp    810a1b <ip_addr_isbroadcast+0x9b>
  else
    return 0;
  810a16:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810a1b:	c9                   	leaveq 
  810a1c:	c3                   	retq   
  810a1d:	00 00                	add    %al,(%rax)
	...

0000000000810a20 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  810a20:	55                   	push   %rbp
  810a21:	48 89 e5             	mov    %rsp,%rbp
  810a24:	48 83 ec 20          	sub    $0x20,%rsp
  810a28:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  810a2c:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  810a33:	00 00 00 
  810a36:	48 8b 00             	mov    (%rax),%rax
  810a39:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810a3d:	eb 44                	jmp    810a83 <ip_route+0x63>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  810a3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a43:	48 89 c7             	mov    %rax,%rdi
  810a46:	48 b8 33 d0 80 00 00 	movabs $0x80d033,%rax
  810a4d:	00 00 00 
  810a50:	ff d0                	callq  *%rax
  810a52:	84 c0                	test   %al,%al
  810a54:	74 22                	je     810a78 <ip_route+0x58>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  810a56:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810a5a:	8b 10                	mov    (%rax),%edx
  810a5c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a60:	8b 40 08             	mov    0x8(%rax),%eax
  810a63:	31 c2                	xor    %eax,%edx
  810a65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a69:	8b 40 0c             	mov    0xc(%rax),%eax
  810a6c:	21 d0                	and    %edx,%eax
  810a6e:	85 c0                	test   %eax,%eax
  810a70:	75 06                	jne    810a78 <ip_route+0x58>
        /* return netif on which to forward IP packet */
        return netif;
  810a72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a76:	eb 58                	jmp    810ad0 <ip_route+0xb0>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  810a78:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  810a7c:	48 8b 00             	mov    (%rax),%rax
  810a7f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  810a83:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  810a88:	75 b5                	jne    810a3f <ip_route+0x1f>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  810a8a:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  810a91:	00 00 00 
  810a94:	48 8b 00             	mov    (%rax),%rax
  810a97:	48 85 c0             	test   %rax,%rax
  810a9a:	74 20                	je     810abc <ip_route+0x9c>
  810a9c:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  810aa3:	00 00 00 
  810aa6:	48 8b 00             	mov    (%rax),%rax
  810aa9:	48 89 c7             	mov    %rax,%rdi
  810aac:	48 b8 33 d0 80 00 00 	movabs $0x80d033,%rax
  810ab3:	00 00 00 
  810ab6:	ff d0                	callq  *%rax
  810ab8:	84 c0                	test   %al,%al
  810aba:	75 07                	jne    810ac3 <ip_route+0xa3>
    LWIP_DEBUGF(IP_DEBUG | 2, ("ip_route: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  810abc:	b8 00 00 00 00       	mov    $0x0,%eax
  810ac1:	eb 0d                	jmp    810ad0 <ip_route+0xb0>
  }
  /* no matching netif found, use default netif */
  return netif_default;
  810ac3:	48 b8 10 b0 b5 00 00 	movabs $0xb5b010,%rax
  810aca:	00 00 00 
  810acd:	48 8b 00             	mov    (%rax),%rax
}
  810ad0:	c9                   	leaveq 
  810ad1:	c3                   	retq   

0000000000810ad2 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  810ad2:	55                   	push   %rbp
  810ad3:	48 89 e5             	mov    %rsp,%rbp
  810ad6:	53                   	push   %rbx
  810ad7:	48 83 ec 38          	sub    $0x38,%rsp
  810adb:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  810adf:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct ip_hdr *iphdr;
  struct netif *netif;
  u16_t iphdr_hlen;
  u16_t iphdr_len;
#if LWIP_DHCP
  int check_ip_src=1;
  810ae3:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%rbp)

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  810aea:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810aee:	48 8b 40 08          	mov    0x8(%rax),%rax
  810af2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (IPH_V(iphdr) != 4) {
  810af6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810afa:	0f b7 00             	movzwl (%rax),%eax
  810afd:	0f b7 c0             	movzwl %ax,%eax
  810b00:	89 c7                	mov    %eax,%edi
  810b02:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  810b09:	00 00 00 
  810b0c:	ff d0                	callq  *%rax
  810b0e:	66 c1 e8 0c          	shr    $0xc,%ax
  810b12:	66 83 f8 04          	cmp    $0x4,%ax
  810b16:	74 1d                	je     810b35 <ip_input+0x63>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  810b18:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810b1c:	48 89 c7             	mov    %rax,%rdi
  810b1f:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  810b26:	00 00 00 
  810b29:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  810b2b:	b8 00 00 00 00       	mov    $0x0,%eax
  810b30:	e9 1b 04 00 00       	jmpq   810f50 <ip_input+0x47e>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  810b35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810b39:	0f b7 00             	movzwl (%rax),%eax
  810b3c:	0f b7 c0             	movzwl %ax,%eax
  810b3f:	89 c7                	mov    %eax,%edi
  810b41:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  810b48:	00 00 00 
  810b4b:	ff d0                	callq  *%rax
  810b4d:	66 c1 e8 08          	shr    $0x8,%ax
  810b51:	83 e0 0f             	and    $0xf,%eax
  810b54:	66 89 45 d6          	mov    %ax,-0x2a(%rbp)
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  810b58:	66 c1 65 d6 02       	shlw   $0x2,-0x2a(%rbp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  810b5d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810b61:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  810b65:	0f b7 c0             	movzwl %ax,%eax
  810b68:	89 c7                	mov    %eax,%edi
  810b6a:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  810b71:	00 00 00 
  810b74:	ff d0                	callq  *%rax
  810b76:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  810b7a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810b7e:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  810b82:	66 3b 45 d6          	cmp    -0x2a(%rbp),%ax
  810b86:	72 0e                	jb     810b96 <ip_input+0xc4>
  810b88:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810b8c:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  810b90:	66 3b 45 d4          	cmp    -0x2c(%rbp),%ax
  810b94:	73 1d                	jae    810bb3 <ip_input+0xe1>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  810b96:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810b9a:	48 89 c7             	mov    %rax,%rdi
  810b9d:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  810ba4:	00 00 00 
  810ba7:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  810ba9:	b8 00 00 00 00       	mov    $0x0,%eax
  810bae:	e9 9d 03 00 00       	jmpq   810f50 <ip_input+0x47e>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  810bb3:	0f b7 55 d6          	movzwl -0x2a(%rbp),%edx
  810bb7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810bbb:	89 d6                	mov    %edx,%esi
  810bbd:	48 89 c7             	mov    %rax,%rdi
  810bc0:	48 b8 76 27 81 00 00 	movabs $0x812776,%rax
  810bc7:	00 00 00 
  810bca:	ff d0                	callq  *%rax
  810bcc:	66 85 c0             	test   %ax,%ax
  810bcf:	74 1d                	je     810bee <ip_input+0x11c>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  810bd1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810bd5:	48 89 c7             	mov    %rax,%rdi
  810bd8:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  810bdf:	00 00 00 
  810be2:	ff d0                	callq  *%rax
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  810be4:	b8 00 00 00 00       	mov    $0x0,%eax
  810be9:	e9 62 03 00 00       	jmpq   810f50 <ip_input+0x47e>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  810bee:	0f b7 55 d4          	movzwl -0x2c(%rbp),%edx
  810bf2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810bf6:	89 d6                	mov    %edx,%esi
  810bf8:	48 89 c7             	mov    %rax,%rdi
  810bfb:	48 b8 1f d5 80 00 00 	movabs $0x80d51f,%rax
  810c02:	00 00 00 
  810c05:	ff d0                	callq  *%rax
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
  810c07:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%rbp)
    netif = inp;
  810c0e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  810c12:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  810c16:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810c1a:	48 89 c7             	mov    %rax,%rdi
  810c1d:	48 b8 33 d0 80 00 00 	movabs $0x80d033,%rax
  810c24:	00 00 00 
  810c27:	ff d0                	callq  *%rax
  810c29:	84 c0                	test   %al,%al
  810c2b:	74 4c                	je     810c79 <ip_input+0x1a7>
  810c2d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810c31:	48 83 c0 08          	add    $0x8,%rax
  810c35:	48 85 c0             	test   %rax,%rax
  810c38:	74 3f                	je     810c79 <ip_input+0x1a7>
  810c3a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810c3e:	8b 40 08             	mov    0x8(%rax),%eax
  810c41:	85 c0                	test   %eax,%eax
  810c43:	74 34                	je     810c79 <ip_input+0x1a7>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  810c45:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810c49:	8b 50 10             	mov    0x10(%rax),%edx
  810c4c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810c50:	8b 40 08             	mov    0x8(%rax),%eax
  810c53:	39 c2                	cmp    %eax,%edx
  810c55:	74 6f                	je     810cc6 <ip_input+0x1f4>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  810c57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810c5b:	48 8d 50 10          	lea    0x10(%rax),%rdx
  810c5f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810c63:	48 89 c6             	mov    %rax,%rsi
  810c66:	48 89 d7             	mov    %rdx,%rdi
  810c69:	48 b8 80 09 81 00 00 	movabs $0x810980,%rax
  810c70:	00 00 00 
  810c73:	ff d0                	callq  *%rax
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  810c75:	84 c0                	test   %al,%al
  810c77:	75 4d                	jne    810cc6 <ip_input+0x1f4>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  810c79:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  810c7d:	74 1a                	je     810c99 <ip_input+0x1c7>
        first = 0;
  810c7f:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
        netif = netif_list;
  810c86:	48 b8 08 b0 b5 00 00 	movabs $0xb5b008,%rax
  810c8d:	00 00 00 
  810c90:	48 8b 00             	mov    (%rax),%rax
  810c93:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  810c97:	eb 0b                	jmp    810ca4 <ip_input+0x1d2>
      } else {
        netif = netif->next;
  810c99:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810c9d:	48 8b 00             	mov    (%rax),%rax
  810ca0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      }
      if (netif == inp) {
  810ca4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810ca8:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  810cac:	75 0b                	jne    810cb9 <ip_input+0x1e7>
        netif = netif->next;
  810cae:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  810cb2:	48 8b 00             	mov    (%rax),%rax
  810cb5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      }
    } while(netif != NULL);
  810cb9:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  810cbe:	0f 85 52 ff ff ff    	jne    810c16 <ip_input+0x144>
  810cc4:	eb 01                	jmp    810cc7 <ip_input+0x1f5>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
          LWIP_DEBUGF(IP_DEBUG, ("ip_input: packet accepted on interface %c%c\n",
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
  810cc6:	90                   	nop
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  810cc7:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  810ccc:	75 58                	jne    810d26 <ip_input+0x254>
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  810cce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810cd2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  810cd6:	0f b7 c0             	movzwl %ax,%eax
  810cd9:	89 c7                	mov    %eax,%edi
  810cdb:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  810ce2:	00 00 00 
  810ce5:	ff d0                	callq  *%rax
  810ce7:	0f b7 c0             	movzwl %ax,%eax
  810cea:	25 ff 00 00 00       	and    $0xff,%eax
  810cef:	83 f8 11             	cmp    $0x11,%eax
  810cf2:	75 32                	jne    810d26 <ip_input+0x254>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  810cf4:	0f b7 45 d6          	movzwl -0x2a(%rbp),%eax
  810cf8:	48 03 45 e8          	add    -0x18(%rbp),%rax
  810cfc:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  810d00:	0f b7 c0             	movzwl %ax,%eax
  810d03:	89 c7                	mov    %eax,%edi
  810d05:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  810d0c:	00 00 00 
  810d0f:	ff d0                	callq  *%rax
  810d11:	66 83 f8 44          	cmp    $0x44,%ax
  810d15:	75 0f                	jne    810d26 <ip_input+0x254>
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
  810d17:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  810d1b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        check_ip_src = 0;
  810d1f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
  }
#endif /* LWIP_DHCP */

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
  810d26:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  810d2a:	74 6e                	je     810d9a <ip_input+0x2c8>
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  810d2c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810d30:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  810d34:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  810d38:	48 89 c6             	mov    %rax,%rsi
  810d3b:	48 89 d7             	mov    %rdx,%rdi
  810d3e:	48 b8 80 09 81 00 00 	movabs $0x810980,%rax
  810d45:	00 00 00 
  810d48:	ff d0                	callq  *%rax
  810d4a:	84 c0                	test   %al,%al
  810d4c:	75 2f                	jne    810d7d <ip_input+0x2ab>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  810d4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810d52:	8b 58 0c             	mov    0xc(%rax),%ebx
  810d55:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  810d5a:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  810d61:	00 00 00 
  810d64:	ff d0                	callq  *%rax
  810d66:	21 c3                	and    %eax,%ebx
  810d68:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  810d6d:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  810d74:	00 00 00 
  810d77:	ff d0                	callq  *%rax

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  810d79:	39 c3                	cmp    %eax,%ebx
  810d7b:	75 1d                	jne    810d9a <ip_input+0x2c8>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  810d7d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810d81:	48 89 c7             	mov    %rax,%rdi
  810d84:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  810d8b:	00 00 00 
  810d8e:	ff d0                	callq  *%rax
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  810d90:	b8 00 00 00 00       	mov    $0x0,%eax
  810d95:	e9 b6 01 00 00       	jmpq   810f50 <ip_input+0x47e>
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  810d9a:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  810d9f:	75 1d                	jne    810dbe <ip_input+0x2ec>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  810da1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810da5:	48 89 c7             	mov    %rax,%rdi
  810da8:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  810daf:	00 00 00 
  810db2:	ff d0                	callq  *%rax
    return ERR_OK;
  810db4:	b8 00 00 00 00       	mov    $0x0,%eax
  810db9:	e9 92 01 00 00       	jmpq   810f50 <ip_input+0x47e>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  810dbe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810dc2:	0f b7 58 06          	movzwl 0x6(%rax),%ebx
  810dc6:	bf ff 3f 00 00       	mov    $0x3fff,%edi
  810dcb:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  810dd2:	00 00 00 
  810dd5:	ff d0                	callq  *%rax
  810dd7:	21 d8                	and    %ebx,%eax
  810dd9:	66 85 c0             	test   %ax,%ax
  810ddc:	74 34                	je     810e12 <ip_input+0x340>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  810dde:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810de2:	48 89 c7             	mov    %rax,%rdi
  810de5:	48 b8 34 1c 81 00 00 	movabs $0x811c34,%rax
  810dec:	00 00 00 
  810def:	ff d0                	callq  *%rax
  810df1:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  810df5:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  810dfa:	75 0a                	jne    810e06 <ip_input+0x334>
      return ERR_OK;
  810dfc:	b8 00 00 00 00       	mov    $0x0,%eax
  810e01:	e9 4a 01 00 00       	jmpq   810f50 <ip_input+0x47e>
    }
    iphdr = p->payload;
  810e06:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810e0a:	48 8b 40 08          	mov    0x8(%rax),%rax
  810e0e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  810e12:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  810e16:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810e1a:	48 89 d6             	mov    %rdx,%rsi
  810e1d:	48 89 c7             	mov    %rax,%rdi
  810e20:	48 b8 dc f9 81 00 00 	movabs $0x81f9dc,%rax
  810e27:	00 00 00 
  810e2a:	ff d0                	callq  *%rax
  810e2c:	84 c0                	test   %al,%al
  810e2e:	0f 85 17 01 00 00    	jne    810f4b <ip_input+0x479>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  810e34:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810e38:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  810e3c:	0f b7 c0             	movzwl %ax,%eax
  810e3f:	89 c7                	mov    %eax,%edi
  810e41:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  810e48:	00 00 00 
  810e4b:	ff d0                	callq  *%rax
  810e4d:	0f b7 c0             	movzwl %ax,%eax
  810e50:	25 ff 00 00 00       	and    $0xff,%eax
  810e55:	83 f8 06             	cmp    $0x6,%eax
  810e58:	74 2b                	je     810e85 <ip_input+0x3b3>
  810e5a:	83 f8 11             	cmp    $0x11,%eax
  810e5d:	74 07                	je     810e66 <ip_input+0x394>
  810e5f:	83 f8 01             	cmp    $0x1,%eax
  810e62:	74 40                	je     810ea4 <ip_input+0x3d2>
  810e64:	eb 5d                	jmp    810ec3 <ip_input+0x3f1>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  810e66:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  810e6a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810e6e:	48 89 d6             	mov    %rdx,%rsi
  810e71:	48 89 c7             	mov    %rax,%rdi
  810e74:	48 b8 1c 4a 81 00 00 	movabs $0x814a1c,%rax
  810e7b:	00 00 00 
  810e7e:	ff d0                	callq  *%rax
      break;
  810e80:	e9 c6 00 00 00       	jmpq   810f4b <ip_input+0x479>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  810e85:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  810e89:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810e8d:	48 89 d6             	mov    %rdx,%rsi
  810e90:	48 89 c7             	mov    %rax,%rdi
  810e93:	48 b8 30 c0 81 00 00 	movabs $0x81c030,%rax
  810e9a:	00 00 00 
  810e9d:	ff d0                	callq  *%rax
      break;
  810e9f:	e9 a7 00 00 00       	jmpq   810f4b <ip_input+0x479>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  810ea4:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  810ea8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810eac:	48 89 d6             	mov    %rdx,%rsi
  810eaf:	48 89 c7             	mov    %rax,%rdi
  810eb2:	48 b8 98 fe 81 00 00 	movabs $0x81fe98,%rax
  810eb9:	00 00 00 
  810ebc:	ff d0                	callq  *%rax
      break;
  810ebe:	e9 88 00 00 00       	jmpq   810f4b <ip_input+0x479>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  810ec3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810ec7:	48 8d 50 10          	lea    0x10(%rax),%rdx
  810ecb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  810ecf:	48 89 c6             	mov    %rax,%rsi
  810ed2:	48 89 d7             	mov    %rdx,%rdi
  810ed5:	48 b8 80 09 81 00 00 	movabs $0x810980,%rax
  810edc:	00 00 00 
  810edf:	ff d0                	callq  *%rax
  810ee1:	84 c0                	test   %al,%al
  810ee3:	75 53                	jne    810f38 <ip_input+0x466>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  810ee5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810ee9:	8b 58 10             	mov    0x10(%rax),%ebx
  810eec:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  810ef1:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  810ef8:	00 00 00 
  810efb:	ff d0                	callq  *%rax
  810efd:	21 c3                	and    %eax,%ebx
  810eff:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  810f04:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  810f0b:	00 00 00 
  810f0e:	ff d0                	callq  *%rax
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  810f10:	39 c3                	cmp    %eax,%ebx
  810f12:	74 24                	je     810f38 <ip_input+0x466>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  810f14:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810f18:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  810f1c:	48 89 50 08          	mov    %rdx,0x8(%rax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  810f20:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810f24:	be 02 00 00 00       	mov    $0x2,%esi
  810f29:	48 89 c7             	mov    %rax,%rdi
  810f2c:	48 b8 c2 03 82 00 00 	movabs $0x8203c2,%rax
  810f33:	00 00 00 
  810f36:	ff d0                	callq  *%rax
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  810f38:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  810f3c:	48 89 c7             	mov    %rax,%rdi
  810f3f:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  810f46:	00 00 00 
  810f49:	ff d0                	callq  *%rax
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
  810f4b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810f50:	48 83 c4 38          	add    $0x38,%rsp
  810f54:	5b                   	pop    %rbx
  810f55:	5d                   	pop    %rbp
  810f56:	c3                   	retq   

0000000000810f57 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  810f57:	55                   	push   %rbp
  810f58:	48 89 e5             	mov    %rsp,%rbp
  810f5b:	53                   	push   %rbx
  810f5c:	48 83 ec 48          	sub    $0x48,%rsp
  810f60:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  810f64:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  810f68:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  810f6c:	89 c8                	mov    %ecx,%eax
  810f6e:	44 89 c1             	mov    %r8d,%ecx
  810f71:	44 89 ca             	mov    %r9d,%edx
  810f74:	88 45 c4             	mov    %al,-0x3c(%rbp)
  810f77:	88 4d c0             	mov    %cl,-0x40(%rbp)
  810f7a:	88 55 bc             	mov    %dl,-0x44(%rbp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  810f7d:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  810f82:	0f 84 0e 02 00 00    	je     811196 <ip_output_if+0x23f>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  810f88:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  810f8c:	be 14 00 00 00       	mov    $0x14,%esi
  810f91:	48 89 c7             	mov    %rax,%rdi
  810f94:	48 b8 6f d7 80 00 00 	movabs $0x80d76f,%rax
  810f9b:	00 00 00 
  810f9e:	ff d0                	callq  *%rax
  810fa0:	84 c0                	test   %al,%al
  810fa2:	74 0a                	je     810fae <ip_output_if+0x57>
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
  810fa4:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  810fa9:	e9 58 02 00 00       	jmpq   811206 <ip_output_if+0x2af>
    }

    iphdr = p->payload;
  810fae:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  810fb2:	48 8b 40 08          	mov    0x8(%rax),%rax
  810fb6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  810fba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  810fbe:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  810fc2:	66 83 f8 13          	cmp    $0x13,%ax
  810fc6:	77 2a                	ja     810ff2 <ip_output_if+0x9b>
  810fc8:	48 ba b0 23 82 00 00 	movabs $0x8223b0,%rdx
  810fcf:	00 00 00 
  810fd2:	be ee 01 00 00       	mov    $0x1ee,%esi
  810fd7:	48 bf dd 23 82 00 00 	movabs $0x8223dd,%rdi
  810fde:	00 00 00 
  810fe1:	b8 00 00 00 00       	mov    $0x0,%eax
  810fe6:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  810fed:	00 00 00 
  810ff0:	ff d1                	callq  *%rcx
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  810ff2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  810ff6:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  810ffa:	0f b7 c0             	movzwl %ax,%eax
  810ffd:	89 c7                	mov    %eax,%edi
  810fff:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  811006:	00 00 00 
  811009:	ff d0                	callq  *%rax
  81100b:	0f b6 d0             	movzbl %al,%edx
  81100e:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  811012:	c1 e0 08             	shl    $0x8,%eax
  811015:	09 d0                	or     %edx,%eax
  811017:	0f b7 c0             	movzwl %ax,%eax
  81101a:	89 c7                	mov    %eax,%edi
  81101c:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  811023:	00 00 00 
  811026:	ff d0                	callq  *%rax
  811028:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81102c:	66 89 42 08          	mov    %ax,0x8(%rdx)
    IPH_PROTO_SET(iphdr, proto);
  811030:	0f b6 5d bc          	movzbl -0x44(%rbp),%ebx
  811034:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811038:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81103c:	0f b7 c0             	movzwl %ax,%eax
  81103f:	89 c7                	mov    %eax,%edi
  811041:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  811048:	00 00 00 
  81104b:	ff d0                	callq  *%rax
  81104d:	66 c1 e8 08          	shr    $0x8,%ax
  811051:	0f b7 c0             	movzwl %ax,%eax
  811054:	c1 e0 08             	shl    $0x8,%eax
  811057:	09 d8                	or     %ebx,%eax
  811059:	0f b7 c0             	movzwl %ax,%eax
  81105c:	89 c7                	mov    %eax,%edi
  81105e:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  811065:	00 00 00 
  811068:	ff d0                	callq  *%rax
  81106a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81106e:	66 89 42 08          	mov    %ax,0x8(%rdx)

    ip_addr_set(&(iphdr->dest), dest);
  811072:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  811077:	74 08                	je     811081 <ip_output_if+0x12a>
  811079:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81107d:	8b 00                	mov    (%rax),%eax
  81107f:	eb 05                	jmp    811086 <ip_output_if+0x12f>
  811081:	b8 00 00 00 00       	mov    $0x0,%eax
  811086:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81108a:	89 42 10             	mov    %eax,0x10(%rdx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  81108d:	0f b6 45 c0          	movzbl -0x40(%rbp),%eax
  811091:	80 cc 45             	or     $0x45,%ah
  811094:	0f b7 c0             	movzwl %ax,%eax
  811097:	89 c7                	mov    %eax,%edi
  811099:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  8110a0:	00 00 00 
  8110a3:	ff d0                	callq  *%rax
  8110a5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8110a9:	66 89 02             	mov    %ax,(%rdx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  8110ac:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8110b0:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8110b4:	0f b7 c0             	movzwl %ax,%eax
  8110b7:	89 c7                	mov    %eax,%edi
  8110b9:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  8110c0:	00 00 00 
  8110c3:	ff d0                	callq  *%rax
  8110c5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8110c9:	66 89 42 02          	mov    %ax,0x2(%rdx)
    IPH_OFFSET_SET(iphdr, 0);
  8110cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8110d1:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
    IPH_ID_SET(iphdr, htons(ip_id));
  8110d7:	48 b8 b4 b0 b4 00 00 	movabs $0xb4b0b4,%rax
  8110de:	00 00 00 
  8110e1:	0f b7 00             	movzwl (%rax),%eax
  8110e4:	0f b7 c0             	movzwl %ax,%eax
  8110e7:	89 c7                	mov    %eax,%edi
  8110e9:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  8110f0:	00 00 00 
  8110f3:	ff d0                	callq  *%rax
  8110f5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8110f9:	66 89 42 04          	mov    %ax,0x4(%rdx)
    ++ip_id;
  8110fd:	48 b8 b4 b0 b4 00 00 	movabs $0xb4b0b4,%rax
  811104:	00 00 00 
  811107:	0f b7 00             	movzwl (%rax),%eax
  81110a:	8d 50 01             	lea    0x1(%rax),%edx
  81110d:	48 b8 b4 b0 b4 00 00 	movabs $0xb4b0b4,%rax
  811114:	00 00 00 
  811117:	66 89 10             	mov    %dx,(%rax)

    if (ip_addr_isany(src)) {
  81111a:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81111f:	74 0a                	je     81112b <ip_output_if+0x1d4>
  811121:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811125:	8b 00                	mov    (%rax),%eax
  811127:	85 c0                	test   %eax,%eax
  811129:	75 24                	jne    81114f <ip_output_if+0x1f8>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  81112b:	48 8b 45 10          	mov    0x10(%rbp),%rax
  81112f:	48 83 c0 08          	add    $0x8,%rax
  811133:	48 85 c0             	test   %rax,%rax
  811136:	74 09                	je     811141 <ip_output_if+0x1ea>
  811138:	48 8b 45 10          	mov    0x10(%rbp),%rax
  81113c:	8b 40 08             	mov    0x8(%rax),%eax
  81113f:	eb 05                	jmp    811146 <ip_output_if+0x1ef>
  811141:	b8 00 00 00 00       	mov    $0x0,%eax
  811146:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81114a:	89 42 0c             	mov    %eax,0xc(%rdx)
  81114d:	eb 1b                	jmp    81116a <ip_output_if+0x213>
    } else {
      ip_addr_set(&(iphdr->src), src);
  81114f:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  811154:	74 08                	je     81115e <ip_output_if+0x207>
  811156:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81115a:	8b 00                	mov    (%rax),%eax
  81115c:	eb 05                	jmp    811163 <ip_output_if+0x20c>
  81115e:	b8 00 00 00 00       	mov    $0x0,%eax
  811163:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811167:	89 42 0c             	mov    %eax,0xc(%rdx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  81116a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81116e:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  811174:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811178:	be 14 00 00 00       	mov    $0x14,%esi
  81117d:	48 89 c7             	mov    %rax,%rdi
  811180:	48 b8 76 27 81 00 00 	movabs $0x812776,%rax
  811187:	00 00 00 
  81118a:	ff d0                	callq  *%rax
  81118c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811190:	66 89 42 0a          	mov    %ax,0xa(%rdx)
  811194:	eb 18                	jmp    8111ae <ip_output_if+0x257>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
  811196:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81119a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81119e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    dest = &(iphdr->dest);
  8111a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8111a6:	48 83 c0 10          	add    $0x10,%rax
  8111aa:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  8111ae:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8111b2:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  8111b6:	66 85 c0             	test   %ax,%ax
  8111b9:	74 32                	je     8111ed <ip_output_if+0x296>
  8111bb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8111bf:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  8111c3:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8111c7:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  8111cb:	66 39 c2             	cmp    %ax,%dx
  8111ce:	76 1d                	jbe    8111ed <ip_output_if+0x296>
    return ip_frag(p,netif,dest);
  8111d0:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8111d4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8111d8:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  8111dc:	48 89 c7             	mov    %rax,%rdi
  8111df:	48 b8 83 20 81 00 00 	movabs $0x812083,%rax
  8111e6:	00 00 00 
  8111e9:	ff d0                	callq  *%rax
  8111eb:	eb 19                	jmp    811206 <ip_output_if+0x2af>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  8111ed:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8111f1:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8111f5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8111f9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8111fd:	48 89 c6             	mov    %rax,%rsi
  811200:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  811204:	ff d1                	callq  *%rcx
  }
}
  811206:	48 83 c4 48          	add    $0x48,%rsp
  81120a:	5b                   	pop    %rbx
  81120b:	5d                   	pop    %rbp
  81120c:	c3                   	retq   

000000000081120d <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  81120d:	55                   	push   %rbp
  81120e:	48 89 e5             	mov    %rsp,%rbp
  811211:	48 83 ec 50          	sub    $0x50,%rsp
  811215:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  811219:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81121d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  811221:	89 c8                	mov    %ecx,%eax
  811223:	44 89 c1             	mov    %r8d,%ecx
  811226:	44 89 ca             	mov    %r9d,%edx
  811229:	88 45 d4             	mov    %al,-0x2c(%rbp)
  81122c:	88 4d d0             	mov    %cl,-0x30(%rbp)
  81122f:	88 55 cc             	mov    %dl,-0x34(%rbp)
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  811232:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811236:	48 89 c7             	mov    %rax,%rdi
  811239:	48 b8 20 0a 81 00 00 	movabs $0x810a20,%rax
  811240:	00 00 00 
  811243:	ff d0                	callq  *%rax
  811245:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  811249:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81124e:	75 07                	jne    811257 <ip_output+0x4a>
    return ERR_RTE;
  811250:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  811255:	eb 31                	jmp    811288 <ip_output+0x7b>
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  811257:	44 0f b6 4d cc       	movzbl -0x34(%rbp),%r9d
  81125c:	44 0f b6 45 d0       	movzbl -0x30(%rbp),%r8d
  811261:	0f b6 4d d4          	movzbl -0x2c(%rbp),%ecx
  811265:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  811269:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  81126d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811271:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  811275:	48 89 3c 24          	mov    %rdi,(%rsp)
  811279:	48 89 c7             	mov    %rax,%rdi
  81127c:	48 b8 57 0f 81 00 00 	movabs $0x810f57,%rax
  811283:	00 00 00 
  811286:	ff d0                	callq  *%rax
}
  811288:	c9                   	leaveq 
  811289:	c3                   	retq   
	...

000000000081128c <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  81128c:	55                   	push   %rbp
  81128d:	48 89 e5             	mov    %rsp,%rbp
  811290:	48 83 ec 20          	sub    $0x20,%rsp
  struct ip_reassdata *r, *prev = NULL;
  811294:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  81129b:	00 

  r = reassdatagrams;
  81129c:	48 b8 c0 b0 b4 00 00 	movabs $0xb4b0c0,%rax
  8112a3:	00 00 00 
  8112a6:	48 8b 00             	mov    (%rax),%rax
  8112a9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  while (r != NULL) {
  8112ad:	eb 60                	jmp    81130f <ip_reass_tmr+0x83>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  8112af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8112b3:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  8112b7:	84 c0                	test   %al,%al
  8112b9:	74 27                	je     8112e2 <ip_reass_tmr+0x56>
      r->timer--;
  8112bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8112bf:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  8112c3:	8d 50 ff             	lea    -0x1(%rax),%edx
  8112c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8112ca:	88 50 27             	mov    %dl,0x27(%rax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
  8112cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8112d1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      r = r->next;
  8112d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8112d9:	48 8b 00             	mov    (%rax),%rax
  8112dc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8112e0:	eb 2d                	jmp    81130f <ip_reass_tmr+0x83>
    } else {
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
  8112e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8112e6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      /* get the next pointer before freeing */
      r = r->next;
  8112ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8112ee:	48 8b 00             	mov    (%rax),%rax
  8112f1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  8112f5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8112f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8112fd:	48 89 d6             	mov    %rdx,%rsi
  811300:	48 89 c7             	mov    %rax,%rdi
  811303:	48 b8 18 13 81 00 00 	movabs $0x811318,%rax
  81130a:	00 00 00 
  81130d:	ff d0                	callq  *%rax
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  81130f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  811314:	75 99                	jne    8112af <ip_reass_tmr+0x23>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  811316:	c9                   	leaveq 
  811317:	c3                   	retq   

0000000000811318 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  811318:	55                   	push   %rbp
  811319:	48 89 e5             	mov    %rsp,%rbp
  81131c:	48 83 ec 30          	sub    $0x30,%rsp
  811320:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  811324:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  int pbufs_freed = 0;
  811328:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  81132f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811333:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  811337:	75 2a                	jne    811363 <ip_reass_free_complete_datagram+0x4b>
  811339:	48 ba f8 23 82 00 00 	movabs $0x8223f8,%rdx
  811340:	00 00 00 
  811343:	be 99 00 00 00       	mov    $0x99,%esi
  811348:	48 bf 04 24 82 00 00 	movabs $0x822404,%rdi
  81134f:	00 00 00 
  811352:	b8 00 00 00 00       	mov    $0x0,%eax
  811357:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81135e:	00 00 00 
  811361:	ff d1                	callq  *%rcx
  if (prev != NULL) {
  811363:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  811368:	74 37                	je     8113a1 <ip_reass_free_complete_datagram+0x89>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  81136a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81136e:	48 8b 00             	mov    (%rax),%rax
  811371:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  811375:	74 2a                	je     8113a1 <ip_reass_free_complete_datagram+0x89>
  811377:	48 ba 21 24 82 00 00 	movabs $0x822421,%rdx
  81137e:	00 00 00 
  811381:	be 9b 00 00 00       	mov    $0x9b,%esi
  811386:	48 bf 04 24 82 00 00 	movabs $0x822404,%rdi
  81138d:	00 00 00 
  811390:	b8 00 00 00 00       	mov    $0x0,%eax
  811395:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81139c:	00 00 00 
  81139f:	ff d1                	callq  *%rcx
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  8113a1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8113a5:	48 8b 40 08          	mov    0x8(%rax),%rax
  8113a9:	48 8b 40 08          	mov    0x8(%rax),%rax
  8113ad:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (iprh->start == 0) {
  8113b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8113b5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8113b9:	66 85 c0             	test   %ax,%ax
  8113bc:	0f 85 86 00 00 00    	jne    811448 <ip_reass_free_complete_datagram+0x130>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
  8113c2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8113c6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8113ca:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    ipr->p = iprh->next_pbuf;
  8113ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8113d2:	48 8b 10             	mov    (%rax),%rdx
  8113d5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8113d9:	48 89 50 08          	mov    %rdx,0x8(%rax)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  8113dd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8113e1:	48 8d 48 10          	lea    0x10(%rax),%rcx
  8113e5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8113e9:	48 8b 40 08          	mov    0x8(%rax),%rax
  8113ed:	ba 14 00 00 00       	mov    $0x14,%edx
  8113f2:	48 89 ce             	mov    %rcx,%rsi
  8113f5:	48 89 c7             	mov    %rax,%rdi
  8113f8:	48 b8 fd 22 80 00 00 	movabs $0x8022fd,%rax
  8113ff:	00 00 00 
  811402:	ff d0                	callq  *%rax
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  811404:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811408:	be 01 00 00 00       	mov    $0x1,%esi
  81140d:	48 89 c7             	mov    %rax,%rdi
  811410:	48 b8 61 05 82 00 00 	movabs $0x820561,%rax
  811417:	00 00 00 
  81141a:	ff d0                	callq  *%rax
    pbufs_freed += pbuf_clen(p);
  81141c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811420:	48 89 c7             	mov    %rax,%rdi
  811423:	48 b8 e1 da 80 00 00 	movabs $0x80dae1,%rax
  81142a:	00 00 00 
  81142d:	ff d0                	callq  *%rax
  81142f:	0f b6 c0             	movzbl %al,%eax
  811432:	01 45 fc             	add    %eax,-0x4(%rbp)
    pbuf_free(p);
  811435:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811439:	48 89 c7             	mov    %rax,%rdi
  81143c:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  811443:	00 00 00 
  811446:	ff d0                	callq  *%rax
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  811448:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81144c:	48 8b 40 08          	mov    0x8(%rax),%rax
  811450:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  while (p != NULL) {
  811454:	eb 4b                	jmp    8114a1 <ip_reass_free_complete_datagram+0x189>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  811456:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81145a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81145e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    pcur = p;
  811462:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811466:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  81146a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81146e:	48 8b 00             	mov    (%rax),%rax
  811471:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    pbufs_freed += pbuf_clen(pcur);
  811475:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811479:	48 89 c7             	mov    %rax,%rdi
  81147c:	48 b8 e1 da 80 00 00 	movabs $0x80dae1,%rax
  811483:	00 00 00 
  811486:	ff d0                	callq  *%rax
  811488:	0f b6 c0             	movzbl %al,%eax
  81148b:	01 45 fc             	add    %eax,-0x4(%rbp)
    pbuf_free(pcur);    
  81148e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811492:	48 89 c7             	mov    %rax,%rdi
  811495:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81149c:	00 00 00 
  81149f:	ff d0                	callq  *%rax
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  8114a1:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8114a6:	75 ae                	jne    811456 <ip_reass_free_complete_datagram+0x13e>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  8114a8:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8114ac:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8114b0:	48 89 d6             	mov    %rdx,%rsi
  8114b3:	48 89 c7             	mov    %rax,%rdi
  8114b6:	48 b8 1c 17 81 00 00 	movabs $0x81171c,%rax
  8114bd:	00 00 00 
  8114c0:	ff d0                	callq  *%rax
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  8114c2:	48 b8 c8 b0 b4 00 00 	movabs $0xb4b0c8,%rax
  8114c9:	00 00 00 
  8114cc:	0f b7 00             	movzwl (%rax),%eax
  8114cf:	0f b7 c0             	movzwl %ax,%eax
  8114d2:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8114d5:	7d 2a                	jge    811501 <ip_reass_free_complete_datagram+0x1e9>
  8114d7:	48 ba 33 24 82 00 00 	movabs $0x822433,%rdx
  8114de:	00 00 00 
  8114e1:	be bc 00 00 00       	mov    $0xbc,%esi
  8114e6:	48 bf 04 24 82 00 00 	movabs $0x822404,%rdi
  8114ed:	00 00 00 
  8114f0:	b8 00 00 00 00       	mov    $0x0,%eax
  8114f5:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8114fc:	00 00 00 
  8114ff:	ff d1                	callq  *%rcx
  ip_reass_pbufcount -= pbufs_freed;
  811501:	48 b8 c8 b0 b4 00 00 	movabs $0xb4b0c8,%rax
  811508:	00 00 00 
  81150b:	0f b7 10             	movzwl (%rax),%edx
  81150e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  811511:	66 29 c2             	sub    %ax,%dx
  811514:	48 b8 c8 b0 b4 00 00 	movabs $0xb4b0c8,%rax
  81151b:	00 00 00 
  81151e:	66 89 10             	mov    %dx,(%rax)

  return pbufs_freed;
  811521:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  811524:	c9                   	leaveq 
  811525:	c3                   	retq   

0000000000811526 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  811526:	55                   	push   %rbp
  811527:	48 89 e5             	mov    %rsp,%rbp
  81152a:	48 83 ec 40          	sub    $0x40,%rsp
  81152e:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  811532:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
  811535:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
  81153c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  811543:	00 
    prev = NULL;
  811544:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  81154b:	00 
    other_datagrams = 0;
  81154c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
    r = reassdatagrams;
  811553:	48 b8 c0 b0 b4 00 00 	movabs $0xb4b0c0,%rax
  81155a:	00 00 00 
  81155d:	48 8b 00             	mov    (%rax),%rax
  811560:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (r != NULL) {
  811564:	e9 89 00 00 00       	jmpq   8115f2 <ip_reass_remove_oldest_datagram+0xcc>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  811569:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81156d:	8b 50 1c             	mov    0x1c(%rax),%edx
  811570:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811574:	8b 40 0c             	mov    0xc(%rax),%eax
  811577:	39 c2                	cmp    %eax,%edx
  811579:	75 27                	jne    8115a2 <ip_reass_remove_oldest_datagram+0x7c>
  81157b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81157f:	8b 50 20             	mov    0x20(%rax),%edx
  811582:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811586:	8b 40 10             	mov    0x10(%rax),%eax
  811589:	39 c2                	cmp    %eax,%edx
  81158b:	75 15                	jne    8115a2 <ip_reass_remove_oldest_datagram+0x7c>
  81158d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811591:	0f b7 50 14          	movzwl 0x14(%rax),%edx
  811595:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  811599:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  81159d:	66 39 c2             	cmp    %ax,%dx
  8115a0:	74 31                	je     8115d3 <ip_reass_remove_oldest_datagram+0xad>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  8115a2:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
        if (oldest == NULL) {
  8115a6:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8115ab:	75 0a                	jne    8115b7 <ip_reass_remove_oldest_datagram+0x91>
          oldest = r;
  8115ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8115b1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8115b5:	eb 1c                	jmp    8115d3 <ip_reass_remove_oldest_datagram+0xad>
        } else if (r->timer <= oldest->timer) {
  8115b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8115bb:	0f b6 50 27          	movzbl 0x27(%rax),%edx
  8115bf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8115c3:	0f b6 40 27          	movzbl 0x27(%rax),%eax
  8115c7:	38 c2                	cmp    %al,%dl
  8115c9:	77 08                	ja     8115d3 <ip_reass_remove_oldest_datagram+0xad>
          /* older than the previous oldest */
          oldest = r;
  8115cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8115cf:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        }
      }
      if (r->next != NULL) {
  8115d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8115d7:	48 8b 00             	mov    (%rax),%rax
  8115da:	48 85 c0             	test   %rax,%rax
  8115dd:	74 08                	je     8115e7 <ip_reass_remove_oldest_datagram+0xc1>
        prev = r;
  8115df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8115e3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      }
      r = r->next;
  8115e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8115eb:	48 8b 00             	mov    (%rax),%rax
  8115ee:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  8115f2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8115f7:	0f 85 6c ff ff ff    	jne    811569 <ip_reass_remove_oldest_datagram+0x43>
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  8115fd:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  811602:	74 23                	je     811627 <ip_reass_remove_oldest_datagram+0x101>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  811604:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811608:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81160c:	48 89 d6             	mov    %rdx,%rsi
  81160f:	48 89 c7             	mov    %rax,%rdi
  811612:	48 b8 18 13 81 00 00 	movabs $0x811318,%rax
  811619:	00 00 00 
  81161c:	ff d0                	callq  *%rax
  81161e:	89 45 dc             	mov    %eax,-0x24(%rbp)
      pbufs_freed += pbufs_freed_current;
  811621:	8b 45 dc             	mov    -0x24(%rbp),%eax
  811624:	01 45 e4             	add    %eax,-0x1c(%rbp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  811627:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  81162a:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81162d:	7d 0a                	jge    811639 <ip_reass_remove_oldest_datagram+0x113>
  81162f:	83 7d e0 01          	cmpl   $0x1,-0x20(%rbp)
  811633:	0f 8f 03 ff ff ff    	jg     81153c <ip_reass_remove_oldest_datagram+0x16>
  return pbufs_freed;
  811639:	8b 45 e4             	mov    -0x1c(%rbp),%eax
}
  81163c:	c9                   	leaveq 
  81163d:	c3                   	retq   

000000000081163e <ip_reass_enqueue_new_datagram>:
 * @param clen number of pbufs needed to enqueue (used for freeing other datagrams if not enough space)
 * @return A pointer to the queue location into which the fragment was enqueued
 */
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  81163e:	55                   	push   %rbp
  81163f:	48 89 e5             	mov    %rsp,%rbp
  811642:	48 83 ec 20          	sub    $0x20,%rsp
  811646:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81164a:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  81164d:	bf 05 00 00 00       	mov    $0x5,%edi
  811652:	48 b8 41 ca 80 00 00 	movabs $0x80ca41,%rax
  811659:	00 00 00 
  81165c:	ff d0                	callq  *%rax
  81165e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (ipr == NULL) {
  811662:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  811667:	75 40                	jne    8116a9 <ip_reass_enqueue_new_datagram+0x6b>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  811669:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  81166c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811670:	89 d6                	mov    %edx,%esi
  811672:	48 89 c7             	mov    %rax,%rdi
  811675:	48 b8 26 15 81 00 00 	movabs $0x811526,%rax
  81167c:	00 00 00 
  81167f:	ff d0                	callq  *%rax
  811681:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  811684:	7c 15                	jl     81169b <ip_reass_enqueue_new_datagram+0x5d>
      ipr = memp_malloc(MEMP_REASSDATA);
  811686:	bf 05 00 00 00       	mov    $0x5,%edi
  81168b:	48 b8 41 ca 80 00 00 	movabs $0x80ca41,%rax
  811692:	00 00 00 
  811695:	ff d0                	callq  *%rax
  811697:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    }
    if (ipr == NULL)
  81169b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8116a0:	75 07                	jne    8116a9 <ip_reass_enqueue_new_datagram+0x6b>
#endif /* IP_REASS_FREE_OLDEST */
    {
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
  8116a2:	b8 00 00 00 00       	mov    $0x0,%eax
  8116a7:	eb 71                	jmp    81171a <ip_reass_enqueue_new_datagram+0xdc>
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  8116a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8116ad:	ba 28 00 00 00       	mov    $0x28,%edx
  8116b2:	be 00 00 00 00       	mov    $0x0,%esi
  8116b7:	48 89 c7             	mov    %rax,%rdi
  8116ba:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  8116c1:	00 00 00 
  8116c4:	ff d0                	callq  *%rax
  ipr->timer = IP_REASS_MAXAGE;
  8116c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8116ca:	c6 40 27 03          	movb   $0x3,0x27(%rax)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  8116ce:	48 b8 c0 b0 b4 00 00 	movabs $0xb4b0c0,%rax
  8116d5:	00 00 00 
  8116d8:	48 8b 10             	mov    (%rax),%rdx
  8116db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8116df:	48 89 10             	mov    %rdx,(%rax)
  reassdatagrams = ipr;
  8116e2:	48 b8 c0 b0 b4 00 00 	movabs $0xb4b0c0,%rax
  8116e9:	00 00 00 
  8116ec:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8116f0:	48 89 10             	mov    %rdx,(%rax)
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  8116f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8116f7:	48 8d 48 10          	lea    0x10(%rax),%rcx
  8116fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8116ff:	ba 14 00 00 00       	mov    $0x14,%edx
  811704:	48 89 c6             	mov    %rax,%rsi
  811707:	48 89 cf             	mov    %rcx,%rdi
  81170a:	48 b8 fd 22 80 00 00 	movabs $0x8022fd,%rax
  811711:	00 00 00 
  811714:	ff d0                	callq  *%rax
  return ipr;
  811716:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81171a:	c9                   	leaveq 
  81171b:	c3                   	retq   

000000000081171c <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  81171c:	55                   	push   %rbp
  81171d:	48 89 e5             	mov    %rsp,%rbp
  811720:	48 83 ec 10          	sub    $0x10,%rsp
  811724:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  811728:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  81172c:	48 b8 c0 b0 b4 00 00 	movabs $0xb4b0c0,%rax
  811733:	00 00 00 
  811736:	48 8b 00             	mov    (%rax),%rax
  811739:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  81173d:	75 16                	jne    811755 <ip_reass_dequeue_datagram+0x39>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  81173f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811743:	48 8b 10             	mov    (%rax),%rdx
  811746:	48 b8 c0 b0 b4 00 00 	movabs $0xb4b0c0,%rax
  81174d:	00 00 00 
  811750:	48 89 10             	mov    %rdx,(%rax)
  811753:	eb 3f                	jmp    811794 <ip_reass_dequeue_datagram+0x78>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  811755:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81175a:	75 2a                	jne    811786 <ip_reass_dequeue_datagram+0x6a>
  81175c:	48 ba 4e 24 82 00 00 	movabs $0x82244e,%rdx
  811763:	00 00 00 
  811766:	be 29 01 00 00       	mov    $0x129,%esi
  81176b:	48 bf 04 24 82 00 00 	movabs $0x822404,%rdi
  811772:	00 00 00 
  811775:	b8 00 00 00 00       	mov    $0x0,%eax
  81177a:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  811781:	00 00 00 
  811784:	ff d1                	callq  *%rcx
    prev->next = ipr->next;
  811786:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81178a:	48 8b 10             	mov    (%rax),%rdx
  81178d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  811791:	48 89 10             	mov    %rdx,(%rax)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  811794:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  811798:	48 89 c6             	mov    %rax,%rsi
  81179b:	bf 05 00 00 00       	mov    $0x5,%edi
  8117a0:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  8117a7:	00 00 00 
  8117aa:	ff d0                	callq  *%rax
}
  8117ac:	c9                   	leaveq 
  8117ad:	c3                   	retq   

00000000008117ae <ip_reass_chain_frag_into_datagram_and_validate>:
 * @param new_p points to the pbuf for the current fragment
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
  8117ae:	55                   	push   %rbp
  8117af:	48 89 e5             	mov    %rsp,%rbp
  8117b2:	53                   	push   %rbx
  8117b3:	48 83 ec 58          	sub    $0x58,%rsp
  8117b7:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8117bb:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  8117bf:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8117c6:	00 
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
  8117c7:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  8117ce:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8117d2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8117d6:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  8117da:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8117de:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8117e2:	0f b7 c0             	movzwl %ax,%eax
  8117e5:	89 c7                	mov    %eax,%edi
  8117e7:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  8117ee:	00 00 00 
  8117f1:	ff d0                	callq  *%rax
  8117f3:	89 c3                	mov    %eax,%ebx
  8117f5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8117f9:	0f b7 00             	movzwl (%rax),%eax
  8117fc:	0f b7 c0             	movzwl %ax,%eax
  8117ff:	89 c7                	mov    %eax,%edi
  811801:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  811808:	00 00 00 
  81180b:	ff d0                	callq  *%rax
  81180d:	66 c1 e8 08          	shr    $0x8,%ax
  811811:	89 c2                	mov    %eax,%edx
  811813:	83 e2 0f             	and    $0xf,%edx
  811816:	b8 00 00 00 00       	mov    $0x0,%eax
  81181b:	66 29 d0             	sub    %dx,%ax
  81181e:	c1 e0 02             	shl    $0x2,%eax
  811821:	01 d8                	add    %ebx,%eax
  811823:	66 89 45 c6          	mov    %ax,-0x3a(%rbp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  811827:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81182b:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  81182f:	0f b7 c0             	movzwl %ax,%eax
  811832:	89 c7                	mov    %eax,%edi
  811834:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81183b:	00 00 00 
  81183e:	ff d0                	callq  *%rax
  811840:	66 25 ff 1f          	and    $0x1fff,%ax
  811844:	c1 e0 03             	shl    $0x3,%eax
  811847:	66 89 45 c4          	mov    %ax,-0x3c(%rbp)
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  81184b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  81184f:	48 8b 40 08          	mov    0x8(%rax),%rax
  811853:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  iprh->next_pbuf = NULL;
  811857:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81185b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  iprh->start = offset;
  811862:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811866:	0f b7 55 c4          	movzwl -0x3c(%rbp),%edx
  81186a:	66 89 50 08          	mov    %dx,0x8(%rax)
  iprh->end = offset + len;
  81186e:	0f b7 45 c6          	movzwl -0x3a(%rbp),%eax
  811872:	0f b7 55 c4          	movzwl -0x3c(%rbp),%edx
  811876:	01 c2                	add    %eax,%edx
  811878:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81187c:	66 89 50 0a          	mov    %dx,0xa(%rax)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  811880:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811884:	48 8b 40 08          	mov    0x8(%rax),%rax
  811888:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81188c:	e9 eb 00 00 00       	jmpq   81197c <ip_reass_chain_frag_into_datagram_and_validate+0x1ce>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  811891:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811895:	48 8b 40 08          	mov    0x8(%rax),%rax
  811899:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    if (iprh->start < iprh_tmp->start) {
  81189d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8118a1:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  8118a5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8118a9:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8118ad:	66 39 c2             	cmp    %ax,%dx
  8118b0:	73 62                	jae    811914 <ip_reass_chain_frag_into_datagram_and_validate+0x166>
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  8118b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8118b6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8118ba:	48 89 10             	mov    %rdx,(%rax)
      if (iprh_prev != NULL) {
  8118bd:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8118c2:	74 42                	je     811906 <ip_reass_chain_frag_into_datagram_and_validate+0x158>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  8118c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8118c8:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  8118cc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8118d0:	0f b7 40 0a          	movzwl 0xa(%rax),%eax
  8118d4:	66 39 c2             	cmp    %ax,%dx
  8118d7:	0f 82 03 03 00 00    	jb     811be0 <ip_reass_chain_frag_into_datagram_and_validate+0x432>
  8118dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8118e1:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  8118e5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8118e9:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8118ed:	66 39 c2             	cmp    %ax,%dx
  8118f0:	0f 87 ea 02 00 00    	ja     811be0 <ip_reass_chain_frag_into_datagram_and_validate+0x432>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  8118f6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8118fa:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8118fe:	48 89 10             	mov    %rdx,(%rax)
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
  811901:	e9 81 00 00 00       	jmpq   811987 <ip_reass_chain_frag_into_datagram_and_validate+0x1d9>
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  811906:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81190a:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  81190e:	48 89 50 08          	mov    %rdx,0x8(%rax)
      }
      break;
  811912:	eb 73                	jmp    811987 <ip_reass_chain_frag_into_datagram_and_validate+0x1d9>
    } else if(iprh->start == iprh_tmp->start) {
  811914:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811918:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  81191c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811920:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811924:	66 39 c2             	cmp    %ax,%dx
  811927:	0f 84 af 02 00 00    	je     811bdc <ip_reass_chain_frag_into_datagram_and_validate+0x42e>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  81192d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811931:	0f b7 50 08          	movzwl 0x8(%rax),%edx
  811935:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811939:	0f b7 40 0a          	movzwl 0xa(%rax),%eax
  81193d:	66 39 c2             	cmp    %ax,%dx
  811940:	0f 82 99 02 00 00    	jb     811bdf <ip_reass_chain_frag_into_datagram_and_validate+0x431>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  811946:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81194b:	74 1c                	je     811969 <ip_reass_chain_frag_into_datagram_and_validate+0x1bb>
        if (iprh_prev->end != iprh_tmp->start) {
  81194d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811951:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811955:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811959:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81195d:	66 39 c2             	cmp    %ax,%dx
  811960:	74 07                	je     811969 <ip_reass_chain_frag_into_datagram_and_validate+0x1bb>
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
  811962:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  811969:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81196d:	48 8b 00             	mov    (%rax),%rax
  811970:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    iprh_prev = iprh_tmp;
  811974:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811978:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  81197c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  811981:	0f 85 0a ff ff ff    	jne    811891 <ip_reass_chain_frag_into_datagram_and_validate+0xe3>
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
  811987:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81198c:	0f 85 b2 00 00 00    	jne    811a44 <ip_reass_chain_frag_into_datagram_and_validate+0x296>
    if (iprh_prev != NULL) {
  811992:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811997:	74 68                	je     811a01 <ip_reass_chain_frag_into_datagram_and_validate+0x253>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  811999:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81199d:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  8119a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8119a5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8119a9:	66 39 c2             	cmp    %ax,%dx
  8119ac:	76 2a                	jbe    8119d8 <ip_reass_chain_frag_into_datagram_and_validate+0x22a>
  8119ae:	48 ba 67 24 82 00 00 	movabs $0x822467,%rdx
  8119b5:	00 00 00 
  8119b8:	be 83 01 00 00       	mov    $0x183,%esi
  8119bd:	48 bf 04 24 82 00 00 	movabs $0x822404,%rdi
  8119c4:	00 00 00 
  8119c7:	b8 00 00 00 00       	mov    $0x0,%eax
  8119cc:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8119d3:	00 00 00 
  8119d6:	ff d1                	callq  *%rcx
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  8119d8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8119dc:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8119e0:	48 89 10             	mov    %rdx,(%rax)
      if (iprh_prev->end != iprh->start) {
  8119e3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8119e7:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  8119eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8119ef:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8119f3:	66 39 c2             	cmp    %ax,%dx
  8119f6:	74 4c                	je     811a44 <ip_reass_chain_frag_into_datagram_and_validate+0x296>
        valid = 0;
  8119f8:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  8119ff:	eb 43                	jmp    811a44 <ip_reass_chain_frag_into_datagram_and_validate+0x296>
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  811a01:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811a05:	48 8b 40 08          	mov    0x8(%rax),%rax
  811a09:	48 85 c0             	test   %rax,%rax
  811a0c:	74 2a                	je     811a38 <ip_reass_chain_frag_into_datagram_and_validate+0x28a>
  811a0e:	48 ba 88 24 82 00 00 	movabs $0x822488,%rdx
  811a15:	00 00 00 
  811a18:	be 8c 01 00 00       	mov    $0x18c,%esi
  811a1d:	48 bf 04 24 82 00 00 	movabs $0x822404,%rdi
  811a24:	00 00 00 
  811a27:	b8 00 00 00 00       	mov    $0x0,%eax
  811a2c:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  811a33:	00 00 00 
  811a36:	ff d1                	callq  *%rcx
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  811a38:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811a3c:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  811a40:	48 89 50 08          	mov    %rdx,0x8(%rax)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  811a44:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811a48:	0f b6 40 26          	movzbl 0x26(%rax),%eax
  811a4c:	0f b6 c0             	movzbl %al,%eax
  811a4f:	83 e0 01             	and    $0x1,%eax
  811a52:	84 c0                	test   %al,%al
  811a54:	0f 84 7b 01 00 00    	je     811bd5 <ip_reass_chain_frag_into_datagram_and_validate+0x427>
    /* and had no wholes so far */
    if (valid) {
  811a5a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  811a5e:	0f 84 6c 01 00 00    	je     811bd0 <ip_reass_chain_frag_into_datagram_and_validate+0x422>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  811a64:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811a68:	48 8b 40 08          	mov    0x8(%rax),%rax
  811a6c:	48 8b 40 08          	mov    0x8(%rax),%rax
  811a70:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811a74:	66 85 c0             	test   %ax,%ax
  811a77:	74 0c                	je     811a85 <ip_reass_chain_frag_into_datagram_and_validate+0x2d7>
        valid = 0;
  811a79:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  811a80:	e9 4b 01 00 00       	jmpq   811bd0 <ip_reass_chain_frag_into_datagram_and_validate+0x422>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
  811a85:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811a89:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        q = iprh->next_pbuf;
  811a8d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811a91:	48 8b 00             	mov    (%rax),%rax
  811a94:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        while (q != NULL) {
  811a98:	eb 3d                	jmp    811ad7 <ip_reass_chain_frag_into_datagram_and_validate+0x329>
          iprh = (struct ip_reass_helper*)q->payload;
  811a9a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  811a9e:	48 8b 40 08          	mov    0x8(%rax),%rax
  811aa2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
          if (iprh_prev->end != iprh->start) {
  811aa6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811aaa:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811aae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811ab2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  811ab6:	66 39 c2             	cmp    %ax,%dx
  811ab9:	74 09                	je     811ac4 <ip_reass_chain_frag_into_datagram_and_validate+0x316>
            valid = 0;
  811abb:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
            break;
  811ac2:	eb 1a                	jmp    811ade <ip_reass_chain_frag_into_datagram_and_validate+0x330>
          }
          iprh_prev = iprh;
  811ac4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811ac8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
          q = iprh->next_pbuf;
  811acc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811ad0:	48 8b 00             	mov    (%rax),%rax
  811ad3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  811ad7:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  811adc:	75 bc                	jne    811a9a <ip_reass_chain_frag_into_datagram_and_validate+0x2ec>
          iprh_prev = iprh;
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
  811ade:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  811ae2:	0f 84 e8 00 00 00    	je     811bd0 <ip_reass_chain_frag_into_datagram_and_validate+0x422>
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  811ae8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811aec:	48 8b 40 08          	mov    0x8(%rax),%rax
  811af0:	48 85 c0             	test   %rax,%rax
  811af3:	75 2a                	jne    811b1f <ip_reass_chain_frag_into_datagram_and_validate+0x371>
  811af5:	48 ba bf 24 82 00 00 	movabs $0x8224bf,%rdx
  811afc:	00 00 00 
  811aff:	be ac 01 00 00       	mov    $0x1ac,%esi
  811b04:	48 bf 04 24 82 00 00 	movabs $0x822404,%rdi
  811b0b:	00 00 00 
  811b0e:	b8 00 00 00 00       	mov    $0x0,%eax
  811b13:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  811b1a:	00 00 00 
  811b1d:	ff d1                	callq  *%rcx
          LWIP_ASSERT("sanity check",
  811b1f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811b23:	48 8b 40 08          	mov    0x8(%rax),%rax
  811b27:	48 8b 40 08          	mov    0x8(%rax),%rax
  811b2b:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  811b2f:	75 2a                	jne    811b5b <ip_reass_chain_frag_into_datagram_and_validate+0x3ad>
  811b31:	48 ba bf 24 82 00 00 	movabs $0x8224bf,%rdx
  811b38:	00 00 00 
  811b3b:	be ae 01 00 00       	mov    $0x1ae,%esi
  811b40:	48 bf 04 24 82 00 00 	movabs $0x822404,%rdi
  811b47:	00 00 00 
  811b4a:	b8 00 00 00 00       	mov    $0x0,%eax
  811b4f:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  811b56:	00 00 00 
  811b59:	ff d1                	callq  *%rcx
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  811b5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811b5f:	48 8b 00             	mov    (%rax),%rax
  811b62:	48 85 c0             	test   %rax,%rax
  811b65:	74 2a                	je     811b91 <ip_reass_chain_frag_into_datagram_and_validate+0x3e3>
  811b67:	48 ba d0 24 82 00 00 	movabs $0x8224d0,%rdx
  811b6e:	00 00 00 
  811b71:	be b0 01 00 00       	mov    $0x1b0,%esi
  811b76:	48 bf 04 24 82 00 00 	movabs $0x822404,%rdi
  811b7d:	00 00 00 
  811b80:	b8 00 00 00 00       	mov    $0x0,%eax
  811b85:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  811b8c:	00 00 00 
  811b8f:	ff d1                	callq  *%rcx
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  811b91:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811b95:	0f b7 50 0a          	movzwl 0xa(%rax),%edx
  811b99:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  811b9d:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  811ba1:	66 39 c2             	cmp    %ax,%dx
  811ba4:	74 2a                	je     811bd0 <ip_reass_chain_frag_into_datagram_and_validate+0x422>
  811ba6:	48 ba f8 24 82 00 00 	movabs $0x8224f8,%rdx
  811bad:	00 00 00 
  811bb0:	be b2 01 00 00       	mov    $0x1b2,%esi
  811bb5:	48 bf 04 24 82 00 00 	movabs $0x822404,%rdi
  811bbc:	00 00 00 
  811bbf:	b8 00 00 00 00       	mov    $0x0,%eax
  811bc4:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  811bcb:	00 00 00 
  811bce:	ff d1                	callq  *%rcx
      }
    }
    /* If valid is 0 here, there are some fragments missing in the middle
     * (since MF == 0 has already arrived). Such datagrams simply time out if
     * no more fragments are received... */
    return valid;
  811bd0:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  811bd3:	eb 58                	jmp    811c2d <ip_reass_chain_frag_into_datagram_and_validate+0x47f>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
  811bd5:	b8 00 00 00 00       	mov    $0x0,%eax
  811bda:	eb 51                	jmp    811c2d <ip_reass_chain_frag_into_datagram_and_validate+0x47f>
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
  811bdc:	90                   	nop
  811bdd:	eb 01                	jmp    811be0 <ip_reass_chain_frag_into_datagram_and_validate+0x432>
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
  811bdf:	90                   	nop
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  811be0:	48 b8 c8 b0 b4 00 00 	movabs $0xb4b0c8,%rax
  811be7:	00 00 00 
  811bea:	0f b7 18             	movzwl (%rax),%ebx
  811bed:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  811bf1:	48 89 c7             	mov    %rax,%rdi
  811bf4:	48 b8 e1 da 80 00 00 	movabs $0x80dae1,%rax
  811bfb:	00 00 00 
  811bfe:	ff d0                	callq  *%rax
  811c00:	0f b6 c0             	movzbl %al,%eax
  811c03:	89 da                	mov    %ebx,%edx
  811c05:	66 29 c2             	sub    %ax,%dx
  811c08:	48 b8 c8 b0 b4 00 00 	movabs $0xb4b0c8,%rax
  811c0f:	00 00 00 
  811c12:	66 89 10             	mov    %dx,(%rax)
  pbuf_free(new_p);
  811c15:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  811c19:	48 89 c7             	mov    %rax,%rdi
  811c1c:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  811c23:	00 00 00 
  811c26:	ff d0                	callq  *%rax
  return 0;
  811c28:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* IP_REASS_CHECK_OVERLAP */
}
  811c2d:	48 83 c4 58          	add    $0x58,%rsp
  811c31:	5b                   	pop    %rbx
  811c32:	5d                   	pop    %rbp
  811c33:	c3                   	retq   

0000000000811c34 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  811c34:	55                   	push   %rbp
  811c35:	48 89 e5             	mov    %rsp,%rbp
  811c38:	53                   	push   %rbx
  811c39:	48 83 ec 48          	sub    $0x48,%rsp
  811c3d:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
  811c41:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  811c48:	00 

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  811c49:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811c4d:	48 8b 40 08          	mov    0x8(%rax),%rax
  811c51:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  811c55:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811c59:	0f b7 00             	movzwl (%rax),%eax
  811c5c:	0f b7 c0             	movzwl %ax,%eax
  811c5f:	89 c7                	mov    %eax,%edi
  811c61:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  811c68:	00 00 00 
  811c6b:	ff d0                	callq  *%rax
  811c6d:	66 c1 e8 08          	shr    $0x8,%ax
  811c71:	0f b7 c0             	movzwl %ax,%eax
  811c74:	83 e0 0f             	and    $0xf,%eax
  811c77:	c1 e0 02             	shl    $0x2,%eax
  811c7a:	83 f8 14             	cmp    $0x14,%eax
  811c7d:	0f 85 dd 03 00 00    	jne    812060 <ip_reass+0x42c>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  811c83:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811c87:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  811c8b:	0f b7 c0             	movzwl %ax,%eax
  811c8e:	89 c7                	mov    %eax,%edi
  811c90:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  811c97:	00 00 00 
  811c9a:	ff d0                	callq  *%rax
  811c9c:	66 25 ff 1f          	and    $0x1fff,%ax
  811ca0:	c1 e0 03             	shl    $0x3,%eax
  811ca3:	66 89 45 ce          	mov    %ax,-0x32(%rbp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  811ca7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811cab:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  811caf:	0f b7 c0             	movzwl %ax,%eax
  811cb2:	89 c7                	mov    %eax,%edi
  811cb4:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  811cbb:	00 00 00 
  811cbe:	ff d0                	callq  *%rax
  811cc0:	89 c3                	mov    %eax,%ebx
  811cc2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811cc6:	0f b7 00             	movzwl (%rax),%eax
  811cc9:	0f b7 c0             	movzwl %ax,%eax
  811ccc:	89 c7                	mov    %eax,%edi
  811cce:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  811cd5:	00 00 00 
  811cd8:	ff d0                	callq  *%rax
  811cda:	66 c1 e8 08          	shr    $0x8,%ax
  811cde:	89 c2                	mov    %eax,%edx
  811ce0:	83 e2 0f             	and    $0xf,%edx
  811ce3:	b8 00 00 00 00       	mov    $0x0,%eax
  811ce8:	66 29 d0             	sub    %dx,%ax
  811ceb:	c1 e0 02             	shl    $0x2,%eax
  811cee:	01 d8                	add    %ebx,%eax
  811cf0:	66 89 45 cc          	mov    %ax,-0x34(%rbp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  811cf4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811cf8:	48 89 c7             	mov    %rax,%rdi
  811cfb:	48 b8 e1 da 80 00 00 	movabs $0x80dae1,%rax
  811d02:	00 00 00 
  811d05:	ff d0                	callq  *%rax
  811d07:	88 45 cb             	mov    %al,-0x35(%rbp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  811d0a:	48 b8 c8 b0 b4 00 00 	movabs $0xb4b0c8,%rax
  811d11:	00 00 00 
  811d14:	0f b7 00             	movzwl (%rax),%eax
  811d17:	0f b7 d0             	movzwl %ax,%edx
  811d1a:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  811d1e:	01 d0                	add    %edx,%eax
  811d20:	83 f8 0a             	cmp    $0xa,%eax
  811d23:	7e 40                	jle    811d65 <ip_reass+0x131>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  811d25:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  811d29:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811d2d:	89 d6                	mov    %edx,%esi
  811d2f:	48 89 c7             	mov    %rax,%rdi
  811d32:	48 b8 26 15 81 00 00 	movabs $0x811526,%rax
  811d39:	00 00 00 
  811d3c:	ff d0                	callq  *%rax
  811d3e:	85 c0                	test   %eax,%eax
  811d40:	0f 84 1d 03 00 00    	je     812063 <ip_reass+0x42f>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  811d46:	48 b8 c8 b0 b4 00 00 	movabs $0xb4b0c8,%rax
  811d4d:	00 00 00 
  811d50:	0f b7 00             	movzwl (%rax),%eax
  811d53:	0f b7 d0             	movzwl %ax,%edx
  811d56:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  811d5a:	01 d0                	add    %edx,%eax

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  811d5c:	83 f8 0a             	cmp    $0xa,%eax
  811d5f:	0f 8f fe 02 00 00    	jg     812063 <ip_reass+0x42f>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  811d65:	48 b8 c0 b0 b4 00 00 	movabs $0xb4b0c0,%rax
  811d6c:	00 00 00 
  811d6f:	48 8b 00             	mov    (%rax),%rax
  811d72:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  811d76:	eb 4c                	jmp    811dc4 <ip_reass+0x190>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  811d78:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811d7c:	8b 50 1c             	mov    0x1c(%rax),%edx
  811d7f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811d83:	8b 40 0c             	mov    0xc(%rax),%eax
  811d86:	39 c2                	cmp    %eax,%edx
  811d88:	75 27                	jne    811db1 <ip_reass+0x17d>
  811d8a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811d8e:	8b 50 20             	mov    0x20(%rax),%edx
  811d91:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811d95:	8b 40 10             	mov    0x10(%rax),%eax
  811d98:	39 c2                	cmp    %eax,%edx
  811d9a:	75 15                	jne    811db1 <ip_reass+0x17d>
  811d9c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811da0:	0f b7 50 14          	movzwl 0x14(%rax),%edx
  811da4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811da8:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  811dac:	66 39 c2             	cmp    %ax,%dx
  811daf:	74 1c                	je     811dcd <ip_reass+0x199>
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
      break;
    }
    ipr_prev = ipr;
  811db1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811db5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  811db9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811dbd:	48 8b 00             	mov    (%rax),%rax
  811dc0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  811dc4:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811dc9:	75 ad                	jne    811d78 <ip_reass+0x144>
  811dcb:	eb 01                	jmp    811dce <ip_reass+0x19a>
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass: matching previous fragment ID=%"X16_F"\n",
        ntohs(IPH_ID(fraghdr))));
      IPFRAG_STATS_INC(ip_frag.cachehit);
      break;
  811dcd:	90                   	nop
    }
    ipr_prev = ipr;
  }

  if (ipr == NULL) {
  811dce:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811dd3:	75 29                	jne    811dfe <ip_reass+0x1ca>
  /* Enqueue a new datagram into the datagram queue */
    ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
  811dd5:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  811dd9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811ddd:	89 d6                	mov    %edx,%esi
  811ddf:	48 89 c7             	mov    %rax,%rdi
  811de2:	48 b8 3e 16 81 00 00 	movabs $0x81163e,%rax
  811de9:	00 00 00 
  811dec:	ff d0                	callq  *%rax
  811dee:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
  811df2:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  811df7:	75 72                	jne    811e6b <ip_reass+0x237>
      goto nullreturn;
  811df9:	e9 66 02 00 00       	jmpq   812064 <ip_reass+0x430>
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  811dfe:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811e02:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  811e06:	0f b7 c0             	movzwl %ax,%eax
  811e09:	89 c7                	mov    %eax,%edi
  811e0b:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  811e12:	00 00 00 
  811e15:	ff d0                	callq  *%rax
  811e17:	0f b7 c0             	movzwl %ax,%eax
  811e1a:	25 ff 1f 00 00       	and    $0x1fff,%eax
  811e1f:	85 c0                	test   %eax,%eax
  811e21:	75 48                	jne    811e6b <ip_reass+0x237>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  811e23:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811e27:	0f b7 40 16          	movzwl 0x16(%rax),%eax
  811e2b:	0f b7 c0             	movzwl %ax,%eax
  811e2e:	89 c7                	mov    %eax,%edi
  811e30:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  811e37:	00 00 00 
  811e3a:	ff d0                	callq  *%rax
  811e3c:	0f b7 c0             	movzwl %ax,%eax
  811e3f:	25 ff 1f 00 00       	and    $0x1fff,%eax
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  811e44:	85 c0                	test   %eax,%eax
  811e46:	74 23                	je     811e6b <ip_reass+0x237>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  811e48:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811e4c:	48 8d 48 10          	lea    0x10(%rax),%rcx
  811e50:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811e54:	ba 14 00 00 00       	mov    $0x14,%edx
  811e59:	48 89 c6             	mov    %rax,%rsi
  811e5c:	48 89 cf             	mov    %rcx,%rdi
  811e5f:	48 b8 fd 22 80 00 00 	movabs $0x8022fd,%rax
  811e66:	00 00 00 
  811e69:	ff d0                	callq  *%rax
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  811e6b:	0f b6 55 cb          	movzbl -0x35(%rbp),%edx
  811e6f:	48 b8 c8 b0 b4 00 00 	movabs $0xb4b0c8,%rax
  811e76:	00 00 00 
  811e79:	0f b7 00             	movzwl (%rax),%eax
  811e7c:	01 c2                	add    %eax,%edx
  811e7e:	48 b8 c8 b0 b4 00 00 	movabs $0xb4b0c8,%rax
  811e85:	00 00 00 
  811e88:	66 89 10             	mov    %dx,(%rax)

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  811e8b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811e8f:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  811e93:	0f b7 c0             	movzwl %ax,%eax
  811e96:	89 c7                	mov    %eax,%edi
  811e98:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  811e9f:	00 00 00 
  811ea2:	ff d0                	callq  *%rax
  811ea4:	0f b7 c0             	movzwl %ax,%eax
  811ea7:	25 00 20 00 00       	and    $0x2000,%eax
  811eac:	85 c0                	test   %eax,%eax
  811eae:	75 26                	jne    811ed6 <ip_reass+0x2a2>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  811eb0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811eb4:	0f b6 40 26          	movzbl 0x26(%rax),%eax
  811eb8:	89 c2                	mov    %eax,%edx
  811eba:	83 ca 01             	or     $0x1,%edx
  811ebd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811ec1:	88 50 26             	mov    %dl,0x26(%rax)
    ipr->datagram_len = offset + len;
  811ec4:	0f b7 45 cc          	movzwl -0x34(%rbp),%eax
  811ec8:	0f b7 55 ce          	movzwl -0x32(%rbp),%edx
  811ecc:	01 c2                	add    %eax,%edx
  811ece:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811ed2:	66 89 50 24          	mov    %dx,0x24(%rax)
     ("ip_reass: last fragment seen, total len %"S16_F"\n",
      ipr->datagram_len));
  }
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
  811ed6:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  811eda:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811ede:	48 89 d6             	mov    %rdx,%rsi
  811ee1:	48 89 c7             	mov    %rax,%rdi
  811ee4:	48 b8 ae 17 81 00 00 	movabs $0x8117ae,%rax
  811eeb:	00 00 00 
  811eee:	ff d0                	callq  *%rax
  811ef0:	85 c0                	test   %eax,%eax
  811ef2:	0f 84 61 01 00 00    	je     812059 <ip_reass+0x425>
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  811ef8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811efc:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  811f00:	8d 50 14             	lea    0x14(%rax),%edx
  811f03:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811f07:	66 89 50 24          	mov    %dx,0x24(%rax)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  811f0b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811f0f:	48 8b 40 08          	mov    0x8(%rax),%rax
  811f13:	48 8b 40 08          	mov    0x8(%rax),%rax
  811f17:	48 8b 00             	mov    (%rax),%rax
  811f1a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
  811f1e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811f22:	48 8b 40 08          	mov    0x8(%rax),%rax
  811f26:	48 8b 40 08          	mov    0x8(%rax),%rax
  811f2a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  811f2e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811f32:	48 8d 48 10          	lea    0x10(%rax),%rcx
  811f36:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811f3a:	ba 14 00 00 00       	mov    $0x14,%edx
  811f3f:	48 89 ce             	mov    %rcx,%rsi
  811f42:	48 89 c7             	mov    %rax,%rdi
  811f45:	48 b8 fd 22 80 00 00 	movabs $0x8022fd,%rax
  811f4c:	00 00 00 
  811f4f:	ff d0                	callq  *%rax
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  811f51:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811f55:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  811f59:	0f b7 c0             	movzwl %ax,%eax
  811f5c:	89 c7                	mov    %eax,%edi
  811f5e:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  811f65:	00 00 00 
  811f68:	ff d0                	callq  *%rax
  811f6a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  811f6e:	66 89 42 02          	mov    %ax,0x2(%rdx)
    IPH_OFFSET_SET(fraghdr, 0);
  811f72:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811f76:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
    IPH_CHKSUM_SET(fraghdr, 0);
  811f7c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811f80:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  811f86:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  811f8a:	be 14 00 00 00       	mov    $0x14,%esi
  811f8f:	48 89 c7             	mov    %rax,%rdi
  811f92:	48 b8 76 27 81 00 00 	movabs $0x812776,%rax
  811f99:	00 00 00 
  811f9c:	ff d0                	callq  *%rax
  811f9e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  811fa2:	66 89 42 0a          	mov    %ax,0xa(%rdx)

    p = ipr->p;
  811fa6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  811faa:	48 8b 40 08          	mov    0x8(%rax),%rax
  811fae:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  811fb2:	eb 49                	jmp    811ffd <ip_reass+0x3c9>
      iprh = (struct ip_reass_helper*)r->payload;
  811fb4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811fb8:	48 8b 40 08          	mov    0x8(%rax),%rax
  811fbc:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  811fc0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  811fc4:	be ec ff ff ff       	mov    $0xffffffec,%esi
  811fc9:	48 89 c7             	mov    %rax,%rdi
  811fcc:	48 b8 6f d7 80 00 00 	movabs $0x80d76f,%rax
  811fd3:	00 00 00 
  811fd6:	ff d0                	callq  *%rax
      pbuf_cat(p, r);
  811fd8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  811fdc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  811fe0:	48 89 d6             	mov    %rdx,%rsi
  811fe3:	48 89 c7             	mov    %rax,%rdi
  811fe6:	48 b8 37 db 80 00 00 	movabs $0x80db37,%rax
  811fed:	00 00 00 
  811ff0:	ff d0                	callq  *%rax
      r = iprh->next_pbuf;
  811ff2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  811ff6:	48 8b 00             	mov    (%rax),%rax
  811ff9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  811ffd:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  812002:	75 b0                	jne    811fb4 <ip_reass+0x380>
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  812004:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  812008:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81200c:	48 89 d6             	mov    %rdx,%rsi
  81200f:	48 89 c7             	mov    %rax,%rdi
  812012:	48 b8 1c 17 81 00 00 	movabs $0x81171c,%rax
  812019:	00 00 00 
  81201c:	ff d0                	callq  *%rax

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  81201e:	48 b8 c8 b0 b4 00 00 	movabs $0xb4b0c8,%rax
  812025:	00 00 00 
  812028:	0f b7 18             	movzwl (%rax),%ebx
  81202b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81202f:	48 89 c7             	mov    %rax,%rdi
  812032:	48 b8 e1 da 80 00 00 	movabs $0x80dae1,%rax
  812039:	00 00 00 
  81203c:	ff d0                	callq  *%rax
  81203e:	0f b6 c0             	movzbl %al,%eax
  812041:	89 da                	mov    %ebx,%edx
  812043:	66 29 c2             	sub    %ax,%dx
  812046:	48 b8 c8 b0 b4 00 00 	movabs $0xb4b0c8,%rax
  81204d:	00 00 00 
  812050:	66 89 10             	mov    %dx,(%rax)

    /* Return the pbuf chain */
    return p;
  812053:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  812057:	eb 23                	jmp    81207c <ip_reass+0x448>
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  812059:	b8 00 00 00 00       	mov    $0x0,%eax
  81205e:	eb 1c                	jmp    81207c <ip_reass+0x448>
  fraghdr = (struct ip_hdr*)p->payload;

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  812060:	90                   	nop
  812061:	eb 01                	jmp    812064 <ip_reass+0x430>
      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
        ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
      IPFRAG_STATS_INC(ip_frag.memerr);
      /* @todo: send ICMP time exceeded here? */
      /* drop this pbuf */
      goto nullreturn;
  812063:	90                   	nop
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  812064:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  812068:	48 89 c7             	mov    %rax,%rdi
  81206b:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  812072:	00 00 00 
  812075:	ff d0                	callq  *%rax
  return NULL;
  812077:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81207c:	48 83 c4 48          	add    $0x48,%rsp
  812080:	5b                   	pop    %rbx
  812081:	5d                   	pop    %rbp
  812082:	c3                   	retq   

0000000000812083 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  812083:	55                   	push   %rbp
  812084:	48 89 e5             	mov    %rsp,%rbp
  812087:	48 83 ec 50          	sub    $0x50,%rsp
  81208b:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81208f:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  812093:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  812097:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81209b:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  81209f:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
  8120a3:	66 c7 45 fa 14 00    	movw   $0x14,-0x6(%rbp)
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  8120a9:	ba 02 00 00 00       	mov    $0x2,%edx
  8120ae:	be 00 00 00 00       	mov    $0x0,%esi
  8120b3:	bf 02 00 00 00       	mov    $0x2,%edi
  8120b8:	48 b8 4c d0 80 00 00 	movabs $0x80d04c,%rax
  8120bf:	00 00 00 
  8120c2:	ff d0                	callq  *%rax
  8120c4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (rambuf == NULL) {
  8120c8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8120cd:	75 0a                	jne    8120d9 <ip_frag+0x56>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  8120cf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8120d4:	e9 83 02 00 00       	jmpq   81235c <ip_frag+0x2d9>
  }
  rambuf->tot_len = rambuf->len = mtu;
  8120d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8120dd:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8120e1:	66 89 50 12          	mov    %dx,0x12(%rax)
  8120e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8120e9:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  8120ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8120f1:	66 89 50 10          	mov    %dx,0x10(%rax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  8120f5:	48 b8 e0 b0 b4 00 00 	movabs $0xb4b0e0,%rax
  8120fc:	00 00 00 
  8120ff:	48 83 c0 03          	add    $0x3,%rax
  812103:	48 83 e0 fc          	and    $0xfffffffffffffffc,%rax
  812107:	48 89 c2             	mov    %rax,%rdx
  81210a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81210e:	48 89 50 08          	mov    %rdx,0x8(%rax)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  812112:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812116:	48 8b 40 08          	mov    0x8(%rax),%rax
  81211a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  81211e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812122:	48 8b 48 08          	mov    0x8(%rax),%rcx
  812126:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81212a:	ba 14 00 00 00       	mov    $0x14,%edx
  81212f:	48 89 ce             	mov    %rcx,%rsi
  812132:	48 89 c7             	mov    %rax,%rdi
  812135:	48 b8 fd 22 80 00 00 	movabs $0x8022fd,%rax
  81213c:	00 00 00 
  81213f:	ff d0                	callq  *%rax
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  812141:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812145:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  812149:	0f b7 c0             	movzwl %ax,%eax
  81214c:	89 c7                	mov    %eax,%edi
  81214e:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  812155:	00 00 00 
  812158:	ff d0                	callq  *%rax
  81215a:	66 89 45 f8          	mov    %ax,-0x8(%rbp)
  ofo = tmp & IP_OFFMASK;
  81215e:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  812162:	66 25 ff 1f          	and    $0x1fff,%ax
  812166:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  omf = tmp & IP_MF;
  81216a:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  81216e:	66 25 00 20          	and    $0x2000,%ax
  812172:	66 89 45 de          	mov    %ax,-0x22(%rbp)

  left = p->tot_len - IP_HLEN;
  812176:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81217a:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81217e:	83 e8 14             	sub    $0x14,%eax
  812181:	66 89 45 fe          	mov    %ax,-0x2(%rbp)

  nfb = (mtu - IP_HLEN) / 8;
  812185:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  812189:	83 e8 14             	sub    $0x14,%eax
  81218c:	8d 50 07             	lea    0x7(%rax),%edx
  81218f:	85 c0                	test   %eax,%eax
  812191:	0f 48 c2             	cmovs  %edx,%eax
  812194:	c1 f8 03             	sar    $0x3,%eax
  812197:	66 89 45 dc          	mov    %ax,-0x24(%rbp)

  while (left) {
  81219b:	e9 99 01 00 00       	jmpq   812339 <ip_frag+0x2b6>
    last = (left <= mtu - IP_HLEN);
  8121a0:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  8121a4:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8121a8:	83 ea 14             	sub    $0x14,%edx
  8121ab:	39 d0                	cmp    %edx,%eax
  8121ad:	0f 9e c0             	setle  %al
  8121b0:	0f b6 c0             	movzbl %al,%eax
  8121b3:	66 89 45 da          	mov    %ax,-0x26(%rbp)

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  8121b7:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  8121bb:	66 25 ff 1f          	and    $0x1fff,%ax
  8121bf:	66 0b 45 de          	or     -0x22(%rbp),%ax
  8121c3:	66 89 45 f8          	mov    %ax,-0x8(%rbp)
    if (!last)
  8121c7:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  8121cc:	75 06                	jne    8121d4 <ip_frag+0x151>
      tmp = tmp | IP_MF;
  8121ce:	66 81 4d f8 00 20    	orw    $0x2000,-0x8(%rbp)

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  8121d4:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  8121d9:	75 09                	jne    8121e4 <ip_frag+0x161>
  8121db:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8121df:	c1 e0 03             	shl    $0x3,%eax
  8121e2:	eb 04                	jmp    8121e8 <ip_frag+0x165>
  8121e4:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  8121e8:	66 89 45 d8          	mov    %ax,-0x28(%rbp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8121ec:	0f b7 4d fa          	movzwl -0x6(%rbp),%ecx
  8121f0:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
  8121f4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8121f8:	48 8d 70 14          	lea    0x14(%rax),%rsi
  8121fc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812200:	48 89 c7             	mov    %rax,%rdi
  812203:	48 b8 4b e0 80 00 00 	movabs $0x80e04b,%rax
  81220a:	00 00 00 
  81220d:	ff d0                	callq  *%rax
  81220f:	66 01 45 fa          	add    %ax,-0x6(%rbp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  812213:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
  812217:	89 c7                	mov    %eax,%edi
  812219:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  812220:	00 00 00 
  812223:	ff d0                	callq  *%rax
  812225:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  812229:	66 89 42 06          	mov    %ax,0x6(%rdx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  81222d:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  812231:	83 c0 14             	add    $0x14,%eax
  812234:	0f b7 c0             	movzwl %ax,%eax
  812237:	89 c7                	mov    %eax,%edi
  812239:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  812240:	00 00 00 
  812243:	ff d0                	callq  *%rax
  812245:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  812249:	66 89 42 02          	mov    %ax,0x2(%rdx)
    IPH_CHKSUM_SET(iphdr, 0);
  81224d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  812251:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  812257:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81225b:	be 14 00 00 00       	mov    $0x14,%esi
  812260:	48 89 c7             	mov    %rax,%rdi
  812263:	48 b8 76 27 81 00 00 	movabs $0x812776,%rax
  81226a:	00 00 00 
  81226d:	ff d0                	callq  *%rax
  81226f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  812273:	66 89 42 0a          	mov    %ax,0xa(%rdx)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  812277:	66 83 7d da 00       	cmpw   $0x0,-0x26(%rbp)
  81227c:	74 1f                	je     81229d <ip_frag+0x21a>
      pbuf_realloc(rambuf, left + IP_HLEN);
  81227e:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  812282:	83 c0 14             	add    $0x14,%eax
  812285:	0f b7 d0             	movzwl %ax,%edx
  812288:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81228c:	89 d6                	mov    %edx,%esi
  81228e:	48 89 c7             	mov    %rax,%rdi
  812291:	48 b8 1f d5 80 00 00 	movabs $0x80d51f,%rax
  812298:	00 00 00 
  81229b:	ff d0                	callq  *%rax
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  81229d:	ba 00 00 00 00       	mov    $0x0,%edx
  8122a2:	be 00 00 00 00       	mov    $0x0,%esi
  8122a7:	bf 02 00 00 00       	mov    $0x2,%edi
  8122ac:	48 b8 4c d0 80 00 00 	movabs $0x80d04c,%rax
  8122b3:	00 00 00 
  8122b6:	ff d0                	callq  *%rax
  8122b8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (header != NULL) {
  8122bc:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8122c1:	74 5c                	je     81231f <ip_frag+0x29c>
      pbuf_chain(header, rambuf);
  8122c3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8122c7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8122cb:	48 89 d6             	mov    %rdx,%rsi
  8122ce:	48 89 c7             	mov    %rax,%rdi
  8122d1:	48 b8 56 dc 80 00 00 	movabs $0x80dc56,%rax
  8122d8:	00 00 00 
  8122db:	ff d0                	callq  *%rax
      netif->output(netif, header, dest);
  8122dd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8122e1:	4c 8b 40 20          	mov    0x20(%rax),%r8
  8122e5:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8122e9:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8122ed:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8122f1:	48 89 ce             	mov    %rcx,%rsi
  8122f4:	48 89 c7             	mov    %rax,%rdi
  8122f7:	41 ff d0             	callq  *%r8
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  8122fa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8122fe:	48 89 c7             	mov    %rax,%rdi
  812301:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  812308:	00 00 00 
  81230b:	ff d0                	callq  *%rax
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
  81230d:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
  812311:	66 29 45 fe          	sub    %ax,-0x2(%rbp)
    ofo += nfb;
  812315:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  812319:	66 01 45 fc          	add    %ax,-0x4(%rbp)
  81231d:	eb 1a                	jmp    812339 <ip_frag+0x2b6>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  81231f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812323:	48 89 c7             	mov    %rax,%rdi
  812326:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81232d:	00 00 00 
  812330:	ff d0                	callq  *%rax
      return ERR_MEM;
  812332:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  812337:	eb 23                	jmp    81235c <ip_frag+0x2d9>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  812339:	66 83 7d fe 00       	cmpw   $0x0,-0x2(%rbp)
  81233e:	0f 85 5c fe ff ff    	jne    8121a0 <ip_frag+0x11d>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  812344:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812348:	48 89 c7             	mov    %rax,%rdi
  81234b:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  812352:	00 00 00 
  812355:	ff d0                	callq  *%rax
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  812357:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81235c:	c9                   	leaveq 
  81235d:	c3                   	retq   
	...

0000000000812360 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  812360:	55                   	push   %rbp
  812361:	48 89 e5             	mov    %rsp,%rbp
  812364:	48 83 ec 30          	sub    $0x30,%rsp
  812368:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81236c:	89 f0                	mov    %esi,%eax
  81236e:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  812372:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  812379:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81237d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  while (len > 1) {
  812381:	eb 35                	jmp    8123b8 <lwip_standard_chksum+0x58>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  812383:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812387:	0f b6 00             	movzbl (%rax),%eax
  81238a:	0f b6 c0             	movzbl %al,%eax
  81238d:	c1 e0 08             	shl    $0x8,%eax
  812390:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    octetptr++;
  812394:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
    /* declare second octet as least significant */
    src |= (*octetptr);
  812399:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81239d:	0f b6 00             	movzbl (%rax),%eax
  8123a0:	0f b6 c0             	movzbl %al,%eax
  8123a3:	66 09 45 ee          	or     %ax,-0x12(%rbp)
    octetptr++;
  8123a7:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
    acc += src;
  8123ac:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  8123b0:	01 45 fc             	add    %eax,-0x4(%rbp)
    len -= 2;
  8123b3:	66 83 6d d4 02       	subw   $0x2,-0x2c(%rbp)
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  8123b8:	66 83 7d d4 01       	cmpw   $0x1,-0x2c(%rbp)
  8123bd:	77 c4                	ja     812383 <lwip_standard_chksum+0x23>
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  8123bf:	66 83 7d d4 00       	cmpw   $0x0,-0x2c(%rbp)
  8123c4:	74 18                	je     8123de <lwip_standard_chksum+0x7e>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  8123c6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8123ca:	0f b6 00             	movzbl (%rax),%eax
  8123cd:	0f b6 c0             	movzbl %al,%eax
  8123d0:	c1 e0 08             	shl    $0x8,%eax
  8123d3:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    acc += src;
  8123d7:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  8123db:	01 45 fc             	add    %eax,-0x4(%rbp)
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  8123de:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8123e1:	89 c2                	mov    %eax,%edx
  8123e3:	c1 ea 10             	shr    $0x10,%edx
  8123e6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8123e9:	25 ff ff 00 00       	and    $0xffff,%eax
  8123ee:	01 d0                	add    %edx,%eax
  8123f0:	89 45 fc             	mov    %eax,-0x4(%rbp)
  if ((acc & 0xffff0000) != 0) {
  8123f3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8123f6:	66 b8 00 00          	mov    $0x0,%ax
  8123fa:	85 c0                	test   %eax,%eax
  8123fc:	74 15                	je     812413 <lwip_standard_chksum+0xb3>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  8123fe:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812401:	89 c2                	mov    %eax,%edx
  812403:	c1 ea 10             	shr    $0x10,%edx
  812406:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812409:	25 ff ff 00 00       	and    $0xffff,%eax
  81240e:	01 d0                	add    %edx,%eax
  812410:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  812413:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812416:	0f b7 c0             	movzwl %ax,%eax
  812419:	89 c7                	mov    %eax,%edi
  81241b:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  812422:	00 00 00 
  812425:	ff d0                	callq  *%rax
}
  812427:	c9                   	leaveq 
  812428:	c3                   	retq   

0000000000812429 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  812429:	55                   	push   %rbp
  81242a:	48 89 e5             	mov    %rsp,%rbp
  81242d:	48 83 ec 40          	sub    $0x40,%rsp
  812431:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  812435:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  812439:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  81243d:	89 c8                	mov    %ecx,%eax
  81243f:	44 89 c2             	mov    %r8d,%edx
  812442:	88 45 c4             	mov    %al,-0x3c(%rbp)
  812445:	66 89 55 c0          	mov    %dx,-0x40(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  812449:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  812450:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  812454:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  812458:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  81245c:	e9 80 00 00 00       	jmpq   8124e1 <inet_chksum_pseudo+0xb8>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  812461:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812465:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812469:	0f b7 d0             	movzwl %ax,%edx
  81246c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812470:	48 8b 40 08          	mov    0x8(%rax),%rax
  812474:	89 d6                	mov    %edx,%esi
  812476:	48 89 c7             	mov    %rax,%rdi
  812479:	48 b8 60 23 81 00 00 	movabs $0x812360,%rax
  812480:	00 00 00 
  812483:	ff d0                	callq  *%rax
  812485:	0f b7 c0             	movzwl %ax,%eax
  812488:	01 45 fc             	add    %eax,-0x4(%rbp)
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  81248b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81248e:	89 c2                	mov    %eax,%edx
  812490:	c1 ea 10             	shr    $0x10,%edx
  812493:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812496:	25 ff ff 00 00       	and    $0xffff,%eax
  81249b:	01 d0                	add    %edx,%eax
  81249d:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  8124a0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8124a4:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8124a8:	0f b7 c0             	movzwl %ax,%eax
  8124ab:	83 e0 01             	and    $0x1,%eax
  8124ae:	84 c0                	test   %al,%al
  8124b0:	74 24                	je     8124d6 <inet_chksum_pseudo+0xad>
      swapped = 1 - swapped;
  8124b2:	b8 01 00 00 00       	mov    $0x1,%eax
  8124b7:	2a 45 ef             	sub    -0x11(%rbp),%al
  8124ba:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  8124bd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8124c0:	c1 e0 08             	shl    $0x8,%eax
  8124c3:	0f b7 d0             	movzwl %ax,%edx
  8124c6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8124c9:	25 00 ff 00 00       	and    $0xff00,%eax
  8124ce:	c1 e8 08             	shr    $0x8,%eax
  8124d1:	09 d0                	or     %edx,%eax
  8124d3:	89 45 fc             	mov    %eax,-0x4(%rbp)
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  8124d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8124da:	48 8b 00             	mov    (%rax),%rax
  8124dd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8124e1:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8124e6:	0f 85 75 ff ff ff    	jne    812461 <inet_chksum_pseudo+0x38>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  8124ec:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  8124f0:	74 19                	je     81250b <inet_chksum_pseudo+0xe2>
    acc = SWAP_BYTES_IN_WORD(acc);
  8124f2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8124f5:	c1 e0 08             	shl    $0x8,%eax
  8124f8:	0f b7 d0             	movzwl %ax,%edx
  8124fb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8124fe:	25 00 ff 00 00       	and    $0xff00,%eax
  812503:	c1 e8 08             	shr    $0x8,%eax
  812506:	09 d0                	or     %edx,%eax
  812508:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  acc += (src->addr & 0xffffUL);
  81250b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81250f:	8b 00                	mov    (%rax),%eax
  812511:	25 ff ff 00 00       	and    $0xffff,%eax
  812516:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((src->addr >> 16) & 0xffffUL);
  812519:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81251d:	8b 00                	mov    (%rax),%eax
  81251f:	c1 e8 10             	shr    $0x10,%eax
  812522:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (dest->addr & 0xffffUL);
  812525:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812529:	8b 00                	mov    (%rax),%eax
  81252b:	25 ff ff 00 00       	and    $0xffff,%eax
  812530:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((dest->addr >> 16) & 0xffffUL);
  812533:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  812537:	8b 00                	mov    (%rax),%eax
  812539:	c1 e8 10             	shr    $0x10,%eax
  81253c:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons((u16_t)proto);
  81253f:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  812543:	89 c7                	mov    %eax,%edi
  812545:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  81254c:	00 00 00 
  81254f:	ff d0                	callq  *%rax
  812551:	0f b7 c0             	movzwl %ax,%eax
  812554:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons(proto_len);
  812557:	0f b7 45 c0          	movzwl -0x40(%rbp),%eax
  81255b:	89 c7                	mov    %eax,%edi
  81255d:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  812564:	00 00 00 
  812567:	ff d0                	callq  *%rax
  812569:	0f b7 c0             	movzwl %ax,%eax
  81256c:	01 45 fc             	add    %eax,-0x4(%rbp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  81256f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812572:	89 c2                	mov    %eax,%edx
  812574:	c1 ea 10             	shr    $0x10,%edx
  812577:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81257a:	25 ff ff 00 00       	and    $0xffff,%eax
  81257f:	01 d0                	add    %edx,%eax
  812581:	89 45 fc             	mov    %eax,-0x4(%rbp)
  acc = FOLD_U32T(acc);
  812584:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812587:	89 c2                	mov    %eax,%edx
  812589:	c1 ea 10             	shr    $0x10,%edx
  81258c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81258f:	25 ff ff 00 00       	and    $0xffff,%eax
  812594:	01 d0                	add    %edx,%eax
  812596:	89 45 fc             	mov    %eax,-0x4(%rbp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  812599:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81259c:	f7 d0                	not    %eax
}
  81259e:	c9                   	leaveq 
  81259f:	c3                   	retq   

00000000008125a0 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  8125a0:	55                   	push   %rbp
  8125a1:	48 89 e5             	mov    %rsp,%rbp
  8125a4:	48 83 ec 50          	sub    $0x50,%rsp
  8125a8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8125ac:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8125b0:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8125b4:	89 c8                	mov    %ecx,%eax
  8125b6:	44 89 c1             	mov    %r8d,%ecx
  8125b9:	44 89 ca             	mov    %r9d,%edx
  8125bc:	88 45 c4             	mov    %al,-0x3c(%rbp)
  8125bf:	66 89 4d c0          	mov    %cx,-0x40(%rbp)
  8125c3:	66 89 55 bc          	mov    %dx,-0x44(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  8125c7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  8125ce:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  8125d2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8125d6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8125da:	e9 d1 00 00 00       	jmpq   8126b0 <inet_chksum_pseudo_partial+0x110>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  8125df:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8125e3:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8125e7:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
    if (chklen > chksum_len) {
  8125eb:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  8125ef:	66 3b 45 bc          	cmp    -0x44(%rbp),%ax
  8125f3:	76 08                	jbe    8125fd <inet_chksum_pseudo_partial+0x5d>
      chklen = chksum_len;
  8125f5:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  8125f9:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  8125fd:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
  812601:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812605:	48 8b 40 08          	mov    0x8(%rax),%rax
  812609:	89 d6                	mov    %edx,%esi
  81260b:	48 89 c7             	mov    %rax,%rdi
  81260e:	48 b8 60 23 81 00 00 	movabs $0x812360,%rax
  812615:	00 00 00 
  812618:	ff d0                	callq  *%rax
  81261a:	0f b7 c0             	movzwl %ax,%eax
  81261d:	01 45 fc             	add    %eax,-0x4(%rbp)
    chksum_len -= chklen;
  812620:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
  812624:	66 29 45 bc          	sub    %ax,-0x44(%rbp)
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  812628:	66 81 7d bc fe 7f    	cmpw   $0x7ffe,-0x44(%rbp)
  81262e:	76 2a                	jbe    81265a <inet_chksum_pseudo_partial+0xba>
  812630:	48 ba 28 25 82 00 00 	movabs $0x822528,%rdx
  812637:	00 00 00 
  81263a:	be 60 01 00 00       	mov    $0x160,%esi
  81263f:	48 bf 38 25 82 00 00 	movabs $0x822538,%rdi
  812646:	00 00 00 
  812649:	b8 00 00 00 00       	mov    $0x0,%eax
  81264e:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  812655:	00 00 00 
  812658:	ff d1                	callq  *%rcx
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  81265a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81265d:	89 c2                	mov    %eax,%edx
  81265f:	c1 ea 10             	shr    $0x10,%edx
  812662:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812665:	25 ff ff 00 00       	and    $0xffff,%eax
  81266a:	01 d0                	add    %edx,%eax
  81266c:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  81266f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812673:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812677:	0f b7 c0             	movzwl %ax,%eax
  81267a:	83 e0 01             	and    $0x1,%eax
  81267d:	84 c0                	test   %al,%al
  81267f:	74 24                	je     8126a5 <inet_chksum_pseudo_partial+0x105>
      swapped = 1 - swapped;
  812681:	b8 01 00 00 00       	mov    $0x1,%eax
  812686:	2a 45 ef             	sub    -0x11(%rbp),%al
  812689:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  81268c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81268f:	c1 e0 08             	shl    $0x8,%eax
  812692:	0f b7 d0             	movzwl %ax,%edx
  812695:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812698:	25 00 ff 00 00       	and    $0xff00,%eax
  81269d:	c1 e8 08             	shr    $0x8,%eax
  8126a0:	09 d0                	or     %edx,%eax
  8126a2:	89 45 fc             	mov    %eax,-0x4(%rbp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  8126a5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8126a9:	48 8b 00             	mov    (%rax),%rax
  8126ac:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8126b0:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8126b5:	74 0b                	je     8126c2 <inet_chksum_pseudo_partial+0x122>
  8126b7:	66 83 7d bc 00       	cmpw   $0x0,-0x44(%rbp)
  8126bc:	0f 85 1d ff ff ff    	jne    8125df <inet_chksum_pseudo_partial+0x3f>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  8126c2:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  8126c6:	74 19                	je     8126e1 <inet_chksum_pseudo_partial+0x141>
    acc = SWAP_BYTES_IN_WORD(acc);
  8126c8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8126cb:	c1 e0 08             	shl    $0x8,%eax
  8126ce:	0f b7 d0             	movzwl %ax,%edx
  8126d1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8126d4:	25 00 ff 00 00       	and    $0xff00,%eax
  8126d9:	c1 e8 08             	shr    $0x8,%eax
  8126dc:	09 d0                	or     %edx,%eax
  8126de:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  acc += (src->addr & 0xffffUL);
  8126e1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8126e5:	8b 00                	mov    (%rax),%eax
  8126e7:	25 ff ff 00 00       	and    $0xffff,%eax
  8126ec:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((src->addr >> 16) & 0xffffUL);
  8126ef:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8126f3:	8b 00                	mov    (%rax),%eax
  8126f5:	c1 e8 10             	shr    $0x10,%eax
  8126f8:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (dest->addr & 0xffffUL);
  8126fb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8126ff:	8b 00                	mov    (%rax),%eax
  812701:	25 ff ff 00 00       	and    $0xffff,%eax
  812706:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += ((dest->addr >> 16) & 0xffffUL);
  812709:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81270d:	8b 00                	mov    (%rax),%eax
  81270f:	c1 e8 10             	shr    $0x10,%eax
  812712:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons((u16_t)proto);
  812715:	0f b6 45 c4          	movzbl -0x3c(%rbp),%eax
  812719:	89 c7                	mov    %eax,%edi
  81271b:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  812722:	00 00 00 
  812725:	ff d0                	callq  *%rax
  812727:	0f b7 c0             	movzwl %ax,%eax
  81272a:	01 45 fc             	add    %eax,-0x4(%rbp)
  acc += (u32_t)htons(proto_len);
  81272d:	0f b7 45 c0          	movzwl -0x40(%rbp),%eax
  812731:	89 c7                	mov    %eax,%edi
  812733:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  81273a:	00 00 00 
  81273d:	ff d0                	callq  *%rax
  81273f:	0f b7 c0             	movzwl %ax,%eax
  812742:	01 45 fc             	add    %eax,-0x4(%rbp)

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  812745:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812748:	89 c2                	mov    %eax,%edx
  81274a:	c1 ea 10             	shr    $0x10,%edx
  81274d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812750:	25 ff ff 00 00       	and    $0xffff,%eax
  812755:	01 d0                	add    %edx,%eax
  812757:	89 45 fc             	mov    %eax,-0x4(%rbp)
  acc = FOLD_U32T(acc);
  81275a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81275d:	89 c2                	mov    %eax,%edx
  81275f:	c1 ea 10             	shr    $0x10,%edx
  812762:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812765:	25 ff ff 00 00       	and    $0xffff,%eax
  81276a:	01 d0                	add    %edx,%eax
  81276c:	89 45 fc             	mov    %eax,-0x4(%rbp)
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  81276f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812772:	f7 d0                	not    %eax
}
  812774:	c9                   	leaveq 
  812775:	c3                   	retq   

0000000000812776 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  812776:	55                   	push   %rbp
  812777:	48 89 e5             	mov    %rsp,%rbp
  81277a:	48 83 ec 10          	sub    $0x10,%rsp
  81277e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  812782:	89 f0                	mov    %esi,%eax
  812784:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
  return ~LWIP_CHKSUM(dataptr, len);
  812788:	0f b7 55 f4          	movzwl -0xc(%rbp),%edx
  81278c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812790:	89 d6                	mov    %edx,%esi
  812792:	48 89 c7             	mov    %rax,%rdi
  812795:	48 b8 60 23 81 00 00 	movabs $0x812360,%rax
  81279c:	00 00 00 
  81279f:	ff d0                	callq  *%rax
  8127a1:	f7 d0                	not    %eax
}
  8127a3:	c9                   	leaveq 
  8127a4:	c3                   	retq   

00000000008127a5 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  8127a5:	55                   	push   %rbp
  8127a6:	48 89 e5             	mov    %rsp,%rbp
  8127a9:	48 83 ec 30          	sub    $0x30,%rsp
  8127ad:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  8127b1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  swapped = 0;
  8127b8:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  for(q = p; q != NULL; q = q->next) {
  8127bc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8127c0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8127c4:	e9 80 00 00 00       	jmpq   812849 <inet_chksum_pbuf+0xa4>
    acc += LWIP_CHKSUM(q->payload, q->len);
  8127c9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8127cd:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8127d1:	0f b7 d0             	movzwl %ax,%edx
  8127d4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8127d8:	48 8b 40 08          	mov    0x8(%rax),%rax
  8127dc:	89 d6                	mov    %edx,%esi
  8127de:	48 89 c7             	mov    %rax,%rdi
  8127e1:	48 b8 60 23 81 00 00 	movabs $0x812360,%rax
  8127e8:	00 00 00 
  8127eb:	ff d0                	callq  *%rax
  8127ed:	0f b7 c0             	movzwl %ax,%eax
  8127f0:	01 45 fc             	add    %eax,-0x4(%rbp)
    acc = FOLD_U32T(acc);
  8127f3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8127f6:	89 c2                	mov    %eax,%edx
  8127f8:	c1 ea 10             	shr    $0x10,%edx
  8127fb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8127fe:	25 ff ff 00 00       	and    $0xffff,%eax
  812803:	01 d0                	add    %edx,%eax
  812805:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (q->len % 2 != 0) {
  812808:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81280c:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  812810:	0f b7 c0             	movzwl %ax,%eax
  812813:	83 e0 01             	and    $0x1,%eax
  812816:	84 c0                	test   %al,%al
  812818:	74 24                	je     81283e <inet_chksum_pbuf+0x99>
      swapped = 1 - swapped;
  81281a:	b8 01 00 00 00       	mov    $0x1,%eax
  81281f:	2a 45 ef             	sub    -0x11(%rbp),%al
  812822:	88 45 ef             	mov    %al,-0x11(%rbp)
      acc = SWAP_BYTES_IN_WORD(acc);
  812825:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812828:	c1 e0 08             	shl    $0x8,%eax
  81282b:	0f b7 d0             	movzwl %ax,%edx
  81282e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812831:	25 00 ff 00 00       	and    $0xff00,%eax
  812836:	c1 e8 08             	shr    $0x8,%eax
  812839:	09 d0                	or     %edx,%eax
  81283b:	89 45 fc             	mov    %eax,-0x4(%rbp)
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  81283e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812842:	48 8b 00             	mov    (%rax),%rax
  812845:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  812849:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81284e:	0f 85 75 ff ff ff    	jne    8127c9 <inet_chksum_pbuf+0x24>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  812854:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  812858:	74 19                	je     812873 <inet_chksum_pbuf+0xce>
    acc = SWAP_BYTES_IN_WORD(acc);
  81285a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81285d:	c1 e0 08             	shl    $0x8,%eax
  812860:	0f b7 d0             	movzwl %ax,%edx
  812863:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812866:	25 00 ff 00 00       	and    $0xff00,%eax
  81286b:	c1 e8 08             	shr    $0x8,%eax
  81286e:	09 d0                	or     %edx,%eax
  812870:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
  return (u16_t)~(acc & 0xffffUL);
  812873:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812876:	f7 d0                	not    %eax
}
  812878:	c9                   	leaveq 
  812879:	c3                   	retq   
	...

000000000081287c <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  81287c:	55                   	push   %rbp
  81287d:	48 89 e5             	mov    %rsp,%rbp
  812880:	48 83 ec 20          	sub    $0x20,%rsp
  812884:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  812888:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  81288c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812890:	48 89 d6             	mov    %rdx,%rsi
  812893:	48 89 c7             	mov    %rax,%rdi
  812896:	48 b8 b2 28 81 00 00 	movabs $0x8128b2,%rax
  81289d:	00 00 00 
  8128a0:	ff d0                	callq  *%rax
  8128a2:	85 c0                	test   %eax,%eax
  8128a4:	74 05                	je     8128ab <inet_addr+0x2f>
    return (val.s_addr);
  8128a6:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8128a9:	eb 05                	jmp    8128b0 <inet_addr+0x34>
  }
  return (INADDR_NONE);
  8128ab:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8128b0:	c9                   	leaveq 
  8128b1:	c3                   	retq   

00000000008128b2 <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  8128b2:	55                   	push   %rbp
  8128b3:	48 89 e5             	mov    %rsp,%rbp
  8128b6:	53                   	push   %rbx
  8128b7:	48 83 ec 48          	sub    $0x48,%rsp
  8128bb:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8128bf:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;
  8128c3:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8128c7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  c = *cp;
  8128cb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8128cf:	0f b6 00             	movzbl (%rax),%eax
  8128d2:	0f be c0             	movsbl %al,%eax
  8128d5:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  8128d8:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8128db:	3c 2f                	cmp    $0x2f,%al
  8128dd:	76 07                	jbe    8128e6 <inet_aton+0x34>
  8128df:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8128e2:	3c 39                	cmp    $0x39,%al
  8128e4:	76 0a                	jbe    8128f0 <inet_aton+0x3e>
      return (0);
  8128e6:	b8 00 00 00 00       	mov    $0x0,%eax
  8128eb:	e9 6a 02 00 00       	jmpq   812b5a <inet_aton+0x2a8>
    val = 0;
  8128f0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
    base = 10;
  8128f7:	c7 45 e8 0a 00 00 00 	movl   $0xa,-0x18(%rbp)
    if (c == '0') {
  8128fe:	83 7d e4 30          	cmpl   $0x30,-0x1c(%rbp)
  812902:	75 40                	jne    812944 <inet_aton+0x92>
      c = *++cp;
  812904:	48 83 45 b8 01       	addq   $0x1,-0x48(%rbp)
  812909:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81290d:	0f b6 00             	movzbl (%rax),%eax
  812910:	0f be c0             	movsbl %al,%eax
  812913:	89 45 e4             	mov    %eax,-0x1c(%rbp)
      if (c == 'x' || c == 'X') {
  812916:	83 7d e4 78          	cmpl   $0x78,-0x1c(%rbp)
  81291a:	74 06                	je     812922 <inet_aton+0x70>
  81291c:	83 7d e4 58          	cmpl   $0x58,-0x1c(%rbp)
  812920:	75 1b                	jne    81293d <inet_aton+0x8b>
        base = 16;
  812922:	c7 45 e8 10 00 00 00 	movl   $0x10,-0x18(%rbp)
        c = *++cp;
  812929:	48 83 45 b8 01       	addq   $0x1,-0x48(%rbp)
  81292e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  812932:	0f b6 00             	movzbl (%rax),%eax
  812935:	0f be c0             	movsbl %al,%eax
  812938:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  81293b:	eb 07                	jmp    812944 <inet_aton+0x92>
      } else
        base = 8;
  81293d:	c7 45 e8 08 00 00 00 	movl   $0x8,-0x18(%rbp)
    }
    for (;;) {
      if (isdigit(c)) {
  812944:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  812947:	3c 2f                	cmp    $0x2f,%al
  812949:	76 2f                	jbe    81297a <inet_aton+0xc8>
  81294b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  81294e:	3c 39                	cmp    $0x39,%al
  812950:	77 28                	ja     81297a <inet_aton+0xc8>
        val = (val * base) + (int)(c - '0');
  812952:	8b 45 e8             	mov    -0x18(%rbp),%eax
  812955:	89 c2                	mov    %eax,%edx
  812957:	0f af 55 ec          	imul   -0x14(%rbp),%edx
  81295b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  81295e:	01 d0                	add    %edx,%eax
  812960:	83 e8 30             	sub    $0x30,%eax
  812963:	89 45 ec             	mov    %eax,-0x14(%rbp)
        c = *++cp;
  812966:	48 83 45 b8 01       	addq   $0x1,-0x48(%rbp)
  81296b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81296f:	0f b6 00             	movzbl (%rax),%eax
  812972:	0f be c0             	movsbl %al,%eax
  812975:	89 45 e4             	mov    %eax,-0x1c(%rbp)
      } else if (base == 16 && isxdigit(c)) {
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
        c = *++cp;
      } else
        break;
    }
  812978:	eb ca                	jmp    812944 <inet_aton+0x92>
    }
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (int)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
  81297a:	83 7d e8 10          	cmpl   $0x10,-0x18(%rbp)
  81297e:	75 74                	jne    8129f4 <inet_aton+0x142>
  812980:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  812983:	3c 2f                	cmp    $0x2f,%al
  812985:	76 07                	jbe    81298e <inet_aton+0xdc>
  812987:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  81298a:	3c 39                	cmp    $0x39,%al
  81298c:	76 1c                	jbe    8129aa <inet_aton+0xf8>
  81298e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  812991:	3c 60                	cmp    $0x60,%al
  812993:	76 07                	jbe    81299c <inet_aton+0xea>
  812995:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  812998:	3c 66                	cmp    $0x66,%al
  81299a:	76 0e                	jbe    8129aa <inet_aton+0xf8>
  81299c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  81299f:	3c 40                	cmp    $0x40,%al
  8129a1:	76 51                	jbe    8129f4 <inet_aton+0x142>
  8129a3:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8129a6:	3c 46                	cmp    $0x46,%al
  8129a8:	77 4a                	ja     8129f4 <inet_aton+0x142>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  8129aa:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8129ad:	89 c2                	mov    %eax,%edx
  8129af:	c1 e2 04             	shl    $0x4,%edx
  8129b2:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8129b5:	8d 48 0a             	lea    0xa(%rax),%ecx
  8129b8:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8129bb:	3c 60                	cmp    $0x60,%al
  8129bd:	76 0e                	jbe    8129cd <inet_aton+0x11b>
  8129bf:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8129c2:	3c 7a                	cmp    $0x7a,%al
  8129c4:	77 07                	ja     8129cd <inet_aton+0x11b>
  8129c6:	b8 61 00 00 00       	mov    $0x61,%eax
  8129cb:	eb 05                	jmp    8129d2 <inet_aton+0x120>
  8129cd:	b8 41 00 00 00       	mov    $0x41,%eax
  8129d2:	89 cb                	mov    %ecx,%ebx
  8129d4:	29 c3                	sub    %eax,%ebx
  8129d6:	89 d8                	mov    %ebx,%eax
  8129d8:	09 d0                	or     %edx,%eax
  8129da:	89 45 ec             	mov    %eax,-0x14(%rbp)
        c = *++cp;
  8129dd:	48 83 45 b8 01       	addq   $0x1,-0x48(%rbp)
  8129e2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8129e6:	0f b6 00             	movzbl (%rax),%eax
  8129e9:	0f be c0             	movsbl %al,%eax
  8129ec:	89 45 e4             	mov    %eax,-0x1c(%rbp)
      } else
        break;
    }
  8129ef:	e9 50 ff ff ff       	jmpq   812944 <inet_aton+0x92>
    if (c == '.') {
  8129f4:	83 7d e4 2e          	cmpl   $0x2e,-0x1c(%rbp)
  8129f8:	75 3d                	jne    812a37 <inet_aton+0x185>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  8129fa:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8129fe:	48 83 c0 0c          	add    $0xc,%rax
  812a02:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  812a06:	72 0a                	jb     812a12 <inet_aton+0x160>
        return (0);
  812a08:	b8 00 00 00 00       	mov    $0x0,%eax
  812a0d:	e9 48 01 00 00       	jmpq   812b5a <inet_aton+0x2a8>
      *pp++ = val;
  812a12:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  812a16:	8b 55 ec             	mov    -0x14(%rbp),%edx
  812a19:	89 10                	mov    %edx,(%rax)
  812a1b:	48 83 45 d8 04       	addq   $0x4,-0x28(%rbp)
      c = *++cp;
  812a20:	48 83 45 b8 01       	addq   $0x1,-0x48(%rbp)
  812a25:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  812a29:	0f b6 00             	movzbl (%rax),%eax
  812a2c:	0f be c0             	movsbl %al,%eax
  812a2f:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    } else
      break;
  }
  812a32:	e9 a1 fe ff ff       	jmpq   8128d8 <inet_aton+0x26>
      if (pp >= parts + 3)
        return (0);
      *pp++ = val;
      c = *++cp;
    } else
      break;
  812a37:	90                   	nop
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  812a38:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  812a3c:	74 3c                	je     812a7a <inet_aton+0x1c8>
  812a3e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  812a41:	3c 1f                	cmp    $0x1f,%al
  812a43:	76 2b                	jbe    812a70 <inet_aton+0x1be>
  812a45:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  812a48:	84 c0                	test   %al,%al
  812a4a:	78 24                	js     812a70 <inet_aton+0x1be>
  812a4c:	83 7d e4 20          	cmpl   $0x20,-0x1c(%rbp)
  812a50:	74 28                	je     812a7a <inet_aton+0x1c8>
  812a52:	83 7d e4 0c          	cmpl   $0xc,-0x1c(%rbp)
  812a56:	74 22                	je     812a7a <inet_aton+0x1c8>
  812a58:	83 7d e4 0a          	cmpl   $0xa,-0x1c(%rbp)
  812a5c:	74 1c                	je     812a7a <inet_aton+0x1c8>
  812a5e:	83 7d e4 0d          	cmpl   $0xd,-0x1c(%rbp)
  812a62:	74 16                	je     812a7a <inet_aton+0x1c8>
  812a64:	83 7d e4 09          	cmpl   $0x9,-0x1c(%rbp)
  812a68:	74 10                	je     812a7a <inet_aton+0x1c8>
  812a6a:	83 7d e4 0b          	cmpl   $0xb,-0x1c(%rbp)
  812a6e:	74 0a                	je     812a7a <inet_aton+0x1c8>
    return (0);
  812a70:	b8 00 00 00 00       	mov    $0x0,%eax
  812a75:	e9 e0 00 00 00       	jmpq   812b5a <inet_aton+0x2a8>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  812a7a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  812a7e:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  812a82:	48 89 d1             	mov    %rdx,%rcx
  812a85:	48 29 c1             	sub    %rax,%rcx
  812a88:	48 89 c8             	mov    %rcx,%rax
  812a8b:	48 c1 f8 02          	sar    $0x2,%rax
  812a8f:	83 c0 01             	add    $0x1,%eax
  812a92:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  switch (n) {
  812a95:	83 7d d4 04          	cmpl   $0x4,-0x2c(%rbp)
  812a99:	0f 87 98 00 00 00    	ja     812b37 <inet_aton+0x285>
  812a9f:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  812aa2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  812aa9:	00 
  812aaa:	48 b8 60 25 82 00 00 	movabs $0x822560,%rax
  812ab1:	00 00 00 
  812ab4:	48 01 d0             	add    %rdx,%rax
  812ab7:	48 8b 00             	mov    (%rax),%rax
  812aba:	ff e0                	jmpq   *%rax

  case 0:
    return (0);       /* initial nondigit */
  812abc:	b8 00 00 00 00       	mov    $0x0,%eax
  812ac1:	e9 94 00 00 00       	jmpq   812b5a <inet_aton+0x2a8>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  812ac6:	81 7d ec ff ff ff 00 	cmpl   $0xffffff,-0x14(%rbp)
  812acd:	76 0a                	jbe    812ad9 <inet_aton+0x227>
      return (0);
  812acf:	b8 00 00 00 00       	mov    $0x0,%eax
  812ad4:	e9 81 00 00 00       	jmpq   812b5a <inet_aton+0x2a8>
    val |= parts[0] << 24;
  812ad9:	8b 45 c0             	mov    -0x40(%rbp),%eax
  812adc:	c1 e0 18             	shl    $0x18,%eax
  812adf:	09 45 ec             	or     %eax,-0x14(%rbp)
    break;
  812ae2:	eb 53                	jmp    812b37 <inet_aton+0x285>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  812ae4:	81 7d ec ff ff 00 00 	cmpl   $0xffff,-0x14(%rbp)
  812aeb:	76 07                	jbe    812af4 <inet_aton+0x242>
      return (0);
  812aed:	b8 00 00 00 00       	mov    $0x0,%eax
  812af2:	eb 66                	jmp    812b5a <inet_aton+0x2a8>
    val |= (parts[0] << 24) | (parts[1] << 16);
  812af4:	8b 45 c0             	mov    -0x40(%rbp),%eax
  812af7:	89 c2                	mov    %eax,%edx
  812af9:	c1 e2 18             	shl    $0x18,%edx
  812afc:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  812aff:	c1 e0 10             	shl    $0x10,%eax
  812b02:	09 d0                	or     %edx,%eax
  812b04:	09 45 ec             	or     %eax,-0x14(%rbp)
    break;
  812b07:	eb 2e                	jmp    812b37 <inet_aton+0x285>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  812b09:	81 7d ec ff 00 00 00 	cmpl   $0xff,-0x14(%rbp)
  812b10:	76 07                	jbe    812b19 <inet_aton+0x267>
      return (0);
  812b12:	b8 00 00 00 00       	mov    $0x0,%eax
  812b17:	eb 41                	jmp    812b5a <inet_aton+0x2a8>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  812b19:	8b 45 c0             	mov    -0x40(%rbp),%eax
  812b1c:	89 c2                	mov    %eax,%edx
  812b1e:	c1 e2 18             	shl    $0x18,%edx
  812b21:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  812b24:	c1 e0 10             	shl    $0x10,%eax
  812b27:	09 c2                	or     %eax,%edx
  812b29:	8b 45 c8             	mov    -0x38(%rbp),%eax
  812b2c:	c1 e0 08             	shl    $0x8,%eax
  812b2f:	09 d0                	or     %edx,%eax
  812b31:	09 45 ec             	or     %eax,-0x14(%rbp)
    break;
  812b34:	eb 01                	jmp    812b37 <inet_aton+0x285>

  case 0:
    return (0);       /* initial nondigit */

  case 1:             /* a -- 32 bits */
    break;
  812b36:	90                   	nop
    if (val > 0xff)
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    break;
  }
  if (addr)
  812b37:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  812b3c:	74 17                	je     812b55 <inet_aton+0x2a3>
    addr->s_addr = htonl(val);
  812b3e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  812b41:	89 c7                	mov    %eax,%edi
  812b43:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  812b4a:	00 00 00 
  812b4d:	ff d0                	callq  *%rax
  812b4f:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  812b53:	89 02                	mov    %eax,(%rdx)
  return (1);
  812b55:	b8 01 00 00 00       	mov    $0x1,%eax
}
  812b5a:	48 83 c4 48          	add    $0x48,%rsp
  812b5e:	5b                   	pop    %rbx
  812b5f:	5d                   	pop    %rbp
  812b60:	c3                   	retq   

0000000000812b61 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  812b61:	55                   	push   %rbp
  812b62:	48 89 e5             	mov    %rsp,%rbp
  812b65:	48 83 ec 30          	sub    $0x30,%rsp
  812b69:	89 7d d0             	mov    %edi,-0x30(%rbp)
  static char str[16];
  u32_t s_addr = addr.s_addr;
  812b6c:	8b 45 d0             	mov    -0x30(%rbp),%eax
  812b6f:	89 45 e8             	mov    %eax,-0x18(%rbp)
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  812b72:	48 b8 c0 b6 b4 00 00 	movabs $0xb4b6c0,%rax
  812b79:	00 00 00 
  812b7c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  ap = (u8_t *)&s_addr;
  812b80:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  812b84:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  for(n = 0; n < 4; n++) {
  812b88:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  812b8c:	e9 d1 00 00 00       	jmpq   812c62 <inet_ntoa+0x101>
    i = 0;
  812b91:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)
    do {
      rem = *ap % (u8_t)10;
  812b95:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812b99:	0f b6 08             	movzbl (%rax),%ecx
  812b9c:	0f b6 d1             	movzbl %cl,%edx
  812b9f:	89 d0                	mov    %edx,%eax
  812ba1:	c1 e0 02             	shl    $0x2,%eax
  812ba4:	01 d0                	add    %edx,%eax
  812ba6:	c1 e0 03             	shl    $0x3,%eax
  812ba9:	01 d0                	add    %edx,%eax
  812bab:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
  812bb2:	01 d0                	add    %edx,%eax
  812bb4:	66 c1 e8 08          	shr    $0x8,%ax
  812bb8:	c0 e8 03             	shr    $0x3,%al
  812bbb:	88 45 ed             	mov    %al,-0x13(%rbp)
  812bbe:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  812bc2:	89 d0                	mov    %edx,%eax
  812bc4:	c1 e0 02             	shl    $0x2,%eax
  812bc7:	01 d0                	add    %edx,%eax
  812bc9:	01 c0                	add    %eax,%eax
  812bcb:	89 ca                	mov    %ecx,%edx
  812bcd:	28 c2                	sub    %al,%dl
  812bcf:	89 d0                	mov    %edx,%eax
  812bd1:	88 45 ed             	mov    %al,-0x13(%rbp)
      *ap /= (u8_t)10;
  812bd4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812bd8:	0f b6 00             	movzbl (%rax),%eax
  812bdb:	0f b6 d0             	movzbl %al,%edx
  812bde:	89 d0                	mov    %edx,%eax
  812be0:	c1 e0 02             	shl    $0x2,%eax
  812be3:	01 d0                	add    %edx,%eax
  812be5:	c1 e0 03             	shl    $0x3,%eax
  812be8:	01 d0                	add    %edx,%eax
  812bea:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
  812bf1:	01 d0                	add    %edx,%eax
  812bf3:	66 c1 e8 08          	shr    $0x8,%ax
  812bf7:	89 c2                	mov    %eax,%edx
  812bf9:	c0 ea 03             	shr    $0x3,%dl
  812bfc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812c00:	88 10                	mov    %dl,(%rax)
      inv[i++] = '0' + rem;
  812c02:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  812c06:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  812c0a:	83 c2 30             	add    $0x30,%edx
  812c0d:	48 98                	cltq   
  812c0f:	88 54 05 e0          	mov    %dl,-0x20(%rbp,%rax,1)
  812c13:	80 45 ee 01          	addb   $0x1,-0x12(%rbp)
    } while(*ap);
  812c17:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  812c1b:	0f b6 00             	movzbl (%rax),%eax
  812c1e:	84 c0                	test   %al,%al
  812c20:	0f 85 6f ff ff ff    	jne    812b95 <inet_ntoa+0x34>
    while(i--)
  812c26:	eb 16                	jmp    812c3e <inet_ntoa+0xdd>
      *rp++ = inv[i];
  812c28:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  812c2c:	48 98                	cltq   
  812c2e:	0f b6 54 05 e0       	movzbl -0x20(%rbp,%rax,1),%edx
  812c33:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812c37:	88 10                	mov    %dl,(%rax)
  812c39:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  812c3e:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  812c42:	0f 95 c0             	setne  %al
  812c45:	80 6d ee 01          	subb   $0x1,-0x12(%rbp)
  812c49:	84 c0                	test   %al,%al
  812c4b:	75 db                	jne    812c28 <inet_ntoa+0xc7>
      *rp++ = inv[i];
    *rp++ = '.';
  812c4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812c51:	c6 00 2e             	movb   $0x2e,(%rax)
  812c54:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
    ap++;
  812c59:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  812c5e:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
  812c62:	80 7d ef 03          	cmpb   $0x3,-0x11(%rbp)
  812c66:	0f 86 25 ff ff ff    	jbe    812b91 <inet_ntoa+0x30>
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
  812c6c:	48 83 6d f8 01       	subq   $0x1,-0x8(%rbp)
  812c71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812c75:	c6 00 00             	movb   $0x0,(%rax)
  return str;
  812c78:	48 b8 c0 b6 b4 00 00 	movabs $0xb4b6c0,%rax
  812c7f:	00 00 00 
}
  812c82:	c9                   	leaveq 
  812c83:	c3                   	retq   

0000000000812c84 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  812c84:	55                   	push   %rbp
  812c85:	48 89 e5             	mov    %rsp,%rbp
  812c88:	48 83 ec 08          	sub    $0x8,%rsp
  812c8c:	89 f8                	mov    %edi,%eax
  812c8e:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  812c92:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  812c96:	c1 e0 08             	shl    $0x8,%eax
  812c99:	89 c2                	mov    %eax,%edx
  812c9b:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  812c9f:	66 c1 e8 08          	shr    $0x8,%ax
  812ca3:	09 d0                	or     %edx,%eax
}
  812ca5:	c9                   	leaveq 
  812ca6:	c3                   	retq   

0000000000812ca7 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  812ca7:	55                   	push   %rbp
  812ca8:	48 89 e5             	mov    %rsp,%rbp
  812cab:	48 83 ec 08          	sub    $0x8,%rsp
  812caf:	89 f8                	mov    %edi,%eax
  812cb1:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  return htons(n);
  812cb5:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
  812cb9:	89 c7                	mov    %eax,%edi
  812cbb:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  812cc2:	00 00 00 
  812cc5:	ff d0                	callq  *%rax
}
  812cc7:	c9                   	leaveq 
  812cc8:	c3                   	retq   

0000000000812cc9 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  812cc9:	55                   	push   %rbp
  812cca:	48 89 e5             	mov    %rsp,%rbp
  812ccd:	48 83 ec 08          	sub    $0x8,%rsp
  812cd1:	89 7d fc             	mov    %edi,-0x4(%rbp)
  return ((n & 0xff) << 24) |
  812cd4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812cd7:	89 c2                	mov    %eax,%edx
  812cd9:	c1 e2 18             	shl    $0x18,%edx
    ((n & 0xff00) << 8) |
  812cdc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812cdf:	25 00 ff 00 00       	and    $0xff00,%eax
  812ce4:	c1 e0 08             	shl    $0x8,%eax
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  812ce7:	09 c2                	or     %eax,%edx
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
  812ce9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812cec:	25 00 00 ff 00       	and    $0xff0000,%eax
  812cf1:	48 c1 e8 08          	shr    $0x8,%rax
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  812cf5:	09 c2                	or     %eax,%edx
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  812cf7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812cfa:	c1 e8 18             	shr    $0x18,%eax
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  812cfd:	09 d0                	or     %edx,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  812cff:	c9                   	leaveq 
  812d00:	c3                   	retq   

0000000000812d01 <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  812d01:	55                   	push   %rbp
  812d02:	48 89 e5             	mov    %rsp,%rbp
  812d05:	48 83 ec 08          	sub    $0x8,%rsp
  812d09:	89 7d fc             	mov    %edi,-0x4(%rbp)
  return htonl(n);
  812d0c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  812d0f:	89 c7                	mov    %eax,%edi
  812d11:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  812d18:	00 00 00 
  812d1b:	ff d0                	callq  *%rax
}
  812d1d:	c9                   	leaveq 
  812d1e:	c3                   	retq   
	...

0000000000812d20 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  812d20:	55                   	push   %rbp
  812d21:	48 89 e5             	mov    %rsp,%rbp
  812d24:	48 83 ec 20          	sub    $0x20,%rsp
  812d28:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  812d2c:	89 f0                	mov    %esi,%eax
  812d2e:	88 45 f4             	mov    %al,-0xc(%rbp)
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  812d31:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
  812d35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812d39:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  812d40:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  812d46:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  812d4c:	89 d1                	mov    %edx,%ecx
  812d4e:	ba 00 00 00 00       	mov    $0x0,%edx
  812d53:	be 00 00 00 00       	mov    $0x0,%esi
  812d58:	48 89 c7             	mov    %rax,%rdi
  812d5b:	48 b8 fd 2d 81 00 00 	movabs $0x812dfd,%rax
  812d62:	00 00 00 
  812d65:	ff d0                	callq  *%rax
}
  812d67:	c9                   	leaveq 
  812d68:	c3                   	retq   

0000000000812d69 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  812d69:	55                   	push   %rbp
  812d6a:	48 89 e5             	mov    %rsp,%rbp
  812d6d:	48 83 ec 30          	sub    $0x30,%rsp
  812d71:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  812d75:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  812d79:	89 c8                	mov    %ecx,%eax
  812d7b:	66 89 55 ec          	mov    %dx,-0x14(%rbp)
  812d7f:	88 45 e8             	mov    %al,-0x18(%rbp)
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  812d82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812d86:	8b 40 18             	mov    0x18(%rax),%eax
  812d89:	83 f8 04             	cmp    $0x4,%eax
  812d8c:	74 24                	je     812db2 <tcp_write+0x49>
     pcb->state == CLOSE_WAIT ||
  812d8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812d92:	8b 40 18             	mov    0x18(%rax),%eax
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  812d95:	83 f8 07             	cmp    $0x7,%eax
  812d98:	74 18                	je     812db2 <tcp_write+0x49>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
  812d9a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812d9e:	8b 40 18             	mov    0x18(%rax),%eax
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
  812da1:	83 f8 02             	cmp    $0x2,%eax
  812da4:	74 0c                	je     812db2 <tcp_write+0x49>
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
  812da6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812daa:	8b 40 18             	mov    0x18(%rax),%eax
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
  812dad:	83 f8 03             	cmp    $0x3,%eax
  812db0:	75 44                	jne    812df6 <tcp_write+0x8d>
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  812db2:	66 83 7d ec 00       	cmpw   $0x0,-0x14(%rbp)
  812db7:	74 36                	je     812def <tcp_write+0x86>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  812db9:	0f b6 4d e8          	movzbl -0x18(%rbp),%ecx
  812dbd:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
  812dc1:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  812dc5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  812dc9:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  812dd0:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  812dd6:	41 89 c8             	mov    %ecx,%r8d
  812dd9:	b9 00 00 00 00       	mov    $0x0,%ecx
  812dde:	48 89 c7             	mov    %rax,%rdi
  812de1:	48 b8 fd 2d 81 00 00 	movabs $0x812dfd,%rax
  812de8:	00 00 00 
  812deb:	ff d0                	callq  *%rax
  812ded:	eb 0c                	jmp    812dfb <tcp_write+0x92>
    }
    return ERR_OK;
  812def:	b8 00 00 00 00       	mov    $0x0,%eax
  812df4:	eb 05                	jmp    812dfb <tcp_write+0x92>
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  812df6:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  }
}
  812dfb:	c9                   	leaveq 
  812dfc:	c3                   	retq   

0000000000812dfd <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  812dfd:	55                   	push   %rbp
  812dfe:	48 89 e5             	mov    %rsp,%rbp
  812e01:	41 54                	push   %r12
  812e03:	53                   	push   %rbx
  812e04:	48 83 ec 70          	sub    $0x70,%rsp
  812e08:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  812e0c:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  812e10:	89 c8                	mov    %ecx,%eax
  812e12:	44 89 c6             	mov    %r8d,%esi
  812e15:	4c 89 4d 88          	mov    %r9,-0x78(%rbp)
  812e19:	8b 4d 10             	mov    0x10(%rbp),%ecx
  812e1c:	66 89 55 9c          	mov    %dx,-0x64(%rbp)
  812e20:	88 45 98             	mov    %al,-0x68(%rbp)
  812e23:	40 88 75 94          	mov    %sil,-0x6c(%rbp)
  812e27:	88 4d 90             	mov    %cl,-0x70(%rbp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  812e2a:	66 83 7d 9c 00       	cmpw   $0x0,-0x64(%rbp)
  812e2f:	74 30                	je     812e61 <tcp_enqueue+0x64>
  812e31:	80 7d 90 00          	cmpb   $0x0,-0x70(%rbp)
  812e35:	74 2a                	je     812e61 <tcp_enqueue+0x64>
  812e37:	48 ba 88 25 82 00 00 	movabs $0x822588,%rdx
  812e3e:	00 00 00 
  812e41:	be 90 00 00 00       	mov    $0x90,%esi
  812e46:	48 bf c7 25 82 00 00 	movabs $0x8225c7,%rdi
  812e4d:	00 00 00 
  812e50:	b8 00 00 00 00       	mov    $0x0,%eax
  812e55:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  812e5c:	00 00 00 
  812e5f:	ff d1                	callq  *%rcx
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  812e61:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  812e66:	74 31                	je     812e99 <tcp_enqueue+0x9c>
  812e68:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  812e6d:	74 2a                	je     812e99 <tcp_enqueue+0x9c>
  812e6f:	48 ba e0 25 82 00 00 	movabs $0x8225e0,%rdx
  812e76:	00 00 00 
  812e79:	be 92 00 00 00       	mov    $0x92,%esi
  812e7e:	48 bf c7 25 82 00 00 	movabs $0x8225c7,%rdi
  812e85:	00 00 00 
  812e88:	b8 00 00 00 00       	mov    $0x0,%eax
  812e8d:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  812e94:	00 00 00 
  812e97:	ff d1                	callq  *%rcx
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  812e99:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812e9d:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  812ea1:	66 3b 45 9c          	cmp    -0x64(%rbp),%ax
  812ea5:	73 1e                	jae    812ec5 <tcp_enqueue+0xc8>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  812ea7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812eab:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  812eaf:	89 c2                	mov    %eax,%edx
  812eb1:	83 ca 80             	or     $0xffffff80,%edx
  812eb4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812eb8:	88 50 2c             	mov    %dl,0x2c(%rax)
    return ERR_MEM;
  812ebb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  812ec0:	e9 f4 09 00 00       	jmpq   8138b9 <tcp_enqueue+0xabc>
  }
  left = len;
  812ec5:	0f b7 45 9c          	movzwl -0x64(%rbp),%eax
  812ec9:	66 89 45 d2          	mov    %ax,-0x2e(%rbp)
  ptr = arg;
  812ecd:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  812ed1:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  812ed5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812ed9:	8b 40 74             	mov    0x74(%rax),%eax
  812edc:	89 45 d4             	mov    %eax,-0x2c(%rbp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  812edf:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812ee3:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  812ee7:	66 89 45 c6          	mov    %ax,-0x3a(%rbp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  812eeb:	66 83 7d c6 1f       	cmpw   $0x1f,-0x3a(%rbp)
  812ef0:	77 07                	ja     812ef9 <tcp_enqueue+0xfc>
  812ef2:	66 83 7d c6 fc       	cmpw   $0xfffc,-0x3a(%rbp)
  812ef7:	76 1e                	jbe    812f17 <tcp_enqueue+0x11a>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  812ef9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812efd:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  812f01:	89 c2                	mov    %eax,%edx
  812f03:	83 ca 80             	or     $0xffffff80,%edx
  812f06:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812f0a:	88 50 2c             	mov    %dl,0x2c(%rax)
    return ERR_MEM;
  812f0d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  812f12:	e9 a2 09 00 00       	jmpq   8138b9 <tcp_enqueue+0xabc>
  }
  if (queuelen != 0) {
  812f17:	66 83 7d c6 00       	cmpw   $0x0,-0x3a(%rbp)
  812f1c:	74 4e                	je     812f6c <tcp_enqueue+0x16f>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  812f1e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812f22:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  812f29:	48 85 c0             	test   %rax,%rax
  812f2c:	0f 85 84 00 00 00    	jne    812fb6 <tcp_enqueue+0x1b9>
  812f32:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812f36:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  812f3d:	48 85 c0             	test   %rax,%rax
  812f40:	75 74                	jne    812fb6 <tcp_enqueue+0x1b9>
  812f42:	48 ba 28 26 82 00 00 	movabs $0x822628,%rdx
  812f49:	00 00 00 
  812f4c:	be ae 00 00 00       	mov    $0xae,%esi
  812f51:	48 bf c7 25 82 00 00 	movabs $0x8225c7,%rdi
  812f58:	00 00 00 
  812f5b:	b8 00 00 00 00       	mov    $0x0,%eax
  812f60:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  812f67:	00 00 00 
  812f6a:	ff d1                	callq  *%rcx
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  812f6c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812f70:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  812f77:	48 85 c0             	test   %rax,%rax
  812f7a:	75 10                	jne    812f8c <tcp_enqueue+0x18f>
  812f7c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812f80:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  812f87:	48 85 c0             	test   %rax,%rax
  812f8a:	74 2a                	je     812fb6 <tcp_enqueue+0x1b9>
  812f8c:	48 ba 68 26 82 00 00 	movabs $0x822668,%rdx
  812f93:	00 00 00 
  812f96:	be b1 00 00 00       	mov    $0xb1,%esi
  812f9b:	48 bf c7 25 82 00 00 	movabs $0x8225c7,%rdi
  812fa2:	00 00 00 
  812fa5:	b8 00 00 00 00       	mov    $0x0,%eax
  812faa:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  812fb1:	00 00 00 
  812fb4:	ff d1                	callq  *%rcx
      pcb->unacked == NULL && pcb->unsent == NULL);
  }

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  812fb6:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  812fbd:	00 
  812fbe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  812fc2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  812fc6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  812fca:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  seglen = 0;
  812fce:	66 c7 45 d0 00 00    	movw   $0x0,-0x30(%rbp)
  while (queue == NULL || left > 0) {
  812fd4:	e9 f8 04 00 00       	jmpq   8134d1 <tcp_enqueue+0x6d4>

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  812fd9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  812fdd:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  812fe1:	0f b7 45 d2          	movzwl -0x2e(%rbp),%eax
  812fe5:	66 39 c2             	cmp    %ax,%dx
  812fe8:	0f 46 c2             	cmovbe %edx,%eax
  812feb:	66 89 45 d0          	mov    %ax,-0x30(%rbp)

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  812fef:	bf 04 00 00 00       	mov    $0x4,%edi
  812ff4:	48 b8 41 ca 80 00 00 	movabs $0x80ca41,%rax
  812ffb:	00 00 00 
  812ffe:	ff d0                	callq  *%rax
  813000:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (seg == NULL) {
  813004:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813009:	0f 84 10 08 00 00    	je     81381f <tcp_enqueue+0xa22>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
  81300f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813013:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    seg->p = NULL;
  81301a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81301e:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  813025:	00 

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  813026:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81302b:	75 0a                	jne    813037 <tcp_enqueue+0x23a>
      queue = seg;
  81302d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813031:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  813035:	eb 3c                	jmp    813073 <tcp_enqueue+0x276>
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  813037:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81303c:	75 2a                	jne    813068 <tcp_enqueue+0x26b>
  81303e:	48 ba 9c 26 82 00 00 	movabs $0x82269c,%rdx
  813045:	00 00 00 
  813048:	be ce 00 00 00       	mov    $0xce,%esi
  81304d:	48 bf c7 25 82 00 00 	movabs $0x8225c7,%rdi
  813054:	00 00 00 
  813057:	b8 00 00 00 00       	mov    $0x0,%eax
  81305c:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  813063:	00 00 00 
  813066:	ff d1                	callq  *%rcx
      useg->next = seg;
  813068:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81306c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  813070:	48 89 10             	mov    %rdx,(%rax)
    }
    /* remember last segment of to-be-queued data for next iteration */
    useg = seg;
  813073:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813077:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  81307b:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  813080:	0f 84 ab 00 00 00    	je     813131 <tcp_enqueue+0x334>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  813086:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  81308a:	ba 00 00 00 00       	mov    $0x0,%edx
  81308f:	89 c6                	mov    %eax,%esi
  813091:	bf 00 00 00 00       	mov    $0x0,%edi
  813096:	48 b8 4c d0 80 00 00 	movabs $0x80d04c,%rax
  81309d:	00 00 00 
  8130a0:	ff d0                	callq  *%rax
  8130a2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8130a6:	48 89 42 08          	mov    %rax,0x8(%rdx)
  8130aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8130ae:	48 8b 40 08          	mov    0x8(%rax),%rax
  8130b2:	48 85 c0             	test   %rax,%rax
  8130b5:	0f 84 67 07 00 00    	je     813822 <tcp_enqueue+0xa25>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  8130bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8130bf:	48 8b 40 08          	mov    0x8(%rax),%rax
  8130c3:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  8130c7:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  8130cb:	66 39 c2             	cmp    %ax,%dx
  8130ce:	73 2a                	jae    8130fa <tcp_enqueue+0x2fd>
  8130d0:	48 ba b0 26 82 00 00 	movabs $0x8226b0,%rdx
  8130d7:	00 00 00 
  8130da:	be df 00 00 00       	mov    $0xdf,%esi
  8130df:	48 bf c7 25 82 00 00 	movabs $0x8225c7,%rdi
  8130e6:	00 00 00 
  8130e9:	b8 00 00 00 00       	mov    $0x0,%eax
  8130ee:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8130f5:	00 00 00 
  8130f8:	ff d1                	callq  *%rcx
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  8130fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8130fe:	48 8b 40 08          	mov    0x8(%rax),%rax
  813102:	48 89 c7             	mov    %rax,%rdi
  813105:	48 b8 e1 da 80 00 00 	movabs $0x80dae1,%rax
  81310c:	00 00 00 
  81310f:	ff d0                	callq  *%rax
  813111:	0f b6 c0             	movzbl %al,%eax
  813114:	66 01 45 c6          	add    %ax,-0x3a(%rbp)
      seg->dataptr = seg->p->payload;
  813118:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81311c:	48 8b 40 08          	mov    0x8(%rax),%rax
  813120:	48 8b 50 08          	mov    0x8(%rax),%rdx
  813124:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813128:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81312c:	e9 b8 01 00 00       	jmpq   8132e9 <tcp_enqueue+0x4ec>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  813131:	0f b6 45 94          	movzbl -0x6c(%rbp),%eax
  813135:	83 e0 01             	and    $0x1,%eax
  813138:	84 c0                	test   %al,%al
  81313a:	0f 84 d5 00 00 00    	je     813215 <tcp_enqueue+0x418>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  813140:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  813144:	ba 00 00 00 00       	mov    $0x0,%edx
  813149:	89 c6                	mov    %eax,%esi
  81314b:	bf 00 00 00 00       	mov    $0x0,%edi
  813150:	48 b8 4c d0 80 00 00 	movabs $0x80d04c,%rax
  813157:	00 00 00 
  81315a:	ff d0                	callq  *%rax
  81315c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  813160:	48 89 42 08          	mov    %rax,0x8(%rdx)
  813164:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813168:	48 8b 40 08          	mov    0x8(%rax),%rax
  81316c:	48 85 c0             	test   %rax,%rax
  81316f:	0f 84 b0 06 00 00    	je     813825 <tcp_enqueue+0xa28>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  813175:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813179:	48 8b 40 08          	mov    0x8(%rax),%rax
  81317d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  813181:	66 3b 45 d0          	cmp    -0x30(%rbp),%ax
  813185:	73 2a                	jae    8131b1 <tcp_enqueue+0x3b4>
  813187:	48 ba d8 26 82 00 00 	movabs $0x8226d8,%rdx
  81318e:	00 00 00 
  813191:	be ea 00 00 00       	mov    $0xea,%esi
  813196:	48 bf c7 25 82 00 00 	movabs $0x8225c7,%rdi
  81319d:	00 00 00 
  8131a0:	b8 00 00 00 00       	mov    $0x0,%eax
  8131a5:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8131ac:	00 00 00 
  8131af:	ff d1                	callq  *%rcx
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  8131b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8131b5:	48 8b 40 08          	mov    0x8(%rax),%rax
  8131b9:	48 89 c7             	mov    %rax,%rdi
  8131bc:	48 b8 e1 da 80 00 00 	movabs $0x80dae1,%rax
  8131c3:	00 00 00 
  8131c6:	ff d0                	callq  *%rax
  8131c8:	0f b6 c0             	movzbl %al,%eax
  8131cb:	66 01 45 c6          	add    %ax,-0x3a(%rbp)
      if (arg != NULL) {
  8131cf:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8131d4:	74 26                	je     8131fc <tcp_enqueue+0x3ff>
        MEMCPY(seg->p->payload, ptr, seglen);
  8131d6:	0f b7 55 d0          	movzwl -0x30(%rbp),%edx
  8131da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8131de:	48 8b 40 08          	mov    0x8(%rax),%rax
  8131e2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8131e6:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8131ea:	48 89 ce             	mov    %rcx,%rsi
  8131ed:	48 89 c7             	mov    %rax,%rdi
  8131f0:	48 b8 fd 22 80 00 00 	movabs $0x8022fd,%rax
  8131f7:	00 00 00 
  8131fa:	ff d0                	callq  *%rax
      }
      seg->dataptr = seg->p->payload;
  8131fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813200:	48 8b 40 08          	mov    0x8(%rax),%rax
  813204:	48 8b 50 08          	mov    0x8(%rax),%rdx
  813208:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81320c:	48 89 50 10          	mov    %rdx,0x10(%rax)
  813210:	e9 d4 00 00 00       	jmpq   8132e9 <tcp_enqueue+0x4ec>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  813215:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  813219:	ba 01 00 00 00       	mov    $0x1,%edx
  81321e:	89 c6                	mov    %eax,%esi
  813220:	bf 00 00 00 00       	mov    $0x0,%edi
  813225:	48 b8 4c d0 80 00 00 	movabs $0x80d04c,%rax
  81322c:	00 00 00 
  81322f:	ff d0                	callq  *%rax
  813231:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  813235:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  81323a:	0f 84 e8 05 00 00    	je     813828 <tcp_enqueue+0xa2b>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
  813240:	66 83 45 c6 01       	addw   $0x1,-0x3a(%rbp)
      /* reference the non-volatile payload data */
      p->payload = ptr;
  813245:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813249:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81324d:	48 89 50 08          	mov    %rdx,0x8(%rax)
      seg->dataptr = ptr;
  813251:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813255:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813259:	48 89 50 10          	mov    %rdx,0x10(%rax)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  81325d:	ba 00 00 00 00       	mov    $0x0,%edx
  813262:	be 00 00 00 00       	mov    $0x0,%esi
  813267:	bf 00 00 00 00       	mov    $0x0,%edi
  81326c:	48 b8 4c d0 80 00 00 	movabs $0x80d04c,%rax
  813273:	00 00 00 
  813276:	ff d0                	callq  *%rax
  813278:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81327c:	48 89 42 08          	mov    %rax,0x8(%rdx)
  813280:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813284:	48 8b 40 08          	mov    0x8(%rax),%rax
  813288:	48 85 c0             	test   %rax,%rax
  81328b:	75 18                	jne    8132a5 <tcp_enqueue+0x4a8>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  81328d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813291:	48 89 c7             	mov    %rax,%rdi
  813294:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81329b:	00 00 00 
  81329e:	ff d0                	callq  *%rax
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  8132a0:	e9 8a 05 00 00       	jmpq   81382f <tcp_enqueue+0xa32>
      }
      queuelen += pbuf_clen(seg->p);
  8132a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8132a9:	48 8b 40 08          	mov    0x8(%rax),%rax
  8132ad:	48 89 c7             	mov    %rax,%rdi
  8132b0:	48 b8 e1 da 80 00 00 	movabs $0x80dae1,%rax
  8132b7:	00 00 00 
  8132ba:	ff d0                	callq  *%rax
  8132bc:	0f b6 c0             	movzbl %al,%eax
  8132bf:	66 01 45 c6          	add    %ax,-0x3a(%rbp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  8132c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8132c7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8132cb:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8132cf:	48 89 d6             	mov    %rdx,%rsi
  8132d2:	48 89 c7             	mov    %rax,%rdi
  8132d5:	48 b8 37 db 80 00 00 	movabs $0x80db37,%rax
  8132dc:	00 00 00 
  8132df:	ff d0                	callq  *%rax
      p = NULL;
  8132e1:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  8132e8:	00 
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  8132e9:	66 83 7d c6 20       	cmpw   $0x20,-0x3a(%rbp)
  8132ee:	0f 87 37 05 00 00    	ja     81382b <tcp_enqueue+0xa2e>
  8132f4:	66 83 7d c6 fc       	cmpw   $0xfffc,-0x3a(%rbp)
  8132f9:	0f 87 2c 05 00 00    	ja     81382b <tcp_enqueue+0xa2e>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
  8132ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813303:	0f b7 55 d0          	movzwl -0x30(%rbp),%edx
  813307:	66 89 50 18          	mov    %dx,0x18(%rax)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  81330b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81330f:	48 8b 40 08          	mov    0x8(%rax),%rax
  813313:	be 14 00 00 00       	mov    $0x14,%esi
  813318:	48 89 c7             	mov    %rax,%rdi
  81331b:	48 b8 6f d7 80 00 00 	movabs $0x80d76f,%rax
  813322:	00 00 00 
  813325:	ff d0                	callq  *%rax
  813327:	84 c0                	test   %al,%al
  813329:	0f 85 ff 04 00 00    	jne    81382e <tcp_enqueue+0xa31>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
  81332f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813333:	48 8b 40 08          	mov    0x8(%rax),%rax
  813337:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81333b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81333f:	48 89 50 20          	mov    %rdx,0x20(%rax)
    seg->tcphdr->src = htons(pcb->local_port);
  813343:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813347:	48 8b 58 20          	mov    0x20(%rax),%rbx
  81334b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81334f:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  813353:	0f b7 c0             	movzwl %ax,%eax
  813356:	89 c7                	mov    %eax,%edi
  813358:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  81335f:	00 00 00 
  813362:	ff d0                	callq  *%rax
  813364:	66 89 03             	mov    %ax,(%rbx)
    seg->tcphdr->dest = htons(pcb->remote_port);
  813367:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81336b:	48 8b 58 20          	mov    0x20(%rax),%rbx
  81336f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813373:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  813377:	0f b7 c0             	movzwl %ax,%eax
  81337a:	89 c7                	mov    %eax,%edi
  81337c:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  813383:	00 00 00 
  813386:	ff d0                	callq  *%rax
  813388:	66 89 43 02          	mov    %ax,0x2(%rbx)
    seg->tcphdr->seqno = htonl(seqno);
  81338c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813390:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813394:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  813397:	89 c7                	mov    %eax,%edi
  813399:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  8133a0:	00 00 00 
  8133a3:	ff d0                	callq  *%rax
  8133a5:	89 43 04             	mov    %eax,0x4(%rbx)
    seg->tcphdr->urgp = 0;
  8133a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8133ac:	48 8b 40 20          	mov    0x20(%rax),%rax
  8133b0:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  8133b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8133ba:	48 8b 58 20          	mov    0x20(%rax),%rbx
  8133be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8133c2:	48 8b 40 20          	mov    0x20(%rax),%rax
  8133c6:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8133ca:	0f b7 c0             	movzwl %ax,%eax
  8133cd:	89 c7                	mov    %eax,%edi
  8133cf:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  8133d6:	00 00 00 
  8133d9:	ff d0                	callq  *%rax
  8133db:	89 c2                	mov    %eax,%edx
  8133dd:	83 e2 c0             	and    $0xffffffc0,%edx
  8133e0:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  8133e4:	09 d0                	or     %edx,%eax
  8133e6:	0f b7 c0             	movzwl %ax,%eax
  8133e9:	89 c7                	mov    %eax,%edi
  8133eb:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  8133f2:	00 00 00 
  8133f5:	ff d0                	callq  *%rax
  8133f7:	66 89 43 0c          	mov    %ax,0xc(%rbx)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  8133fb:	48 83 7d 88 00       	cmpq   $0x0,-0x78(%rbp)
  813400:	75 42                	jne    813444 <tcp_enqueue+0x647>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  813402:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813406:	48 8b 58 20          	mov    0x20(%rax),%rbx
  81340a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81340e:	48 8b 40 20          	mov    0x20(%rax),%rax
  813412:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813416:	0f b7 c0             	movzwl %ax,%eax
  813419:	89 c7                	mov    %eax,%edi
  81341b:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  813422:	00 00 00 
  813425:	ff d0                	callq  *%rax
  813427:	83 e0 3f             	and    $0x3f,%eax
  81342a:	80 cc 50             	or     $0x50,%ah
  81342d:	0f b7 c0             	movzwl %ax,%eax
  813430:	89 c7                	mov    %eax,%edi
  813432:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  813439:	00 00 00 
  81343c:	ff d0                	callq  *%rax
  81343e:	66 89 43 0c          	mov    %ax,0xc(%rbx)
  813442:	eb 76                	jmp    8134ba <tcp_enqueue+0x6bd>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  813444:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813448:	48 8b 58 20          	mov    0x20(%rax),%rbx
  81344c:	0f b6 45 90          	movzbl -0x70(%rbp),%eax
  813450:	c0 e8 02             	shr    $0x2,%al
  813453:	0f b6 c0             	movzbl %al,%eax
  813456:	83 c0 05             	add    $0x5,%eax
  813459:	41 89 c4             	mov    %eax,%r12d
  81345c:	41 c1 e4 0c          	shl    $0xc,%r12d
  813460:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813464:	48 8b 40 20          	mov    0x20(%rax),%rax
  813468:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81346c:	0f b7 c0             	movzwl %ax,%eax
  81346f:	89 c7                	mov    %eax,%edi
  813471:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  813478:	00 00 00 
  81347b:	ff d0                	callq  *%rax
  81347d:	83 e0 3f             	and    $0x3f,%eax
  813480:	44 09 e0             	or     %r12d,%eax
  813483:	0f b7 c0             	movzwl %ax,%eax
  813486:	89 c7                	mov    %eax,%edi
  813488:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  81348f:	00 00 00 
  813492:	ff d0                	callq  *%rax
  813494:	66 89 43 0c          	mov    %ax,0xc(%rbx)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  813498:	0f b6 55 90          	movzbl -0x70(%rbp),%edx
  81349c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8134a0:	48 8b 40 10          	mov    0x10(%rax),%rax
  8134a4:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
  8134a8:	48 89 ce             	mov    %rcx,%rsi
  8134ab:	48 89 c7             	mov    %rax,%rdi
  8134ae:	48 b8 fd 22 80 00 00 	movabs $0x8022fd,%rax
  8134b5:	00 00 00 
  8134b8:	ff d0                	callq  *%rax
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
  8134ba:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  8134be:	66 29 45 d2          	sub    %ax,-0x2e(%rbp)
    seqno += seglen;
  8134c2:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  8134c6:	01 45 d4             	add    %eax,-0x2c(%rbp)
    ptr = (void *)((u8_t *)ptr + seglen);
  8134c9:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  8134cd:	48 01 45 c8          	add    %rax,-0x38(%rbp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  8134d1:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8134d6:	0f 84 fd fa ff ff    	je     812fd9 <tcp_enqueue+0x1dc>
  8134dc:	66 83 7d d2 00       	cmpw   $0x0,-0x2e(%rbp)
  8134e1:	0f 85 f2 fa ff ff    	jne    812fd9 <tcp_enqueue+0x1dc>
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  8134e7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8134eb:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8134f2:	48 85 c0             	test   %rax,%rax
  8134f5:	75 0a                	jne    813501 <tcp_enqueue+0x704>
    useg = NULL;
  8134f7:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8134fe:	00 
  8134ff:	eb 28                	jmp    813529 <tcp_enqueue+0x72c>
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  813501:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813505:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81350c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  813510:	eb 0b                	jmp    81351d <tcp_enqueue+0x720>
  813512:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813516:	48 8b 00             	mov    (%rax),%rax
  813519:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  81351d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813521:	48 8b 00             	mov    (%rax),%rax
  813524:	48 85 c0             	test   %rax,%rax
  813527:	75 e9                	jne    813512 <tcp_enqueue+0x715>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  813529:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81352e:	0f 84 94 01 00 00    	je     8136c8 <tcp_enqueue+0x8cb>
    TCP_TCPLEN(useg) != 0 &&
  813534:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813538:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81353c:	0f b7 d8             	movzwl %ax,%ebx
  81353f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813543:	48 8b 40 20          	mov    0x20(%rax),%rax
  813547:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81354b:	0f b7 c0             	movzwl %ax,%eax
  81354e:	89 c7                	mov    %eax,%edi
  813550:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  813557:	00 00 00 
  81355a:	ff d0                	callq  *%rax
  81355c:	0f b7 c0             	movzwl %ax,%eax
  81355f:	83 e0 01             	and    $0x1,%eax
  813562:	84 c0                	test   %al,%al
  813564:	75 27                	jne    81358d <tcp_enqueue+0x790>
  813566:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81356a:	48 8b 40 20          	mov    0x20(%rax),%rax
  81356e:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813572:	0f b7 c0             	movzwl %ax,%eax
  813575:	89 c7                	mov    %eax,%edi
  813577:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81357e:	00 00 00 
  813581:	ff d0                	callq  *%rax
  813583:	0f b7 c0             	movzwl %ax,%eax
  813586:	83 e0 02             	and    $0x2,%eax
  813589:	85 c0                	test   %eax,%eax
  81358b:	74 07                	je     813594 <tcp_enqueue+0x797>
  81358d:	b8 01 00 00 00       	mov    $0x1,%eax
  813592:	eb 05                	jmp    813599 <tcp_enqueue+0x79c>
  813594:	b8 00 00 00 00       	mov    $0x0,%eax
  813599:	01 d8                	add    %ebx,%eax
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  81359b:	85 c0                	test   %eax,%eax
  81359d:	0f 84 25 01 00 00    	je     8136c8 <tcp_enqueue+0x8cb>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  8135a3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8135a7:	48 8b 40 20          	mov    0x20(%rax),%rax
  8135ab:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8135af:	0f b7 c0             	movzwl %ax,%eax
  8135b2:	89 c7                	mov    %eax,%edi
  8135b4:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  8135bb:	00 00 00 
  8135be:	ff d0                	callq  *%rax
  8135c0:	0f b7 c0             	movzwl %ax,%eax
  8135c3:	83 e0 03             	and    $0x3,%eax
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
  8135c6:	85 c0                	test   %eax,%eax
  8135c8:	0f 85 fa 00 00 00    	jne    8136c8 <tcp_enqueue+0x8cb>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
  8135ce:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  8135d2:	83 e0 03             	and    $0x3,%eax

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  8135d5:	85 c0                	test   %eax,%eax
  8135d7:	0f 85 eb 00 00 00    	jne    8136c8 <tcp_enqueue+0x8cb>
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  8135dd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8135e1:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8135e5:	0f b7 d0             	movzwl %ax,%edx
  8135e8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8135ec:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8135f0:	0f b7 c0             	movzwl %ax,%eax
  8135f3:	01 c2                	add    %eax,%edx
  8135f5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8135f9:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  8135fd:	0f b7 c0             	movzwl %ax,%eax
  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
  813600:	39 c2                	cmp    %eax,%edx
  813602:	0f 8f c0 00 00 00    	jg     8136c8 <tcp_enqueue+0x8cb>
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  813608:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81360c:	48 8b 40 08          	mov    0x8(%rax),%rax
  813610:	be ec ff ff ff       	mov    $0xffffffec,%esi
  813615:	48 89 c7             	mov    %rax,%rdi
  813618:	48 b8 6f d7 80 00 00 	movabs $0x80d76f,%rax
  81361f:	00 00 00 
  813622:	ff d0                	callq  *%rax
  813624:	84 c0                	test   %al,%al
  813626:	74 2a                	je     813652 <tcp_enqueue+0x855>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  813628:	48 ba 0b 27 82 00 00 	movabs $0x82270b,%rdx
  81362f:	00 00 00 
  813632:	be 52 01 00 00       	mov    $0x152,%esi
  813637:	48 bf c7 25 82 00 00 	movabs $0x8225c7,%rdi
  81363e:	00 00 00 
  813641:	b8 00 00 00 00       	mov    $0x0,%eax
  813646:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81364d:	00 00 00 
  813650:	ff d1                	callq  *%rcx
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  813652:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813656:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81365a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81365e:	48 8b 40 08          	mov    0x8(%rax),%rax
  813662:	48 89 d6             	mov    %rdx,%rsi
  813665:	48 89 c7             	mov    %rax,%rdi
  813668:	48 b8 37 db 80 00 00 	movabs $0x80db37,%rax
  81366f:	00 00 00 
  813672:	ff d0                	callq  *%rax
    useg->len += queue->len;
  813674:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813678:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  81367c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813680:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813684:	01 c2                	add    %eax,%edx
  813686:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81368a:	66 89 50 18          	mov    %dx,0x18(%rax)
    useg->next = queue->next;
  81368e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813692:	48 8b 10             	mov    (%rax),%rdx
  813695:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813699:	48 89 10             	mov    %rdx,(%rax)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  81369c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8136a0:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8136a4:	75 08                	jne    8136ae <tcp_enqueue+0x8b1>
      seg = NULL;
  8136a6:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8136ad:	00 
    }
    memp_free(MEMP_TCP_SEG, queue);
  8136ae:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8136b2:	48 89 c6             	mov    %rax,%rsi
  8136b5:	bf 04 00 00 00       	mov    $0x4,%edi
  8136ba:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  8136c1:	00 00 00 
  8136c4:	ff d0                	callq  *%rax
  8136c6:	eb 23                	jmp    8136eb <tcp_enqueue+0x8ee>
  }
  else {
    /* empty list */
    if (useg == NULL) {
  8136c8:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8136cd:	75 11                	jne    8136e0 <tcp_enqueue+0x8e3>
      /* initialize list with this segment */
      pcb->unsent = queue;
  8136cf:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8136d3:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8136d7:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  8136de:	eb 0b                	jmp    8136eb <tcp_enqueue+0x8ee>
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  8136e0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8136e4:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8136e8:	48 89 10             	mov    %rdx,(%rax)
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  8136eb:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  8136ef:	83 e0 02             	and    $0x2,%eax
  8136f2:	85 c0                	test   %eax,%eax
  8136f4:	75 0b                	jne    813701 <tcp_enqueue+0x904>
  8136f6:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  8136fa:	83 e0 01             	and    $0x1,%eax
  8136fd:	84 c0                	test   %al,%al
  8136ff:	74 05                	je     813706 <tcp_enqueue+0x909>
    ++len;
  813701:	66 83 45 9c 01       	addw   $0x1,-0x64(%rbp)
  }
  if (flags & TCP_FIN) {
  813706:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
  81370a:	83 e0 01             	and    $0x1,%eax
  81370d:	84 c0                	test   %al,%al
  81370f:	74 14                	je     813725 <tcp_enqueue+0x928>
    pcb->flags |= TF_FIN;
  813711:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813715:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813719:	89 c2                	mov    %eax,%edx
  81371b:	83 ca 20             	or     $0x20,%edx
  81371e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813722:	88 50 2c             	mov    %dl,0x2c(%rax)
  }
  pcb->snd_lbb += len;
  813725:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813729:	8b 50 74             	mov    0x74(%rax),%edx
  81372c:	0f b7 45 9c          	movzwl -0x64(%rbp),%eax
  813730:	01 c2                	add    %eax,%edx
  813732:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813736:	89 50 74             	mov    %edx,0x74(%rax)

  pcb->snd_buf -= len;
  813739:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81373d:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  813741:	89 c2                	mov    %eax,%edx
  813743:	66 2b 55 9c          	sub    -0x64(%rbp),%dx
  813747:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81374b:	66 89 50 7a          	mov    %dx,0x7a(%rax)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  81374f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813753:	0f b7 55 c6          	movzwl -0x3a(%rbp),%edx
  813757:	66 89 50 7c          	mov    %dx,0x7c(%rax)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  81375b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81375f:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  813763:	66 85 c0             	test   %ax,%ax
  813766:	74 4a                	je     8137b2 <tcp_enqueue+0x9b5>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  813768:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81376c:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813773:	48 85 c0             	test   %rax,%rax
  813776:	75 3a                	jne    8137b2 <tcp_enqueue+0x9b5>
  813778:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81377c:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813783:	48 85 c0             	test   %rax,%rax
  813786:	75 2a                	jne    8137b2 <tcp_enqueue+0x9b5>
  813788:	48 ba 20 27 82 00 00 	movabs $0x822720,%rdx
  81378f:	00 00 00 
  813792:	be 7a 01 00 00       	mov    $0x17a,%esi
  813797:	48 bf c7 25 82 00 00 	movabs $0x8225c7,%rdi
  81379e:	00 00 00 
  8137a1:	b8 00 00 00 00       	mov    $0x0,%eax
  8137a6:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8137ad:	00 00 00 
  8137b0:	ff d1                	callq  *%rcx
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  8137b2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8137b7:	74 5c                	je     813815 <tcp_enqueue+0xa18>
  8137b9:	66 83 7d d0 00       	cmpw   $0x0,-0x30(%rbp)
  8137be:	74 55                	je     813815 <tcp_enqueue+0xa18>
  8137c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8137c4:	48 8b 40 20          	mov    0x20(%rax),%rax
  8137c8:	48 85 c0             	test   %rax,%rax
  8137cb:	74 48                	je     813815 <tcp_enqueue+0xa18>
  8137cd:	0f b6 45 94          	movzbl -0x6c(%rbp),%eax
  8137d1:	83 e0 02             	and    $0x2,%eax
  8137d4:	85 c0                	test   %eax,%eax
  8137d6:	75 3d                	jne    813815 <tcp_enqueue+0xa18>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  8137d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8137dc:	48 8b 58 20          	mov    0x20(%rax),%rbx
  8137e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8137e4:	48 8b 40 20          	mov    0x20(%rax),%rax
  8137e8:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8137ec:	0f b7 c0             	movzwl %ax,%eax
  8137ef:	89 c7                	mov    %eax,%edi
  8137f1:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  8137f8:	00 00 00 
  8137fb:	ff d0                	callq  *%rax
  8137fd:	83 c8 08             	or     $0x8,%eax
  813800:	0f b7 c0             	movzwl %ax,%eax
  813803:	89 c7                	mov    %eax,%edi
  813805:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  81380c:	00 00 00 
  81380f:	ff d0                	callq  *%rax
  813811:	66 89 43 0c          	mov    %ax,0xc(%rbx)
  }

  return ERR_OK;
  813815:	b8 00 00 00 00       	mov    $0x0,%eax
  81381a:	e9 9a 00 00 00       	jmpq   8138b9 <tcp_enqueue+0xabc>

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
    if (seg == NULL) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
  81381f:	90                   	nop
  813820:	eb 0d                	jmp    81382f <tcp_enqueue+0xa32>
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
        goto memerr;
  813822:	90                   	nop
  813823:	eb 0a                	jmp    81382f <tcp_enqueue+0xa32>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
  813825:	90                   	nop
  813826:	eb 07                	jmp    81382f <tcp_enqueue+0xa32>
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
  813828:	90                   	nop
  813829:	eb 04                	jmp    81382f <tcp_enqueue+0xa32>

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
  81382b:	90                   	nop
  81382c:	eb 01                	jmp    81382f <tcp_enqueue+0xa32>

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
  81382e:	90                   	nop
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  81382f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813833:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813837:	89 c2                	mov    %eax,%edx
  813839:	83 ca 80             	or     $0xffffff80,%edx
  81383c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813840:	88 50 2c             	mov    %dl,0x2c(%rax)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  813843:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  813848:	74 13                	je     81385d <tcp_enqueue+0xa60>
    tcp_segs_free(queue);
  81384a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81384e:	48 89 c7             	mov    %rax,%rdi
  813851:	48 b8 6b 00 81 00 00 	movabs $0x81006b,%rax
  813858:	00 00 00 
  81385b:	ff d0                	callq  *%rax
  }
  if (pcb->snd_queuelen != 0) {
  81385d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  813861:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  813865:	66 85 c0             	test   %ax,%ax
  813868:	74 4a                	je     8138b4 <tcp_enqueue+0xab7>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  81386a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81386e:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813875:	48 85 c0             	test   %rax,%rax
  813878:	75 3a                	jne    8138b4 <tcp_enqueue+0xab7>
  81387a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81387e:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813885:	48 85 c0             	test   %rax,%rax
  813888:	75 2a                	jne    8138b4 <tcp_enqueue+0xab7>
  81388a:	48 ba 20 27 82 00 00 	movabs $0x822720,%rdx
  813891:	00 00 00 
  813894:	be 8d 01 00 00       	mov    $0x18d,%esi
  813899:	48 bf c7 25 82 00 00 	movabs $0x8225c7,%rdi
  8138a0:	00 00 00 
  8138a3:	b8 00 00 00 00       	mov    $0x0,%eax
  8138a8:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8138af:	00 00 00 
  8138b2:	ff d1                	callq  *%rcx
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  8138b4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8138b9:	48 83 c4 70          	add    $0x70,%rsp
  8138bd:	5b                   	pop    %rbx
  8138be:	41 5c                	pop    %r12
  8138c0:	5d                   	pop    %rbp
  8138c1:	c3                   	retq   

00000000008138c2 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  8138c2:	55                   	push   %rbp
  8138c3:	48 89 e5             	mov    %rsp,%rbp
  8138c6:	41 54                	push   %r12
  8138c8:	53                   	push   %rbx
  8138c9:	48 83 ec 40          	sub    $0x40,%rsp
  8138cd:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  8138d1:	48 b8 50 b0 b5 00 00 	movabs $0xb5b050,%rax
  8138d8:	00 00 00 
  8138db:	48 8b 00             	mov    (%rax),%rax
  8138de:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8138e2:	75 0a                	jne    8138ee <tcp_output+0x2c>
    return ERR_OK;
  8138e4:	b8 00 00 00 00       	mov    $0x0,%eax
  8138e9:	e9 c7 06 00 00       	jmpq   813fb5 <tcp_output+0x6f3>
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  8138ee:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8138f2:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  8138f6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8138fa:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  8138fe:	66 39 c2             	cmp    %ax,%dx
  813901:	0f 46 c2             	cmovbe %edx,%eax
  813904:	0f b7 c0             	movzwl %ax,%eax
  813907:	89 45 dc             	mov    %eax,-0x24(%rbp)

  seg = pcb->unsent;
  81390a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81390e:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813915:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  813919:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81391d:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813924:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  if (useg != NULL) {
  813928:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81392d:	74 19                	je     813948 <tcp_output+0x86>
    for (; useg->next != NULL; useg = useg->next);
  81392f:	eb 0b                	jmp    81393c <tcp_output+0x7a>
  813931:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813935:	48 8b 00             	mov    (%rax),%rax
  813938:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  81393c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813940:	48 8b 00             	mov    (%rax),%rax
  813943:	48 85 c0             	test   %rax,%rax
  813946:	75 e9                	jne    813931 <tcp_output+0x6f>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  813948:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81394c:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813950:	0f b6 c0             	movzbl %al,%eax
  813953:	83 e0 02             	and    $0x2,%eax
  813956:	85 c0                	test   %eax,%eax
  813958:	0f 84 87 05 00 00    	je     813ee5 <tcp_output+0x623>
  81395e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813963:	74 3c                	je     8139a1 <tcp_output+0xdf>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  813965:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813969:	48 8b 40 20          	mov    0x20(%rax),%rax
  81396d:	8b 40 04             	mov    0x4(%rax),%eax
  813970:	89 c7                	mov    %eax,%edi
  813972:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  813979:	00 00 00 
  81397c:	ff d0                	callq  *%rax
  81397e:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  813982:	8b 52 54             	mov    0x54(%rdx),%edx
  813985:	89 c1                	mov    %eax,%ecx
  813987:	29 d1                	sub    %edx,%ecx
  813989:	89 ca                	mov    %ecx,%edx
  81398b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81398f:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813993:	0f b7 c0             	movzwl %ax,%eax
  813996:	01 d0                	add    %edx,%eax
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
  813998:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  81399b:	0f 86 44 05 00 00    	jbe    813ee5 <tcp_output+0x623>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8139a1:	ba 00 00 00 00       	mov    $0x0,%edx
  8139a6:	be 14 00 00 00       	mov    $0x14,%esi
  8139ab:	bf 01 00 00 00       	mov    $0x1,%edi
  8139b0:	48 b8 4c d0 80 00 00 	movabs $0x80d04c,%rax
  8139b7:	00 00 00 
  8139ba:	ff d0                	callq  *%rax
  8139bc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (p == NULL) {
  8139c0:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8139c5:	75 0a                	jne    8139d1 <tcp_output+0x10f>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
  8139c7:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8139cc:	e9 e4 05 00 00       	jmpq   813fb5 <tcp_output+0x6f3>
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8139d1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8139d5:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  8139d9:	89 c2                	mov    %eax,%edx
  8139db:	83 e2 fc             	and    $0xfffffffc,%edx
  8139de:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8139e2:	88 50 2c             	mov    %dl,0x2c(%rax)

    tcphdr = p->payload;
  8139e5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8139e9:	48 8b 40 08          	mov    0x8(%rax),%rax
  8139ed:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    tcphdr->src = htons(pcb->local_port);
  8139f1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8139f5:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  8139f9:	0f b7 c0             	movzwl %ax,%eax
  8139fc:	89 c7                	mov    %eax,%edi
  8139fe:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  813a05:	00 00 00 
  813a08:	ff d0                	callq  *%rax
  813a0a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813a0e:	66 89 02             	mov    %ax,(%rdx)
    tcphdr->dest = htons(pcb->remote_port);
  813a11:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813a15:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  813a19:	0f b7 c0             	movzwl %ax,%eax
  813a1c:	89 c7                	mov    %eax,%edi
  813a1e:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  813a25:	00 00 00 
  813a28:	ff d0                	callq  *%rax
  813a2a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813a2e:	66 89 42 02          	mov    %ax,0x2(%rdx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  813a32:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813a36:	8b 40 60             	mov    0x60(%rax),%eax
  813a39:	89 c7                	mov    %eax,%edi
  813a3b:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  813a42:	00 00 00 
  813a45:	ff d0                	callq  *%rax
  813a47:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813a4b:	89 42 04             	mov    %eax,0x4(%rdx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  813a4e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813a52:	8b 40 30             	mov    0x30(%rax),%eax
  813a55:	89 c7                	mov    %eax,%edi
  813a57:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  813a5e:	00 00 00 
  813a61:	ff d0                	callq  *%rax
  813a63:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813a67:	89 42 08             	mov    %eax,0x8(%rdx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  813a6a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813a6e:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813a72:	0f b7 c0             	movzwl %ax,%eax
  813a75:	89 c7                	mov    %eax,%edi
  813a77:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  813a7e:	00 00 00 
  813a81:	ff d0                	callq  *%rax
  813a83:	83 e0 c0             	and    $0xffffffc0,%eax
  813a86:	83 c8 10             	or     $0x10,%eax
  813a89:	0f b7 c0             	movzwl %ax,%eax
  813a8c:	89 c7                	mov    %eax,%edi
  813a8e:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  813a95:	00 00 00 
  813a98:	ff d0                	callq  *%rax
  813a9a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813a9e:	66 89 42 0c          	mov    %ax,0xc(%rdx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  813aa2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813aa6:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  813aaa:	0f b7 c0             	movzwl %ax,%eax
  813aad:	89 c7                	mov    %eax,%edi
  813aaf:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  813ab6:	00 00 00 
  813ab9:	ff d0                	callq  *%rax
  813abb:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813abf:	66 89 42 0e          	mov    %ax,0xe(%rdx)
    tcphdr->urgp = 0;
  813ac3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813ac7:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
    TCPH_HDRLEN_SET(tcphdr, 5);
  813acd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813ad1:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813ad5:	0f b7 c0             	movzwl %ax,%eax
  813ad8:	89 c7                	mov    %eax,%edi
  813ada:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  813ae1:	00 00 00 
  813ae4:	ff d0                	callq  *%rax
  813ae6:	83 e0 3f             	and    $0x3f,%eax
  813ae9:	80 cc 50             	or     $0x50,%ah
  813aec:	0f b7 c0             	movzwl %ax,%eax
  813aef:	89 c7                	mov    %eax,%edi
  813af1:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  813af8:	00 00 00 
  813afb:	ff d0                	callq  *%rax
  813afd:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813b01:	66 89 42 0c          	mov    %ax,0xc(%rdx)

    tcphdr->chksum = 0;
  813b05:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  813b09:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
          IP_PROTO_TCP, p->tot_len);
  813b0f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813b13:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    tcphdr->urgp = 0;
    TCPH_HDRLEN_SET(tcphdr, 5);

    tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  813b17:	0f b7 c8             	movzwl %ax,%ecx
  813b1a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813b1e:	48 8d 50 04          	lea    0x4(%rax),%rdx
  813b22:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  813b26:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813b2a:	41 89 c8             	mov    %ecx,%r8d
  813b2d:	b9 06 00 00 00       	mov    $0x6,%ecx
  813b32:	48 89 c7             	mov    %rax,%rdi
  813b35:	48 b8 29 24 81 00 00 	movabs $0x812429,%rax
  813b3c:	00 00 00 
  813b3f:	ff d0                	callq  *%rax
  813b41:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  813b45:	66 89 42 10          	mov    %ax,0x10(%rdx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  813b49:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813b4d:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  813b51:	0f b6 c8             	movzbl %al,%ecx
  813b54:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813b58:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  813b5c:	0f b6 d0             	movzbl %al,%edx
  813b5f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813b63:	48 8d 78 04          	lea    0x4(%rax),%rdi
  813b67:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  813b6b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813b6f:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  813b75:	41 89 c8             	mov    %ecx,%r8d
  813b78:	89 d1                	mov    %edx,%ecx
  813b7a:	48 89 fa             	mov    %rdi,%rdx
  813b7d:	48 89 c7             	mov    %rax,%rdi
  813b80:	48 b8 0d 12 81 00 00 	movabs $0x81120d,%rax
  813b87:	00 00 00 
  813b8a:	ff d0                	callq  *%rax
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  813b8c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813b90:	48 89 c7             	mov    %rax,%rdi
  813b93:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  813b9a:	00 00 00 
  813b9d:	ff d0                	callq  *%rax

    return ERR_OK;
  813b9f:	b8 00 00 00 00       	mov    $0x0,%eax
  813ba4:	e9 0c 04 00 00       	jmpq   813fb5 <tcp_output+0x6f3>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  813ba9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813bad:	48 8b 40 20          	mov    0x20(%rax),%rax
  813bb1:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813bb5:	0f b7 c0             	movzwl %ax,%eax
  813bb8:	89 c7                	mov    %eax,%edi
  813bba:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  813bc1:	00 00 00 
  813bc4:	ff d0                	callq  *%rax
  813bc6:	0f b7 c0             	movzwl %ax,%eax
  813bc9:	83 e0 04             	and    $0x4,%eax
  813bcc:	85 c0                	test   %eax,%eax
  813bce:	74 2a                	je     813bfa <tcp_output+0x338>
  813bd0:	48 ba 40 27 82 00 00 	movabs $0x822740,%rdx
  813bd7:	00 00 00 
  813bda:	be 05 02 00 00       	mov    $0x205,%esi
  813bdf:	48 bf c7 25 82 00 00 	movabs $0x8225c7,%rdi
  813be6:	00 00 00 
  813be9:	b8 00 00 00 00       	mov    $0x0,%eax
  813bee:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  813bf5:	00 00 00 
  813bf8:	ff d1                	callq  *%rcx
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  813bfa:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813bfe:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813c05:	48 85 c0             	test   %rax,%rax
  813c08:	74 35                	je     813c3f <tcp_output+0x37d>
  813c0a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813c0e:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813c12:	0f b6 c0             	movzbl %al,%eax
  813c15:	83 e0 40             	and    $0x40,%eax
  813c18:	85 c0                	test   %eax,%eax
  813c1a:	75 23                	jne    813c3f <tcp_output+0x37d>
  813c1c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813c20:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813c27:	48 85 c0             	test   %rax,%rax
  813c2a:	74 1a                	je     813c46 <tcp_output+0x384>
  813c2c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813c30:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813c37:	48 8b 00             	mov    (%rax),%rax
  813c3a:	48 85 c0             	test   %rax,%rax
  813c3d:	74 07                	je     813c46 <tcp_output+0x384>
  813c3f:	b8 01 00 00 00       	mov    $0x1,%eax
  813c44:	eb 05                	jmp    813c4b <tcp_output+0x389>
  813c46:	b8 00 00 00 00       	mov    $0x0,%eax
  813c4b:	85 c0                	test   %eax,%eax
  813c4d:	75 18                	jne    813c67 <tcp_output+0x3a5>
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
  813c4f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813c53:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813c57:	0f b6 c0             	movzbl %al,%eax
  813c5a:	25 a0 00 00 00       	and    $0xa0,%eax
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  813c5f:	85 c0                	test   %eax,%eax
  813c61:	0f 84 c3 02 00 00    	je     813f2a <tcp_output+0x668>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  813c67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813c6b:	48 8b 10             	mov    (%rax),%rdx
  813c6e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813c72:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)

    if (pcb->state != SYN_SENT) {
  813c79:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813c7d:	8b 40 18             	mov    0x18(%rax),%eax
  813c80:	83 f8 02             	cmp    $0x2,%eax
  813c83:	74 51                	je     813cd6 <tcp_output+0x414>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  813c85:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813c89:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813c8d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813c91:	48 8b 40 20          	mov    0x20(%rax),%rax
  813c95:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813c99:	0f b7 c0             	movzwl %ax,%eax
  813c9c:	89 c7                	mov    %eax,%edi
  813c9e:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  813ca5:	00 00 00 
  813ca8:	ff d0                	callq  *%rax
  813caa:	83 c8 10             	or     $0x10,%eax
  813cad:	0f b7 c0             	movzwl %ax,%eax
  813cb0:	89 c7                	mov    %eax,%edi
  813cb2:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  813cb9:	00 00 00 
  813cbc:	ff d0                	callq  *%rax
  813cbe:	66 89 43 0c          	mov    %ax,0xc(%rbx)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  813cc2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813cc6:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813cca:	89 c2                	mov    %eax,%edx
  813ccc:	83 e2 fc             	and    $0xfffffffc,%edx
  813ccf:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813cd3:	88 50 2c             	mov    %dl,0x2c(%rax)
    }

    tcp_output_segment(seg, pcb);
  813cd6:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  813cda:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813cde:	48 89 d6             	mov    %rdx,%rsi
  813ce1:	48 89 c7             	mov    %rax,%rdi
  813ce4:	48 b8 be 3f 81 00 00 	movabs $0x813fbe,%rax
  813ceb:	00 00 00 
  813cee:	ff d0                	callq  *%rax
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  813cf0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813cf4:	48 8b 40 20          	mov    0x20(%rax),%rax
  813cf8:	8b 40 04             	mov    0x4(%rax),%eax
  813cfb:	89 c7                	mov    %eax,%edi
  813cfd:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  813d04:	00 00 00 
  813d07:	ff d0                	callq  *%rax
  813d09:	89 c3                	mov    %eax,%ebx
  813d0b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813d0f:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813d13:	44 0f b7 e0          	movzwl %ax,%r12d
  813d17:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813d1b:	48 8b 40 20          	mov    0x20(%rax),%rax
  813d1f:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813d23:	0f b7 c0             	movzwl %ax,%eax
  813d26:	89 c7                	mov    %eax,%edi
  813d28:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  813d2f:	00 00 00 
  813d32:	ff d0                	callq  *%rax
  813d34:	0f b7 c0             	movzwl %ax,%eax
  813d37:	83 e0 01             	and    $0x1,%eax
  813d3a:	84 c0                	test   %al,%al
  813d3c:	75 27                	jne    813d65 <tcp_output+0x4a3>
  813d3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813d42:	48 8b 40 20          	mov    0x20(%rax),%rax
  813d46:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813d4a:	0f b7 c0             	movzwl %ax,%eax
  813d4d:	89 c7                	mov    %eax,%edi
  813d4f:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  813d56:	00 00 00 
  813d59:	ff d0                	callq  *%rax
  813d5b:	0f b7 c0             	movzwl %ax,%eax
  813d5e:	83 e0 02             	and    $0x2,%eax
  813d61:	85 c0                	test   %eax,%eax
  813d63:	74 07                	je     813d6c <tcp_output+0x4aa>
  813d65:	b8 01 00 00 00       	mov    $0x1,%eax
  813d6a:	eb 05                	jmp    813d71 <tcp_output+0x4af>
  813d6c:	b8 00 00 00 00       	mov    $0x0,%eax
  813d71:	44 01 e0             	add    %r12d,%eax
  813d74:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  813d77:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813d7b:	89 50 60             	mov    %edx,0x60(%rax)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  813d7e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813d82:	8b 50 64             	mov    0x64(%rax),%edx
  813d85:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813d89:	8b 40 60             	mov    0x60(%rax),%eax
  813d8c:	89 d1                	mov    %edx,%ecx
  813d8e:	29 c1                	sub    %eax,%ecx
  813d90:	89 c8                	mov    %ecx,%eax
  813d92:	85 c0                	test   %eax,%eax
  813d94:	79 0e                	jns    813da4 <tcp_output+0x4e2>
      pcb->snd_max = pcb->snd_nxt;
  813d96:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813d9a:	8b 50 60             	mov    0x60(%rax),%edx
  813d9d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813da1:	89 50 64             	mov    %edx,0x64(%rax)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  813da4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813da8:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813dac:	0f b7 d8             	movzwl %ax,%ebx
  813daf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813db3:	48 8b 40 20          	mov    0x20(%rax),%rax
  813db7:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813dbb:	0f b7 c0             	movzwl %ax,%eax
  813dbe:	89 c7                	mov    %eax,%edi
  813dc0:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  813dc7:	00 00 00 
  813dca:	ff d0                	callq  *%rax
  813dcc:	0f b7 c0             	movzwl %ax,%eax
  813dcf:	83 e0 01             	and    $0x1,%eax
  813dd2:	84 c0                	test   %al,%al
  813dd4:	75 27                	jne    813dfd <tcp_output+0x53b>
  813dd6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813dda:	48 8b 40 20          	mov    0x20(%rax),%rax
  813dde:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  813de2:	0f b7 c0             	movzwl %ax,%eax
  813de5:	89 c7                	mov    %eax,%edi
  813de7:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  813dee:	00 00 00 
  813df1:	ff d0                	callq  *%rax
  813df3:	0f b7 c0             	movzwl %ax,%eax
  813df6:	83 e0 02             	and    $0x2,%eax
  813df9:	85 c0                	test   %eax,%eax
  813dfb:	74 07                	je     813e04 <tcp_output+0x542>
  813dfd:	b8 01 00 00 00       	mov    $0x1,%eax
  813e02:	eb 05                	jmp    813e09 <tcp_output+0x547>
  813e04:	b8 00 00 00 00       	mov    $0x0,%eax
  813e09:	01 d8                	add    %ebx,%eax
  813e0b:	85 c0                	test   %eax,%eax
  813e0d:	0f 8e b0 00 00 00    	jle    813ec3 <tcp_output+0x601>
      seg->next = NULL;
  813e13:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813e17:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  813e1e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813e22:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  813e29:	48 85 c0             	test   %rax,%rax
  813e2c:	75 1c                	jne    813e4a <tcp_output+0x588>
        pcb->unacked = seg;
  813e2e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813e32:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  813e36:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
        useg = seg;
  813e3d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813e41:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  813e45:	e9 8c 00 00 00       	jmpq   813ed6 <tcp_output+0x614>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  813e4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813e4e:	48 8b 40 20          	mov    0x20(%rax),%rax
  813e52:	8b 40 04             	mov    0x4(%rax),%eax
  813e55:	89 c7                	mov    %eax,%edi
  813e57:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  813e5e:	00 00 00 
  813e61:	ff d0                	callq  *%rax
  813e63:	89 c3                	mov    %eax,%ebx
  813e65:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813e69:	48 8b 40 20          	mov    0x20(%rax),%rax
  813e6d:	8b 40 04             	mov    0x4(%rax),%eax
  813e70:	89 c7                	mov    %eax,%edi
  813e72:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  813e79:	00 00 00 
  813e7c:	ff d0                	callq  *%rax
  813e7e:	89 da                	mov    %ebx,%edx
  813e80:	29 c2                	sub    %eax,%edx
  813e82:	89 d0                	mov    %edx,%eax
  813e84:	85 c0                	test   %eax,%eax
  813e86:	79 23                	jns    813eab <tcp_output+0x5e9>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  813e88:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813e8c:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  813e93:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813e97:	48 89 10             	mov    %rdx,(%rax)
          pcb->unacked = seg;
  813e9a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813e9e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  813ea2:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
  813ea9:	eb 2b                	jmp    813ed6 <tcp_output+0x614>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  813eab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813eaf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  813eb3:	48 89 10             	mov    %rdx,(%rax)
          useg = useg->next;
  813eb6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  813eba:	48 8b 00             	mov    (%rax),%rax
  813ebd:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  813ec1:	eb 13                	jmp    813ed6 <tcp_output+0x614>
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  813ec3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813ec7:	48 89 c7             	mov    %rax,%rdi
  813eca:	48 b8 b3 00 81 00 00 	movabs $0x8100b3,%rax
  813ed1:	00 00 00 
  813ed4:	ff d0                	callq  *%rax
    }
    seg = pcb->unsent;
  813ed6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813eda:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  813ee1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  813ee5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813eea:	74 3f                	je     813f2b <tcp_output+0x669>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  813eec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813ef0:	48 8b 40 20          	mov    0x20(%rax),%rax
  813ef4:	8b 40 04             	mov    0x4(%rax),%eax
  813ef7:	89 c7                	mov    %eax,%edi
  813ef9:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  813f00:	00 00 00 
  813f03:	ff d0                	callq  *%rax
  813f05:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  813f09:	8b 52 54             	mov    0x54(%rdx),%edx
  813f0c:	89 c1                	mov    %eax,%ecx
  813f0e:	29 d1                	sub    %edx,%ecx
  813f10:	89 ca                	mov    %ecx,%edx
  813f12:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813f16:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813f1a:	0f b7 c0             	movzwl %ax,%eax
  813f1d:	01 d0                	add    %edx,%eax
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  813f1f:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  813f22:	0f 86 81 fc ff ff    	jbe    813ba9 <tcp_output+0x2e7>
  813f28:	eb 01                	jmp    813f2b <tcp_output+0x669>
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
      ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)){
      break;
  813f2a:	90                   	nop
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  813f2b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  813f30:	74 6a                	je     813f9c <tcp_output+0x6da>
  813f32:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813f36:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  813f3d:	84 c0                	test   %al,%al
  813f3f:	75 5b                	jne    813f9c <tcp_output+0x6da>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  813f41:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813f45:	48 8b 40 20          	mov    0x20(%rax),%rax
  813f49:	8b 40 04             	mov    0x4(%rax),%eax
  813f4c:	89 c7                	mov    %eax,%edi
  813f4e:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  813f55:	00 00 00 
  813f58:	ff d0                	callq  *%rax
  813f5a:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  813f5e:	8b 52 54             	mov    0x54(%rdx),%edx
  813f61:	89 c1                	mov    %eax,%ecx
  813f63:	29 d1                	sub    %edx,%ecx
  813f65:	89 ca                	mov    %ecx,%edx
  813f67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  813f6b:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  813f6f:	0f b7 c0             	movzwl %ax,%eax
  813f72:	01 c2                	add    %eax,%edx
  813f74:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813f78:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  813f7c:	0f b7 c0             	movzwl %ax,%eax
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  813f7f:	39 c2                	cmp    %eax,%edx
  813f81:	76 19                	jbe    813f9c <tcp_output+0x6da>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  813f83:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813f87:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  813f8e:	00 00 00 
    pcb->persist_backoff = 1;
  813f91:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813f95:	c6 80 d8 00 00 00 01 	movb   $0x1,0xd8(%rax)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  813f9c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813fa0:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  813fa4:	89 c2                	mov    %eax,%edx
  813fa6:	83 e2 7f             	and    $0x7f,%edx
  813fa9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  813fad:	88 50 2c             	mov    %dl,0x2c(%rax)
  return ERR_OK;
  813fb0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  813fb5:	48 83 c4 40          	add    $0x40,%rsp
  813fb9:	5b                   	pop    %rbx
  813fba:	41 5c                	pop    %r12
  813fbc:	5d                   	pop    %rbp
  813fbd:	c3                   	retq   

0000000000813fbe <tcp_output_segment>:
 * @param seg the tcp_seg to send
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 */
static void
tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
  813fbe:	55                   	push   %rbp
  813fbf:	48 89 e5             	mov    %rsp,%rbp
  813fc2:	53                   	push   %rbx
  813fc3:	48 83 ec 28          	sub    $0x28,%rsp
  813fc7:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  813fcb:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  813fcf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813fd3:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813fd7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813fdb:	8b 40 30             	mov    0x30(%rax),%eax
  813fde:	89 c7                	mov    %eax,%edi
  813fe0:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  813fe7:	00 00 00 
  813fea:	ff d0                	callq  *%rax
  813fec:	89 43 08             	mov    %eax,0x8(%rbx)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  813fef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  813ff3:	48 8b 58 20          	mov    0x20(%rax),%rbx
  813ff7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  813ffb:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  813fff:	0f b7 c0             	movzwl %ax,%eax
  814002:	89 c7                	mov    %eax,%edi
  814004:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  81400b:	00 00 00 
  81400e:	ff d0                	callq  *%rax
  814010:	66 89 43 0e          	mov    %ax,0xe(%rbx)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  814014:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814018:	48 85 c0             	test   %rax,%rax
  81401b:	74 0a                	je     814027 <tcp_output_segment+0x69>
  81401d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814021:	8b 00                	mov    (%rax),%eax
  814023:	85 c0                	test   %eax,%eax
  814025:	75 47                	jne    81406e <tcp_output_segment+0xb0>
    netif = ip_route(&(pcb->remote_ip));
  814027:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81402b:	48 83 c0 04          	add    $0x4,%rax
  81402f:	48 89 c7             	mov    %rax,%rdi
  814032:	48 b8 20 0a 81 00 00 	movabs $0x810a20,%rax
  814039:	00 00 00 
  81403c:	ff d0                	callq  *%rax
  81403e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (netif == NULL) {
  814042:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  814047:	0f 84 84 01 00 00    	je     8141d1 <tcp_output_segment+0x213>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  81404d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814051:	48 83 c0 08          	add    $0x8,%rax
  814055:	48 85 c0             	test   %rax,%rax
  814058:	74 09                	je     814063 <tcp_output_segment+0xa5>
  81405a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81405e:	8b 40 08             	mov    0x8(%rax),%eax
  814061:	eb 05                	jmp    814068 <tcp_output_segment+0xaa>
  814063:	b8 00 00 00 00       	mov    $0x0,%eax
  814068:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81406c:	89 02                	mov    %eax,(%rdx)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  81406e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814072:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  814076:	66 83 f8 ff          	cmp    $0xffff,%ax
  81407a:	75 0a                	jne    814086 <tcp_output_segment+0xc8>
    pcb->rtime = 0;
  81407c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814080:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

  if (pcb->rttest == 0) {
  814086:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81408a:	8b 40 44             	mov    0x44(%rax),%eax
  81408d:	85 c0                	test   %eax,%eax
  81408f:	75 33                	jne    8140c4 <tcp_output_segment+0x106>
    pcb->rttest = tcp_ticks;
  814091:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  814098:	00 00 00 
  81409b:	8b 10                	mov    (%rax),%edx
  81409d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8140a1:	89 50 44             	mov    %edx,0x44(%rax)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  8140a4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8140a8:	48 8b 40 20          	mov    0x20(%rax),%rax
  8140ac:	8b 40 04             	mov    0x4(%rax),%eax
  8140af:	89 c7                	mov    %eax,%edi
  8140b1:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  8140b8:	00 00 00 
  8140bb:	ff d0                	callq  *%rax
  8140bd:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8140c1:	89 42 48             	mov    %eax,0x48(%rdx)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  8140c4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8140c8:	48 8b 40 20          	mov    0x20(%rax),%rax
  8140cc:	48 89 c2             	mov    %rax,%rdx
  8140cf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8140d3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8140d7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8140db:	48 89 d1             	mov    %rdx,%rcx
  8140de:	48 29 c1             	sub    %rax,%rcx
  8140e1:	48 89 c8             	mov    %rcx,%rax
  8140e4:	66 89 45 e6          	mov    %ax,-0x1a(%rbp)

  seg->p->len -= len;
  8140e8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8140ec:	48 8b 40 08          	mov    0x8(%rax),%rax
  8140f0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8140f4:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8140f8:	0f b7 52 12          	movzwl 0x12(%rdx),%edx
  8140fc:	66 2b 55 e6          	sub    -0x1a(%rbp),%dx
  814100:	66 89 50 12          	mov    %dx,0x12(%rax)
  seg->p->tot_len -= len;
  814104:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814108:	48 8b 40 08          	mov    0x8(%rax),%rax
  81410c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  814110:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  814114:	0f b7 52 10          	movzwl 0x10(%rdx),%edx
  814118:	66 2b 55 e6          	sub    -0x1a(%rbp),%dx
  81411c:	66 89 50 10          	mov    %dx,0x10(%rax)

  seg->p->payload = seg->tcphdr;
  814120:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814124:	48 8b 40 08          	mov    0x8(%rax),%rax
  814128:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81412c:	48 8b 52 20          	mov    0x20(%rdx),%rdx
  814130:	48 89 50 08          	mov    %rdx,0x8(%rax)

  seg->tcphdr->chksum = 0;
  814134:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814138:	48 8b 40 20          	mov    0x20(%rax),%rax
  81413c:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  814142:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814146:	48 8b 58 20          	mov    0x20(%rax),%rbx
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  81414a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81414e:	48 8b 40 08          	mov    0x8(%rax),%rax
  814152:	0f b7 40 10          	movzwl 0x10(%rax),%eax

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  814156:	0f b7 c8             	movzwl %ax,%ecx
  814159:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81415d:	48 8d 50 04          	lea    0x4(%rax),%rdx
  814161:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  814165:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814169:	48 8b 40 08          	mov    0x8(%rax),%rax
  81416d:	41 89 c8             	mov    %ecx,%r8d
  814170:	b9 06 00 00 00       	mov    $0x6,%ecx
  814175:	48 89 c7             	mov    %rax,%rdi
  814178:	48 b8 29 24 81 00 00 	movabs $0x812429,%rax
  81417f:	00 00 00 
  814182:	ff d0                	callq  *%rax
  814184:	66 89 43 10          	mov    %ax,0x10(%rbx)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  814188:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81418c:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  814190:	0f b6 c8             	movzbl %al,%ecx
  814193:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  814197:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  81419b:	0f b6 d0             	movzbl %al,%edx
  81419e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8141a2:	48 8d 78 04          	lea    0x4(%rax),%rdi
  8141a6:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8141aa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8141ae:	48 8b 40 08          	mov    0x8(%rax),%rax
  8141b2:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  8141b8:	41 89 c8             	mov    %ecx,%r8d
  8141bb:	89 d1                	mov    %edx,%ecx
  8141bd:	48 89 fa             	mov    %rdi,%rdx
  8141c0:	48 89 c7             	mov    %rax,%rdi
  8141c3:	48 b8 0d 12 81 00 00 	movabs $0x81120d,%rax
  8141ca:	00 00 00 
  8141cd:	ff d0                	callq  *%rax
  8141cf:	eb 01                	jmp    8141d2 <tcp_output_segment+0x214>
  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
    netif = ip_route(&(pcb->remote_ip));
    if (netif == NULL) {
      return;
  8141d1:	90                   	nop
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
}
  8141d2:	48 83 c4 28          	add    $0x28,%rsp
  8141d6:	5b                   	pop    %rbx
  8141d7:	5d                   	pop    %rbp
  8141d8:	c3                   	retq   

00000000008141d9 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  8141d9:	55                   	push   %rbp
  8141da:	48 89 e5             	mov    %rsp,%rbp
  8141dd:	48 83 ec 30          	sub    $0x30,%rsp
  8141e1:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8141e4:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8141e7:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  8141eb:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
  8141ef:	44 89 c2             	mov    %r8d,%edx
  8141f2:	44 89 c8             	mov    %r9d,%eax
  8141f5:	66 89 55 d4          	mov    %dx,-0x2c(%rbp)
  8141f9:	66 89 45 d0          	mov    %ax,-0x30(%rbp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  8141fd:	ba 00 00 00 00       	mov    $0x0,%edx
  814202:	be 14 00 00 00       	mov    $0x14,%esi
  814207:	bf 01 00 00 00       	mov    $0x1,%edi
  81420c:	48 b8 4c d0 80 00 00 	movabs $0x80d04c,%rax
  814213:	00 00 00 
  814216:	ff d0                	callq  *%rax
  814218:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (p == NULL) {
  81421c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814221:	0f 84 bb 01 00 00    	je     8143e2 <tcp_rst+0x209>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  814227:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81422b:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81422f:	66 83 f8 13          	cmp    $0x13,%ax
  814233:	77 2a                	ja     81425f <tcp_rst+0x86>
  814235:	48 ba 58 27 82 00 00 	movabs $0x822758,%rdx
  81423c:	00 00 00 
  81423f:	be be 02 00 00       	mov    $0x2be,%esi
  814244:	48 bf c7 25 82 00 00 	movabs $0x8225c7,%rdi
  81424b:	00 00 00 
  81424e:	b8 00 00 00 00       	mov    $0x0,%eax
  814253:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81425a:	00 00 00 
  81425d:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  81425f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814263:	48 8b 40 08          	mov    0x8(%rax),%rax
  814267:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  tcphdr->src = htons(local_port);
  81426b:	0f b7 45 d4          	movzwl -0x2c(%rbp),%eax
  81426f:	89 c7                	mov    %eax,%edi
  814271:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  814278:	00 00 00 
  81427b:	ff d0                	callq  *%rax
  81427d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814281:	66 89 02             	mov    %ax,(%rdx)
  tcphdr->dest = htons(remote_port);
  814284:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
  814288:	89 c7                	mov    %eax,%edi
  81428a:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  814291:	00 00 00 
  814294:	ff d0                	callq  *%rax
  814296:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81429a:	66 89 42 02          	mov    %ax,0x2(%rdx)
  tcphdr->seqno = htonl(seqno);
  81429e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8142a1:	89 c7                	mov    %eax,%edi
  8142a3:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  8142aa:	00 00 00 
  8142ad:	ff d0                	callq  *%rax
  8142af:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8142b3:	89 42 04             	mov    %eax,0x4(%rdx)
  tcphdr->ackno = htonl(ackno);
  8142b6:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8142b9:	89 c7                	mov    %eax,%edi
  8142bb:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  8142c2:	00 00 00 
  8142c5:	ff d0                	callq  *%rax
  8142c7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8142cb:	89 42 08             	mov    %eax,0x8(%rdx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  8142ce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8142d2:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8142d6:	0f b7 c0             	movzwl %ax,%eax
  8142d9:	89 c7                	mov    %eax,%edi
  8142db:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  8142e2:	00 00 00 
  8142e5:	ff d0                	callq  *%rax
  8142e7:	83 e0 c0             	and    $0xffffffc0,%eax
  8142ea:	83 c8 14             	or     $0x14,%eax
  8142ed:	0f b7 c0             	movzwl %ax,%eax
  8142f0:	89 c7                	mov    %eax,%edi
  8142f2:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  8142f9:	00 00 00 
  8142fc:	ff d0                	callq  *%rax
  8142fe:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814302:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  tcphdr->wnd = htons(TCP_WND);
  814306:	bf c0 5d 00 00       	mov    $0x5dc0,%edi
  81430b:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  814312:	00 00 00 
  814315:	ff d0                	callq  *%rax
  814317:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81431b:	66 89 42 0e          	mov    %ax,0xe(%rdx)
  tcphdr->urgp = 0;
  81431f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814323:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  814329:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81432d:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814331:	0f b7 c0             	movzwl %ax,%eax
  814334:	89 c7                	mov    %eax,%edi
  814336:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81433d:	00 00 00 
  814340:	ff d0                	callq  *%rax
  814342:	83 e0 3f             	and    $0x3f,%eax
  814345:	80 cc 50             	or     $0x50,%ah
  814348:	0f b7 c0             	movzwl %ax,%eax
  81434b:	89 c7                	mov    %eax,%edi
  81434d:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  814354:	00 00 00 
  814357:	ff d0                	callq  *%rax
  814359:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81435d:	66 89 42 0c          	mov    %ax,0xc(%rdx)

  tcphdr->chksum = 0;
  814361:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814365:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
              IP_PROTO_TCP, p->tot_len);
  81436b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81436f:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  tcphdr->urgp = 0;
  TCPH_HDRLEN_SET(tcphdr, 5);

  tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  814373:	0f b7 c8             	movzwl %ax,%ecx
  814376:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81437a:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  81437e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814382:	41 89 c8             	mov    %ecx,%r8d
  814385:	b9 06 00 00 00       	mov    $0x6,%ecx
  81438a:	48 89 c7             	mov    %rax,%rdi
  81438d:	48 b8 29 24 81 00 00 	movabs $0x812429,%rax
  814394:	00 00 00 
  814397:	ff d0                	callq  *%rax
  814399:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81439d:	66 89 42 10          	mov    %ax,0x10(%rdx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  8143a1:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8143a5:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8143a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8143ad:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  8143b3:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8143b9:	b9 ff 00 00 00       	mov    $0xff,%ecx
  8143be:	48 89 c7             	mov    %rax,%rdi
  8143c1:	48 b8 0d 12 81 00 00 	movabs $0x81120d,%rax
  8143c8:	00 00 00 
  8143cb:	ff d0                	callq  *%rax
  pbuf_free(p);
  8143cd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8143d1:	48 89 c7             	mov    %rax,%rdi
  8143d4:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  8143db:	00 00 00 
  8143de:	ff d0                	callq  *%rax
  8143e0:	eb 01                	jmp    8143e3 <tcp_rst+0x20a>
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  if (p == NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  8143e2:	90                   	nop
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  pbuf_free(p);
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  8143e3:	c9                   	leaveq 
  8143e4:	c3                   	retq   

00000000008143e5 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  8143e5:	55                   	push   %rbp
  8143e6:	48 89 e5             	mov    %rsp,%rbp
  8143e9:	48 83 ec 20          	sub    $0x20,%rsp
  8143ed:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  8143f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8143f5:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8143fc:	48 85 c0             	test   %rax,%rax
  8143ff:	0f 84 b8 00 00 00    	je     8144bd <tcp_rexmit_rto+0xd8>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  814405:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814409:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  814410:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  814414:	eb 0b                	jmp    814421 <tcp_rexmit_rto+0x3c>
  814416:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81441a:	48 8b 00             	mov    (%rax),%rax
  81441d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  814421:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814425:	48 8b 00             	mov    (%rax),%rax
  814428:	48 85 c0             	test   %rax,%rax
  81442b:	75 e9                	jne    814416 <tcp_rexmit_rto+0x31>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  81442d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814431:	48 8b 90 80 00 00 00 	mov    0x80(%rax),%rdx
  814438:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81443c:	48 89 10             	mov    %rdx,(%rax)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  81443f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814443:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  81444a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81444e:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  814455:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814459:	48 c7 80 88 00 00 00 	movq   $0x0,0x88(%rax)
  814460:	00 00 00 00 

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  814464:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814468:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81446f:	48 8b 40 20          	mov    0x20(%rax),%rax
  814473:	8b 40 04             	mov    0x4(%rax),%eax
  814476:	89 c7                	mov    %eax,%edi
  814478:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81447f:	00 00 00 
  814482:	ff d0                	callq  *%rax
  814484:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814488:	89 42 60             	mov    %eax,0x60(%rdx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  81448b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81448f:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  814493:	8d 50 01             	lea    0x1(%rax),%edx
  814496:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81449a:	88 50 52             	mov    %dl,0x52(%rax)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  81449d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8144a1:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)

  /* Do the actual retransmission */
  tcp_output(pcb);
  8144a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8144ac:	48 89 c7             	mov    %rax,%rdi
  8144af:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  8144b6:	00 00 00 
  8144b9:	ff d0                	callq  *%rax
  8144bb:	eb 01                	jmp    8144be <tcp_rexmit_rto+0xd9>
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    return;
  8144bd:	90                   	nop
  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission */
  tcp_output(pcb);
}
  8144be:	c9                   	leaveq 
  8144bf:	c3                   	retq   

00000000008144c0 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  8144c0:	55                   	push   %rbp
  8144c1:	48 89 e5             	mov    %rsp,%rbp
  8144c4:	48 83 ec 20          	sub    $0x20,%rsp
  8144c8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  8144cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8144d0:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8144d7:	48 85 c0             	test   %rax,%rax
  8144da:	0f 84 a9 00 00 00    	je     814589 <tcp_rexmit+0xc9>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  8144e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8144e4:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8144eb:	48 8b 00             	mov    (%rax),%rax
  8144ee:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  pcb->unacked->next = pcb->unsent;
  8144f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8144f6:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8144fd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814501:	48 8b 92 80 00 00 00 	mov    0x80(%rdx),%rdx
  814508:	48 89 10             	mov    %rdx,(%rax)
  pcb->unsent = pcb->unacked;
  81450b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81450f:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
  814516:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81451a:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
  pcb->unacked = seg;
  814521:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814525:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  814529:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  814530:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814534:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81453b:	48 8b 40 20          	mov    0x20(%rax),%rax
  81453f:	8b 40 04             	mov    0x4(%rax),%eax
  814542:	89 c7                	mov    %eax,%edi
  814544:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81454b:	00 00 00 
  81454e:	ff d0                	callq  *%rax
  814550:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814554:	89 42 60             	mov    %eax,0x60(%rdx)

  ++pcb->nrtx;
  814557:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81455b:	0f b6 40 52          	movzbl 0x52(%rax),%eax
  81455f:	8d 50 01             	lea    0x1(%rax),%edx
  814562:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814566:	88 50 52             	mov    %dl,0x52(%rax)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  814569:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81456d:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  814574:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814578:	48 89 c7             	mov    %rax,%rdi
  81457b:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  814582:	00 00 00 
  814585:	ff d0                	callq  *%rax
  814587:	eb 01                	jmp    81458a <tcp_rexmit+0xca>
tcp_rexmit(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    return;
  814589:	90                   	nop
  pcb->rttest = 0;

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
}
  81458a:	c9                   	leaveq 
  81458b:	c3                   	retq   

000000000081458c <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  81458c:	55                   	push   %rbp
  81458d:	48 89 e5             	mov    %rsp,%rbp
  814590:	48 83 ec 20          	sub    $0x20,%rsp
  814594:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  814598:	ba 00 00 00 00       	mov    $0x0,%edx
  81459d:	be 14 00 00 00       	mov    $0x14,%esi
  8145a2:	bf 01 00 00 00       	mov    $0x1,%edi
  8145a7:	48 b8 4c d0 80 00 00 	movabs $0x80d04c,%rax
  8145ae:	00 00 00 
  8145b1:	ff d0                	callq  *%rax
  8145b3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
   
  if(p == NULL) {
  8145b7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8145bc:	0f 84 ee 01 00 00    	je     8147b0 <tcp_keepalive+0x224>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  8145c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8145c6:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8145ca:	66 83 f8 13          	cmp    $0x13,%ax
  8145ce:	77 2a                	ja     8145fa <tcp_keepalive+0x6e>
  8145d0:	48 ba 58 27 82 00 00 	movabs $0x822758,%rdx
  8145d7:	00 00 00 
  8145da:	be 3a 03 00 00       	mov    $0x33a,%esi
  8145df:	48 bf c7 25 82 00 00 	movabs $0x8225c7,%rdi
  8145e6:	00 00 00 
  8145e9:	b8 00 00 00 00       	mov    $0x0,%eax
  8145ee:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8145f5:	00 00 00 
  8145f8:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  8145fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8145fe:	48 8b 40 08          	mov    0x8(%rax),%rax
  814602:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  tcphdr->src = htons(pcb->local_port);
  814606:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81460a:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  81460e:	0f b7 c0             	movzwl %ax,%eax
  814611:	89 c7                	mov    %eax,%edi
  814613:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  81461a:	00 00 00 
  81461d:	ff d0                	callq  *%rax
  81461f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814623:	66 89 02             	mov    %ax,(%rdx)
  tcphdr->dest = htons(pcb->remote_port);
  814626:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81462a:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  81462e:	0f b7 c0             	movzwl %ax,%eax
  814631:	89 c7                	mov    %eax,%edi
  814633:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  81463a:	00 00 00 
  81463d:	ff d0                	callq  *%rax
  81463f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814643:	66 89 42 02          	mov    %ax,0x2(%rdx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  814647:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81464b:	8b 40 60             	mov    0x60(%rax),%eax
  81464e:	83 e8 01             	sub    $0x1,%eax
  814651:	89 c7                	mov    %eax,%edi
  814653:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  81465a:	00 00 00 
  81465d:	ff d0                	callq  *%rax
  81465f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814663:	89 42 04             	mov    %eax,0x4(%rdx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  814666:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81466a:	8b 40 30             	mov    0x30(%rax),%eax
  81466d:	89 c7                	mov    %eax,%edi
  81466f:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  814676:	00 00 00 
  814679:	ff d0                	callq  *%rax
  81467b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81467f:	89 42 08             	mov    %eax,0x8(%rdx)
  TCPH_FLAGS_SET(tcphdr, 0);
  814682:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814686:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81468a:	0f b7 c0             	movzwl %ax,%eax
  81468d:	89 c7                	mov    %eax,%edi
  81468f:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  814696:	00 00 00 
  814699:	ff d0                	callq  *%rax
  81469b:	0f b7 c0             	movzwl %ax,%eax
  81469e:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8146a3:	89 c7                	mov    %eax,%edi
  8146a5:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  8146ac:	00 00 00 
  8146af:	ff d0                	callq  *%rax
  8146b1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8146b5:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8146b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8146bd:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  8146c1:	0f b7 c0             	movzwl %ax,%eax
  8146c4:	89 c7                	mov    %eax,%edi
  8146c6:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  8146cd:	00 00 00 
  8146d0:	ff d0                	callq  *%rax
  8146d2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8146d6:	66 89 42 0e          	mov    %ax,0xe(%rdx)
  tcphdr->urgp = 0;
  8146da:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8146de:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  8146e4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8146e8:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8146ec:	0f b7 c0             	movzwl %ax,%eax
  8146ef:	89 c7                	mov    %eax,%edi
  8146f1:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  8146f8:	00 00 00 
  8146fb:	ff d0                	callq  *%rax
  8146fd:	83 e0 3f             	and    $0x3f,%eax
  814700:	80 cc 50             	or     $0x50,%ah
  814703:	0f b7 c0             	movzwl %ax,%eax
  814706:	89 c7                	mov    %eax,%edi
  814708:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  81470f:	00 00 00 
  814712:	ff d0                	callq  *%rax
  814714:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  814718:	66 89 42 0c          	mov    %ax,0xc(%rdx)

  tcphdr->chksum = 0;
  81471c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814720:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
                                      IP_PROTO_TCP, p->tot_len);
  814726:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81472a:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  tcphdr->urgp = 0;
  TCPH_HDRLEN_SET(tcphdr, 5);

  tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  81472e:	0f b7 c8             	movzwl %ax,%ecx
  814731:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814735:	48 8d 50 04          	lea    0x4(%rax),%rdx
  814739:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81473d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814741:	41 89 c8             	mov    %ecx,%r8d
  814744:	b9 06 00 00 00       	mov    $0x6,%ecx
  814749:	48 89 c7             	mov    %rax,%rdi
  81474c:	48 b8 29 24 81 00 00 	movabs $0x812429,%rax
  814753:	00 00 00 
  814756:	ff d0                	callq  *%rax
  814758:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81475c:	66 89 42 10          	mov    %ax,0x10(%rdx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  814760:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814764:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  814768:	0f b6 d0             	movzbl %al,%edx
  81476b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81476f:	48 8d 78 04          	lea    0x4(%rax),%rdi
  814773:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  814777:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81477b:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  814781:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  814787:	89 d1                	mov    %edx,%ecx
  814789:	48 89 fa             	mov    %rdi,%rdx
  81478c:	48 89 c7             	mov    %rax,%rdi
  81478f:	48 b8 0d 12 81 00 00 	movabs $0x81120d,%rax
  814796:	00 00 00 
  814799:	ff d0                	callq  *%rax
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  81479b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81479f:	48 89 c7             	mov    %rax,%rdi
  8147a2:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  8147a9:	00 00 00 
  8147ac:	ff d0                	callq  *%rax
  8147ae:	eb 01                	jmp    8147b1 <tcp_keepalive+0x225>
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
   
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  8147b0:	90                   	nop

  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  8147b1:	c9                   	leaveq 
  8147b2:	c3                   	retq   

00000000008147b3 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  8147b3:	55                   	push   %rbp
  8147b4:	48 89 e5             	mov    %rsp,%rbp
  8147b7:	48 83 ec 30          	sub    $0x30,%rsp
  8147bb:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  8147bf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8147c3:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8147ca:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if(seg == NULL)
  8147ce:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8147d3:	75 0f                	jne    8147e4 <tcp_zero_window_probe+0x31>
    seg = pcb->unsent;
  8147d5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8147d9:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8147e0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if(seg == NULL)
  8147e4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8147e9:	0f 84 24 02 00 00    	je     814a13 <tcp_zero_window_probe+0x260>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  8147ef:	ba 00 00 00 00       	mov    $0x0,%edx
  8147f4:	be 15 00 00 00       	mov    $0x15,%esi
  8147f9:	bf 01 00 00 00       	mov    $0x1,%edi
  8147fe:	48 b8 4c d0 80 00 00 	movabs $0x80d04c,%rax
  814805:	00 00 00 
  814808:	ff d0                	callq  *%rax
  81480a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
   
  if(p == NULL) {
  81480e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  814813:	0f 84 fd 01 00 00    	je     814a16 <tcp_zero_window_probe+0x263>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  814819:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81481d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  814821:	66 83 f8 13          	cmp    $0x13,%ax
  814825:	77 2a                	ja     814851 <tcp_zero_window_probe+0x9e>
  814827:	48 ba 58 27 82 00 00 	movabs $0x822758,%rdx
  81482e:	00 00 00 
  814831:	be 8d 03 00 00       	mov    $0x38d,%esi
  814836:	48 bf c7 25 82 00 00 	movabs $0x8225c7,%rdi
  81483d:	00 00 00 
  814840:	b8 00 00 00 00       	mov    $0x0,%eax
  814845:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81484c:	00 00 00 
  81484f:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  814851:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814855:	48 8b 40 08          	mov    0x8(%rax),%rax
  814859:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  tcphdr->src = htons(pcb->local_port);
  81485d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814861:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  814865:	0f b7 c0             	movzwl %ax,%eax
  814868:	89 c7                	mov    %eax,%edi
  81486a:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  814871:	00 00 00 
  814874:	ff d0                	callq  *%rax
  814876:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81487a:	66 89 02             	mov    %ax,(%rdx)
  tcphdr->dest = htons(pcb->remote_port);
  81487d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814881:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  814885:	0f b7 c0             	movzwl %ax,%eax
  814888:	89 c7                	mov    %eax,%edi
  81488a:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  814891:	00 00 00 
  814894:	ff d0                	callq  *%rax
  814896:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81489a:	66 89 42 02          	mov    %ax,0x2(%rdx)
  tcphdr->seqno = seg->tcphdr->seqno;
  81489e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8148a2:	48 8b 40 20          	mov    0x20(%rax),%rax
  8148a6:	8b 50 04             	mov    0x4(%rax),%edx
  8148a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8148ad:	89 50 04             	mov    %edx,0x4(%rax)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  8148b0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8148b4:	8b 40 30             	mov    0x30(%rax),%eax
  8148b7:	89 c7                	mov    %eax,%edi
  8148b9:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  8148c0:	00 00 00 
  8148c3:	ff d0                	callq  *%rax
  8148c5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8148c9:	89 42 08             	mov    %eax,0x8(%rdx)
  TCPH_FLAGS_SET(tcphdr, 0);
  8148cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8148d0:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  8148d4:	0f b7 c0             	movzwl %ax,%eax
  8148d7:	89 c7                	mov    %eax,%edi
  8148d9:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  8148e0:	00 00 00 
  8148e3:	ff d0                	callq  *%rax
  8148e5:	0f b7 c0             	movzwl %ax,%eax
  8148e8:	25 c0 ff 00 00       	and    $0xffc0,%eax
  8148ed:	89 c7                	mov    %eax,%edi
  8148ef:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  8148f6:	00 00 00 
  8148f9:	ff d0                	callq  *%rax
  8148fb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8148ff:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  814903:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814907:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  81490b:	0f b7 c0             	movzwl %ax,%eax
  81490e:	89 c7                	mov    %eax,%edi
  814910:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  814917:	00 00 00 
  81491a:	ff d0                	callq  *%rax
  81491c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814920:	66 89 42 0e          	mov    %ax,0xe(%rdx)
  tcphdr->urgp = 0;
  814924:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814928:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
  TCPH_HDRLEN_SET(tcphdr, 5);
  81492e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814932:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  814936:	0f b7 c0             	movzwl %ax,%eax
  814939:	89 c7                	mov    %eax,%edi
  81493b:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  814942:	00 00 00 
  814945:	ff d0                	callq  *%rax
  814947:	83 e0 3f             	and    $0x3f,%eax
  81494a:	80 cc 50             	or     $0x50,%ah
  81494d:	0f b7 c0             	movzwl %ax,%eax
  814950:	89 c7                	mov    %eax,%edi
  814952:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  814959:	00 00 00 
  81495c:	ff d0                	callq  *%rax
  81495e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814962:	66 89 42 0c          	mov    %ax,0xc(%rdx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  814966:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81496a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81496e:	48 8d 50 14          	lea    0x14(%rax),%rdx
  814972:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814976:	48 8b 40 10          	mov    0x10(%rax),%rax
  81497a:	0f b6 00             	movzbl (%rax),%eax
  81497d:	88 02                	mov    %al,(%rdx)

  tcphdr->chksum = 0;
  81497f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814983:	66 c7 40 10 00 00    	movw   $0x0,0x10(%rax)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
                                      IP_PROTO_TCP, p->tot_len);
  814989:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81498d:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;

  tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  814991:	0f b7 c8             	movzwl %ax,%ecx
  814994:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814998:	48 8d 50 04          	lea    0x4(%rax),%rdx
  81499c:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  8149a0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8149a4:	41 89 c8             	mov    %ecx,%r8d
  8149a7:	b9 06 00 00 00       	mov    $0x6,%ecx
  8149ac:	48 89 c7             	mov    %rax,%rdi
  8149af:	48 b8 29 24 81 00 00 	movabs $0x812429,%rax
  8149b6:	00 00 00 
  8149b9:	ff d0                	callq  *%rax
  8149bb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8149bf:	66 89 42 10          	mov    %ax,0x10(%rdx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  8149c3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8149c7:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8149cb:	0f b6 d0             	movzbl %al,%edx
  8149ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8149d2:	48 8d 78 04          	lea    0x4(%rax),%rdi
  8149d6:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  8149da:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8149de:	41 b9 06 00 00 00    	mov    $0x6,%r9d
  8149e4:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8149ea:	89 d1                	mov    %edx,%ecx
  8149ec:	48 89 fa             	mov    %rdi,%rdx
  8149ef:	48 89 c7             	mov    %rax,%rdi
  8149f2:	48 b8 0d 12 81 00 00 	movabs $0x81120d,%rax
  8149f9:	00 00 00 
  8149fc:	ff d0                	callq  *%rax
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  8149fe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  814a02:	48 89 c7             	mov    %rax,%rdi
  814a05:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  814a0c:	00 00 00 
  814a0f:	ff d0                	callq  *%rax
  814a11:	eb 04                	jmp    814a17 <tcp_zero_window_probe+0x264>

  if(seg == NULL)
    seg = pcb->unsent;

  if(seg == NULL)
    return;
  814a13:	90                   	nop
  814a14:	eb 01                	jmp    814a17 <tcp_zero_window_probe+0x264>

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
   
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  814a16:	90                   	nop
  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  814a17:	c9                   	leaveq 
  814a18:	c3                   	retq   
  814a19:	00 00                	add    %al,(%rax)
	...

0000000000814a1c <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  814a1c:	55                   	push   %rbp
  814a1d:	48 89 e5             	mov    %rsp,%rbp
  814a20:	53                   	push   %rbx
  814a21:	48 83 ec 58          	sub    $0x58,%rsp
  814a25:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  814a29:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  814a2d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814a31:	48 8b 40 08          	mov    0x8(%rax),%rax
  814a35:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  814a39:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814a3d:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  814a41:	0f b7 d8             	movzwl %ax,%ebx
  814a44:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814a48:	0f b7 00             	movzwl (%rax),%eax
  814a4b:	0f b7 c0             	movzwl %ax,%eax
  814a4e:	89 c7                	mov    %eax,%edi
  814a50:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  814a57:	00 00 00 
  814a5a:	ff d0                	callq  *%rax
  814a5c:	66 c1 e8 08          	shr    $0x8,%ax
  814a60:	0f b7 c0             	movzwl %ax,%eax
  814a63:	83 e0 0f             	and    $0xf,%eax
  814a66:	83 c0 02             	add    $0x2,%eax
  814a69:	c1 e0 02             	shl    $0x2,%eax
  814a6c:	39 c3                	cmp    %eax,%ebx
  814a6e:	7c 40                	jl     814ab0 <udp_input+0x94>
  814a70:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814a74:	0f b7 00             	movzwl (%rax),%eax
  814a77:	0f b7 c0             	movzwl %ax,%eax
  814a7a:	89 c7                	mov    %eax,%edi
  814a7c:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  814a83:	00 00 00 
  814a86:	ff d0                	callq  *%rax
  814a88:	66 c1 e8 08          	shr    $0x8,%ax
  814a8c:	83 e0 0f             	and    $0xf,%eax
  814a8f:	c1 e0 02             	shl    $0x2,%eax
  814a92:	f7 d8                	neg    %eax
  814a94:	0f bf d0             	movswl %ax,%edx
  814a97:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814a9b:	89 d6                	mov    %edx,%esi
  814a9d:	48 89 c7             	mov    %rax,%rdi
  814aa0:	48 b8 6f d7 80 00 00 	movabs $0x80d76f,%rax
  814aa7:	00 00 00 
  814aaa:	ff d0                	callq  *%rax
  814aac:	84 c0                	test   %al,%al
  814aae:	74 18                	je     814ac8 <udp_input+0xac>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  814ab0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814ab4:	48 89 c7             	mov    %rax,%rdi
  814ab7:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  814abe:	00 00 00 
  814ac1:	ff d0                	callq  *%rax
    goto end;
  814ac3:	e9 6b 04 00 00       	jmpq   814f33 <udp_input+0x517>
  }

  udphdr = (struct udp_hdr *)p->payload;
  814ac8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814acc:	48 8b 40 08          	mov    0x8(%rax),%rax
  814ad0:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  814ad4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  814ad8:	0f b7 00             	movzwl (%rax),%eax
  814adb:	0f b7 c0             	movzwl %ax,%eax
  814ade:	89 c7                	mov    %eax,%edi
  814ae0:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  814ae7:	00 00 00 
  814aea:	ff d0                	callq  *%rax
  814aec:	66 89 45 be          	mov    %ax,-0x42(%rbp)
  dest = ntohs(udphdr->dest);
  814af0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  814af4:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  814af8:	0f b7 c0             	movzwl %ax,%eax
  814afb:	89 c7                	mov    %eax,%edi
  814afd:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  814b04:	00 00 00 
  814b07:	ff d0                	callq  *%rax
  814b09:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
               ip4_addr3(&iphdr->dest), ip4_addr4(&iphdr->dest), ntohs(udphdr->dest),
               ip4_addr1(&iphdr->src), ip4_addr2(&iphdr->src),
               ip4_addr3(&iphdr->src), ip4_addr4(&iphdr->src), ntohs(udphdr->src)));

#if LWIP_DHCP
  pcb = NULL;
  814b0d:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  814b14:	00 
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  814b15:	66 83 7d bc 44       	cmpw   $0x44,-0x44(%rbp)
  814b1a:	0f 85 8c 00 00 00    	jne    814bac <udp_input+0x190>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  814b20:	66 83 7d be 43       	cmpw   $0x43,-0x42(%rbp)
  814b25:	0f 85 d6 01 00 00    	jne    814d01 <udp_input+0x2e5>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  814b2b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814b2f:	48 8b 40 38          	mov    0x38(%rax),%rax
  814b33:	48 85 c0             	test   %rax,%rax
  814b36:	0f 84 c5 01 00 00    	je     814d01 <udp_input+0x2e5>
  814b3c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814b40:	48 8b 40 38          	mov    0x38(%rax),%rax
  814b44:	48 8b 40 08          	mov    0x8(%rax),%rax
  814b48:	48 85 c0             	test   %rax,%rax
  814b4b:	0f 84 b0 01 00 00    	je     814d01 <udp_input+0x2e5>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  814b51:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814b55:	48 8b 40 38          	mov    0x38(%rax),%rax
  814b59:	48 8b 40 08          	mov    0x8(%rax),%rax
  814b5d:	48 83 c0 04          	add    $0x4,%rax
  814b61:	48 85 c0             	test   %rax,%rax
  814b64:	74 31                	je     814b97 <udp_input+0x17b>
  814b66:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814b6a:	48 8b 40 38          	mov    0x38(%rax),%rax
  814b6e:	48 8b 40 08          	mov    0x8(%rax),%rax
  814b72:	8b 40 04             	mov    0x4(%rax),%eax
  814b75:	85 c0                	test   %eax,%eax
  814b77:	74 1e                	je     814b97 <udp_input+0x17b>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
  814b79:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814b7d:	48 8b 40 38          	mov    0x38(%rax),%rax
  814b81:	48 8b 40 08          	mov    0x8(%rax),%rax
  814b85:	8b 50 04             	mov    0x4(%rax),%edx
  814b88:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814b8c:	8b 40 0c             	mov    0xc(%rax),%eax
    if (src == DHCP_SERVER_PORT) {
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  814b8f:	39 c2                	cmp    %eax,%edx
  814b91:	0f 85 6a 01 00 00    	jne    814d01 <udp_input+0x2e5>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
          pcb = inp->dhcp->pcb;
  814b97:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814b9b:	48 8b 40 38          	mov    0x38(%rax),%rax
  814b9f:	48 8b 40 08          	mov    0x8(%rax),%rax
  814ba3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  814ba7:	e9 55 01 00 00       	jmpq   814d01 <udp_input+0x2e5>
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
  814bac:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  814bb3:	00 
    local_match = 0;
  814bb4:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
    uncon_pcb = NULL;
  814bb8:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  814bbf:	00 
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  814bc0:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  814bc7:	00 00 00 
  814bca:	48 8b 00             	mov    (%rax),%rax
  814bcd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  814bd1:	e9 0e 01 00 00       	jmpq   814ce4 <udp_input+0x2c8>
      local_match = 0;
  814bd6:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  814bda:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814bde:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  814be2:	66 3b 45 bc          	cmp    -0x44(%rbp),%ax
  814be6:	75 6b                	jne    814c53 <udp_input+0x237>
          (ip_addr_isany(&pcb->local_ip) ||
  814be8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  814bec:	48 85 c0             	test   %rax,%rax
  814bef:	74 3d                	je     814c2e <udp_input+0x212>
          (ip_addr_isany(&pcb->local_ip) ||
  814bf1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814bf5:	8b 00                	mov    (%rax),%eax
  814bf7:	85 c0                	test   %eax,%eax
  814bf9:	74 33                	je     814c2e <udp_input+0x212>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  814bfb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814bff:	8b 10                	mov    (%rax),%edx
  814c01:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814c05:	8b 40 10             	mov    0x10(%rax),%eax
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
  814c08:	39 c2                	cmp    %eax,%edx
  814c0a:	74 22                	je     814c2e <udp_input+0x212>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  814c0c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814c10:	48 8d 50 10          	lea    0x10(%rax),%rdx
  814c14:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814c18:	48 89 c6             	mov    %rax,%rsi
  814c1b:	48 89 d7             	mov    %rdx,%rdi
  814c1e:	48 b8 80 09 81 00 00 	movabs $0x810980,%rax
  814c25:	00 00 00 
  814c28:	ff d0                	callq  *%rax
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  814c2a:	84 c0                	test   %al,%al
  814c2c:	74 25                	je     814c53 <udp_input+0x237>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
  814c2e:	c6 45 d7 01          	movb   $0x1,-0x29(%rbp)
        if ((uncon_pcb == NULL) && 
  814c32:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  814c37:	75 1a                	jne    814c53 <udp_input+0x237>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
  814c39:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c3d:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  814c41:	0f b6 c0             	movzbl %al,%eax
  814c44:	83 e0 04             	and    $0x4,%eax
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  814c47:	85 c0                	test   %eax,%eax
  814c49:	75 08                	jne    814c53 <udp_input+0x237>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
  814c4b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c4f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  814c53:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  814c57:	74 77                	je     814cd0 <udp_input+0x2b4>
          (pcb->remote_port == src) &&
  814c59:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c5d:	0f b7 40 1c          	movzwl 0x1c(%rax),%eax
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  814c61:	66 3b 45 be          	cmp    -0x42(%rbp),%ax
  814c65:	75 69                	jne    814cd0 <udp_input+0x2b4>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
  814c67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c6b:	48 83 c0 04          	add    $0x4,%rax
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  814c6f:	48 85 c0             	test   %rax,%rax
  814c72:	74 1d                	je     814c91 <udp_input+0x275>
          (ip_addr_isany(&pcb->remote_ip) ||
  814c74:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c78:	8b 40 04             	mov    0x4(%rax),%eax
  814c7b:	85 c0                	test   %eax,%eax
  814c7d:	74 12                	je     814c91 <udp_input+0x275>
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
  814c7f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c83:	8b 50 04             	mov    0x4(%rax),%edx
  814c86:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814c8a:	8b 40 0c             	mov    0xc(%rax),%eax
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
  814c8d:	39 c2                	cmp    %eax,%edx
  814c8f:	75 3f                	jne    814cd0 <udp_input+0x2b4>
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
  814c91:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  814c96:	74 59                	je     814cf1 <udp_input+0x2d5>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  814c98:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814c9c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  814ca0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  814ca4:	48 89 50 10          	mov    %rdx,0x10(%rax)
          pcb->next = udp_pcbs;
  814ca8:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  814caf:	00 00 00 
  814cb2:	48 8b 10             	mov    (%rax),%rdx
  814cb5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814cb9:	48 89 50 10          	mov    %rdx,0x10(%rax)
          udp_pcbs = pcb;
  814cbd:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  814cc4:	00 00 00 
  814cc7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  814ccb:	48 89 10             	mov    %rdx,(%rax)
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
  814cce:	eb 21                	jmp    814cf1 <udp_input+0x2d5>
      }
      prev = pcb;
  814cd0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814cd4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  814cd8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814cdc:	48 8b 40 10          	mov    0x10(%rax),%rax
  814ce0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  814ce4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  814ce9:	0f 85 e7 fe ff ff    	jne    814bd6 <udp_input+0x1ba>
  814cef:	eb 01                	jmp    814cf2 <udp_input+0x2d6>
          pcb->next = udp_pcbs;
          udp_pcbs = pcb;
        } else {
          UDP_STATS_INC(udp.cachehit);
        }
        break;
  814cf1:	90                   	nop
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
  814cf2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  814cf7:	75 08                	jne    814d01 <udp_input+0x2e5>
      pcb = uncon_pcb;
  814cf9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814cfd:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  814d01:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  814d06:	75 16                	jne    814d1e <udp_input+0x302>
  814d08:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814d0c:	8b 50 08             	mov    0x8(%rax),%edx
  814d0f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814d13:	8b 40 10             	mov    0x10(%rax),%eax
  814d16:	39 c2                	cmp    %eax,%edx
  814d18:	0f 85 02 02 00 00    	jne    814f20 <udp_input+0x504>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  814d1e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  814d22:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  814d26:	66 85 c0             	test   %ax,%ax
  814d29:	74 53                	je     814d7e <udp_input+0x362>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
                               (struct ip_addr *)&(iphdr->dest),
                               IP_PROTO_UDP, p->tot_len) != 0) {
  814d2b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814d2f:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  814d33:	0f b7 c8             	movzwl %ax,%ecx
  814d36:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814d3a:	48 8d 50 10          	lea    0x10(%rax),%rdx
  814d3e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814d42:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  814d46:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814d4a:	41 89 c8             	mov    %ecx,%r8d
  814d4d:	b9 11 00 00 00       	mov    $0x11,%ecx
  814d52:	48 89 c7             	mov    %rax,%rdi
  814d55:	48 b8 29 24 81 00 00 	movabs $0x812429,%rax
  814d5c:	00 00 00 
  814d5f:	ff d0                	callq  *%rax
  814d61:	66 85 c0             	test   %ax,%ax
  814d64:	74 18                	je     814d7e <udp_input+0x362>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  814d66:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814d6a:	48 89 c7             	mov    %rax,%rdi
  814d6d:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  814d74:	00 00 00 
  814d77:	ff d0                	callq  *%rax
          goto end;
  814d79:	e9 b5 01 00 00       	jmpq   814f33 <udp_input+0x517>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  814d7e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814d82:	be f8 ff ff ff       	mov    $0xfffffff8,%esi
  814d87:	48 89 c7             	mov    %rax,%rdi
  814d8a:	48 b8 6f d7 80 00 00 	movabs $0x80d76f,%rax
  814d91:	00 00 00 
  814d94:	ff d0                	callq  *%rax
  814d96:	84 c0                	test   %al,%al
  814d98:	74 2a                	je     814dc4 <udp_input+0x3a8>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  814d9a:	48 ba 88 27 82 00 00 	movabs $0x822788,%rdx
  814da1:	00 00 00 
  814da4:	be 0a 01 00 00       	mov    $0x10a,%esi
  814da9:	48 bf 9c 27 82 00 00 	movabs $0x82279c,%rdi
  814db0:	00 00 00 
  814db3:	b8 00 00 00 00       	mov    $0x0,%eax
  814db8:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  814dbf:	00 00 00 
  814dc2:	ff d1                	callq  *%rcx
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  814dc4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  814dc9:	74 57                	je     814e22 <udp_input+0x406>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  814dcb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814dcf:	48 8b 40 20          	mov    0x20(%rax),%rax
  814dd3:	48 85 c0             	test   %rax,%rax
  814dd6:	74 32                	je     814e0a <udp_input+0x3ee>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  814dd8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814ddc:	4c 8b 48 20          	mov    0x20(%rax),%r9
  814de0:	0f b7 7d be          	movzwl -0x42(%rbp),%edi
  814de4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814de8:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  814dec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814df0:	48 8b 40 28          	mov    0x28(%rax),%rax
  814df4:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  814df8:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  814dfc:	41 89 f8             	mov    %edi,%r8d
  814dff:	48 89 c7             	mov    %rax,%rdi
  814e02:	41 ff d1             	callq  *%r9
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  814e05:	e9 29 01 00 00       	jmpq   814f33 <udp_input+0x517>
      if (pcb->recv != NULL) {
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  814e0a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814e0e:	48 89 c7             	mov    %rax,%rdi
  814e11:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  814e18:	00 00 00 
  814e1b:	ff d0                	callq  *%rax
        goto end;
  814e1d:	e9 11 01 00 00       	jmpq   814f33 <udp_input+0x517>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  814e22:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814e26:	48 8d 50 10          	lea    0x10(%rax),%rdx
  814e2a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  814e2e:	48 89 c6             	mov    %rax,%rsi
  814e31:	48 89 d7             	mov    %rdx,%rdi
  814e34:	48 b8 80 09 81 00 00 	movabs $0x810980,%rax
  814e3b:	00 00 00 
  814e3e:	ff d0                	callq  *%rax
  814e40:	84 c0                	test   %al,%al
  814e42:	0f 85 c3 00 00 00    	jne    814f0b <udp_input+0x4ef>
          !ip_addr_ismulticast(&iphdr->dest)) {
  814e48:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814e4c:	8b 58 10             	mov    0x10(%rax),%ebx
  814e4f:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  814e54:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  814e5b:	00 00 00 
  814e5e:	ff d0                	callq  *%rax
  814e60:	21 c3                	and    %eax,%ebx
  814e62:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  814e67:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  814e6e:	00 00 00 
  814e71:	ff d0                	callq  *%rax
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  814e73:	39 c3                	cmp    %eax,%ebx
  814e75:	0f 84 90 00 00 00    	je     814f0b <udp_input+0x4ef>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  814e7b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  814e7f:	0f b7 00             	movzwl (%rax),%eax
  814e82:	0f b7 c0             	movzwl %ax,%eax
  814e85:	89 c7                	mov    %eax,%edi
  814e87:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  814e8e:	00 00 00 
  814e91:	ff d0                	callq  *%rax
  814e93:	66 c1 e8 08          	shr    $0x8,%ax
  814e97:	0f b7 c0             	movzwl %ax,%eax
  814e9a:	83 e0 0f             	and    $0xf,%eax
  814e9d:	83 c0 02             	add    $0x2,%eax
  814ea0:	c1 e0 02             	shl    $0x2,%eax
  814ea3:	0f bf d0             	movswl %ax,%edx
  814ea6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814eaa:	89 d6                	mov    %edx,%esi
  814eac:	48 89 c7             	mov    %rax,%rdi
  814eaf:	48 b8 6f d7 80 00 00 	movabs $0x80d76f,%rax
  814eb6:	00 00 00 
  814eb9:	ff d0                	callq  *%rax
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  814ebb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814ebf:	48 8b 40 08          	mov    0x8(%rax),%rax
  814ec3:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  814ec7:	74 2a                	je     814ef3 <udp_input+0x4d7>
  814ec9:	48 ba b0 27 82 00 00 	movabs $0x8227b0,%rdx
  814ed0:	00 00 00 
  814ed3:	be 25 01 00 00       	mov    $0x125,%esi
  814ed8:	48 bf 9c 27 82 00 00 	movabs $0x82279c,%rdi
  814edf:	00 00 00 
  814ee2:	b8 00 00 00 00       	mov    $0x0,%eax
  814ee7:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  814eee:	00 00 00 
  814ef1:	ff d1                	callq  *%rcx
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  814ef3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814ef7:	be 03 00 00 00       	mov    $0x3,%esi
  814efc:	48 89 c7             	mov    %rax,%rdi
  814eff:	48 b8 c2 03 82 00 00 	movabs $0x8203c2,%rax
  814f06:	00 00 00 
  814f09:	ff d0                	callq  *%rax
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  814f0b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814f0f:	48 89 c7             	mov    %rax,%rdi
  814f12:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  814f19:	00 00 00 
  814f1c:	ff d0                	callq  *%rax
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  814f1e:	eb 13                	jmp    814f33 <udp_input+0x517>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
    }
  } else {
    pbuf_free(p);
  814f20:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  814f24:	48 89 c7             	mov    %rax,%rdi
  814f27:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  814f2e:	00 00 00 
  814f31:	ff d0                	callq  *%rax
  }
end:
  PERF_STOP("udp_input");
}
  814f33:	48 83 c4 58          	add    $0x58,%rsp
  814f37:	5b                   	pop    %rbx
  814f38:	5d                   	pop    %rbp
  814f39:	c3                   	retq   

0000000000814f3a <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  814f3a:	55                   	push   %rbp
  814f3b:	48 89 e5             	mov    %rsp,%rbp
  814f3e:	48 83 ec 10          	sub    $0x10,%rsp
  814f42:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  814f46:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  814f4a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814f4e:	0f b7 40 1c          	movzwl 0x1c(%rax),%eax
  814f52:	0f b7 d0             	movzwl %ax,%edx
  814f55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814f59:	48 8d 78 04          	lea    0x4(%rax),%rdi
  814f5d:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  814f61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  814f65:	89 d1                	mov    %edx,%ecx
  814f67:	48 89 fa             	mov    %rdi,%rdx
  814f6a:	48 89 c7             	mov    %rax,%rdi
  814f6d:	48 b8 7b 4f 81 00 00 	movabs $0x814f7b,%rax
  814f74:	00 00 00 
  814f77:	ff d0                	callq  *%rax
}
  814f79:	c9                   	leaveq 
  814f7a:	c3                   	retq   

0000000000814f7b <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  814f7b:	55                   	push   %rbp
  814f7c:	48 89 e5             	mov    %rsp,%rbp
  814f7f:	48 83 ec 30          	sub    $0x30,%rsp
  814f83:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  814f87:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  814f8b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  814f8f:	89 c8                	mov    %ecx,%eax
  814f91:	66 89 45 d4          	mov    %ax,-0x2c(%rbp)

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  814f95:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  814f99:	48 89 c7             	mov    %rax,%rdi
  814f9c:	48 b8 20 0a 81 00 00 	movabs $0x810a20,%rax
  814fa3:	00 00 00 
  814fa6:	ff d0                	callq  *%rax
  814fa8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  814fac:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  814fb1:	75 07                	jne    814fba <udp_sendto+0x3f>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  814fb3:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  814fb8:	eb 26                	jmp    814fe0 <udp_sendto+0x65>
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  814fba:	0f b7 4d d4          	movzwl -0x2c(%rbp),%ecx
  814fbe:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  814fc2:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  814fc6:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  814fca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  814fce:	49 89 f8             	mov    %rdi,%r8
  814fd1:	48 89 c7             	mov    %rax,%rdi
  814fd4:	48 b8 e2 4f 81 00 00 	movabs $0x814fe2,%rax
  814fdb:	00 00 00 
  814fde:	ff d0                	callq  *%rax
}
  814fe0:	c9                   	leaveq 
  814fe1:	c3                   	retq   

0000000000814fe2 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  814fe2:	55                   	push   %rbp
  814fe3:	48 89 e5             	mov    %rsp,%rbp
  814fe6:	48 83 ec 60          	sub    $0x60,%rsp
  814fea:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  814fee:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  814ff2:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  814ff6:	89 c8                	mov    %ecx,%eax
  814ff8:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  814ffc:	66 89 45 c4          	mov    %ax,-0x3c(%rbp)
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  815000:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815004:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  815008:	66 85 c0             	test   %ax,%ax
  81500b:	75 37                	jne    815044 <udp_sendto_if+0x62>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  81500d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815011:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  815015:	0f b7 d0             	movzwl %ax,%edx
  815018:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  81501c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815020:	48 89 ce             	mov    %rcx,%rsi
  815023:	48 89 c7             	mov    %rax,%rdi
  815026:	48 b8 93 52 81 00 00 	movabs $0x815293,%rax
  81502d:	00 00 00 
  815030:	ff d0                	callq  *%rax
  815032:	88 45 ef             	mov    %al,-0x11(%rbp)
    if (err != ERR_OK) {
  815035:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  815039:	74 09                	je     815044 <udp_sendto_if+0x62>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: forced port bind failed\n"));
      return err;
  81503b:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81503f:	e9 4d 02 00 00       	jmpq   815291 <udp_sendto_if+0x2af>
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  815044:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  815048:	be 08 00 00 00       	mov    $0x8,%esi
  81504d:	48 89 c7             	mov    %rax,%rdi
  815050:	48 b8 6f d7 80 00 00 	movabs $0x80d76f,%rax
  815057:	00 00 00 
  81505a:	ff d0                	callq  *%rax
  81505c:	84 c0                	test   %al,%al
  81505e:	74 4c                	je     8150ac <udp_sendto_if+0xca>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  815060:	ba 00 00 00 00       	mov    $0x0,%edx
  815065:	be 08 00 00 00       	mov    $0x8,%esi
  81506a:	bf 01 00 00 00       	mov    $0x1,%edi
  81506f:	48 b8 4c d0 80 00 00 	movabs $0x80d04c,%rax
  815076:	00 00 00 
  815079:	ff d0                	callq  *%rax
  81507b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  81507f:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  815084:	75 0a                	jne    815090 <udp_sendto_if+0xae>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
  815086:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81508b:	e9 01 02 00 00       	jmpq   815291 <udp_sendto_if+0x2af>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  815090:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  815094:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815098:	48 89 d6             	mov    %rdx,%rsi
  81509b:	48 89 c7             	mov    %rax,%rdi
  81509e:	48 b8 56 dc 80 00 00 	movabs $0x80dc56,%rax
  8150a5:	00 00 00 
  8150a8:	ff d0                	callq  *%rax
  8150aa:	eb 08                	jmp    8150b4 <udp_sendto_if+0xd2>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
  8150ac:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8150b0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  8150b4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8150b8:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8150bc:	66 83 f8 07          	cmp    $0x7,%ax
  8150c0:	77 2a                	ja     8150ec <udp_sendto_if+0x10a>
  8150c2:	48 ba c8 27 82 00 00 	movabs $0x8227c8,%rdx
  8150c9:	00 00 00 
  8150cc:	be b2 01 00 00       	mov    $0x1b2,%esi
  8150d1:	48 bf 9c 27 82 00 00 	movabs $0x82279c,%rdi
  8150d8:	00 00 00 
  8150db:	b8 00 00 00 00       	mov    $0x0,%eax
  8150e0:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8150e7:	00 00 00 
  8150ea:	ff d1                	callq  *%rcx
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  8150ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8150f0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8150f4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  udphdr->src = htons(pcb->local_port);
  8150f8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8150fc:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  815100:	0f b7 c0             	movzwl %ax,%eax
  815103:	89 c7                	mov    %eax,%edi
  815105:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  81510c:	00 00 00 
  81510f:	ff d0                	callq  *%rax
  815111:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  815115:	66 89 02             	mov    %ax,(%rdx)
  udphdr->dest = htons(dst_port);
  815118:	0f b7 45 c4          	movzwl -0x3c(%rbp),%eax
  81511c:	89 c7                	mov    %eax,%edi
  81511e:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  815125:	00 00 00 
  815128:	ff d0                	callq  *%rax
  81512a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81512e:	66 89 42 02          	mov    %ax,0x2(%rdx)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  815132:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815136:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  81513c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815140:	48 85 c0             	test   %rax,%rax
  815143:	74 0a                	je     81514f <udp_sendto_if+0x16d>
  815145:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815149:	8b 00                	mov    (%rax),%eax
  81514b:	85 c0                	test   %eax,%eax
  81514d:	75 0e                	jne    81515d <udp_sendto_if+0x17b>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  81514f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  815153:	48 83 c0 08          	add    $0x8,%rax
  815157:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81515b:	eb 48                	jmp    8151a5 <udp_sendto_if+0x1c3>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  81515d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815161:	8b 10                	mov    (%rax),%edx
  815163:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  815167:	8b 40 08             	mov    0x8(%rax),%eax
  81516a:	39 c2                	cmp    %eax,%edx
  81516c:	74 2f                	je     81519d <udp_sendto_if+0x1bb>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  81516e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815172:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  815176:	74 1b                	je     815193 <udp_sendto_if+0x1b1>
        /* free the header pbuf */
        pbuf_free(q);
  815178:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81517c:	48 89 c7             	mov    %rax,%rdi
  81517f:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  815186:	00 00 00 
  815189:	ff d0                	callq  *%rax
        q = NULL;
  81518b:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  815192:	00 
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  815193:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  815198:	e9 f4 00 00 00       	jmpq   815291 <udp_sendto_if+0x2af>
    }
    /* use UDP PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  81519d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8151a1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  8151a5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8151a9:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8151ad:	0f b7 c0             	movzwl %ax,%eax
  8151b0:	89 c7                	mov    %eax,%edi
  8151b2:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  8151b9:	00 00 00 
  8151bc:	ff d0                	callq  *%rax
  8151be:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8151c2:	66 89 42 04          	mov    %ax,0x4(%rdx)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  8151c6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8151ca:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8151ce:	0f b6 c0             	movzbl %al,%eax
  8151d1:	83 e0 01             	and    $0x1,%eax
  8151d4:	85 c0                	test   %eax,%eax
  8151d6:	75 4d                	jne    815225 <udp_sendto_if+0x243>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  8151d8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8151dc:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  8151e0:	0f b7 c8             	movzwl %ax,%ecx
  8151e3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8151e7:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8151eb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8151ef:	41 89 c8             	mov    %ecx,%r8d
  8151f2:	b9 11 00 00 00       	mov    $0x11,%ecx
  8151f7:	48 89 c7             	mov    %rax,%rdi
  8151fa:	48 b8 29 24 81 00 00 	movabs $0x812429,%rax
  815201:	00 00 00 
  815204:	ff d0                	callq  *%rax
  815206:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81520a:	66 89 42 06          	mov    %ax,0x6(%rdx)
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  81520e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815212:	0f b7 40 06          	movzwl 0x6(%rax),%eax
  815216:	66 85 c0             	test   %ax,%ax
  815219:	75 0a                	jne    815225 <udp_sendto_if+0x243>
  81521b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81521f:	66 c7 40 06 ff ff    	movw   $0xffff,0x6(%rax)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  815225:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815229:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  81522d:	44 0f b6 c0          	movzbl %al,%r8d
  815231:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  815235:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  815239:	0f b6 c8             	movzbl %al,%ecx
  81523c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  815240:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  815244:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815248:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  81524c:	48 89 3c 24          	mov    %rdi,(%rsp)
  815250:	41 b9 11 00 00 00    	mov    $0x11,%r9d
  815256:	48 89 c7             	mov    %rax,%rdi
  815259:	48 b8 57 0f 81 00 00 	movabs $0x810f57,%rax
  815260:	00 00 00 
  815263:	ff d0                	callq  *%rax
  815265:	88 45 ef             	mov    %al,-0x11(%rbp)
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  815268:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81526c:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  815270:	74 1b                	je     81528d <udp_sendto_if+0x2ab>
    /* free the header pbuf */
    pbuf_free(q);
  815272:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  815276:	48 89 c7             	mov    %rax,%rdi
  815279:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  815280:	00 00 00 
  815283:	ff d0                	callq  *%rax
    q = NULL;
  815285:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  81528c:	00 
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
  81528d:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  815291:	c9                   	leaveq 
  815292:	c3                   	retq   

0000000000815293 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  815293:	55                   	push   %rbp
  815294:	48 89 e5             	mov    %rsp,%rbp
  815297:	48 83 ec 30          	sub    $0x30,%rsp
  81529b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81529f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8152a3:	89 d0                	mov    %edx,%eax
  8152a5:	66 89 45 dc          	mov    %ax,-0x24(%rbp)

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  8152a9:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  8152ad:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8152b4:	00 00 00 
  8152b7:	48 8b 00             	mov    (%rax),%rax
  8152ba:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8152be:	eb 4a                	jmp    81530a <udp_bind+0x77>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  8152c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8152c4:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8152c8:	75 34                	jne    8152fe <udp_bind+0x6b>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  8152ca:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  8152ce:	74 2a                	je     8152fa <udp_bind+0x67>
  8152d0:	48 ba f6 27 82 00 00 	movabs $0x8227f6,%rdx
  8152d7:	00 00 00 
  8152da:	be 41 02 00 00       	mov    $0x241,%esi
  8152df:	48 bf 9c 27 82 00 00 	movabs $0x82279c,%rdi
  8152e6:	00 00 00 
  8152e9:	b8 00 00 00 00       	mov    $0x0,%eax
  8152ee:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8152f5:	00 00 00 
  8152f8:	ff d1                	callq  *%rcx
      /* pcb already in list, just rebind */
      rebind = 1;
  8152fa:	c6 45 f7 01          	movb   $0x1,-0x9(%rbp)
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  8152fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815302:	48 8b 40 10          	mov    0x10(%rax),%rax
  815306:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81530a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81530f:	75 af                	jne    8152c0 <udp_bind+0x2d>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  815311:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  815316:	74 08                	je     815320 <udp_bind+0x8d>
  815318:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81531c:	8b 00                	mov    (%rax),%eax
  81531e:	eb 05                	jmp    815325 <udp_bind+0x92>
  815320:	b8 00 00 00 00       	mov    $0x0,%eax
  815325:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  815329:	89 02                	mov    %eax,(%rdx)

  /* no port specified? */
  if (port == 0) {
  81532b:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  815330:	75 68                	jne    81539a <udp_bind+0x107>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
  815332:	66 c7 45 dc 00 10    	movw   $0x1000,-0x24(%rbp)
    ipcb = udp_pcbs;
  815338:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  81533f:	00 00 00 
  815342:	48 8b 00             	mov    (%rax),%rax
  815345:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  815349:	eb 32                	jmp    81537d <udp_bind+0xea>
      if (ipcb->local_port == port) {
  81534b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81534f:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  815353:	66 3b 45 dc          	cmp    -0x24(%rbp),%ax
  815357:	75 18                	jne    815371 <udp_bind+0xde>
        /* port is already used by another udp_pcb */
        port++;
  815359:	66 83 45 dc 01       	addw   $0x1,-0x24(%rbp)
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
  81535e:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815365:	00 00 00 
  815368:	48 8b 00             	mov    (%rax),%rax
  81536b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81536f:	eb 0c                	jmp    81537d <udp_bind+0xea>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  815371:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815375:	48 8b 40 10          	mov    0x10(%rax),%rax
  815379:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  81537d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  815382:	74 08                	je     81538c <udp_bind+0xf9>
  815384:	66 81 7d dc ff 7f    	cmpw   $0x7fff,-0x24(%rbp)
  81538a:	75 bf                	jne    81534b <udp_bind+0xb8>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
  81538c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  815391:	74 07                	je     81539a <udp_bind+0x107>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
  815393:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  815398:	eb 3d                	jmp    8153d7 <udp_bind+0x144>
    }
  }
  pcb->local_port = port;
  81539a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81539e:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  8153a2:	66 89 50 1a          	mov    %dx,0x1a(%rax)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  8153a6:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  8153aa:	75 26                	jne    8153d2 <udp_bind+0x13f>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  8153ac:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8153b3:	00 00 00 
  8153b6:	48 8b 10             	mov    (%rax),%rdx
  8153b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8153bd:	48 89 50 10          	mov    %rdx,0x10(%rax)
    udp_pcbs = pcb;
  8153c1:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8153c8:	00 00 00 
  8153cb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8153cf:	48 89 10             	mov    %rdx,(%rax)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  8153d2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8153d7:	c9                   	leaveq 
  8153d8:	c3                   	retq   

00000000008153d9 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  8153d9:	55                   	push   %rbp
  8153da:	48 89 e5             	mov    %rsp,%rbp
  8153dd:	48 83 ec 30          	sub    $0x30,%rsp
  8153e1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8153e5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8153e9:	89 d0                	mov    %edx,%eax
  8153eb:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  8153ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8153f3:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  8153f7:	66 85 c0             	test   %ax,%ax
  8153fa:	75 37                	jne    815433 <udp_connect+0x5a>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  8153fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815400:	0f b7 40 1a          	movzwl 0x1a(%rax),%eax
  815404:	0f b7 d0             	movzwl %ax,%edx
  815407:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81540b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81540f:	48 89 ce             	mov    %rcx,%rsi
  815412:	48 89 c7             	mov    %rax,%rdi
  815415:	48 b8 93 52 81 00 00 	movabs $0x815293,%rax
  81541c:	00 00 00 
  81541f:	ff d0                	callq  *%rax
  815421:	88 45 f7             	mov    %al,-0x9(%rbp)
    if (err != ERR_OK)
  815424:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  815428:	74 09                	je     815433 <udp_connect+0x5a>
      return err;
  81542a:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  81542e:	e9 9d 00 00 00       	jmpq   8154d0 <udp_connect+0xf7>
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  815433:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  815438:	74 08                	je     815442 <udp_connect+0x69>
  81543a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81543e:	8b 00                	mov    (%rax),%eax
  815440:	eb 05                	jmp    815447 <udp_connect+0x6e>
  815442:	b8 00 00 00 00       	mov    $0x0,%eax
  815447:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81544b:	89 42 04             	mov    %eax,0x4(%rdx)
  pcb->remote_port = port;
  81544e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815452:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  815456:	66 89 50 1c          	mov    %dx,0x1c(%rax)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  81545a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81545e:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  815462:	89 c2                	mov    %eax,%edx
  815464:	83 ca 04             	or     $0x4,%edx
  815467:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81546b:	88 50 18             	mov    %dl,0x18(%rax)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  81546e:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815475:	00 00 00 
  815478:	48 8b 00             	mov    (%rax),%rax
  81547b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81547f:	eb 1d                	jmp    81549e <udp_connect+0xc5>
    if (pcb == ipcb) {
  815481:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815485:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  815489:	75 07                	jne    815492 <udp_connect+0xb9>
      /* already on the list, just return */
      return ERR_OK;
  81548b:	b8 00 00 00 00       	mov    $0x0,%eax
  815490:	eb 3e                	jmp    8154d0 <udp_connect+0xf7>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  815492:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815496:	48 8b 40 10          	mov    0x10(%rax),%rax
  81549a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81549e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8154a3:	75 dc                	jne    815481 <udp_connect+0xa8>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  8154a5:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8154ac:	00 00 00 
  8154af:	48 8b 10             	mov    (%rax),%rdx
  8154b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8154b6:	48 89 50 10          	mov    %rdx,0x10(%rax)
  udp_pcbs = pcb;
  8154ba:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  8154c1:	00 00 00 
  8154c4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8154c8:	48 89 10             	mov    %rdx,(%rax)
  return ERR_OK;
  8154cb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8154d0:	c9                   	leaveq 
  8154d1:	c3                   	retq   

00000000008154d2 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  8154d2:	55                   	push   %rbp
  8154d3:	48 89 e5             	mov    %rsp,%rbp
  8154d6:	48 83 ec 08          	sub    $0x8,%rsp
  8154da:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  8154de:	48 b8 a8 23 82 00 00 	movabs $0x8223a8,%rax
  8154e5:	00 00 00 
  8154e8:	8b 10                	mov    (%rax),%edx
  8154ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8154ee:	89 50 04             	mov    %edx,0x4(%rax)
  pcb->remote_port = 0;
  8154f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8154f5:	66 c7 40 1c 00 00    	movw   $0x0,0x1c(%rax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  8154fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8154ff:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  815503:	89 c2                	mov    %eax,%edx
  815505:	83 e2 fb             	and    $0xfffffffb,%edx
  815508:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81550c:	88 50 18             	mov    %dl,0x18(%rax)
}
  81550f:	c9                   	leaveq 
  815510:	c3                   	retq   

0000000000815511 <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  815511:	55                   	push   %rbp
  815512:	48 89 e5             	mov    %rsp,%rbp
  815515:	48 83 ec 18          	sub    $0x18,%rsp
  815519:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81551d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  815521:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
  815525:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815529:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81552d:	48 89 50 20          	mov    %rdx,0x20(%rax)
  pcb->recv_arg = recv_arg;
  815531:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815535:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  815539:	48 89 50 28          	mov    %rdx,0x28(%rax)
}
  81553d:	c9                   	leaveq 
  81553e:	c3                   	retq   

000000000081553f <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  81553f:	55                   	push   %rbp
  815540:	48 89 e5             	mov    %rsp,%rbp
  815543:	48 83 ec 20          	sub    $0x20,%rsp
  815547:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  81554b:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815552:	00 00 00 
  815555:	48 8b 00             	mov    (%rax),%rax
  815558:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81555c:	75 20                	jne    81557e <udp_remove+0x3f>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  81555e:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815565:	00 00 00 
  815568:	48 8b 00             	mov    (%rax),%rax
  81556b:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81556f:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815576:	00 00 00 
  815579:	48 89 10             	mov    %rdx,(%rax)
  81557c:	eb 51                	jmp    8155cf <udp_remove+0x90>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  81557e:	48 b8 48 b0 b5 00 00 	movabs $0xb5b048,%rax
  815585:	00 00 00 
  815588:	48 8b 00             	mov    (%rax),%rax
  81558b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81558f:	eb 37                	jmp    8155c8 <udp_remove+0x89>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  815591:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815595:	48 8b 40 10          	mov    0x10(%rax),%rax
  815599:	48 85 c0             	test   %rax,%rax
  81559c:	74 1e                	je     8155bc <udp_remove+0x7d>
  81559e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8155a2:	48 8b 40 10          	mov    0x10(%rax),%rax
  8155a6:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8155aa:	75 10                	jne    8155bc <udp_remove+0x7d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  8155ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8155b0:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8155b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8155b8:	48 89 50 10          	mov    %rdx,0x10(%rax)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  8155bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8155c0:	48 8b 40 10          	mov    0x10(%rax),%rax
  8155c4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8155c8:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8155cd:	75 c2                	jne    815591 <udp_remove+0x52>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  8155cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8155d3:	48 89 c6             	mov    %rax,%rsi
  8155d6:	bf 01 00 00 00       	mov    $0x1,%edi
  8155db:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  8155e2:	00 00 00 
  8155e5:	ff d0                	callq  *%rax
}
  8155e7:	c9                   	leaveq 
  8155e8:	c3                   	retq   

00000000008155e9 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  8155e9:	55                   	push   %rbp
  8155ea:	48 89 e5             	mov    %rsp,%rbp
  8155ed:	48 83 ec 10          	sub    $0x10,%rsp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  8155f1:	bf 01 00 00 00       	mov    $0x1,%edi
  8155f6:	48 b8 41 ca 80 00 00 	movabs $0x80ca41,%rax
  8155fd:	00 00 00 
  815600:	ff d0                	callq  *%rax
  815602:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  815606:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81560b:	74 25                	je     815632 <udp_new+0x49>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  81560d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815611:	ba 30 00 00 00       	mov    $0x30,%edx
  815616:	be 00 00 00 00       	mov    $0x0,%esi
  81561b:	48 89 c7             	mov    %rax,%rdi
  81561e:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  815625:	00 00 00 
  815628:	ff d0                	callq  *%rax
    pcb->ttl = UDP_TTL;
  81562a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81562e:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
  }
  return pcb;
  815632:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  815636:	c9                   	leaveq 
  815637:	c3                   	retq   

0000000000815638 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  815638:	55                   	push   %rbp
  815639:	48 89 e5             	mov    %rsp,%rbp
  81563c:	48 83 ec 20          	sub    $0x20,%rsp
  815640:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  815644:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815649:	75 2a                	jne    815675 <free_etharp_q+0x3d>
  81564b:	48 ba 14 28 82 00 00 	movabs $0x822814,%rdx
  815652:	00 00 00 
  815655:	be 93 00 00 00       	mov    $0x93,%esi
  81565a:	48 bf 1e 28 82 00 00 	movabs $0x82281e,%rdi
  815661:	00 00 00 
  815664:	b8 00 00 00 00       	mov    $0x0,%eax
  815669:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  815670:	00 00 00 
  815673:	ff d1                	callq  *%rcx
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  815675:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815679:	48 8b 40 08          	mov    0x8(%rax),%rax
  81567d:	48 85 c0             	test   %rax,%rax
  815680:	0f 85 a3 00 00 00    	jne    815729 <free_etharp_q+0xf1>
  815686:	48 ba 36 28 82 00 00 	movabs $0x822836,%rdx
  81568d:	00 00 00 
  815690:	be 94 00 00 00       	mov    $0x94,%esi
  815695:	48 bf 1e 28 82 00 00 	movabs $0x82281e,%rdi
  81569c:	00 00 00 
  81569f:	b8 00 00 00 00       	mov    $0x0,%eax
  8156a4:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8156ab:	00 00 00 
  8156ae:	ff d1                	callq  *%rcx
  while (q) {
    r = q;
  8156b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8156b4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    q = q->next;
  8156b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8156bc:	48 8b 00             	mov    (%rax),%rax
  8156bf:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  8156c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8156c7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8156cb:	48 85 c0             	test   %rax,%rax
  8156ce:	75 2a                	jne    8156fa <free_etharp_q+0xc2>
  8156d0:	48 ba 43 28 82 00 00 	movabs $0x822843,%rdx
  8156d7:	00 00 00 
  8156da:	be 98 00 00 00       	mov    $0x98,%esi
  8156df:	48 bf 1e 28 82 00 00 	movabs $0x82281e,%rdi
  8156e6:	00 00 00 
  8156e9:	b8 00 00 00 00       	mov    $0x0,%eax
  8156ee:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8156f5:	00 00 00 
  8156f8:	ff d1                	callq  *%rcx
    pbuf_free(r->p);
  8156fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8156fe:	48 8b 40 08          	mov    0x8(%rax),%rax
  815702:	48 89 c7             	mov    %rax,%rdi
  815705:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81570c:	00 00 00 
  81570f:	ff d0                	callq  *%rax
    memp_free(MEMP_ARP_QUEUE, r);
  815711:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  815715:	48 89 c6             	mov    %rax,%rsi
  815718:	bf 0a 00 00 00       	mov    $0xa,%edi
  81571d:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  815724:	00 00 00 
  815727:	ff d0                	callq  *%rax
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  815729:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81572e:	75 80                	jne    8156b0 <free_etharp_q+0x78>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  815730:	c9                   	leaveq 
  815731:	c3                   	retq   

0000000000815732 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  815732:	55                   	push   %rbp
  815733:	48 89 e5             	mov    %rsp,%rbp
  815736:	48 83 ec 10          	sub    $0x10,%rsp
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  81573a:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  81573e:	e9 df 01 00 00       	jmpq   815922 <etharp_tmr+0x1f0>
    arp_table[i].ctime++;
  815743:	0f b6 55 ff          	movzbl -0x1(%rbp),%edx
  815747:	48 be e0 b6 b4 00 00 	movabs $0xb4b6e0,%rsi
  81574e:	00 00 00 
  815751:	48 63 ca             	movslq %edx,%rcx
  815754:	48 89 c8             	mov    %rcx,%rax
  815757:	48 c1 e0 02          	shl    $0x2,%rax
  81575b:	48 01 c8             	add    %rcx,%rax
  81575e:	48 c1 e0 03          	shl    $0x3,%rax
  815762:	48 01 f0             	add    %rsi,%rax
  815765:	48 83 c0 10          	add    $0x10,%rax
  815769:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  81576d:	8d 48 01             	lea    0x1(%rax),%ecx
  815770:	48 be e0 b6 b4 00 00 	movabs $0xb4b6e0,%rsi
  815777:	00 00 00 
  81577a:	48 63 d2             	movslq %edx,%rdx
  81577d:	48 89 d0             	mov    %rdx,%rax
  815780:	48 c1 e0 02          	shl    $0x2,%rax
  815784:	48 01 d0             	add    %rdx,%rax
  815787:	48 c1 e0 03          	shl    $0x3,%rax
  81578b:	48 01 f0             	add    %rsi,%rax
  81578e:	48 83 c0 10          	add    $0x10,%rax
  815792:	88 48 08             	mov    %cl,0x8(%rax)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  815795:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815799:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  8157a0:	00 00 00 
  8157a3:	48 63 d0             	movslq %eax,%rdx
  8157a6:	48 89 d0             	mov    %rdx,%rax
  8157a9:	48 c1 e0 02          	shl    $0x2,%rax
  8157ad:	48 01 d0             	add    %rdx,%rax
  8157b0:	48 c1 e0 03          	shl    $0x3,%rax
  8157b4:	48 01 c8             	add    %rcx,%rax
  8157b7:	48 83 c0 10          	add    $0x10,%rax
  8157bb:	8b 40 04             	mov    0x4(%rax),%eax
  8157be:	83 f8 02             	cmp    $0x2,%eax
  8157c1:	75 2e                	jne    8157f1 <etharp_tmr+0xbf>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
  8157c3:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8157c7:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  8157ce:	00 00 00 
  8157d1:	48 63 d0             	movslq %eax,%rdx
  8157d4:	48 89 d0             	mov    %rdx,%rax
  8157d7:	48 c1 e0 02          	shl    $0x2,%rax
  8157db:	48 01 d0             	add    %rdx,%rax
  8157de:	48 c1 e0 03          	shl    $0x3,%rax
  8157e2:	48 01 c8             	add    %rcx,%rax
  8157e5:	48 83 c0 10          	add    $0x10,%rax
  8157e9:	0f b6 40 08          	movzbl 0x8(%rax),%eax

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  8157ed:	3c ef                	cmp    $0xef,%al
  8157ef:	77 64                	ja     815855 <etharp_tmr+0x123>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  8157f1:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8157f5:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  8157fc:	00 00 00 
  8157ff:	48 63 d0             	movslq %eax,%rdx
  815802:	48 89 d0             	mov    %rdx,%rax
  815805:	48 c1 e0 02          	shl    $0x2,%rax
  815809:	48 01 d0             	add    %rdx,%rax
  81580c:	48 c1 e0 03          	shl    $0x3,%rax
  815810:	48 01 c8             	add    %rcx,%rax
  815813:	48 83 c0 10          	add    $0x10,%rax
  815817:	8b 40 04             	mov    0x4(%rax),%eax
  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
  81581a:	83 f8 01             	cmp    $0x1,%eax
  81581d:	0f 85 e6 00 00 00    	jne    815909 <etharp_tmr+0x1d7>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
         (arp_table[i].ctime >= ARP_MAXPENDING))) {
  815823:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815827:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  81582e:	00 00 00 
  815831:	48 63 d0             	movslq %eax,%rdx
  815834:	48 89 d0             	mov    %rdx,%rax
  815837:	48 c1 e0 02          	shl    $0x2,%rax
  81583b:	48 01 d0             	add    %rdx,%rax
  81583e:	48 c1 e0 03          	shl    $0x3,%rax
  815842:	48 01 c8             	add    %rcx,%rax
  815845:	48 83 c0 10          	add    $0x10,%rax
  815849:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  81584d:	3c 01                	cmp    $0x1,%al
  81584f:	0f 86 b4 00 00 00    	jbe    815909 <etharp_tmr+0x1d7>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  815855:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815859:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  815860:	00 00 00 
  815863:	48 63 d0             	movslq %eax,%rdx
  815866:	48 89 d0             	mov    %rdx,%rax
  815869:	48 c1 e0 02          	shl    $0x2,%rax
  81586d:	48 01 d0             	add    %rdx,%rax
  815870:	48 c1 e0 03          	shl    $0x3,%rax
  815874:	48 01 c8             	add    %rcx,%rax
  815877:	48 8b 00             	mov    (%rax),%rax
  81587a:	48 85 c0             	test   %rax,%rax
  81587d:	74 5d                	je     8158dc <etharp_tmr+0x1aa>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  81587f:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815883:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  81588a:	00 00 00 
  81588d:	48 63 d0             	movslq %eax,%rdx
  815890:	48 89 d0             	mov    %rdx,%rax
  815893:	48 c1 e0 02          	shl    $0x2,%rax
  815897:	48 01 d0             	add    %rdx,%rax
  81589a:	48 c1 e0 03          	shl    $0x3,%rax
  81589e:	48 01 c8             	add    %rcx,%rax
  8158a1:	48 8b 00             	mov    (%rax),%rax
  8158a4:	48 89 c7             	mov    %rax,%rdi
  8158a7:	48 b8 38 56 81 00 00 	movabs $0x815638,%rax
  8158ae:	00 00 00 
  8158b1:	ff d0                	callq  *%rax
        arp_table[i].q = NULL;
  8158b3:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8158b7:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  8158be:	00 00 00 
  8158c1:	48 63 d0             	movslq %eax,%rdx
  8158c4:	48 89 d0             	mov    %rdx,%rax
  8158c7:	48 c1 e0 02          	shl    $0x2,%rax
  8158cb:	48 01 d0             	add    %rdx,%rax
  8158ce:	48 c1 e0 03          	shl    $0x3,%rax
  8158d2:	48 01 c8             	add    %rcx,%rax
  8158d5:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  8158dc:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  8158e0:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  8158e7:	00 00 00 
  8158ea:	48 63 d0             	movslq %eax,%rdx
  8158ed:	48 89 d0             	mov    %rdx,%rax
  8158f0:	48 c1 e0 02          	shl    $0x2,%rax
  8158f4:	48 01 d0             	add    %rdx,%rax
  8158f7:	48 c1 e0 03          	shl    $0x3,%rax
  8158fb:	48 01 c8             	add    %rcx,%rax
  8158fe:	48 83 c0 10          	add    $0x10,%rax
  815902:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    }
#if ARP_QUEUEING
    /* still pending entry? (not expired) */
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
  815909:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  81590d:	48 63 d0             	movslq %eax,%rdx
  815910:	48 89 d0             	mov    %rdx,%rax
  815913:	48 c1 e0 02          	shl    $0x2,%rax
  815917:	48 01 d0             	add    %rdx,%rax
  81591a:	48 c1 e0 03          	shl    $0x3,%rax
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  81591e:	80 45 ff 01          	addb   $0x1,-0x1(%rbp)
  815922:	80 7d ff 09          	cmpb   $0x9,-0x1(%rbp)
  815926:	0f 86 17 fe ff ff    	jbe    815743 <etharp_tmr+0x11>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  81592c:	c9                   	leaveq 
  81592d:	c3                   	retq   

000000000081592e <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  81592e:	55                   	push   %rbp
  81592f:	48 89 e5             	mov    %rsp,%rbp
  815932:	48 83 ec 20          	sub    $0x20,%rsp
  815936:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81593a:	89 f0                	mov    %esi,%eax
  81593c:	88 45 e4             	mov    %al,-0x1c(%rbp)
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  81593f:	c6 45 ff 0a          	movb   $0xa,-0x1(%rbp)
  815943:	c6 45 fe 0a          	movb   $0xa,-0x2(%rbp)
  s8_t empty = ARP_TABLE_SIZE;
  815947:	c6 45 fd 0a          	movb   $0xa,-0x3(%rbp)
  u8_t i = 0, age_pending = 0, age_stable = 0;
  81594b:	c6 45 fc 00          	movb   $0x0,-0x4(%rbp)
  81594f:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
  815953:	c6 45 fa 00          	movb   $0x0,-0x6(%rbp)
#if ARP_QUEUEING
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  815957:	c6 45 f9 0a          	movb   $0xa,-0x7(%rbp)
  /* its age */
  u8_t age_queue = 0;
  81595b:	c6 45 f8 00          	movb   $0x0,-0x8(%rbp)
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  81595f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815964:	0f 84 87 00 00 00    	je     8159f1 <find_entry+0xc3>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  81596a:	48 b8 70 b8 b4 00 00 	movabs $0xb4b870,%rax
  815971:	00 00 00 
  815974:	0f b6 00             	movzbl (%rax),%eax
  815977:	0f b6 c0             	movzbl %al,%eax
  81597a:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  815981:	00 00 00 
  815984:	48 63 d0             	movslq %eax,%rdx
  815987:	48 89 d0             	mov    %rdx,%rax
  81598a:	48 c1 e0 02          	shl    $0x2,%rax
  81598e:	48 01 d0             	add    %rdx,%rax
  815991:	48 c1 e0 03          	shl    $0x3,%rax
  815995:	48 01 c8             	add    %rcx,%rax
  815998:	48 83 c0 10          	add    $0x10,%rax
  81599c:	8b 40 04             	mov    0x4(%rax),%eax
  81599f:	83 f8 02             	cmp    $0x2,%eax
  8159a2:	75 4d                	jne    8159f1 <find_entry+0xc3>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  8159a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8159a8:	8b 08                	mov    (%rax),%ecx
  8159aa:	48 b8 70 b8 b4 00 00 	movabs $0xb4b870,%rax
  8159b1:	00 00 00 
  8159b4:	0f b6 00             	movzbl (%rax),%eax
  8159b7:	0f b6 c0             	movzbl %al,%eax
  8159ba:	48 be e0 b6 b4 00 00 	movabs $0xb4b6e0,%rsi
  8159c1:	00 00 00 
  8159c4:	48 63 d0             	movslq %eax,%rdx
  8159c7:	48 89 d0             	mov    %rdx,%rax
  8159ca:	48 c1 e0 02          	shl    $0x2,%rax
  8159ce:	48 01 d0             	add    %rdx,%rax
  8159d1:	48 c1 e0 03          	shl    $0x3,%rax
  8159d5:	48 01 f0             	add    %rsi,%rax
  8159d8:	8b 40 08             	mov    0x8(%rax),%eax
  8159db:	39 c1                	cmp    %eax,%ecx
  8159dd:	75 12                	jne    8159f1 <find_entry+0xc3>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  8159df:	48 b8 70 b8 b4 00 00 	movabs $0xb4b870,%rax
  8159e6:	00 00 00 
  8159e9:	0f b6 00             	movzbl (%rax),%eax
  8159ec:	e9 cf 04 00 00       	jmpq   815ec0 <find_entry+0x592>
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  8159f1:	c6 45 fc 00          	movb   $0x0,-0x4(%rbp)
  8159f5:	e9 aa 02 00 00       	jmpq   815ca4 <find_entry+0x376>
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  8159fa:	80 7d fd 0a          	cmpb   $0xa,-0x3(%rbp)
  8159fe:	75 39                	jne    815a39 <find_entry+0x10b>
  815a00:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815a04:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  815a0b:	00 00 00 
  815a0e:	48 63 d0             	movslq %eax,%rdx
  815a11:	48 89 d0             	mov    %rdx,%rax
  815a14:	48 c1 e0 02          	shl    $0x2,%rax
  815a18:	48 01 d0             	add    %rdx,%rax
  815a1b:	48 c1 e0 03          	shl    $0x3,%rax
  815a1f:	48 01 c8             	add    %rcx,%rax
  815a22:	48 83 c0 10          	add    $0x10,%rax
  815a26:	8b 40 04             	mov    0x4(%rax),%eax
  815a29:	85 c0                	test   %eax,%eax
  815a2b:	75 0c                	jne    815a39 <find_entry+0x10b>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  815a2d:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815a31:	88 45 fd             	mov    %al,-0x3(%rbp)
  815a34:	e9 67 02 00 00       	jmpq   815ca0 <find_entry+0x372>
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  815a39:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815a3d:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  815a44:	00 00 00 
  815a47:	48 63 d0             	movslq %eax,%rdx
  815a4a:	48 89 d0             	mov    %rdx,%rax
  815a4d:	48 c1 e0 02          	shl    $0x2,%rax
  815a51:	48 01 d0             	add    %rdx,%rax
  815a54:	48 c1 e0 03          	shl    $0x3,%rax
  815a58:	48 01 c8             	add    %rcx,%rax
  815a5b:	48 83 c0 10          	add    $0x10,%rax
  815a5f:	8b 40 04             	mov    0x4(%rax),%eax
  815a62:	83 f8 01             	cmp    $0x1,%eax
  815a65:	0f 85 51 01 00 00    	jne    815bbc <find_entry+0x28e>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  815a6b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815a70:	74 48                	je     815aba <find_entry+0x18c>
  815a72:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815a76:	8b 08                	mov    (%rax),%ecx
  815a78:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815a7c:	48 be e0 b6 b4 00 00 	movabs $0xb4b6e0,%rsi
  815a83:	00 00 00 
  815a86:	48 63 d0             	movslq %eax,%rdx
  815a89:	48 89 d0             	mov    %rdx,%rax
  815a8c:	48 c1 e0 02          	shl    $0x2,%rax
  815a90:	48 01 d0             	add    %rdx,%rax
  815a93:	48 c1 e0 03          	shl    $0x3,%rax
  815a97:	48 01 f0             	add    %rsi,%rax
  815a9a:	8b 40 08             	mov    0x8(%rax),%eax
  815a9d:	39 c1                	cmp    %eax,%ecx
  815a9f:	75 19                	jne    815aba <find_entry+0x18c>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  815aa1:	48 b8 70 b8 b4 00 00 	movabs $0xb4b870,%rax
  815aa8:	00 00 00 
  815aab:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  815aaf:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  815ab1:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815ab5:	e9 06 04 00 00       	jmpq   815ec0 <find_entry+0x592>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  815aba:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815abe:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  815ac5:	00 00 00 
  815ac8:	48 63 d0             	movslq %eax,%rdx
  815acb:	48 89 d0             	mov    %rdx,%rax
  815ace:	48 c1 e0 02          	shl    $0x2,%rax
  815ad2:	48 01 d0             	add    %rdx,%rax
  815ad5:	48 c1 e0 03          	shl    $0x3,%rax
  815ad9:	48 01 c8             	add    %rcx,%rax
  815adc:	48 8b 00             	mov    (%rax),%rax
  815adf:	48 85 c0             	test   %rax,%rax
  815ae2:	74 6c                	je     815b50 <find_entry+0x222>
        if (arp_table[i].ctime >= age_queue) {
  815ae4:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815ae8:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  815aef:	00 00 00 
  815af2:	48 63 d0             	movslq %eax,%rdx
  815af5:	48 89 d0             	mov    %rdx,%rax
  815af8:	48 c1 e0 02          	shl    $0x2,%rax
  815afc:	48 01 d0             	add    %rdx,%rax
  815aff:	48 c1 e0 03          	shl    $0x3,%rax
  815b03:	48 01 c8             	add    %rcx,%rax
  815b06:	48 83 c0 10          	add    $0x10,%rax
  815b0a:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815b0e:	3a 45 f8             	cmp    -0x8(%rbp),%al
  815b11:	0f 82 89 01 00 00    	jb     815ca0 <find_entry+0x372>
          old_queue = i;
  815b17:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815b1b:	88 45 f9             	mov    %al,-0x7(%rbp)
          age_queue = arp_table[i].ctime;
  815b1e:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815b22:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  815b29:	00 00 00 
  815b2c:	48 63 d0             	movslq %eax,%rdx
  815b2f:	48 89 d0             	mov    %rdx,%rax
  815b32:	48 c1 e0 02          	shl    $0x2,%rax
  815b36:	48 01 d0             	add    %rdx,%rax
  815b39:	48 c1 e0 03          	shl    $0x3,%rax
  815b3d:	48 01 c8             	add    %rcx,%rax
  815b40:	48 83 c0 10          	add    $0x10,%rax
  815b44:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815b48:	88 45 f8             	mov    %al,-0x8(%rbp)
  815b4b:	e9 50 01 00 00       	jmpq   815ca0 <find_entry+0x372>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  815b50:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815b54:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  815b5b:	00 00 00 
  815b5e:	48 63 d0             	movslq %eax,%rdx
  815b61:	48 89 d0             	mov    %rdx,%rax
  815b64:	48 c1 e0 02          	shl    $0x2,%rax
  815b68:	48 01 d0             	add    %rdx,%rax
  815b6b:	48 c1 e0 03          	shl    $0x3,%rax
  815b6f:	48 01 c8             	add    %rcx,%rax
  815b72:	48 83 c0 10          	add    $0x10,%rax
  815b76:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815b7a:	3a 45 fb             	cmp    -0x5(%rbp),%al
  815b7d:	0f 82 1d 01 00 00    	jb     815ca0 <find_entry+0x372>
          old_pending = i;
  815b83:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815b87:	88 45 ff             	mov    %al,-0x1(%rbp)
          age_pending = arp_table[i].ctime;
  815b8a:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815b8e:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  815b95:	00 00 00 
  815b98:	48 63 d0             	movslq %eax,%rdx
  815b9b:	48 89 d0             	mov    %rdx,%rax
  815b9e:	48 c1 e0 02          	shl    $0x2,%rax
  815ba2:	48 01 d0             	add    %rdx,%rax
  815ba5:	48 c1 e0 03          	shl    $0x3,%rax
  815ba9:	48 01 c8             	add    %rcx,%rax
  815bac:	48 83 c0 10          	add    $0x10,%rax
  815bb0:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815bb4:	88 45 fb             	mov    %al,-0x5(%rbp)
  815bb7:	e9 e4 00 00 00       	jmpq   815ca0 <find_entry+0x372>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  815bbc:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815bc0:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  815bc7:	00 00 00 
  815bca:	48 63 d0             	movslq %eax,%rdx
  815bcd:	48 89 d0             	mov    %rdx,%rax
  815bd0:	48 c1 e0 02          	shl    $0x2,%rax
  815bd4:	48 01 d0             	add    %rdx,%rax
  815bd7:	48 c1 e0 03          	shl    $0x3,%rax
  815bdb:	48 01 c8             	add    %rcx,%rax
  815bde:	48 83 c0 10          	add    $0x10,%rax
  815be2:	8b 40 04             	mov    0x4(%rax),%eax
  815be5:	83 f8 02             	cmp    $0x2,%eax
  815be8:	0f 85 b2 00 00 00    	jne    815ca0 <find_entry+0x372>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  815bee:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815bf3:	74 48                	je     815c3d <find_entry+0x30f>
  815bf5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815bf9:	8b 08                	mov    (%rax),%ecx
  815bfb:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815bff:	48 be e0 b6 b4 00 00 	movabs $0xb4b6e0,%rsi
  815c06:	00 00 00 
  815c09:	48 63 d0             	movslq %eax,%rdx
  815c0c:	48 89 d0             	mov    %rdx,%rax
  815c0f:	48 c1 e0 02          	shl    $0x2,%rax
  815c13:	48 01 d0             	add    %rdx,%rax
  815c16:	48 c1 e0 03          	shl    $0x3,%rax
  815c1a:	48 01 f0             	add    %rsi,%rax
  815c1d:	8b 40 08             	mov    0x8(%rax),%eax
  815c20:	39 c1                	cmp    %eax,%ecx
  815c22:	75 19                	jne    815c3d <find_entry+0x30f>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  815c24:	48 b8 70 b8 b4 00 00 	movabs $0xb4b870,%rax
  815c2b:	00 00 00 
  815c2e:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  815c32:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  815c34:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815c38:	e9 83 02 00 00       	jmpq   815ec0 <find_entry+0x592>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  815c3d:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815c41:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  815c48:	00 00 00 
  815c4b:	48 63 d0             	movslq %eax,%rdx
  815c4e:	48 89 d0             	mov    %rdx,%rax
  815c51:	48 c1 e0 02          	shl    $0x2,%rax
  815c55:	48 01 d0             	add    %rdx,%rax
  815c58:	48 c1 e0 03          	shl    $0x3,%rax
  815c5c:	48 01 c8             	add    %rcx,%rax
  815c5f:	48 83 c0 10          	add    $0x10,%rax
  815c63:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815c67:	3a 45 fa             	cmp    -0x6(%rbp),%al
  815c6a:	72 34                	jb     815ca0 <find_entry+0x372>
        old_stable = i;
  815c6c:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815c70:	88 45 fe             	mov    %al,-0x2(%rbp)
        age_stable = arp_table[i].ctime;
  815c73:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815c77:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  815c7e:	00 00 00 
  815c81:	48 63 d0             	movslq %eax,%rdx
  815c84:	48 89 d0             	mov    %rdx,%rax
  815c87:	48 c1 e0 02          	shl    $0x2,%rax
  815c8b:	48 01 d0             	add    %rdx,%rax
  815c8e:	48 c1 e0 03          	shl    $0x3,%rax
  815c92:	48 01 c8             	add    %rcx,%rax
  815c95:	48 83 c0 10          	add    $0x10,%rax
  815c99:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  815c9d:	88 45 fa             	mov    %al,-0x6(%rbp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  815ca0:	80 45 fc 01          	addb   $0x1,-0x4(%rbp)
  815ca4:	80 7d fc 09          	cmpb   $0x9,-0x4(%rbp)
  815ca8:	0f 86 4c fd ff ff    	jbe    8159fa <find_entry+0xcc>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  815cae:	80 7d fd 0a          	cmpb   $0xa,-0x3(%rbp)
  815cb2:	75 0b                	jne    815cbf <find_entry+0x391>
  815cb4:	0f b6 45 e4          	movzbl -0x1c(%rbp),%eax
  815cb8:	83 e0 01             	and    $0x1,%eax
  815cbb:	85 c0                	test   %eax,%eax
  815cbd:	74 0b                	je     815cca <find_entry+0x39c>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  815cbf:	0f b6 45 e4          	movzbl -0x1c(%rbp),%eax
  815cc3:	83 e0 02             	and    $0x2,%eax
  815cc6:	85 c0                	test   %eax,%eax
  815cc8:	74 0a                	je     815cd4 <find_entry+0x3a6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  815cca:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  815ccf:	e9 ec 01 00 00       	jmpq   815ec0 <find_entry+0x592>
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  815cd4:	80 7d fd 09          	cmpb   $0x9,-0x3(%rbp)
  815cd8:	7f 0c                	jg     815ce6 <find_entry+0x3b8>
    i = empty;
  815cda:	0f b6 45 fd          	movzbl -0x3(%rbp),%eax
  815cde:	88 45 fc             	mov    %al,-0x4(%rbp)
  815ce1:	e9 ea 00 00 00       	jmpq   815dd0 <find_entry+0x4a2>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  815ce6:	80 7d fe 09          	cmpb   $0x9,-0x2(%rbp)
  815cea:	7f 5f                	jg     815d4b <find_entry+0x41d>
    /* recycle oldest stable*/
    i = old_stable;
  815cec:	0f b6 45 fe          	movzbl -0x2(%rbp),%eax
  815cf0:	88 45 fc             	mov    %al,-0x4(%rbp)
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  815cf3:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815cf7:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  815cfe:	00 00 00 
  815d01:	48 63 d0             	movslq %eax,%rdx
  815d04:	48 89 d0             	mov    %rdx,%rax
  815d07:	48 c1 e0 02          	shl    $0x2,%rax
  815d0b:	48 01 d0             	add    %rdx,%rax
  815d0e:	48 c1 e0 03          	shl    $0x3,%rax
  815d12:	48 01 c8             	add    %rcx,%rax
  815d15:	48 8b 00             	mov    (%rax),%rax
  815d18:	48 85 c0             	test   %rax,%rax
  815d1b:	0f 84 af 00 00 00    	je     815dd0 <find_entry+0x4a2>
  815d21:	48 ba 50 28 82 00 00 	movabs $0x822850,%rdx
  815d28:	00 00 00 
  815d2b:	be 75 01 00 00       	mov    $0x175,%esi
  815d30:	48 bf 1e 28 82 00 00 	movabs $0x82281e,%rdi
  815d37:	00 00 00 
  815d3a:	b8 00 00 00 00       	mov    $0x0,%eax
  815d3f:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  815d46:	00 00 00 
  815d49:	ff d1                	callq  *%rcx
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  815d4b:	80 7d ff 09          	cmpb   $0x9,-0x1(%rbp)
  815d4f:	7f 09                	jg     815d5a <find_entry+0x42c>
    /* recycle oldest pending */
    i = old_pending;
  815d51:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815d55:	88 45 fc             	mov    %al,-0x4(%rbp)
  815d58:	eb 76                	jmp    815dd0 <find_entry+0x4a2>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  815d5a:	80 7d f9 09          	cmpb   $0x9,-0x7(%rbp)
  815d5e:	7f 66                	jg     815dc6 <find_entry+0x498>
    /* recycle oldest pending */
    i = old_queue;
  815d60:	0f b6 45 f9          	movzbl -0x7(%rbp),%eax
  815d64:	88 45 fc             	mov    %al,-0x4(%rbp)
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  815d67:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815d6b:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  815d72:	00 00 00 
  815d75:	48 63 d0             	movslq %eax,%rdx
  815d78:	48 89 d0             	mov    %rdx,%rax
  815d7b:	48 c1 e0 02          	shl    $0x2,%rax
  815d7f:	48 01 d0             	add    %rdx,%rax
  815d82:	48 c1 e0 03          	shl    $0x3,%rax
  815d86:	48 01 c8             	add    %rcx,%rax
  815d89:	48 8b 00             	mov    (%rax),%rax
  815d8c:	48 89 c7             	mov    %rax,%rdi
  815d8f:	48 b8 38 56 81 00 00 	movabs $0x815638,%rax
  815d96:	00 00 00 
  815d99:	ff d0                	callq  *%rax
    arp_table[i].q = NULL;
  815d9b:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815d9f:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  815da6:	00 00 00 
  815da9:	48 63 d0             	movslq %eax,%rdx
  815dac:	48 89 d0             	mov    %rdx,%rax
  815daf:	48 c1 e0 02          	shl    $0x2,%rax
  815db3:	48 01 d0             	add    %rdx,%rax
  815db6:	48 c1 e0 03          	shl    $0x3,%rax
  815dba:	48 01 c8             	add    %rcx,%rax
  815dbd:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  815dc4:	eb 0a                	jmp    815dd0 <find_entry+0x4a2>
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
  815dc6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  815dcb:	e9 f0 00 00 00       	jmpq   815ec0 <find_entry+0x592>
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  815dd0:	80 7d fc 09          	cmpb   $0x9,-0x4(%rbp)
  815dd4:	76 2a                	jbe    815e00 <find_entry+0x4d2>
  815dd6:	48 ba 67 28 82 00 00 	movabs $0x822867,%rdx
  815ddd:	00 00 00 
  815de0:	be 8b 01 00 00       	mov    $0x18b,%esi
  815de5:	48 bf 1e 28 82 00 00 	movabs $0x82281e,%rdi
  815dec:	00 00 00 
  815def:	b8 00 00 00 00       	mov    $0x0,%eax
  815df4:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  815dfb:	00 00 00 
  815dfe:	ff d1                	callq  *%rcx

  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  815e00:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815e04:	48 63 d0             	movslq %eax,%rdx
  815e07:	48 89 d0             	mov    %rdx,%rax
  815e0a:	48 c1 e0 02          	shl    $0x2,%rax
  815e0e:	48 01 d0             	add    %rdx,%rax
  815e11:	48 c1 e0 03          	shl    $0x3,%rax
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  815e15:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815e19:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  815e20:	00 00 00 
  815e23:	48 63 d0             	movslq %eax,%rdx
  815e26:	48 89 d0             	mov    %rdx,%rax
  815e29:	48 c1 e0 02          	shl    $0x2,%rax
  815e2d:	48 01 d0             	add    %rdx,%rax
  815e30:	48 c1 e0 03          	shl    $0x3,%rax
  815e34:	48 01 c8             	add    %rcx,%rax
  815e37:	48 83 c0 10          	add    $0x10,%rax
  815e3b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)

  /* IP address given? */
  if (ipaddr != NULL) {
  815e42:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815e47:	74 39                	je     815e82 <find_entry+0x554>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  815e49:	0f b6 4d fc          	movzbl -0x4(%rbp),%ecx
  815e4d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  815e52:	74 08                	je     815e5c <find_entry+0x52e>
  815e54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815e58:	8b 10                	mov    (%rax),%edx
  815e5a:	eb 05                	jmp    815e61 <find_entry+0x533>
  815e5c:	ba 00 00 00 00       	mov    $0x0,%edx
  815e61:	48 be e0 b6 b4 00 00 	movabs $0xb4b6e0,%rsi
  815e68:	00 00 00 
  815e6b:	48 63 c9             	movslq %ecx,%rcx
  815e6e:	48 89 c8             	mov    %rcx,%rax
  815e71:	48 c1 e0 02          	shl    $0x2,%rax
  815e75:	48 01 c8             	add    %rcx,%rax
  815e78:	48 c1 e0 03          	shl    $0x3,%rax
  815e7c:	48 01 f0             	add    %rsi,%rax
  815e7f:	89 50 08             	mov    %edx,0x8(%rax)
  }
  arp_table[i].ctime = 0;
  815e82:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
  815e86:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  815e8d:	00 00 00 
  815e90:	48 63 d0             	movslq %eax,%rdx
  815e93:	48 89 d0             	mov    %rdx,%rax
  815e96:	48 c1 e0 02          	shl    $0x2,%rax
  815e9a:	48 01 d0             	add    %rdx,%rax
  815e9d:	48 c1 e0 03          	shl    $0x3,%rax
  815ea1:	48 01 c8             	add    %rcx,%rax
  815ea4:	48 83 c0 10          	add    $0x10,%rax
  815ea8:	c6 40 08 00          	movb   $0x0,0x8(%rax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  815eac:	48 b8 70 b8 b4 00 00 	movabs $0xb4b870,%rax
  815eb3:	00 00 00 
  815eb6:	0f b6 55 fc          	movzbl -0x4(%rbp),%edx
  815eba:	88 10                	mov    %dl,(%rax)
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  815ebc:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
}
  815ec0:	c9                   	leaveq 
  815ec1:	c3                   	retq   

0000000000815ec2 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  815ec2:	55                   	push   %rbp
  815ec3:	48 89 e5             	mov    %rsp,%rbp
  815ec6:	48 83 ec 30          	sub    $0x30,%rsp
  815eca:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  815ece:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  815ed2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  815ed6:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  struct eth_hdr *ethhdr = p->payload;
  815eda:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  815ede:	48 8b 40 08          	mov    0x8(%rax),%rax
  815ee2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  815ee6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815eea:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  815eee:	3c 06                	cmp    $0x6,%al
  815ef0:	74 2a                	je     815f1c <etharp_send_ip+0x5a>
  815ef2:	48 ba 80 28 82 00 00 	movabs $0x822880,%rdx
  815ef9:	00 00 00 
  815efc:	be b3 01 00 00       	mov    $0x1b3,%esi
  815f01:	48 bf 1e 28 82 00 00 	movabs $0x82281e,%rdi
  815f08:	00 00 00 
  815f0b:	b8 00 00 00 00       	mov    $0x0,%eax
  815f10:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  815f17:	00 00 00 
  815f1a:	ff d1                	callq  *%rcx
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  815f1c:	c6 45 ff 06          	movb   $0x6,-0x1(%rbp)
  while(k > 0) {
  815f20:	eb 3d                	jmp    815f5f <etharp_send_ip+0x9d>
    k--;
  815f22:	80 6d ff 01          	subb   $0x1,-0x1(%rbp)
    ethhdr->dest.addr[k] = dst->addr[k];
  815f26:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  815f2a:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815f2e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  815f32:	48 98                	cltq   
  815f34:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  815f38:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  815f3c:	48 63 c6             	movslq %esi,%rax
  815f3f:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  815f42:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  815f46:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  815f4a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  815f4e:	48 98                	cltq   
  815f50:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  815f54:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  815f58:	48 63 c6             	movslq %esi,%rax
  815f5b:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  815f5f:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  815f63:	75 bd                	jne    815f22 <etharp_send_ip+0x60>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  815f65:	bf 00 08 00 00       	mov    $0x800,%edi
  815f6a:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  815f71:	00 00 00 
  815f74:	ff d0                	callq  *%rax
  815f76:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  815f7a:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  815f7e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815f82:	48 8b 48 28          	mov    0x28(%rax),%rcx
  815f86:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  815f8a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  815f8e:	48 89 d6             	mov    %rdx,%rsi
  815f91:	48 89 c7             	mov    %rax,%rdi
  815f94:	ff d1                	callq  *%rcx
}
  815f96:	c9                   	leaveq 
  815f97:	c3                   	retq   

0000000000815f98 <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  815f98:	55                   	push   %rbp
  815f99:	48 89 e5             	mov    %rsp,%rbp
  815f9c:	53                   	push   %rbx
  815f9d:	48 83 ec 48          	sub    $0x48,%rsp
  815fa1:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  815fa5:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  815fa9:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  815fad:	89 c8                	mov    %ecx,%eax
  815faf:	88 45 b4             	mov    %al,-0x4c(%rbp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  815fb2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  815fb6:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  815fba:	3c 06                	cmp    $0x6,%al
  815fbc:	74 2a                	je     815fe8 <update_arp_entry+0x50>
  815fbe:	48 ba c8 28 82 00 00 	movabs $0x8228c8,%rdx
  815fc5:	00 00 00 
  815fc8:	be d9 01 00 00       	mov    $0x1d9,%esi
  815fcd:	48 bf 1e 28 82 00 00 	movabs $0x82281e,%rdi
  815fd4:	00 00 00 
  815fd7:	b8 00 00 00 00       	mov    $0x0,%eax
  815fdc:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  815fe3:	00 00 00 
  815fe6:	ff d1                	callq  *%rcx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  815fe8:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  815fed:	74 56                	je     816045 <update_arp_entry+0xad>
  815fef:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  815ff3:	8b 00                	mov    (%rax),%eax
  815ff5:	85 c0                	test   %eax,%eax
  815ff7:	74 4c                	je     816045 <update_arp_entry+0xad>
      ip_addr_isbroadcast(ipaddr, netif) ||
  815ff9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  815ffd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  816001:	48 89 d6             	mov    %rdx,%rsi
  816004:	48 89 c7             	mov    %rax,%rdi
  816007:	48 b8 80 09 81 00 00 	movabs $0x810980,%rax
  81600e:	00 00 00 
  816011:	ff d0                	callq  *%rax
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  816013:	84 c0                	test   %al,%al
  816015:	75 2e                	jne    816045 <update_arp_entry+0xad>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  816017:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81601b:	8b 18                	mov    (%rax),%ebx
  81601d:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  816022:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  816029:	00 00 00 
  81602c:	ff d0                	callq  *%rax
  81602e:	21 c3                	and    %eax,%ebx
  816030:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  816035:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81603c:	00 00 00 
  81603f:	ff d0                	callq  *%rax
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
  816041:	39 c3                	cmp    %eax,%ebx
  816043:	75 0a                	jne    81604f <update_arp_entry+0xb7>
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  816045:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  81604a:	e9 ea 01 00 00       	jmpq   816239 <update_arp_entry+0x2a1>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  81604f:	0f b6 55 b4          	movzbl -0x4c(%rbp),%edx
  816053:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  816057:	89 d6                	mov    %edx,%esi
  816059:	48 89 c7             	mov    %rax,%rdi
  81605c:	48 b8 2e 59 81 00 00 	movabs $0x81592e,%rax
  816063:	00 00 00 
  816066:	ff d0                	callq  *%rax
  816068:	88 45 ee             	mov    %al,-0x12(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  81606b:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  81606f:	79 09                	jns    81607a <update_arp_entry+0xe2>
    return (err_t)i;
  816071:	0f b6 45 ee          	movzbl -0x12(%rbp),%eax
  816075:	e9 bf 01 00 00       	jmpq   816239 <update_arp_entry+0x2a1>
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  81607a:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  81607e:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  816085:	00 00 00 
  816088:	48 63 d0             	movslq %eax,%rdx
  81608b:	48 89 d0             	mov    %rdx,%rax
  81608e:	48 c1 e0 02          	shl    $0x2,%rax
  816092:	48 01 d0             	add    %rdx,%rax
  816095:	48 c1 e0 03          	shl    $0x3,%rax
  816099:	48 01 c8             	add    %rcx,%rax
  81609c:	48 83 c0 10          	add    $0x10,%rax
  8160a0:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%rax)
  /* record network interface */
  arp_table[i].netif = netif;
  8160a7:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  8160ab:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  8160b2:	00 00 00 
  8160b5:	48 63 d0             	movslq %eax,%rdx
  8160b8:	48 89 d0             	mov    %rdx,%rax
  8160bb:	48 c1 e0 02          	shl    $0x2,%rax
  8160bf:	48 01 d0             	add    %rdx,%rax
  8160c2:	48 c1 e0 03          	shl    $0x3,%rax
  8160c6:	48 01 c8             	add    %rcx,%rax
  8160c9:	48 8d 50 20          	lea    0x20(%rax),%rdx
  8160cd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8160d1:	48 89 02             	mov    %rax,(%rdx)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  8160d4:	c6 45 ef 06          	movb   $0x6,-0x11(%rbp)
  while (k > 0) {
  8160d8:	eb 42                	jmp    81611c <update_arp_entry+0x184>
    k--;
  8160da:	80 6d ef 01          	subb   $0x1,-0x11(%rbp)
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  8160de:	44 0f be 45 ee       	movsbl -0x12(%rbp),%r8d
  8160e3:	0f b6 7d ef          	movzbl -0x11(%rbp),%edi
  8160e7:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8160eb:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8160ef:	48 98                	cltq   
  8160f1:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  8160f5:	48 be e0 b6 b4 00 00 	movabs $0xb4b6e0,%rsi
  8160fc:	00 00 00 
  8160ff:	48 63 ff             	movslq %edi,%rdi
  816102:	49 63 d0             	movslq %r8d,%rdx
  816105:	48 89 d0             	mov    %rdx,%rax
  816108:	48 c1 e0 02          	shl    $0x2,%rax
  81610c:	48 01 d0             	add    %rdx,%rax
  81610f:	48 c1 e0 03          	shl    $0x3,%rax
  816113:	48 01 f8             	add    %rdi,%rax
  816116:	48 01 f0             	add    %rsi,%rax
  816119:	88 48 0c             	mov    %cl,0xc(%rax)
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
  81611c:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  816120:	75 b8                	jne    8160da <update_arp_entry+0x142>
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  816122:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  816126:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  81612d:	00 00 00 
  816130:	48 63 d0             	movslq %eax,%rdx
  816133:	48 89 d0             	mov    %rdx,%rax
  816136:	48 c1 e0 02          	shl    $0x2,%rax
  81613a:	48 01 d0             	add    %rdx,%rax
  81613d:	48 c1 e0 03          	shl    $0x3,%rax
  816141:	48 01 c8             	add    %rcx,%rax
  816144:	48 83 c0 10          	add    $0x10,%rax
  816148:	c6 40 08 00          	movb   $0x0,0x8(%rax)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  81614c:	e9 b5 00 00 00       	jmpq   816206 <update_arp_entry+0x26e>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
  816151:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  816155:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  81615c:	00 00 00 
  81615f:	48 63 d0             	movslq %eax,%rdx
  816162:	48 89 d0             	mov    %rdx,%rax
  816165:	48 c1 e0 02          	shl    $0x2,%rax
  816169:	48 01 d0             	add    %rdx,%rax
  81616c:	48 c1 e0 03          	shl    $0x3,%rax
  816170:	48 01 c8             	add    %rcx,%rax
  816173:	48 8b 00             	mov    (%rax),%rax
  816176:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  81617a:	0f be 55 ee          	movsbl -0x12(%rbp),%edx
  81617e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816182:	48 8b 08             	mov    (%rax),%rcx
  816185:	48 be e0 b6 b4 00 00 	movabs $0xb4b6e0,%rsi
  81618c:	00 00 00 
  81618f:	48 63 d2             	movslq %edx,%rdx
  816192:	48 89 d0             	mov    %rdx,%rax
  816195:	48 c1 e0 02          	shl    $0x2,%rax
  816199:	48 01 d0             	add    %rdx,%rax
  81619c:	48 c1 e0 03          	shl    $0x3,%rax
  8161a0:	48 01 f0             	add    %rsi,%rax
  8161a3:	48 89 08             	mov    %rcx,(%rax)
    /* get the packet pointer */
    p = q->p;
  8161a6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8161aa:	48 8b 40 08          	mov    0x8(%rax),%rax
  8161ae:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  8161b2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8161b6:	48 89 c6             	mov    %rax,%rsi
  8161b9:	bf 0a 00 00 00       	mov    $0xa,%edi
  8161be:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  8161c5:	00 00 00 
  8161c8:	ff d0                	callq  *%rax
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  8161ca:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8161ce:	48 8d 78 41          	lea    0x41(%rax),%rdi
  8161d2:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8161d6:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  8161da:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8161de:	48 89 d1             	mov    %rdx,%rcx
  8161e1:	48 89 fa             	mov    %rdi,%rdx
  8161e4:	48 89 c7             	mov    %rax,%rdi
  8161e7:	48 b8 c2 5e 81 00 00 	movabs $0x815ec2,%rax
  8161ee:	00 00 00 
  8161f1:	ff d0                	callq  *%rax
    /* free the queued IP packet */
    pbuf_free(p);
  8161f3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8161f7:	48 89 c7             	mov    %rax,%rdi
  8161fa:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  816201:	00 00 00 
  816204:	ff d0                	callq  *%rax
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  816206:	0f be 45 ee          	movsbl -0x12(%rbp),%eax
  81620a:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  816211:	00 00 00 
  816214:	48 63 d0             	movslq %eax,%rdx
  816217:	48 89 d0             	mov    %rdx,%rax
  81621a:	48 c1 e0 02          	shl    $0x2,%rax
  81621e:	48 01 d0             	add    %rdx,%rax
  816221:	48 c1 e0 03          	shl    $0x3,%rax
  816225:	48 01 c8             	add    %rcx,%rax
  816228:	48 8b 00             	mov    (%rax),%rax
  81622b:	48 85 c0             	test   %rax,%rax
  81622e:	0f 85 1d ff ff ff    	jne    816151 <update_arp_entry+0x1b9>
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
  816234:	b8 00 00 00 00       	mov    $0x0,%eax
}
  816239:	48 83 c4 48          	add    $0x48,%rsp
  81623d:	5b                   	pop    %rbx
  81623e:	5d                   	pop    %rbp
  81623f:	c3                   	retq   

0000000000816240 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  816240:	55                   	push   %rbp
  816241:	48 89 e5             	mov    %rsp,%rbp
  816244:	48 83 ec 30          	sub    $0x30,%rsp
  816248:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81624c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  816250:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  816254:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  816258:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81625c:	be 02 00 00 00       	mov    $0x2,%esi
  816261:	48 89 c7             	mov    %rax,%rdi
  816264:	48 b8 2e 59 81 00 00 	movabs $0x81592e,%rax
  81626b:	00 00 00 
  81626e:	ff d0                	callq  *%rax
  816270:	88 45 ff             	mov    %al,-0x1(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  816273:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  816277:	0f 88 8e 00 00 00    	js     81630b <etharp_find_addr+0xcb>
  81627d:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  816281:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  816288:	00 00 00 
  81628b:	48 63 d0             	movslq %eax,%rdx
  81628e:	48 89 d0             	mov    %rdx,%rax
  816291:	48 c1 e0 02          	shl    $0x2,%rax
  816295:	48 01 d0             	add    %rdx,%rax
  816298:	48 c1 e0 03          	shl    $0x3,%rax
  81629c:	48 01 c8             	add    %rcx,%rax
  81629f:	48 83 c0 10          	add    $0x10,%rax
  8162a3:	8b 40 04             	mov    0x4(%rax),%eax
  8162a6:	83 f8 02             	cmp    $0x2,%eax
  8162a9:	75 60                	jne    81630b <etharp_find_addr+0xcb>
      *eth_ret = &arp_table[i].ethaddr;
  8162ab:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  8162af:	48 63 d0             	movslq %eax,%rdx
  8162b2:	48 89 d0             	mov    %rdx,%rax
  8162b5:	48 c1 e0 02          	shl    $0x2,%rax
  8162b9:	48 01 d0             	add    %rdx,%rax
  8162bc:	48 c1 e0 03          	shl    $0x3,%rax
  8162c0:	48 ba e0 b6 b4 00 00 	movabs $0xb4b6e0,%rdx
  8162c7:	00 00 00 
  8162ca:	48 01 d0             	add    %rdx,%rax
  8162cd:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8162d1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8162d5:	48 89 10             	mov    %rdx,(%rax)
      *ip_ret = &arp_table[i].ipaddr;
  8162d8:	0f be 45 ff          	movsbl -0x1(%rbp),%eax
  8162dc:	48 63 d0             	movslq %eax,%rdx
  8162df:	48 89 d0             	mov    %rdx,%rax
  8162e2:	48 c1 e0 02          	shl    $0x2,%rax
  8162e6:	48 01 d0             	add    %rdx,%rax
  8162e9:	48 c1 e0 03          	shl    $0x3,%rax
  8162ed:	48 ba e0 b6 b4 00 00 	movabs $0xb4b6e0,%rdx
  8162f4:	00 00 00 
  8162f7:	48 01 d0             	add    %rdx,%rax
  8162fa:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8162fe:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  816302:	48 89 10             	mov    %rdx,(%rax)
      return i;
  816305:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816309:	eb 05                	jmp    816310 <etharp_find_addr+0xd0>
  }
  return -1;
  81630b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  816310:	c9                   	leaveq 
  816311:	c3                   	retq   

0000000000816312 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  816312:	55                   	push   %rbp
  816313:	48 89 e5             	mov    %rsp,%rbp
  816316:	48 83 ec 20          	sub    $0x20,%rsp
  81631a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81631e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  816322:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  816327:	75 2a                	jne    816353 <etharp_ip_input+0x41>
  816329:	48 ba ef 28 82 00 00 	movabs $0x8228ef,%rdx
  816330:	00 00 00 
  816333:	be 48 02 00 00       	mov    $0x248,%esi
  816338:	48 bf 1e 28 82 00 00 	movabs $0x82281e,%rdi
  81633f:	00 00 00 
  816342:	b8 00 00 00 00       	mov    $0x0,%eax
  816347:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81634e:	00 00 00 
  816351:	ff d1                	callq  *%rcx
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  816353:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816357:	48 8b 40 08          	mov    0x8(%rax),%rax
  81635b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  81635f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816363:	8b 50 1c             	mov    0x1c(%rax),%edx
  816366:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81636a:	8b 40 08             	mov    0x8(%rax),%eax
  81636d:	31 c2                	xor    %eax,%edx
  81636f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816373:	8b 40 0c             	mov    0xc(%rax),%eax
  816376:	21 d0                	and    %edx,%eax
  816378:	85 c0                	test   %eax,%eax
  81637a:	75 2a                	jne    8163a6 <etharp_ip_input+0x94>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  81637c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816380:	48 8d 50 06          	lea    0x6(%rax),%rdx
  816384:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816388:	48 8d 70 1c          	lea    0x1c(%rax),%rsi
  81638c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816390:	b9 00 00 00 00       	mov    $0x0,%ecx
  816395:	48 89 c7             	mov    %rax,%rdi
  816398:	48 b8 98 5f 81 00 00 	movabs $0x815f98,%rax
  81639f:	00 00 00 
  8163a2:	ff d0                	callq  *%rax
  8163a4:	eb 01                	jmp    8163a7 <etharp_ip_input+0x95>
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
    /* do nothing */
    return;
  8163a6:	90                   	nop
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
}
  8163a7:	c9                   	leaveq 
  8163a8:	c3                   	retq   

00000000008163a9 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  8163a9:	55                   	push   %rbp
  8163aa:	48 89 e5             	mov    %rsp,%rbp
  8163ad:	53                   	push   %rbx
  8163ae:	48 83 ec 58          	sub    $0x58,%rsp
  8163b2:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8163b6:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8163ba:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  8163be:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8163c3:	75 2a                	jne    8163ef <etharp_arp_input+0x46>
  8163c5:	48 ba ef 28 82 00 00 	movabs $0x8228ef,%rdx
  8163cc:	00 00 00 
  8163cf:	be 75 02 00 00       	mov    $0x275,%esi
  8163d4:	48 bf 1e 28 82 00 00 	movabs $0x82281e,%rdi
  8163db:	00 00 00 
  8163de:	b8 00 00 00 00       	mov    $0x0,%eax
  8163e3:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8163ea:	00 00 00 
  8163ed:	ff d1                	callq  *%rcx
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  8163ef:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8163f3:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8163f7:	66 83 f8 29          	cmp    $0x29,%ax
  8163fb:	77 18                	ja     816415 <etharp_arp_input+0x6c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  8163fd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816401:	48 89 c7             	mov    %rax,%rdi
  816404:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81640b:	00 00 00 
  81640e:	ff d0                	callq  *%rax
    return;
  816410:	e9 cd 02 00 00       	jmpq   8166e2 <etharp_arp_input+0x339>
  }

  hdr = p->payload;
  816415:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816419:	48 8b 40 08          	mov    0x8(%rax),%rax
  81641d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  816421:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816425:	0f b7 58 0e          	movzwl 0xe(%rax),%ebx
  816429:	bf 01 00 00 00       	mov    $0x1,%edi
  81642e:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  816435:	00 00 00 
  816438:	ff d0                	callq  *%rax
  81643a:	66 39 c3             	cmp    %ax,%bx
  81643d:	75 5a                	jne    816499 <etharp_arp_input+0xf0>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  81643f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816443:	0f b7 58 12          	movzwl 0x12(%rax),%ebx
  816447:	bf 04 06 00 00       	mov    $0x604,%edi
  81644c:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  816453:	00 00 00 
  816456:	ff d0                	callq  *%rax
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  816458:	66 39 c3             	cmp    %ax,%bx
  81645b:	75 3c                	jne    816499 <etharp_arp_input+0xf0>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  81645d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816461:	0f b7 58 10          	movzwl 0x10(%rax),%ebx
  816465:	bf 00 08 00 00       	mov    $0x800,%edi
  81646a:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  816471:	00 00 00 
  816474:	ff d0                	callq  *%rax

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  816476:	66 39 c3             	cmp    %ax,%bx
  816479:	75 1e                	jne    816499 <etharp_arp_input+0xf0>
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  81647b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81647f:	0f b7 58 0c          	movzwl 0xc(%rax),%ebx
  816483:	bf 06 08 00 00       	mov    $0x806,%edi
  816488:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  81648f:	00 00 00 
  816492:	ff d0                	callq  *%rax
  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  816494:	66 39 c3             	cmp    %ax,%bx
  816497:	74 18                	je     8164b1 <etharp_arp_input+0x108>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  816499:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81649d:	48 89 c7             	mov    %rax,%rdi
  8164a0:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  8164a7:	00 00 00 
  8164aa:	ff d0                	callq  *%rax
    return;
  8164ac:	e9 31 02 00 00       	jmpq   8166e2 <etharp_arp_input+0x339>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  8164b1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8164b5:	48 8d 48 1c          	lea    0x1c(%rax),%rcx
  8164b9:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8164bd:	ba 04 00 00 00       	mov    $0x4,%edx
  8164c2:	48 89 ce             	mov    %rcx,%rsi
  8164c5:	48 89 c7             	mov    %rax,%rdi
  8164c8:	48 b8 fd 22 80 00 00 	movabs $0x8022fd,%rax
  8164cf:	00 00 00 
  8164d2:	ff d0                	callq  *%rax
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  8164d4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8164d8:	48 8d 48 26          	lea    0x26(%rax),%rcx
  8164dc:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8164e0:	ba 04 00 00 00       	mov    $0x4,%edx
  8164e5:	48 89 ce             	mov    %rcx,%rsi
  8164e8:	48 89 c7             	mov    %rax,%rdi
  8164eb:	48 b8 fd 22 80 00 00 	movabs $0x8022fd,%rax
  8164f2:	00 00 00 
  8164f5:	ff d0                	callq  *%rax

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  8164f7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8164fb:	8b 40 08             	mov    0x8(%rax),%eax
  8164fe:	85 c0                	test   %eax,%eax
  816500:	75 06                	jne    816508 <etharp_arp_input+0x15f>
    for_us = 0;
  816502:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)
  816506:	eb 12                	jmp    81651a <etharp_arp_input+0x171>
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  816508:	8b 55 c0             	mov    -0x40(%rbp),%edx
  81650b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81650f:	8b 40 08             	mov    0x8(%rax),%eax
  816512:	39 c2                	cmp    %eax,%edx
  816514:	0f 94 c0             	sete   %al
  816517:	88 45 ee             	mov    %al,-0x12(%rbp)
  }

  /* ARP message directed to us? */
  if (for_us) {
  81651a:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  81651e:	74 26                	je     816546 <etharp_arp_input+0x19d>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  816520:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816524:	48 8d 50 16          	lea    0x16(%rax),%rdx
  816528:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  81652c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816530:	b9 01 00 00 00       	mov    $0x1,%ecx
  816535:	48 89 c7             	mov    %rax,%rdi
  816538:	48 b8 98 5f 81 00 00 	movabs $0x815f98,%rax
  81653f:	00 00 00 
  816542:	ff d0                	callq  *%rax
  816544:	eb 24                	jmp    81656a <etharp_arp_input+0x1c1>
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  816546:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81654a:	48 8d 50 16          	lea    0x16(%rax),%rdx
  81654e:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  816552:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816556:	b9 00 00 00 00       	mov    $0x0,%ecx
  81655b:	48 89 c7             	mov    %rax,%rdi
  81655e:	48 b8 98 5f 81 00 00 	movabs $0x815f98,%rax
  816565:	00 00 00 
  816568:	ff d0                	callq  *%rax
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  81656a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81656e:	0f b7 40 14          	movzwl 0x14(%rax),%eax
  816572:	0f b7 c0             	movzwl %ax,%eax
  816575:	89 c7                	mov    %eax,%edi
  816577:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  81657e:	00 00 00 
  816581:	ff d0                	callq  *%rax
  816583:	0f b7 c0             	movzwl %ax,%eax
  816586:	83 f8 01             	cmp    $0x1,%eax
  816589:	74 0e                	je     816599 <etharp_arp_input+0x1f0>
  81658b:	83 f8 02             	cmp    $0x2,%eax
  81658e:	0f 84 1c 01 00 00    	je     8166b0 <etharp_arp_input+0x307>
  816594:	e9 33 01 00 00       	jmpq   8166cc <etharp_arp_input+0x323>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
  816599:	80 7d ee 00          	cmpb   $0x0,-0x12(%rbp)
  81659d:	0f 84 2b 01 00 00    	je     8166ce <etharp_arp_input+0x325>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  8165a3:	bf 02 00 00 00       	mov    $0x2,%edi
  8165a8:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  8165af:	00 00 00 
  8165b2:	ff d0                	callq  *%rax
  8165b4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8165b8:	66 89 42 14          	mov    %ax,0x14(%rdx)

      hdr->dipaddr = hdr->sipaddr;
  8165bc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8165c0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8165c4:	8b 52 1c             	mov    0x1c(%rdx),%edx
  8165c7:	89 50 26             	mov    %edx,0x26(%rax)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  8165ca:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8165ce:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8165d2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8165d6:	8b 12                	mov    (%rdx),%edx
  8165d8:	89 50 1c             	mov    %edx,0x1c(%rax)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  8165db:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8165df:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  8165e3:	3c 06                	cmp    $0x6,%al
  8165e5:	74 2a                	je     816611 <etharp_arp_input+0x268>
  8165e7:	48 ba 80 28 82 00 00 	movabs $0x822880,%rdx
  8165ee:	00 00 00 
  8165f1:	be c7 02 00 00       	mov    $0x2c7,%esi
  8165f6:	48 bf 1e 28 82 00 00 	movabs $0x82281e,%rdi
  8165fd:	00 00 00 
  816600:	b8 00 00 00 00       	mov    $0x0,%eax
  816605:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81660c:	00 00 00 
  81660f:	ff d1                	callq  *%rcx
                  (netif->hwaddr_len == ETHARP_HWADDR_LEN));
      i = ETHARP_HWADDR_LEN;
  816611:	c6 45 ef 06          	movb   $0x6,-0x11(%rbp)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  816615:	eb 79                	jmp    816690 <etharp_arp_input+0x2e7>
        i--;
  816617:	80 6d ef 01          	subb   $0x1,-0x11(%rbp)
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  81661b:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  81661f:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  816623:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816627:	48 98                	cltq   
  816629:	0f b6 4c 02 16       	movzbl 0x16(%rdx,%rax,1),%ecx
  81662e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816632:	48 63 c6             	movslq %esi,%rax
  816635:	88 4c 02 20          	mov    %cl,0x20(%rdx,%rax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  816639:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  81663d:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  816641:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816645:	48 98                	cltq   
  816647:	0f b6 4c 02 16       	movzbl 0x16(%rdx,%rax,1),%ecx
  81664c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816650:	48 63 c6             	movslq %esi,%rax
  816653:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  816656:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  81665a:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81665e:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  816662:	48 98                	cltq   
  816664:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816668:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81666c:	48 63 c6             	movslq %esi,%rax
  81666f:	88 4c 02 16          	mov    %cl,0x16(%rdx,%rax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  816673:	0f b6 75 ef          	movzbl -0x11(%rbp),%esi
  816677:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81667b:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  81667f:	48 98                	cltq   
  816681:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816685:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816689:	48 63 c6             	movslq %esi,%rax
  81668c:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  816690:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  816694:	75 81                	jne    816617 <etharp_arp_input+0x26e>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  816696:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81669a:	48 8b 48 28          	mov    0x28(%rax),%rcx
  81669e:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8166a2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8166a6:	48 89 d6             	mov    %rdx,%rsi
  8166a9:	48 89 c7             	mov    %rax,%rdi
  8166ac:	ff d1                	callq  *%rcx
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
  8166ae:	eb 1e                	jmp    8166ce <etharp_arp_input+0x325>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  8166b0:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8166b4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8166b8:	48 89 d6             	mov    %rdx,%rsi
  8166bb:	48 89 c7             	mov    %rax,%rdi
  8166be:	48 b8 5a 9f 80 00 00 	movabs $0x809f5a,%rax
  8166c5:	00 00 00 
  8166c8:	ff d0                	callq  *%rax
#endif
    break;
  8166ca:	eb 03                	jmp    8166cf <etharp_arp_input+0x326>
  default:
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  8166cc:	eb 01                	jmp    8166cf <etharp_arp_input+0x326>
    /* request was not directed to us */
    } else {
      /* { for_us == 0 and netif->ip_addr.addr != 0 } */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP request was not for us.\n"));
    }
    break;
  8166ce:	90                   	nop
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  8166cf:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8166d3:	48 89 c7             	mov    %rax,%rdi
  8166d6:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  8166dd:	00 00 00 
  8166e0:	ff d0                	callq  *%rax
}
  8166e2:	48 83 c4 58          	add    $0x58,%rsp
  8166e6:	5b                   	pop    %rbx
  8166e7:	5d                   	pop    %rbp
  8166e8:	c3                   	retq   

00000000008166e9 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  8166e9:	55                   	push   %rbp
  8166ea:	48 89 e5             	mov    %rsp,%rbp
  8166ed:	53                   	push   %rbx
  8166ee:	48 83 ec 38          	sub    $0x38,%rsp
  8166f2:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8166f6:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8166fa:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  8166fe:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  816702:	be 0e 00 00 00       	mov    $0xe,%esi
  816707:	48 89 c7             	mov    %rax,%rdi
  81670a:	48 b8 6f d7 80 00 00 	movabs $0x80d76f,%rax
  816711:	00 00 00 
  816714:	ff d0                	callq  *%rax
  816716:	84 c0                	test   %al,%al
  816718:	74 0a                	je     816724 <etharp_output+0x3b>
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
  81671a:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  81671f:	e9 50 01 00 00       	jmpq   816874 <etharp_output+0x18b>
  }

  /* assume unresolved Ethernet address */
  dest = NULL;
  816724:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  81672b:	00 
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  81672c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  816730:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816734:	48 89 d6             	mov    %rdx,%rsi
  816737:	48 89 c7             	mov    %rax,%rdi
  81673a:	48 b8 80 09 81 00 00 	movabs $0x810980,%rax
  816741:	00 00 00 
  816744:	ff d0                	callq  *%rax
  816746:	84 c0                	test   %al,%al
  816748:	74 13                	je     81675d <etharp_output+0x74>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  81674a:	48 b8 08 28 82 00 00 	movabs $0x822808,%rax
  816751:	00 00 00 
  816754:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  816758:	e9 ee 00 00 00       	jmpq   81684b <etharp_output+0x162>
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  81675d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  816761:	8b 18                	mov    (%rax),%ebx
  816763:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  816768:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81676f:	00 00 00 
  816772:	ff d0                	callq  *%rax
  816774:	21 c3                	and    %eax,%ebx
  816776:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  81677b:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  816782:	00 00 00 
  816785:	ff d0                	callq  *%rax
  816787:	39 c3                	cmp    %eax,%ebx
  816789:	75 64                	jne    8167ef <etharp_output+0x106>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  81678b:	c6 45 e0 01          	movb   $0x1,-0x20(%rbp)
    mcastaddr.addr[1] = 0x00;
  81678f:	c6 45 e1 00          	movb   $0x0,-0x1f(%rbp)
    mcastaddr.addr[2] = 0x5e;
  816793:	c6 45 e2 5e          	movb   $0x5e,-0x1e(%rbp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  816797:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81679b:	8b 00                	mov    (%rax),%eax
  81679d:	89 c7                	mov    %eax,%edi
  81679f:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  8167a6:	00 00 00 
  8167a9:	ff d0                	callq  *%rax
  8167ab:	c1 e8 10             	shr    $0x10,%eax
  8167ae:	83 e0 7f             	and    $0x7f,%eax
  8167b1:	88 45 e3             	mov    %al,-0x1d(%rbp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  8167b4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8167b8:	8b 00                	mov    (%rax),%eax
  8167ba:	89 c7                	mov    %eax,%edi
  8167bc:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  8167c3:	00 00 00 
  8167c6:	ff d0                	callq  *%rax
  8167c8:	c1 e8 08             	shr    $0x8,%eax
  8167cb:	88 45 e4             	mov    %al,-0x1c(%rbp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  8167ce:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8167d2:	8b 00                	mov    (%rax),%eax
  8167d4:	89 c7                	mov    %eax,%edi
  8167d6:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  8167dd:	00 00 00 
  8167e0:	ff d0                	callq  *%rax
  8167e2:	88 45 e5             	mov    %al,-0x1b(%rbp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  8167e5:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8167e9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8167ed:	eb 5c                	jmp    81684b <etharp_output+0x162>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  8167ef:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8167f3:	8b 10                	mov    (%rax),%edx
  8167f5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8167f9:	8b 40 08             	mov    0x8(%rax),%eax
  8167fc:	31 c2                	xor    %eax,%edx
  8167fe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816802:	8b 40 0c             	mov    0xc(%rax),%eax
  816805:	21 d0                	and    %edx,%eax
  816807:	85 c0                	test   %eax,%eax
  816809:	74 20                	je     81682b <etharp_output+0x142>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  81680b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81680f:	8b 40 10             	mov    0x10(%rax),%eax
  816812:	85 c0                	test   %eax,%eax
  816814:	74 0e                	je     816824 <etharp_output+0x13b>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  816816:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81681a:	48 83 c0 10          	add    $0x10,%rax
  81681e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  816822:	eb 07                	jmp    81682b <etharp_output+0x142>
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
  816824:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  816829:	eb 49                	jmp    816874 <etharp_output+0x18b>
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  81682b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81682f:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  816833:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816837:	48 89 ce             	mov    %rcx,%rsi
  81683a:	48 89 c7             	mov    %rax,%rdi
  81683d:	48 b8 7b 68 81 00 00 	movabs $0x81687b,%rax
  816844:	00 00 00 
  816847:	ff d0                	callq  *%rax
  816849:	eb 29                	jmp    816874 <etharp_output+0x18b>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  81684b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81684f:	48 8d 78 41          	lea    0x41(%rax),%rdi
  816853:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816857:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  81685b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81685f:	48 89 d1             	mov    %rdx,%rcx
  816862:	48 89 fa             	mov    %rdi,%rdx
  816865:	48 89 c7             	mov    %rax,%rdi
  816868:	48 b8 c2 5e 81 00 00 	movabs $0x815ec2,%rax
  81686f:	00 00 00 
  816872:	ff d0                	callq  *%rax
}
  816874:	48 83 c4 38          	add    $0x38,%rsp
  816878:	5b                   	pop    %rbx
  816879:	5d                   	pop    %rbp
  81687a:	c3                   	retq   

000000000081687b <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  81687b:	55                   	push   %rbp
  81687c:	48 89 e5             	mov    %rsp,%rbp
  81687f:	53                   	push   %rbx
  816880:	48 83 ec 68          	sub    $0x68,%rsp
  816884:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  816888:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  81688c:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  816890:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816894:	48 83 c0 41          	add    $0x41,%rax
  816898:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  err_t result = ERR_MEM;
  81689c:	c6 45 ef ff          	movb   $0xff,-0x11(%rbp)
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  8168a0:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8168a4:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8168a8:	48 89 d6             	mov    %rdx,%rsi
  8168ab:	48 89 c7             	mov    %rax,%rdi
  8168ae:	48 b8 80 09 81 00 00 	movabs $0x810980,%rax
  8168b5:	00 00 00 
  8168b8:	ff d0                	callq  *%rax
  8168ba:	84 c0                	test   %al,%al
  8168bc:	75 3f                	jne    8168fd <etharp_query+0x82>
      ip_addr_ismulticast(ipaddr) ||
  8168be:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8168c2:	8b 18                	mov    (%rax),%ebx
  8168c4:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  8168c9:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  8168d0:	00 00 00 
  8168d3:	ff d0                	callq  *%rax
  8168d5:	21 c3                	and    %eax,%ebx
  8168d7:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  8168dc:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  8168e3:	00 00 00 
  8168e6:	ff d0                	callq  *%rax
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  8168e8:	39 c3                	cmp    %eax,%ebx
  8168ea:	74 11                	je     8168fd <etharp_query+0x82>
      ip_addr_ismulticast(ipaddr) ||
  8168ec:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8168f1:	74 0a                	je     8168fd <etharp_query+0x82>
      ip_addr_isany(ipaddr)) {
  8168f3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8168f7:	8b 00                	mov    (%rax),%eax
  8168f9:	85 c0                	test   %eax,%eax
  8168fb:	75 0a                	jne    816907 <etharp_query+0x8c>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  8168fd:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  816902:	e9 1f 04 00 00       	jmpq   816d26 <etharp_query+0x4ab>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  816907:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  81690b:	be 01 00 00 00       	mov    $0x1,%esi
  816910:	48 89 c7             	mov    %rax,%rdi
  816913:	48 b8 2e 59 81 00 00 	movabs $0x81592e,%rax
  81691a:	00 00 00 
  81691d:	ff d0                	callq  *%rax
  81691f:	88 45 c7             	mov    %al,-0x39(%rbp)
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  816922:	80 7d c7 00          	cmpb   $0x0,-0x39(%rbp)
  816926:	79 09                	jns    816931 <etharp_query+0xb6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not create ARP entry\n"));
    if (q) {
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: packet dropped\n"));
      ETHARP_STATS_INC(etharp.memerr);
    }
    return (err_t)i;
  816928:	0f b6 45 c7          	movzbl -0x39(%rbp),%eax
  81692c:	e9 f5 03 00 00       	jmpq   816d26 <etharp_query+0x4ab>
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  816931:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816935:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  81693c:	00 00 00 
  81693f:	48 63 d0             	movslq %eax,%rdx
  816942:	48 89 d0             	mov    %rdx,%rax
  816945:	48 c1 e0 02          	shl    $0x2,%rax
  816949:	48 01 d0             	add    %rdx,%rax
  81694c:	48 c1 e0 03          	shl    $0x3,%rax
  816950:	48 01 c8             	add    %rcx,%rax
  816953:	48 83 c0 10          	add    $0x10,%rax
  816957:	8b 40 04             	mov    0x4(%rax),%eax
  81695a:	85 c0                	test   %eax,%eax
  81695c:	75 2d                	jne    81698b <etharp_query+0x110>
    arp_table[i].state = ETHARP_STATE_PENDING;
  81695e:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816962:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  816969:	00 00 00 
  81696c:	48 63 d0             	movslq %eax,%rdx
  81696f:	48 89 d0             	mov    %rdx,%rax
  816972:	48 c1 e0 02          	shl    $0x2,%rax
  816976:	48 01 d0             	add    %rdx,%rax
  816979:	48 c1 e0 03          	shl    $0x3,%rax
  81697d:	48 01 c8             	add    %rcx,%rax
  816980:	48 83 c0 10          	add    $0x10,%rax
  816984:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  81698b:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  81698f:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  816996:	00 00 00 
  816999:	48 63 d0             	movslq %eax,%rdx
  81699c:	48 89 d0             	mov    %rdx,%rax
  81699f:	48 c1 e0 02          	shl    $0x2,%rax
  8169a3:	48 01 d0             	add    %rdx,%rax
  8169a6:	48 c1 e0 03          	shl    $0x3,%rax
  8169aa:	48 01 c8             	add    %rcx,%rax
  8169ad:	48 83 c0 10          	add    $0x10,%rax
  8169b1:	8b 40 04             	mov    0x4(%rax),%eax
  8169b4:	83 f8 01             	cmp    $0x1,%eax
  8169b7:	74 58                	je     816a11 <etharp_query+0x196>
  8169b9:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  8169bd:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  8169c4:	00 00 00 
  8169c7:	48 63 d0             	movslq %eax,%rdx
  8169ca:	48 89 d0             	mov    %rdx,%rax
  8169cd:	48 c1 e0 02          	shl    $0x2,%rax
  8169d1:	48 01 d0             	add    %rdx,%rax
  8169d4:	48 c1 e0 03          	shl    $0x3,%rax
  8169d8:	48 01 c8             	add    %rcx,%rax
  8169db:	48 83 c0 10          	add    $0x10,%rax
  8169df:	8b 40 04             	mov    0x4(%rax),%eax
  8169e2:	83 f8 02             	cmp    $0x2,%eax
  8169e5:	74 2a                	je     816a11 <etharp_query+0x196>
  8169e7:	48 ba 00 29 82 00 00 	movabs $0x822900,%rdx
  8169ee:	00 00 00 
  8169f1:	be 92 03 00 00       	mov    $0x392,%esi
  8169f6:	48 bf 1e 28 82 00 00 	movabs $0x82281e,%rdi
  8169fd:	00 00 00 
  816a00:	b8 00 00 00 00       	mov    $0x0,%eax
  816a05:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  816a0c:	00 00 00 
  816a0f:	ff d1                	callq  *%rcx
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  816a11:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816a15:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  816a1c:	00 00 00 
  816a1f:	48 63 d0             	movslq %eax,%rdx
  816a22:	48 89 d0             	mov    %rdx,%rax
  816a25:	48 c1 e0 02          	shl    $0x2,%rax
  816a29:	48 01 d0             	add    %rdx,%rax
  816a2c:	48 c1 e0 03          	shl    $0x3,%rax
  816a30:	48 01 c8             	add    %rcx,%rax
  816a33:	48 83 c0 10          	add    $0x10,%rax
  816a37:	8b 40 04             	mov    0x4(%rax),%eax
  816a3a:	83 f8 01             	cmp    $0x1,%eax
  816a3d:	74 07                	je     816a46 <etharp_query+0x1cb>
  816a3f:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  816a44:	75 1d                	jne    816a63 <etharp_query+0x1e8>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  816a46:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  816a4a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816a4e:	48 89 d6             	mov    %rdx,%rsi
  816a51:	48 89 c7             	mov    %rax,%rdi
  816a54:	48 b8 59 6f 81 00 00 	movabs $0x816f59,%rax
  816a5b:	00 00 00 
  816a5e:	ff d0                	callq  *%rax
  816a60:	88 45 ef             	mov    %al,-0x11(%rbp)
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  816a63:	48 83 7d 98 00       	cmpq   $0x0,-0x68(%rbp)
  816a68:	0f 84 b4 02 00 00    	je     816d22 <etharp_query+0x4a7>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  816a6e:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816a72:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  816a79:	00 00 00 
  816a7c:	48 63 d0             	movslq %eax,%rdx
  816a7f:	48 89 d0             	mov    %rdx,%rax
  816a82:	48 c1 e0 02          	shl    $0x2,%rax
  816a86:	48 01 d0             	add    %rdx,%rax
  816a89:	48 c1 e0 03          	shl    $0x3,%rax
  816a8d:	48 01 c8             	add    %rcx,%rax
  816a90:	48 83 c0 10          	add    $0x10,%rax
  816a94:	8b 40 04             	mov    0x4(%rax),%eax
  816a97:	83 f8 02             	cmp    $0x2,%eax
  816a9a:	75 49                	jne    816ae5 <etharp_query+0x26a>
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  816a9c:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816aa0:	48 63 d0             	movslq %eax,%rdx
  816aa3:	48 89 d0             	mov    %rdx,%rax
  816aa6:	48 c1 e0 02          	shl    $0x2,%rax
  816aaa:	48 01 d0             	add    %rdx,%rax
  816aad:	48 c1 e0 03          	shl    $0x3,%rax
  816ab1:	48 ba e0 b6 b4 00 00 	movabs $0xb4b6e0,%rdx
  816ab8:	00 00 00 
  816abb:	48 01 d0             	add    %rdx,%rax
  816abe:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  816ac2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  816ac6:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
  816aca:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  816ace:	48 89 c7             	mov    %rax,%rdi
  816ad1:	48 b8 c2 5e 81 00 00 	movabs $0x815ec2,%rax
  816ad8:	00 00 00 
  816adb:	ff d0                	callq  *%rax
  816add:	88 45 ef             	mov    %al,-0x11(%rbp)
  816ae0:	e9 3d 02 00 00       	jmpq   816d22 <etharp_query+0x4a7>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  816ae5:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816ae9:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  816af0:	00 00 00 
  816af3:	48 63 d0             	movslq %eax,%rdx
  816af6:	48 89 d0             	mov    %rdx,%rax
  816af9:	48 c1 e0 02          	shl    $0x2,%rax
  816afd:	48 01 d0             	add    %rdx,%rax
  816b00:	48 c1 e0 03          	shl    $0x3,%rax
  816b04:	48 01 c8             	add    %rcx,%rax
  816b07:	48 83 c0 10          	add    $0x10,%rax
  816b0b:	8b 40 04             	mov    0x4(%rax),%eax
  816b0e:	83 f8 01             	cmp    $0x1,%eax
  816b11:	0f 85 0b 02 00 00    	jne    816d22 <etharp_query+0x4a7>
#if ARP_QUEUEING /* queue the given q packet */
      struct pbuf *p;
      int copy_needed = 0;
  816b17:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
  816b1e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  816b22:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      while (p) {
  816b26:	eb 6b                	jmp    816b93 <etharp_query+0x318>
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  816b28:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816b2c:	0f b7 50 12          	movzwl 0x12(%rax),%edx
  816b30:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816b34:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  816b38:	66 39 c2             	cmp    %ax,%dx
  816b3b:	75 36                	jne    816b73 <etharp_query+0x2f8>
  816b3d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816b41:	48 8b 00             	mov    (%rax),%rax
  816b44:	48 85 c0             	test   %rax,%rax
  816b47:	74 2a                	je     816b73 <etharp_query+0x2f8>
  816b49:	48 ba 28 29 82 00 00 	movabs $0x822928,%rdx
  816b50:	00 00 00 
  816b53:	be b1 03 00 00       	mov    $0x3b1,%esi
  816b58:	48 bf 1e 28 82 00 00 	movabs $0x82281e,%rdi
  816b5f:	00 00 00 
  816b62:	b8 00 00 00 00       	mov    $0x0,%eax
  816b67:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  816b6e:	00 00 00 
  816b71:	ff d1                	callq  *%rcx
        if(p->type != PBUF_ROM) {
  816b73:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816b77:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  816b7b:	3c 01                	cmp    $0x1,%al
  816b7d:	74 09                	je     816b88 <etharp_query+0x30d>
          copy_needed = 1;
  816b7f:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%rbp)
          break;
  816b86:	eb 12                	jmp    816b9a <etharp_query+0x31f>
        }
        p = p->next;
  816b88:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816b8c:	48 8b 00             	mov    (%rax),%rax
  816b8f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  816b93:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  816b98:	75 8e                	jne    816b28 <etharp_query+0x2ad>
          copy_needed = 1;
          break;
        }
        p = p->next;
      }
      if(copy_needed) {
  816b9a:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  816b9e:	74 69                	je     816c09 <etharp_query+0x38e>
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  816ba0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816ba4:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  816ba8:	0f b7 c0             	movzwl %ax,%eax
  816bab:	ba 00 00 00 00       	mov    $0x0,%edx
  816bb0:	89 c6                	mov    %eax,%esi
  816bb2:	bf 03 00 00 00       	mov    $0x3,%edi
  816bb7:	48 b8 4c d0 80 00 00 	movabs $0x80d04c,%rax
  816bbe:	00 00 00 
  816bc1:	ff d0                	callq  *%rax
  816bc3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        if(p != NULL) {
  816bc7:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  816bcc:	74 56                	je     816c24 <etharp_query+0x3a9>
          if (pbuf_copy(p, q) != ERR_OK) {
  816bce:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  816bd2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816bd6:	48 89 d6             	mov    %rdx,%rsi
  816bd9:	48 89 c7             	mov    %rax,%rdi
  816bdc:	48 b8 b4 dd 80 00 00 	movabs $0x80ddb4,%rax
  816be3:	00 00 00 
  816be6:	ff d0                	callq  *%rax
  816be8:	84 c0                	test   %al,%al
  816bea:	74 38                	je     816c24 <etharp_query+0x3a9>
            pbuf_free(p);
  816bec:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816bf0:	48 89 c7             	mov    %rax,%rdi
  816bf3:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  816bfa:	00 00 00 
  816bfd:	ff d0                	callq  *%rax
            p = NULL;
  816bff:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  816c06:	00 
  816c07:	eb 1b                	jmp    816c24 <etharp_query+0x3a9>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
  816c09:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  816c0d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        pbuf_ref(p);
  816c11:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816c15:	48 89 c7             	mov    %rax,%rdi
  816c18:	48 b8 0f db 80 00 00 	movabs $0x80db0f,%rax
  816c1f:	00 00 00 
  816c22:	ff d0                	callq  *%rax
      }
      /* packet could be taken over? */
      if (p != NULL) {
  816c24:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  816c29:	0f 84 f3 00 00 00    	je     816d22 <etharp_query+0x4a7>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  816c2f:	bf 0a 00 00 00       	mov    $0xa,%edi
  816c34:	48 b8 41 ca 80 00 00 	movabs $0x80ca41,%rax
  816c3b:	00 00 00 
  816c3e:	ff d0                	callq  *%rax
  816c40:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        if (new_entry != NULL) {
  816c44:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  816c49:	0f 84 c0 00 00 00    	je     816d0f <etharp_query+0x494>
          new_entry->next = 0;
  816c4f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816c53:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
          new_entry->p = p;
  816c5a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816c5e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  816c62:	48 89 50 08          	mov    %rdx,0x8(%rax)
          if(arp_table[i].q != NULL) {
  816c66:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816c6a:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  816c71:	00 00 00 
  816c74:	48 63 d0             	movslq %eax,%rdx
  816c77:	48 89 d0             	mov    %rdx,%rax
  816c7a:	48 c1 e0 02          	shl    $0x2,%rax
  816c7e:	48 01 d0             	add    %rdx,%rax
  816c81:	48 c1 e0 03          	shl    $0x3,%rax
  816c85:	48 01 c8             	add    %rcx,%rax
  816c88:	48 8b 00             	mov    (%rax),%rax
  816c8b:	48 85 c0             	test   %rax,%rax
  816c8e:	74 4f                	je     816cdf <etharp_query+0x464>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
  816c90:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816c94:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  816c9b:	00 00 00 
  816c9e:	48 63 d0             	movslq %eax,%rdx
  816ca1:	48 89 d0             	mov    %rdx,%rax
  816ca4:	48 c1 e0 02          	shl    $0x2,%rax
  816ca8:	48 01 d0             	add    %rdx,%rax
  816cab:	48 c1 e0 03          	shl    $0x3,%rax
  816caf:	48 01 c8             	add    %rcx,%rax
  816cb2:	48 8b 00             	mov    (%rax),%rax
  816cb5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
            while (r->next != NULL) {
  816cb9:	eb 0b                	jmp    816cc6 <etharp_query+0x44b>
              r = r->next;
  816cbb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  816cbf:	48 8b 00             	mov    (%rax),%rax
  816cc2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
          new_entry->p = p;
          if(arp_table[i].q != NULL) {
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  816cc6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  816cca:	48 8b 00             	mov    (%rax),%rax
  816ccd:	48 85 c0             	test   %rax,%rax
  816cd0:	75 e9                	jne    816cbb <etharp_query+0x440>
              r = r->next;
            }
            r->next = new_entry;
  816cd2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  816cd6:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  816cda:	48 89 10             	mov    %rdx,(%rax)
  816cdd:	eb 2a                	jmp    816d09 <etharp_query+0x48e>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  816cdf:	0f be 45 c7          	movsbl -0x39(%rbp),%eax
  816ce3:	48 b9 e0 b6 b4 00 00 	movabs $0xb4b6e0,%rcx
  816cea:	00 00 00 
  816ced:	48 63 d0             	movslq %eax,%rdx
  816cf0:	48 89 d0             	mov    %rdx,%rax
  816cf3:	48 c1 e0 02          	shl    $0x2,%rax
  816cf7:	48 01 d0             	add    %rdx,%rax
  816cfa:	48 c1 e0 03          	shl    $0x3,%rax
  816cfe:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  816d02:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  816d06:	48 89 02             	mov    %rax,(%rdx)
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  816d09:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  816d0d:	eb 13                	jmp    816d22 <etharp_query+0x4a7>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  816d0f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  816d13:	48 89 c7             	mov    %rax,%rdi
  816d16:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  816d1d:	00 00 00 
  816d20:	ff d0                	callq  *%rax
      /* { result == ERR_MEM } through initialization */
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
  816d22:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  816d26:	48 83 c4 68          	add    $0x68,%rsp
  816d2a:	5b                   	pop    %rbx
  816d2b:	5d                   	pop    %rbp
  816d2c:	c3                   	retq   

0000000000816d2d <etharp_raw>:
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
           const struct eth_addr *ethdst_addr,
           const struct eth_addr *hwsrc_addr, const struct ip_addr *ipsrc_addr,
           const struct eth_addr *hwdst_addr, const struct ip_addr *ipdst_addr,
           const u16_t opcode)
{
  816d2d:	55                   	push   %rbp
  816d2e:	48 89 e5             	mov    %rsp,%rbp
  816d31:	48 83 ec 60          	sub    $0x60,%rsp
  816d35:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  816d39:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  816d3d:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  816d41:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  816d45:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  816d49:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
  816d4d:	8b 45 18             	mov    0x18(%rbp),%eax
  816d50:	66 89 45 ac          	mov    %ax,-0x54(%rbp)
  struct pbuf *p;
  err_t result = ERR_OK;
  816d54:	c6 45 fe 00          	movb   $0x0,-0x2(%rbp)
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  816d58:	ba 00 00 00 00       	mov    $0x0,%edx
  816d5d:	be 2a 00 00 00       	mov    $0x2a,%esi
  816d62:	bf 02 00 00 00       	mov    $0x2,%edi
  816d67:	48 b8 4c d0 80 00 00 	movabs $0x80d04c,%rax
  816d6e:	00 00 00 
  816d71:	ff d0                	callq  *%rax
  816d73:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  816d77:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  816d7c:	75 0a                	jne    816d88 <etharp_raw+0x5b>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  816d7e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  816d83:	e9 cf 01 00 00       	jmpq   816f57 <etharp_raw+0x22a>
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  816d88:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  816d8c:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  816d90:	66 83 f8 29          	cmp    $0x29,%ax
  816d94:	77 2a                	ja     816dc0 <etharp_raw+0x93>
  816d96:	48 ba 48 29 82 00 00 	movabs $0x822948,%rdx
  816d9d:	00 00 00 
  816da0:	be 1c 04 00 00       	mov    $0x41c,%esi
  816da5:	48 bf 1e 28 82 00 00 	movabs $0x82281e,%rdi
  816dac:	00 00 00 
  816daf:	b8 00 00 00 00       	mov    $0x0,%eax
  816db4:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  816dbb:	00 00 00 
  816dbe:	ff d1                	callq  *%rcx
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  816dc0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  816dc4:	48 8b 40 08          	mov    0x8(%rax),%rax
  816dc8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  816dcc:	0f b7 45 ac          	movzwl -0x54(%rbp),%eax
  816dd0:	89 c7                	mov    %eax,%edi
  816dd2:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  816dd9:	00 00 00 
  816ddc:	ff d0                	callq  *%rax
  816dde:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816de2:	66 89 42 14          	mov    %ax,0x14(%rdx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  816de6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816dea:	0f b6 40 40          	movzbl 0x40(%rax),%eax
  816dee:	3c 06                	cmp    $0x6,%al
  816df0:	74 2a                	je     816e1c <etharp_raw+0xef>
  816df2:	48 ba 80 28 82 00 00 	movabs $0x822880,%rdx
  816df9:	00 00 00 
  816dfc:	be 23 04 00 00       	mov    $0x423,%esi
  816e01:	48 bf 1e 28 82 00 00 	movabs $0x82281e,%rdi
  816e08:	00 00 00 
  816e0b:	b8 00 00 00 00       	mov    $0x0,%eax
  816e10:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  816e17:	00 00 00 
  816e1a:	ff d1                	callq  *%rcx
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  816e1c:	c6 45 ff 06          	movb   $0x6,-0x1(%rbp)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  816e20:	eb 77                	jmp    816e99 <etharp_raw+0x16c>
    k--;
  816e22:	80 6d ff 01          	subb   $0x1,-0x1(%rbp)
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  816e26:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  816e2a:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816e2e:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  816e32:	48 98                	cltq   
  816e34:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816e38:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816e3c:	48 63 c6             	movslq %esi,%rax
  816e3f:	88 4c 02 16          	mov    %cl,0x16(%rdx,%rax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  816e43:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  816e47:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816e4b:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  816e4f:	48 98                	cltq   
  816e51:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816e55:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816e59:	48 63 c6             	movslq %esi,%rax
  816e5c:	88 4c 02 20          	mov    %cl,0x20(%rdx,%rax,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  816e60:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  816e64:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816e68:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  816e6c:	48 98                	cltq   
  816e6e:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816e72:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816e76:	48 63 c6             	movslq %esi,%rax
  816e79:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  816e7c:	0f b6 75 ff          	movzbl -0x1(%rbp),%esi
  816e80:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
  816e84:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  816e88:	48 98                	cltq   
  816e8a:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
  816e8e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816e92:	48 63 c6             	movslq %esi,%rax
  816e95:	88 4c 02 06          	mov    %cl,0x6(%rdx,%rax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  816e99:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  816e9d:	75 83                	jne    816e22 <etharp_raw+0xf5>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  816e9f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816ea3:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  816ea7:	8b 12                	mov    (%rdx),%edx
  816ea9:	89 50 1c             	mov    %edx,0x1c(%rax)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  816eac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816eb0:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  816eb4:	8b 12                	mov    (%rdx),%edx
  816eb6:	89 50 26             	mov    %edx,0x26(%rax)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  816eb9:	bf 01 00 00 00       	mov    $0x1,%edi
  816ebe:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  816ec5:	00 00 00 
  816ec8:	ff d0                	callq  *%rax
  816eca:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816ece:	66 89 42 0e          	mov    %ax,0xe(%rdx)
  hdr->proto = htons(ETHTYPE_IP);
  816ed2:	bf 00 08 00 00       	mov    $0x800,%edi
  816ed7:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  816ede:	00 00 00 
  816ee1:	ff d0                	callq  *%rax
  816ee3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816ee7:	66 89 42 10          	mov    %ax,0x10(%rdx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  816eeb:	bf 04 06 00 00       	mov    $0x604,%edi
  816ef0:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  816ef7:	00 00 00 
  816efa:	ff d0                	callq  *%rax
  816efc:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816f00:	66 89 42 12          	mov    %ax,0x12(%rdx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  816f04:	bf 06 08 00 00       	mov    $0x806,%edi
  816f09:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  816f10:	00 00 00 
  816f13:	ff d0                	callq  *%rax
  816f15:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  816f19:	66 89 42 0c          	mov    %ax,0xc(%rdx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  816f1d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816f21:	48 8b 48 28          	mov    0x28(%rax),%rcx
  816f25:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  816f29:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  816f2d:	48 89 d6             	mov    %rdx,%rsi
  816f30:	48 89 c7             	mov    %rax,%rdi
  816f33:	ff d1                	callq  *%rcx
  816f35:	88 45 fe             	mov    %al,-0x2(%rbp)
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  816f38:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  816f3c:	48 89 c7             	mov    %rax,%rdi
  816f3f:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  816f46:	00 00 00 
  816f49:	ff d0                	callq  *%rax
  p = NULL;
  816f4b:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  816f52:	00 
  /* could not allocate pbuf for ARP request */

  return result;
  816f53:	0f b6 45 fe          	movzbl -0x2(%rbp),%eax
}
  816f57:	c9                   	leaveq 
  816f58:	c3                   	retq   

0000000000816f59 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  816f59:	55                   	push   %rbp
  816f5a:	48 89 e5             	mov    %rsp,%rbp
  816f5d:	48 83 ec 20          	sub    $0x20,%rsp
  816f61:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  816f65:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
  816f69:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816f6d:	48 8d 78 08          	lea    0x8(%rax),%rdi
  816f71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816f75:	48 8d 48 41          	lea    0x41(%rax),%rcx
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  816f79:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816f7d:	48 8d 70 41          	lea    0x41(%rax),%rsi
  816f81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816f85:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%rsp)
  816f8c:	00 
  816f8d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  816f91:	48 89 14 24          	mov    %rdx,(%rsp)
  816f95:	49 b9 0e 28 82 00 00 	movabs $0x82280e,%r9
  816f9c:	00 00 00 
  816f9f:	49 89 f8             	mov    %rdi,%r8
  816fa2:	48 ba 08 28 82 00 00 	movabs $0x822808,%rdx
  816fa9:	00 00 00 
  816fac:	48 89 c7             	mov    %rax,%rdi
  816faf:	48 b8 2d 6d 81 00 00 	movabs $0x816d2d,%rax
  816fb6:	00 00 00 
  816fb9:	ff d0                	callq  *%rax
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  816fbb:	c9                   	leaveq 
  816fbc:	c3                   	retq   

0000000000816fbd <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  816fbd:	55                   	push   %rbp
  816fbe:	48 89 e5             	mov    %rsp,%rbp
  816fc1:	48 83 ec 20          	sub    $0x20,%rsp
  816fc5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  816fc9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct eth_hdr* ethhdr;

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = p->payload;
  816fcd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  816fd1:	48 8b 40 08          	mov    0x8(%rax),%rax
  816fd5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  816fd9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  816fdd:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  816fe1:	0f b7 c0             	movzwl %ax,%eax
  816fe4:	89 c7                	mov    %eax,%edi
  816fe6:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  816fed:	00 00 00 
  816ff0:	ff d0                	callq  *%rax
  816ff2:	0f b7 c0             	movzwl %ax,%eax
  816ff5:	3d 00 08 00 00       	cmp    $0x800,%eax
  816ffa:	74 10                	je     81700c <ethernet_input+0x4f>
  816ffc:	3d 06 08 00 00       	cmp    $0x806,%eax
  817001:	0f 84 81 00 00 00    	je     817088 <ethernet_input+0xcb>
  817007:	e9 a0 00 00 00       	jmpq   8170ac <ethernet_input+0xef>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  81700c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  817010:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  817014:	48 89 d6             	mov    %rdx,%rsi
  817017:	48 89 c7             	mov    %rax,%rdi
  81701a:	48 b8 12 63 81 00 00 	movabs $0x816312,%rax
  817021:	00 00 00 
  817024:	ff d0                	callq  *%rax
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  817026:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81702a:	be f2 ff ff ff       	mov    $0xfffffff2,%esi
  81702f:	48 89 c7             	mov    %rax,%rdi
  817032:	48 b8 6f d7 80 00 00 	movabs $0x80d76f,%rax
  817039:	00 00 00 
  81703c:	ff d0                	callq  *%rax
  81703e:	84 c0                	test   %al,%al
  817040:	74 2a                	je     81706c <ethernet_input+0xaf>
        LWIP_ASSERT("Can't move over header in packet", 0);
  817042:	48 ba 80 29 82 00 00 	movabs $0x822980,%rdx
  817049:	00 00 00 
  81704c:	be 7e 04 00 00       	mov    $0x47e,%esi
  817051:	48 bf 1e 28 82 00 00 	movabs $0x82281e,%rdi
  817058:	00 00 00 
  81705b:	b8 00 00 00 00       	mov    $0x0,%eax
  817060:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  817067:	00 00 00 
  81706a:	ff d1                	callq  *%rcx
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  81706c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  817070:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  817074:	48 89 d6             	mov    %rdx,%rsi
  817077:	48 89 c7             	mov    %rax,%rdi
  81707a:	48 b8 d2 0a 81 00 00 	movabs $0x810ad2,%rax
  817081:	00 00 00 
  817084:	ff d0                	callq  *%rax
      }
      break;
  817086:	eb 40                	jmp    8170c8 <ethernet_input+0x10b>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  817088:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81708c:	48 8d 48 41          	lea    0x41(%rax),%rcx
  817090:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  817094:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  817098:	48 89 ce             	mov    %rcx,%rsi
  81709b:	48 89 c7             	mov    %rax,%rdi
  81709e:	48 b8 a9 63 81 00 00 	movabs $0x8163a9,%rax
  8170a5:	00 00 00 
  8170a8:	ff d0                	callq  *%rax
      break;
  8170aa:	eb 1c                	jmp    8170c8 <ethernet_input+0x10b>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  8170ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8170b0:	48 89 c7             	mov    %rax,%rdi
  8170b3:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  8170ba:	00 00 00 
  8170bd:	ff d0                	callq  *%rax
      p = NULL;
  8170bf:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8170c6:	00 
      break;
  8170c7:	90                   	nop
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
  8170c8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8170cd:	c9                   	leaveq 
  8170ce:	c3                   	retq   
	...

00000000008170d0 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  8170d0:	55                   	push   %rbp
  8170d1:	48 89 e5             	mov    %rsp,%rbp
  8170d4:	48 83 ec 10          	sub    $0x10,%rsp
    int i = 0;
  8170d8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    for (i = 0; i < NSEM; i++) {
  8170df:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8170e6:	e9 d0 00 00 00       	jmpq   8171bb <sys_init+0xeb>
	sems[i].freed = 1;
  8170eb:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  8170f2:	00 00 00 
  8170f5:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8170f8:	48 63 d2             	movslq %edx,%rdx
  8170fb:	48 c1 e2 05          	shl    $0x5,%rdx
  8170ff:	48 01 d0             	add    %rdx,%rax
  817102:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  817108:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81710b:	48 98                	cltq   
  81710d:	48 89 c2             	mov    %rax,%rdx
  817110:	48 c1 e2 05          	shl    $0x5,%rdx
  817114:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  81711b:	00 00 00 
  81711e:	48 01 d0             	add    %rdx,%rax
  817121:	48 ba a0 d8 b4 00 00 	movabs $0xb4d8a0,%rdx
  817128:	00 00 00 
  81712b:	48 8b 12             	mov    (%rdx),%rdx
  81712e:	48 89 50 10          	mov    %rdx,0x10(%rax)
  817132:	48 8b 40 10          	mov    0x10(%rax),%rax
  817136:	48 85 c0             	test   %rax,%rax
  817139:	74 2f                	je     81716a <sys_init+0x9a>
  81713b:	48 b8 a0 d8 b4 00 00 	movabs $0xb4d8a0,%rax
  817142:	00 00 00 
  817145:	48 8b 00             	mov    (%rax),%rax
  817148:	8b 55 fc             	mov    -0x4(%rbp),%edx
  81714b:	48 63 d2             	movslq %edx,%rdx
  81714e:	48 89 d1             	mov    %rdx,%rcx
  817151:	48 c1 e1 05          	shl    $0x5,%rcx
  817155:	48 ba a0 b8 b4 00 00 	movabs $0xb4b8a0,%rdx
  81715c:	00 00 00 
  81715f:	48 01 ca             	add    %rcx,%rdx
  817162:	48 83 c2 10          	add    $0x10,%rdx
  817166:	48 89 50 18          	mov    %rdx,0x18(%rax)
  81716a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81716d:	48 98                	cltq   
  81716f:	48 89 c2             	mov    %rax,%rdx
  817172:	48 c1 e2 05          	shl    $0x5,%rdx
  817176:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  81717d:	00 00 00 
  817180:	48 01 c2             	add    %rax,%rdx
  817183:	48 b8 a0 d8 b4 00 00 	movabs $0xb4d8a0,%rax
  81718a:	00 00 00 
  81718d:	48 89 10             	mov    %rdx,(%rax)
  817190:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817193:	48 98                	cltq   
  817195:	48 89 c2             	mov    %rax,%rdx
  817198:	48 c1 e2 05          	shl    $0x5,%rdx
  81719c:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  8171a3:	00 00 00 
  8171a6:	48 01 d0             	add    %rdx,%rax
  8171a9:	48 ba a0 d8 b4 00 00 	movabs $0xb4d8a0,%rdx
  8171b0:	00 00 00 
  8171b3:	48 89 50 18          	mov    %rdx,0x18(%rax)

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  8171b7:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8171bb:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%rbp)
  8171c2:	0f 8e 23 ff ff ff    	jle    8170eb <sys_init+0x1b>
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  8171c8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8171cf:	e9 36 01 00 00       	jmpq   81730a <sys_init+0x23a>
	mboxes[i].freed = 1;
  8171d4:	48 b9 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rcx
  8171db:	00 00 00 
  8171de:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8171e1:	48 63 d0             	movslq %eax,%rdx
  8171e4:	48 89 d0             	mov    %rdx,%rax
  8171e7:	48 c1 e0 03          	shl    $0x3,%rax
  8171eb:	48 01 d0             	add    %rdx,%rax
  8171ee:	48 c1 e0 02          	shl    $0x2,%rax
  8171f2:	48 01 d0             	add    %rdx,%rax
  8171f5:	48 c1 e0 03          	shl    $0x3,%rax
  8171f9:	48 01 c8             	add    %rcx,%rax
  8171fc:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  817202:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817205:	48 63 d0             	movslq %eax,%rdx
  817208:	48 89 d0             	mov    %rdx,%rax
  81720b:	48 c1 e0 03          	shl    $0x3,%rax
  81720f:	48 01 d0             	add    %rdx,%rax
  817212:	48 c1 e0 02          	shl    $0x2,%rax
  817216:	48 01 d0             	add    %rdx,%rax
  817219:	48 c1 e0 03          	shl    $0x3,%rax
  81721d:	48 89 c2             	mov    %rax,%rdx
  817220:	48 b8 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rax
  817227:	00 00 00 
  81722a:	48 01 d0             	add    %rdx,%rax
  81722d:	48 ba c0 6c b5 00 00 	movabs $0xb56cc0,%rdx
  817234:	00 00 00 
  817237:	48 8b 12             	mov    (%rdx),%rdx
  81723a:	48 89 90 18 01 00 00 	mov    %rdx,0x118(%rax)
  817241:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  817248:	48 85 c0             	test   %rax,%rax
  81724b:	74 45                	je     817292 <sys_init+0x1c2>
  81724d:	48 b8 c0 6c b5 00 00 	movabs $0xb56cc0,%rax
  817254:	00 00 00 
  817257:	48 8b 08             	mov    (%rax),%rcx
  81725a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81725d:	48 63 d0             	movslq %eax,%rdx
  817260:	48 89 d0             	mov    %rdx,%rax
  817263:	48 c1 e0 03          	shl    $0x3,%rax
  817267:	48 01 d0             	add    %rdx,%rax
  81726a:	48 c1 e0 02          	shl    $0x2,%rax
  81726e:	48 01 d0             	add    %rdx,%rax
  817271:	48 c1 e0 03          	shl    $0x3,%rax
  817275:	48 89 c2             	mov    %rax,%rdx
  817278:	48 b8 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rax
  81727f:	00 00 00 
  817282:	48 01 d0             	add    %rdx,%rax
  817285:	48 05 18 01 00 00    	add    $0x118,%rax
  81728b:	48 89 81 20 01 00 00 	mov    %rax,0x120(%rcx)
  817292:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817295:	48 63 d0             	movslq %eax,%rdx
  817298:	48 89 d0             	mov    %rdx,%rax
  81729b:	48 c1 e0 03          	shl    $0x3,%rax
  81729f:	48 01 d0             	add    %rdx,%rax
  8172a2:	48 c1 e0 02          	shl    $0x2,%rax
  8172a6:	48 01 d0             	add    %rdx,%rax
  8172a9:	48 c1 e0 03          	shl    $0x3,%rax
  8172ad:	48 89 c2             	mov    %rax,%rdx
  8172b0:	48 b8 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rax
  8172b7:	00 00 00 
  8172ba:	48 01 c2             	add    %rax,%rdx
  8172bd:	48 b8 c0 6c b5 00 00 	movabs $0xb56cc0,%rax
  8172c4:	00 00 00 
  8172c7:	48 89 10             	mov    %rdx,(%rax)
  8172ca:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8172cd:	48 63 d0             	movslq %eax,%rdx
  8172d0:	48 89 d0             	mov    %rdx,%rax
  8172d3:	48 c1 e0 03          	shl    $0x3,%rax
  8172d7:	48 01 d0             	add    %rdx,%rax
  8172da:	48 c1 e0 02          	shl    $0x2,%rax
  8172de:	48 01 d0             	add    %rdx,%rax
  8172e1:	48 c1 e0 03          	shl    $0x3,%rax
  8172e5:	48 89 c2             	mov    %rax,%rdx
  8172e8:	48 b8 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rax
  8172ef:	00 00 00 
  8172f2:	48 01 d0             	add    %rdx,%rax
  8172f5:	48 ba c0 6c b5 00 00 	movabs $0xb56cc0,%rdx
  8172fc:	00 00 00 
  8172ff:	48 89 90 20 01 00 00 	mov    %rdx,0x120(%rax)
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  817306:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  81730a:	83 7d fc 7f          	cmpl   $0x7f,-0x4(%rbp)
  81730e:	0f 8e c0 fe ff ff    	jle    8171d4 <sys_init+0x104>
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
    }
}
  817314:	c9                   	leaveq 
  817315:	c3                   	retq   

0000000000817316 <sys_mbox_new>:

sys_mbox_t
sys_mbox_new(int size)
{
  817316:	55                   	push   %rbp
  817317:	48 89 e5             	mov    %rsp,%rbp
  81731a:	48 83 ec 20          	sub    $0x20,%rsp
  81731e:	89 7d ec             	mov    %edi,-0x14(%rbp)
    assert(size < MBOXSLOTS);
  817321:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  817325:	7e 35                	jle    81735c <sys_mbox_new+0x46>
  817327:	48 b9 a8 29 82 00 00 	movabs $0x8229a8,%rcx
  81732e:	00 00 00 
  817331:	48 ba b9 29 82 00 00 	movabs $0x8229b9,%rdx
  817338:	00 00 00 
  81733b:	be 45 00 00 00       	mov    $0x45,%esi
  817340:	48 bf ce 29 82 00 00 	movabs $0x8229ce,%rdi
  817347:	00 00 00 
  81734a:	b8 00 00 00 00       	mov    $0x0,%eax
  81734f:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  817356:	00 00 00 
  817359:	41 ff d0             	callq  *%r8
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  81735c:	48 b8 c0 6c b5 00 00 	movabs $0xb56cc0,%rax
  817363:	00 00 00 
  817366:	48 8b 00             	mov    (%rax),%rax
  817369:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!mbe) {
  81736d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  817372:	75 25                	jne    817399 <sys_mbox_new+0x83>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  817374:	48 bf f0 29 82 00 00 	movabs $0x8229f0,%rdi
  81737b:	00 00 00 
  81737e:	b8 00 00 00 00       	mov    $0x0,%eax
  817383:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  81738a:	00 00 00 
  81738d:	ff d2                	callq  *%rdx
	return SYS_MBOX_NULL;
  81738f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817394:	e9 5e 01 00 00       	jmpq   8174f7 <sys_mbox_new+0x1e1>
    }
    LIST_REMOVE(mbe, link);
  817399:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81739d:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  8173a4:	48 85 c0             	test   %rax,%rax
  8173a7:	74 1d                	je     8173c6 <sys_mbox_new+0xb0>
  8173a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8173ad:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  8173b4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8173b8:	48 8b 92 20 01 00 00 	mov    0x120(%rdx),%rdx
  8173bf:	48 89 90 20 01 00 00 	mov    %rdx,0x120(%rax)
  8173c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8173ca:	48 8b 80 20 01 00 00 	mov    0x120(%rax),%rax
  8173d1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8173d5:	48 8b 92 18 01 00 00 	mov    0x118(%rdx),%rdx
  8173dc:	48 89 10             	mov    %rdx,(%rax)
    assert(mbe->freed);
  8173df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8173e3:	8b 00                	mov    (%rax),%eax
  8173e5:	85 c0                	test   %eax,%eax
  8173e7:	75 35                	jne    81741e <sys_mbox_new+0x108>
  8173e9:	48 b9 16 2a 82 00 00 	movabs $0x822a16,%rcx
  8173f0:	00 00 00 
  8173f3:	48 ba b9 29 82 00 00 	movabs $0x8229b9,%rdx
  8173fa:	00 00 00 
  8173fd:	be 4c 00 00 00       	mov    $0x4c,%esi
  817402:	48 bf ce 29 82 00 00 	movabs $0x8229ce,%rdi
  817409:	00 00 00 
  81740c:	b8 00 00 00 00       	mov    $0x0,%eax
  817411:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  817418:	00 00 00 
  81741b:	41 ff d0             	callq  *%r8
    mbe->freed = 0;
  81741e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817422:	c7 00 00 00 00 00    	movl   $0x0,(%rax)

    int i = mbe - &mboxes[0];
  817428:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81742c:	48 b8 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rax
  817433:	00 00 00 
  817436:	48 89 d1             	mov    %rdx,%rcx
  817439:	48 29 c1             	sub    %rax,%rcx
  81743c:	48 89 c8             	mov    %rcx,%rax
  81743f:	48 89 c2             	mov    %rax,%rdx
  817442:	48 c1 fa 03          	sar    $0x3,%rdx
  817446:	48 b8 ad 1b 4c 91 cf 	movabs $0x14c1bacf914c1bad,%rax
  81744d:	ba c1 14 
  817450:	48 0f af c2          	imul   %rdx,%rax
  817454:	89 45 f4             	mov    %eax,-0xc(%rbp)
    mbe->head = -1;
  817457:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81745b:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%rax)
    mbe->nextq = 0;
  817462:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817466:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
    mbe->queued_msg = sys_sem_new(0);
  81746d:	bf 00 00 00 00       	mov    $0x0,%edi
  817472:	48 b8 e2 79 81 00 00 	movabs $0x8179e2,%rax
  817479:	00 00 00 
  81747c:	ff d0                	callq  *%rax
  81747e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817482:	89 82 10 01 00 00    	mov    %eax,0x110(%rdx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  817488:	bf 20 00 00 00       	mov    $0x20,%edi
  81748d:	48 b8 e2 79 81 00 00 	movabs $0x8179e2,%rax
  817494:	00 00 00 
  817497:	ff d0                	callq  *%rax
  817499:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81749d:	89 82 14 01 00 00    	mov    %eax,0x114(%rdx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  8174a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8174a7:	8b 80 10 01 00 00    	mov    0x110(%rax),%eax
  8174ad:	83 f8 ff             	cmp    $0xffffffff,%eax
  8174b0:	74 0f                	je     8174c1 <sys_mbox_new+0x1ab>
	mbe->free_msg == SYS_SEM_NULL)
  8174b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8174b6:	8b 80 14 01 00 00    	mov    0x114(%rax),%eax
    mbe->head = -1;
    mbe->nextq = 0;
    mbe->queued_msg = sys_sem_new(0);
    mbe->free_msg = sys_sem_new(MBOXSLOTS);

    if (mbe->queued_msg == SYS_SEM_NULL ||
  8174bc:	83 f8 ff             	cmp    $0xffffffff,%eax
  8174bf:	75 33                	jne    8174f4 <sys_mbox_new+0x1de>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  8174c1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8174c4:	89 c7                	mov    %eax,%edi
  8174c6:	48 b8 f9 74 81 00 00 	movabs $0x8174f9,%rax
  8174cd:	00 00 00 
  8174d0:	ff d0                	callq  *%rax
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  8174d2:	48 bf 28 2a 82 00 00 	movabs $0x822a28,%rdi
  8174d9:	00 00 00 
  8174dc:	b8 00 00 00 00       	mov    $0x0,%eax
  8174e1:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  8174e8:	00 00 00 
  8174eb:	ff d2                	callq  *%rdx
	return SYS_MBOX_NULL;
  8174ed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8174f2:	eb 03                	jmp    8174f7 <sys_mbox_new+0x1e1>
    }
    return i;
  8174f4:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  8174f7:	c9                   	leaveq 
  8174f8:	c3                   	retq   

00000000008174f9 <sys_mbox_free>:

void
sys_mbox_free(sys_mbox_t mbox)
{
  8174f9:	55                   	push   %rbp
  8174fa:	48 89 e5             	mov    %rsp,%rbp
  8174fd:	48 83 ec 10          	sub    $0x10,%rsp
  817501:	89 7d fc             	mov    %edi,-0x4(%rbp)
    assert(!mboxes[mbox].freed);
  817504:	48 b9 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rcx
  81750b:	00 00 00 
  81750e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817511:	48 63 d0             	movslq %eax,%rdx
  817514:	48 89 d0             	mov    %rdx,%rax
  817517:	48 c1 e0 03          	shl    $0x3,%rax
  81751b:	48 01 d0             	add    %rdx,%rax
  81751e:	48 c1 e0 02          	shl    $0x2,%rax
  817522:	48 01 d0             	add    %rdx,%rax
  817525:	48 c1 e0 03          	shl    $0x3,%rax
  817529:	48 01 c8             	add    %rcx,%rax
  81752c:	8b 00                	mov    (%rax),%eax
  81752e:	85 c0                	test   %eax,%eax
  817530:	74 35                	je     817567 <sys_mbox_free+0x6e>
  817532:	48 b9 51 2a 82 00 00 	movabs $0x822a51,%rcx
  817539:	00 00 00 
  81753c:	48 ba b9 29 82 00 00 	movabs $0x8229b9,%rdx
  817543:	00 00 00 
  817546:	be 62 00 00 00       	mov    $0x62,%esi
  81754b:	48 bf ce 29 82 00 00 	movabs $0x8229ce,%rdi
  817552:	00 00 00 
  817555:	b8 00 00 00 00       	mov    $0x0,%eax
  81755a:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  817561:	00 00 00 
  817564:	41 ff d0             	callq  *%r8
    sys_sem_free(mboxes[mbox].queued_msg);
  817567:	48 b9 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rcx
  81756e:	00 00 00 
  817571:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817574:	48 63 d0             	movslq %eax,%rdx
  817577:	48 89 d0             	mov    %rdx,%rax
  81757a:	48 c1 e0 03          	shl    $0x3,%rax
  81757e:	48 01 d0             	add    %rdx,%rax
  817581:	48 c1 e0 02          	shl    $0x2,%rax
  817585:	48 01 d0             	add    %rdx,%rax
  817588:	48 c1 e0 03          	shl    $0x3,%rax
  81758c:	48 01 c8             	add    %rcx,%rax
  81758f:	48 05 10 01 00 00    	add    $0x110,%rax
  817595:	8b 00                	mov    (%rax),%eax
  817597:	89 c7                	mov    %eax,%edi
  817599:	48 b8 e3 7a 81 00 00 	movabs $0x817ae3,%rax
  8175a0:	00 00 00 
  8175a3:	ff d0                	callq  *%rax
    sys_sem_free(mboxes[mbox].free_msg);
  8175a5:	48 b9 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rcx
  8175ac:	00 00 00 
  8175af:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8175b2:	48 63 d0             	movslq %eax,%rdx
  8175b5:	48 89 d0             	mov    %rdx,%rax
  8175b8:	48 c1 e0 03          	shl    $0x3,%rax
  8175bc:	48 01 d0             	add    %rdx,%rax
  8175bf:	48 c1 e0 02          	shl    $0x2,%rax
  8175c3:	48 01 d0             	add    %rdx,%rax
  8175c6:	48 c1 e0 03          	shl    $0x3,%rax
  8175ca:	48 01 c8             	add    %rcx,%rax
  8175cd:	48 05 10 01 00 00    	add    $0x110,%rax
  8175d3:	8b 40 04             	mov    0x4(%rax),%eax
  8175d6:	89 c7                	mov    %eax,%edi
  8175d8:	48 b8 e3 7a 81 00 00 	movabs $0x817ae3,%rax
  8175df:	00 00 00 
  8175e2:	ff d0                	callq  *%rax
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  8175e4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8175e7:	48 63 d0             	movslq %eax,%rdx
  8175ea:	48 89 d0             	mov    %rdx,%rax
  8175ed:	48 c1 e0 03          	shl    $0x3,%rax
  8175f1:	48 01 d0             	add    %rdx,%rax
  8175f4:	48 c1 e0 02          	shl    $0x2,%rax
  8175f8:	48 01 d0             	add    %rdx,%rax
  8175fb:	48 c1 e0 03          	shl    $0x3,%rax
  8175ff:	48 89 c2             	mov    %rax,%rdx
  817602:	48 b8 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rax
  817609:	00 00 00 
  81760c:	48 01 d0             	add    %rdx,%rax
  81760f:	48 ba c0 6c b5 00 00 	movabs $0xb56cc0,%rdx
  817616:	00 00 00 
  817619:	48 8b 12             	mov    (%rdx),%rdx
  81761c:	48 89 90 18 01 00 00 	mov    %rdx,0x118(%rax)
  817623:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  81762a:	48 85 c0             	test   %rax,%rax
  81762d:	74 45                	je     817674 <sys_mbox_free+0x17b>
  81762f:	48 b8 c0 6c b5 00 00 	movabs $0xb56cc0,%rax
  817636:	00 00 00 
  817639:	48 8b 08             	mov    (%rax),%rcx
  81763c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81763f:	48 63 d0             	movslq %eax,%rdx
  817642:	48 89 d0             	mov    %rdx,%rax
  817645:	48 c1 e0 03          	shl    $0x3,%rax
  817649:	48 01 d0             	add    %rdx,%rax
  81764c:	48 c1 e0 02          	shl    $0x2,%rax
  817650:	48 01 d0             	add    %rdx,%rax
  817653:	48 c1 e0 03          	shl    $0x3,%rax
  817657:	48 89 c2             	mov    %rax,%rdx
  81765a:	48 b8 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rax
  817661:	00 00 00 
  817664:	48 01 d0             	add    %rdx,%rax
  817667:	48 05 18 01 00 00    	add    $0x118,%rax
  81766d:	48 89 81 20 01 00 00 	mov    %rax,0x120(%rcx)
  817674:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817677:	48 63 d0             	movslq %eax,%rdx
  81767a:	48 89 d0             	mov    %rdx,%rax
  81767d:	48 c1 e0 03          	shl    $0x3,%rax
  817681:	48 01 d0             	add    %rdx,%rax
  817684:	48 c1 e0 02          	shl    $0x2,%rax
  817688:	48 01 d0             	add    %rdx,%rax
  81768b:	48 c1 e0 03          	shl    $0x3,%rax
  81768f:	48 89 c2             	mov    %rax,%rdx
  817692:	48 b8 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rax
  817699:	00 00 00 
  81769c:	48 01 c2             	add    %rax,%rdx
  81769f:	48 b8 c0 6c b5 00 00 	movabs $0xb56cc0,%rax
  8176a6:	00 00 00 
  8176a9:	48 89 10             	mov    %rdx,(%rax)
  8176ac:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8176af:	48 63 d0             	movslq %eax,%rdx
  8176b2:	48 89 d0             	mov    %rdx,%rax
  8176b5:	48 c1 e0 03          	shl    $0x3,%rax
  8176b9:	48 01 d0             	add    %rdx,%rax
  8176bc:	48 c1 e0 02          	shl    $0x2,%rax
  8176c0:	48 01 d0             	add    %rdx,%rax
  8176c3:	48 c1 e0 03          	shl    $0x3,%rax
  8176c7:	48 89 c2             	mov    %rax,%rdx
  8176ca:	48 b8 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rax
  8176d1:	00 00 00 
  8176d4:	48 01 d0             	add    %rdx,%rax
  8176d7:	48 ba c0 6c b5 00 00 	movabs $0xb56cc0,%rdx
  8176de:	00 00 00 
  8176e1:	48 89 90 20 01 00 00 	mov    %rdx,0x120(%rax)
    mboxes[mbox].freed = 1;
  8176e8:	48 b9 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rcx
  8176ef:	00 00 00 
  8176f2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8176f5:	48 63 d0             	movslq %eax,%rdx
  8176f8:	48 89 d0             	mov    %rdx,%rax
  8176fb:	48 c1 e0 03          	shl    $0x3,%rax
  8176ff:	48 01 d0             	add    %rdx,%rax
  817702:	48 c1 e0 02          	shl    $0x2,%rax
  817706:	48 01 d0             	add    %rdx,%rax
  817709:	48 c1 e0 03          	shl    $0x3,%rax
  81770d:	48 01 c8             	add    %rcx,%rax
  817710:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
}
  817716:	c9                   	leaveq 
  817717:	c3                   	retq   

0000000000817718 <sys_mbox_post>:

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  817718:	55                   	push   %rbp
  817719:	48 89 e5             	mov    %rsp,%rbp
  81771c:	48 83 ec 10          	sub    $0x10,%rsp
  817720:	89 7d fc             	mov    %edi,-0x4(%rbp)
  817723:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  817727:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81772b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81772e:	48 89 d6             	mov    %rdx,%rsi
  817731:	89 c7                	mov    %eax,%edi
  817733:	48 b8 7a 77 81 00 00 	movabs $0x81777a,%rax
  81773a:	00 00 00 
  81773d:	ff d0                	callq  *%rax
  81773f:	84 c0                	test   %al,%al
  817741:	74 35                	je     817778 <sys_mbox_post+0x60>
  817743:	48 b9 68 2a 82 00 00 	movabs $0x822a68,%rcx
  81774a:	00 00 00 
  81774d:	48 ba b9 29 82 00 00 	movabs $0x8229b9,%rdx
  817754:	00 00 00 
  817757:	be 6c 00 00 00       	mov    $0x6c,%esi
  81775c:	48 bf ce 29 82 00 00 	movabs $0x8229ce,%rdi
  817763:	00 00 00 
  817766:	b8 00 00 00 00       	mov    $0x0,%eax
  81776b:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  817772:	00 00 00 
  817775:	41 ff d0             	callq  *%r8
}
  817778:	c9                   	leaveq 
  817779:	c3                   	retq   

000000000081777a <sys_mbox_trypost>:

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  81777a:	55                   	push   %rbp
  81777b:	48 89 e5             	mov    %rsp,%rbp
  81777e:	48 83 ec 20          	sub    $0x20,%rsp
  817782:	89 7d ec             	mov    %edi,-0x14(%rbp)
  817785:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    assert(!mboxes[mbox].freed);
  817789:	48 b9 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rcx
  817790:	00 00 00 
  817793:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817796:	48 63 d0             	movslq %eax,%rdx
  817799:	48 89 d0             	mov    %rdx,%rax
  81779c:	48 c1 e0 03          	shl    $0x3,%rax
  8177a0:	48 01 d0             	add    %rdx,%rax
  8177a3:	48 c1 e0 02          	shl    $0x2,%rax
  8177a7:	48 01 d0             	add    %rdx,%rax
  8177aa:	48 c1 e0 03          	shl    $0x3,%rax
  8177ae:	48 01 c8             	add    %rcx,%rax
  8177b1:	8b 00                	mov    (%rax),%eax
  8177b3:	85 c0                	test   %eax,%eax
  8177b5:	74 35                	je     8177ec <sys_mbox_trypost+0x72>
  8177b7:	48 b9 51 2a 82 00 00 	movabs $0x822a51,%rcx
  8177be:	00 00 00 
  8177c1:	48 ba b9 29 82 00 00 	movabs $0x8229b9,%rdx
  8177c8:	00 00 00 
  8177cb:	be 72 00 00 00       	mov    $0x72,%esi
  8177d0:	48 bf ce 29 82 00 00 	movabs $0x8229ce,%rdi
  8177d7:	00 00 00 
  8177da:	b8 00 00 00 00       	mov    $0x0,%eax
  8177df:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  8177e6:	00 00 00 
  8177e9:	41 ff d0             	callq  *%r8

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  8177ec:	48 b9 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rcx
  8177f3:	00 00 00 
  8177f6:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8177f9:	48 63 d0             	movslq %eax,%rdx
  8177fc:	48 89 d0             	mov    %rdx,%rax
  8177ff:	48 c1 e0 03          	shl    $0x3,%rax
  817803:	48 01 d0             	add    %rdx,%rax
  817806:	48 c1 e0 02          	shl    $0x2,%rax
  81780a:	48 01 d0             	add    %rdx,%rax
  81780d:	48 c1 e0 03          	shl    $0x3,%rax
  817811:	48 01 c8             	add    %rcx,%rax
  817814:	48 05 10 01 00 00    	add    $0x110,%rax
  81781a:	8b 40 04             	mov    0x4(%rax),%eax
  81781d:	be 00 00 00 00       	mov    $0x0,%esi
  817822:	89 c7                	mov    %eax,%edi
  817824:	48 b8 46 7d 81 00 00 	movabs $0x817d46,%rax
  81782b:	00 00 00 
  81782e:	ff d0                	callq  *%rax
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  817830:	48 b9 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rcx
  817837:	00 00 00 
  81783a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81783d:	48 63 d0             	movslq %eax,%rdx
  817840:	48 89 d0             	mov    %rdx,%rax
  817843:	48 c1 e0 03          	shl    $0x3,%rax
  817847:	48 01 d0             	add    %rdx,%rax
  81784a:	48 c1 e0 02          	shl    $0x2,%rax
  81784e:	48 01 d0             	add    %rdx,%rax
  817851:	48 c1 e0 03          	shl    $0x3,%rax
  817855:	48 01 c8             	add    %rcx,%rax
  817858:	8b 48 08             	mov    0x8(%rax),%ecx
  81785b:	48 be c0 d8 b4 00 00 	movabs $0xb4d8c0,%rsi
  817862:	00 00 00 
  817865:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817868:	48 63 d0             	movslq %eax,%rdx
  81786b:	48 89 d0             	mov    %rdx,%rax
  81786e:	48 c1 e0 03          	shl    $0x3,%rax
  817872:	48 01 d0             	add    %rdx,%rax
  817875:	48 c1 e0 02          	shl    $0x2,%rax
  817879:	48 01 d0             	add    %rdx,%rax
  81787c:	48 c1 e0 03          	shl    $0x3,%rax
  817880:	48 01 f0             	add    %rsi,%rax
  817883:	8b 40 04             	mov    0x4(%rax),%eax
  817886:	39 c1                	cmp    %eax,%ecx
  817888:	75 0a                	jne    817894 <sys_mbox_trypost+0x11a>
	return ERR_MEM;
  81788a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81788f:	e9 4c 01 00 00       	jmpq   8179e0 <sys_mbox_trypost+0x266>

    int slot = mboxes[mbox].nextq;
  817894:	48 b9 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rcx
  81789b:	00 00 00 
  81789e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8178a1:	48 63 d0             	movslq %eax,%rdx
  8178a4:	48 89 d0             	mov    %rdx,%rax
  8178a7:	48 c1 e0 03          	shl    $0x3,%rax
  8178ab:	48 01 d0             	add    %rdx,%rax
  8178ae:	48 c1 e0 02          	shl    $0x2,%rax
  8178b2:	48 01 d0             	add    %rdx,%rax
  8178b5:	48 c1 e0 03          	shl    $0x3,%rax
  8178b9:	48 01 c8             	add    %rcx,%rax
  8178bc:	8b 40 08             	mov    0x8(%rax),%eax
  8178bf:	89 45 fc             	mov    %eax,-0x4(%rbp)
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  8178c2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8178c5:	8d 50 01             	lea    0x1(%rax),%edx
  8178c8:	89 d0                	mov    %edx,%eax
  8178ca:	c1 f8 1f             	sar    $0x1f,%eax
  8178cd:	c1 e8 1b             	shr    $0x1b,%eax
  8178d0:	01 c2                	add    %eax,%edx
  8178d2:	83 e2 1f             	and    $0x1f,%edx
  8178d5:	89 d1                	mov    %edx,%ecx
  8178d7:	29 c1                	sub    %eax,%ecx
  8178d9:	89 c8                	mov    %ecx,%eax
  8178db:	89 c1                	mov    %eax,%ecx
  8178dd:	48 be c0 d8 b4 00 00 	movabs $0xb4d8c0,%rsi
  8178e4:	00 00 00 
  8178e7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8178ea:	48 63 d0             	movslq %eax,%rdx
  8178ed:	48 89 d0             	mov    %rdx,%rax
  8178f0:	48 c1 e0 03          	shl    $0x3,%rax
  8178f4:	48 01 d0             	add    %rdx,%rax
  8178f7:	48 c1 e0 02          	shl    $0x2,%rax
  8178fb:	48 01 d0             	add    %rdx,%rax
  8178fe:	48 c1 e0 03          	shl    $0x3,%rax
  817902:	48 01 f0             	add    %rsi,%rax
  817905:	89 48 08             	mov    %ecx,0x8(%rax)
    mboxes[mbox].msg[slot] = msg;
  817908:	48 b9 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rcx
  81790f:	00 00 00 
  817912:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817915:	48 63 f0             	movslq %eax,%rsi
  817918:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81791b:	48 63 d0             	movslq %eax,%rdx
  81791e:	48 89 d0             	mov    %rdx,%rax
  817921:	48 c1 e0 03          	shl    $0x3,%rax
  817925:	48 01 d0             	add    %rdx,%rax
  817928:	48 c1 e0 02          	shl    $0x2,%rax
  81792c:	48 01 d0             	add    %rdx,%rax
  81792f:	48 01 f0             	add    %rsi,%rax
  817932:	48 8d 50 02          	lea    0x2(%rax),%rdx
  817936:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81793a:	48 89 04 d1          	mov    %rax,(%rcx,%rdx,8)

    if (mboxes[mbox].head == -1)
  81793e:	48 b9 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rcx
  817945:	00 00 00 
  817948:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81794b:	48 63 d0             	movslq %eax,%rdx
  81794e:	48 89 d0             	mov    %rdx,%rax
  817951:	48 c1 e0 03          	shl    $0x3,%rax
  817955:	48 01 d0             	add    %rdx,%rax
  817958:	48 c1 e0 02          	shl    $0x2,%rax
  81795c:	48 01 d0             	add    %rdx,%rax
  81795f:	48 c1 e0 03          	shl    $0x3,%rax
  817963:	48 01 c8             	add    %rcx,%rax
  817966:	8b 40 04             	mov    0x4(%rax),%eax
  817969:	83 f8 ff             	cmp    $0xffffffff,%eax
  81796c:	75 2f                	jne    81799d <sys_mbox_trypost+0x223>
	mboxes[mbox].head = slot;
  81796e:	48 b9 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rcx
  817975:	00 00 00 
  817978:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81797b:	48 63 d0             	movslq %eax,%rdx
  81797e:	48 89 d0             	mov    %rdx,%rax
  817981:	48 c1 e0 03          	shl    $0x3,%rax
  817985:	48 01 d0             	add    %rdx,%rax
  817988:	48 c1 e0 02          	shl    $0x2,%rax
  81798c:	48 01 d0             	add    %rdx,%rax
  81798f:	48 c1 e0 03          	shl    $0x3,%rax
  817993:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  817997:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81799a:	89 42 04             	mov    %eax,0x4(%rdx)

    sys_sem_signal(mboxes[mbox].queued_msg);
  81799d:	48 b9 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rcx
  8179a4:	00 00 00 
  8179a7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8179aa:	48 63 d0             	movslq %eax,%rdx
  8179ad:	48 89 d0             	mov    %rdx,%rax
  8179b0:	48 c1 e0 03          	shl    $0x3,%rax
  8179b4:	48 01 d0             	add    %rdx,%rax
  8179b7:	48 c1 e0 02          	shl    $0x2,%rax
  8179bb:	48 01 d0             	add    %rdx,%rax
  8179be:	48 c1 e0 03          	shl    $0x3,%rax
  8179c2:	48 01 c8             	add    %rcx,%rax
  8179c5:	48 05 10 01 00 00    	add    $0x110,%rax
  8179cb:	8b 00                	mov    (%rax),%eax
  8179cd:	89 c7                	mov    %eax,%edi
  8179cf:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  8179d6:	00 00 00 
  8179d9:	ff d0                	callq  *%rax

    return ERR_OK;
  8179db:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8179e0:	c9                   	leaveq 
  8179e1:	c3                   	retq   

00000000008179e2 <sys_sem_new>:

sys_sem_t
sys_sem_new(u8_t count)
{
  8179e2:	55                   	push   %rbp
  8179e3:	48 89 e5             	mov    %rsp,%rbp
  8179e6:	48 83 ec 20          	sub    $0x20,%rsp
  8179ea:	89 f8                	mov    %edi,%eax
  8179ec:	88 45 ec             	mov    %al,-0x14(%rbp)
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  8179ef:	48 b8 a0 d8 b4 00 00 	movabs $0xb4d8a0,%rax
  8179f6:	00 00 00 
  8179f9:	48 8b 00             	mov    (%rax),%rax
  8179fc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!se) {
  817a00:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  817a05:	75 25                	jne    817a2c <sys_sem_new+0x4a>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  817a07:	48 bf 90 2a 82 00 00 	movabs $0x822a90,%rdi
  817a0e:	00 00 00 
  817a11:	b8 00 00 00 00       	mov    $0x0,%eax
  817a16:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  817a1d:	00 00 00 
  817a20:	ff d2                	callq  *%rdx
	return SYS_SEM_NULL;
  817a22:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817a27:	e9 b5 00 00 00       	jmpq   817ae1 <sys_sem_new+0xff>
    }
    LIST_REMOVE(se, link);
  817a2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817a30:	48 8b 40 10          	mov    0x10(%rax),%rax
  817a34:	48 85 c0             	test   %rax,%rax
  817a37:	74 14                	je     817a4d <sys_sem_new+0x6b>
  817a39:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817a3d:	48 8b 40 10          	mov    0x10(%rax),%rax
  817a41:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817a45:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  817a49:	48 89 50 18          	mov    %rdx,0x18(%rax)
  817a4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817a51:	48 8b 40 18          	mov    0x18(%rax),%rax
  817a55:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817a59:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  817a5d:	48 89 10             	mov    %rdx,(%rax)
    assert(se->freed);
  817a60:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817a64:	8b 00                	mov    (%rax),%eax
  817a66:	85 c0                	test   %eax,%eax
  817a68:	75 35                	jne    817a9f <sys_sem_new+0xbd>
  817a6a:	48 b9 b6 2a 82 00 00 	movabs $0x822ab6,%rcx
  817a71:	00 00 00 
  817a74:	48 ba b9 29 82 00 00 	movabs $0x8229b9,%rdx
  817a7b:	00 00 00 
  817a7e:	be 8d 00 00 00       	mov    $0x8d,%esi
  817a83:	48 bf ce 29 82 00 00 	movabs $0x8229ce,%rdi
  817a8a:	00 00 00 
  817a8d:	b8 00 00 00 00       	mov    $0x0,%eax
  817a92:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  817a99:	00 00 00 
  817a9c:	41 ff d0             	callq  *%r8
    se->freed = 0;
  817a9f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817aa3:	c7 00 00 00 00 00    	movl   $0x0,(%rax)

    se->counter = count;
  817aa9:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  817aad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817ab1:	66 89 50 08          	mov    %dx,0x8(%rax)
    se->gen++;
  817ab5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817ab9:	8b 40 04             	mov    0x4(%rax),%eax
  817abc:	8d 50 01             	lea    0x1(%rax),%edx
  817abf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  817ac3:	89 50 04             	mov    %edx,0x4(%rax)
    return se - &sems[0];
  817ac6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  817aca:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  817ad1:	00 00 00 
  817ad4:	48 89 d1             	mov    %rdx,%rcx
  817ad7:	48 29 c1             	sub    %rax,%rcx
  817ada:	48 89 c8             	mov    %rcx,%rax
  817add:	48 c1 f8 05          	sar    $0x5,%rax
}
  817ae1:	c9                   	leaveq 
  817ae2:	c3                   	retq   

0000000000817ae3 <sys_sem_free>:

void
sys_sem_free(sys_sem_t sem)
{
  817ae3:	55                   	push   %rbp
  817ae4:	48 89 e5             	mov    %rsp,%rbp
  817ae7:	48 83 ec 10          	sub    $0x10,%rsp
  817aeb:	89 7d fc             	mov    %edi,-0x4(%rbp)
    assert(!sems[sem].freed);
  817aee:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  817af5:	00 00 00 
  817af8:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817afb:	48 63 d2             	movslq %edx,%rdx
  817afe:	48 c1 e2 05          	shl    $0x5,%rdx
  817b02:	48 01 d0             	add    %rdx,%rax
  817b05:	8b 00                	mov    (%rax),%eax
  817b07:	85 c0                	test   %eax,%eax
  817b09:	74 35                	je     817b40 <sys_sem_free+0x5d>
  817b0b:	48 b9 c0 2a 82 00 00 	movabs $0x822ac0,%rcx
  817b12:	00 00 00 
  817b15:	48 ba b9 29 82 00 00 	movabs $0x8229b9,%rdx
  817b1c:	00 00 00 
  817b1f:	be 98 00 00 00       	mov    $0x98,%esi
  817b24:	48 bf ce 29 82 00 00 	movabs $0x8229ce,%rdi
  817b2b:	00 00 00 
  817b2e:	b8 00 00 00 00       	mov    $0x0,%eax
  817b33:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  817b3a:	00 00 00 
  817b3d:	41 ff d0             	callq  *%r8
    sems[sem].freed = 1;
  817b40:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  817b47:	00 00 00 
  817b4a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817b4d:	48 63 d2             	movslq %edx,%rdx
  817b50:	48 c1 e2 05          	shl    $0x5,%rdx
  817b54:	48 01 d0             	add    %rdx,%rax
  817b57:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    sems[sem].gen++;
  817b5d:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  817b64:	00 00 00 
  817b67:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817b6a:	48 63 d2             	movslq %edx,%rdx
  817b6d:	48 c1 e2 05          	shl    $0x5,%rdx
  817b71:	48 01 d0             	add    %rdx,%rax
  817b74:	8b 40 04             	mov    0x4(%rax),%eax
  817b77:	8d 50 01             	lea    0x1(%rax),%edx
  817b7a:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  817b81:	00 00 00 
  817b84:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  817b87:	48 63 c9             	movslq %ecx,%rcx
  817b8a:	48 c1 e1 05          	shl    $0x5,%rcx
  817b8e:	48 01 c8             	add    %rcx,%rax
  817b91:	89 50 04             	mov    %edx,0x4(%rax)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  817b94:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817b97:	48 98                	cltq   
  817b99:	48 89 c2             	mov    %rax,%rdx
  817b9c:	48 c1 e2 05          	shl    $0x5,%rdx
  817ba0:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  817ba7:	00 00 00 
  817baa:	48 01 d0             	add    %rdx,%rax
  817bad:	48 ba a0 d8 b4 00 00 	movabs $0xb4d8a0,%rdx
  817bb4:	00 00 00 
  817bb7:	48 8b 12             	mov    (%rdx),%rdx
  817bba:	48 89 50 10          	mov    %rdx,0x10(%rax)
  817bbe:	48 8b 40 10          	mov    0x10(%rax),%rax
  817bc2:	48 85 c0             	test   %rax,%rax
  817bc5:	74 2f                	je     817bf6 <sys_sem_free+0x113>
  817bc7:	48 b8 a0 d8 b4 00 00 	movabs $0xb4d8a0,%rax
  817bce:	00 00 00 
  817bd1:	48 8b 00             	mov    (%rax),%rax
  817bd4:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817bd7:	48 63 d2             	movslq %edx,%rdx
  817bda:	48 89 d1             	mov    %rdx,%rcx
  817bdd:	48 c1 e1 05          	shl    $0x5,%rcx
  817be1:	48 ba a0 b8 b4 00 00 	movabs $0xb4b8a0,%rdx
  817be8:	00 00 00 
  817beb:	48 01 ca             	add    %rcx,%rdx
  817bee:	48 83 c2 10          	add    $0x10,%rdx
  817bf2:	48 89 50 18          	mov    %rdx,0x18(%rax)
  817bf6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817bf9:	48 98                	cltq   
  817bfb:	48 89 c2             	mov    %rax,%rdx
  817bfe:	48 c1 e2 05          	shl    $0x5,%rdx
  817c02:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  817c09:	00 00 00 
  817c0c:	48 01 c2             	add    %rax,%rdx
  817c0f:	48 b8 a0 d8 b4 00 00 	movabs $0xb4d8a0,%rax
  817c16:	00 00 00 
  817c19:	48 89 10             	mov    %rdx,(%rax)
  817c1c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817c1f:	48 98                	cltq   
  817c21:	48 89 c2             	mov    %rax,%rdx
  817c24:	48 c1 e2 05          	shl    $0x5,%rdx
  817c28:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  817c2f:	00 00 00 
  817c32:	48 01 d0             	add    %rdx,%rax
  817c35:	48 ba a0 d8 b4 00 00 	movabs $0xb4d8a0,%rdx
  817c3c:	00 00 00 
  817c3f:	48 89 50 18          	mov    %rdx,0x18(%rax)
}
  817c43:	c9                   	leaveq 
  817c44:	c3                   	retq   

0000000000817c45 <sys_sem_signal>:

void
sys_sem_signal(sys_sem_t sem)
{
  817c45:	55                   	push   %rbp
  817c46:	48 89 e5             	mov    %rsp,%rbp
  817c49:	48 83 ec 10          	sub    $0x10,%rsp
  817c4d:	89 7d fc             	mov    %edi,-0x4(%rbp)
    assert(!sems[sem].freed);
  817c50:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  817c57:	00 00 00 
  817c5a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817c5d:	48 63 d2             	movslq %edx,%rdx
  817c60:	48 c1 e2 05          	shl    $0x5,%rdx
  817c64:	48 01 d0             	add    %rdx,%rax
  817c67:	8b 00                	mov    (%rax),%eax
  817c69:	85 c0                	test   %eax,%eax
  817c6b:	74 35                	je     817ca2 <sys_sem_signal+0x5d>
  817c6d:	48 b9 c0 2a 82 00 00 	movabs $0x822ac0,%rcx
  817c74:	00 00 00 
  817c77:	48 ba b9 29 82 00 00 	movabs $0x8229b9,%rdx
  817c7e:	00 00 00 
  817c81:	be a1 00 00 00       	mov    $0xa1,%esi
  817c86:	48 bf ce 29 82 00 00 	movabs $0x8229ce,%rdi
  817c8d:	00 00 00 
  817c90:	b8 00 00 00 00       	mov    $0x0,%eax
  817c95:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  817c9c:	00 00 00 
  817c9f:	41 ff d0             	callq  *%r8
    sems[sem].counter++;
  817ca2:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  817ca9:	00 00 00 
  817cac:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817caf:	48 63 d2             	movslq %edx,%rdx
  817cb2:	48 c1 e2 05          	shl    $0x5,%rdx
  817cb6:	48 01 d0             	add    %rdx,%rax
  817cb9:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  817cbd:	8d 50 01             	lea    0x1(%rax),%edx
  817cc0:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  817cc7:	00 00 00 
  817cca:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  817ccd:	48 63 c9             	movslq %ecx,%rcx
  817cd0:	48 c1 e1 05          	shl    $0x5,%rcx
  817cd4:	48 01 c8             	add    %rcx,%rax
  817cd7:	66 89 50 08          	mov    %dx,0x8(%rax)
    if (sems[sem].waiters) {
  817cdb:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  817ce2:	00 00 00 
  817ce5:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817ce8:	48 63 d2             	movslq %edx,%rdx
  817ceb:	48 c1 e2 05          	shl    $0x5,%rdx
  817cef:	48 01 d0             	add    %rdx,%rax
  817cf2:	0f b7 40 0a          	movzwl 0xa(%rax),%eax
  817cf6:	66 85 c0             	test   %ax,%ax
  817cf9:	74 49                	je     817d44 <sys_sem_signal+0xff>
	sems[sem].waiters = 0;
  817cfb:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  817d02:	00 00 00 
  817d05:	8b 55 fc             	mov    -0x4(%rbp),%edx
  817d08:	48 63 d2             	movslq %edx,%rdx
  817d0b:	48 c1 e2 05          	shl    $0x5,%rdx
  817d0f:	48 01 d0             	add    %rdx,%rax
  817d12:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
	thread_wakeup(&sems[sem].v);
  817d18:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817d1b:	48 98                	cltq   
  817d1d:	48 89 c2             	mov    %rax,%rdx
  817d20:	48 c1 e2 05          	shl    $0x5,%rdx
  817d24:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  817d2b:	00 00 00 
  817d2e:	48 01 d0             	add    %rdx,%rax
  817d31:	48 83 c0 08          	add    $0x8,%rax
  817d35:	48 89 c7             	mov    %rax,%rdi
  817d38:	48 b8 cc 87 81 00 00 	movabs $0x8187cc,%rax
  817d3f:	00 00 00 
  817d42:	ff d0                	callq  *%rax
    }
}
  817d44:	c9                   	leaveq 
  817d45:	c3                   	retq   

0000000000817d46 <sys_arch_sem_wait>:

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  817d46:	55                   	push   %rbp
  817d47:	48 89 e5             	mov    %rsp,%rbp
  817d4a:	48 83 ec 30          	sub    $0x30,%rsp
  817d4e:	89 7d dc             	mov    %edi,-0x24(%rbp)
  817d51:	89 75 d8             	mov    %esi,-0x28(%rbp)
    assert(!sems[sem].freed);
  817d54:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  817d5b:	00 00 00 
  817d5e:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817d61:	48 63 d2             	movslq %edx,%rdx
  817d64:	48 c1 e2 05          	shl    $0x5,%rdx
  817d68:	48 01 d0             	add    %rdx,%rax
  817d6b:	8b 00                	mov    (%rax),%eax
  817d6d:	85 c0                	test   %eax,%eax
  817d6f:	74 35                	je     817da6 <sys_arch_sem_wait+0x60>
  817d71:	48 b9 c0 2a 82 00 00 	movabs $0x822ac0,%rcx
  817d78:	00 00 00 
  817d7b:	48 ba b9 29 82 00 00 	movabs $0x8229b9,%rdx
  817d82:	00 00 00 
  817d85:	be ac 00 00 00       	mov    $0xac,%esi
  817d8a:	48 bf ce 29 82 00 00 	movabs $0x8229ce,%rdi
  817d91:	00 00 00 
  817d94:	b8 00 00 00 00       	mov    $0x0,%eax
  817d99:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  817da0:	00 00 00 
  817da3:	41 ff d0             	callq  *%r8
    u32_t waited = 0;
  817da6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)

    int gen = sems[sem].gen;
  817dad:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  817db4:	00 00 00 
  817db7:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817dba:	48 63 d2             	movslq %edx,%rdx
  817dbd:	48 c1 e2 05          	shl    $0x5,%rdx
  817dc1:	48 01 d0             	add    %rdx,%rax
  817dc4:	8b 40 04             	mov    0x4(%rax),%eax
  817dc7:	89 45 f8             	mov    %eax,-0x8(%rbp)

    while (tm_msec == 0 || waited < tm_msec) {
  817dca:	e9 84 01 00 00       	jmpq   817f53 <sys_arch_sem_wait+0x20d>
	if (sems[sem].counter > 0) {
  817dcf:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  817dd6:	00 00 00 
  817dd9:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817ddc:	48 63 d2             	movslq %edx,%rdx
  817ddf:	48 c1 e2 05          	shl    $0x5,%rdx
  817de3:	48 01 d0             	add    %rdx,%rax
  817de6:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  817dea:	66 85 c0             	test   %ax,%ax
  817ded:	74 41                	je     817e30 <sys_arch_sem_wait+0xea>
	    sems[sem].counter--;
  817def:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  817df6:	00 00 00 
  817df9:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817dfc:	48 63 d2             	movslq %edx,%rdx
  817dff:	48 c1 e2 05          	shl    $0x5,%rdx
  817e03:	48 01 d0             	add    %rdx,%rax
  817e06:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  817e0a:	8d 50 ff             	lea    -0x1(%rax),%edx
  817e0d:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  817e14:	00 00 00 
  817e17:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  817e1a:	48 63 c9             	movslq %ecx,%rcx
  817e1d:	48 c1 e1 05          	shl    $0x5,%rcx
  817e21:	48 01 c8             	add    %rcx,%rax
  817e24:	66 89 50 08          	mov    %dx,0x8(%rax)
	    return waited;
  817e28:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817e2b:	e9 3e 01 00 00       	jmpq   817f6e <sys_arch_sem_wait+0x228>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  817e30:	83 7d d8 fe          	cmpl   $0xfffffffe,-0x28(%rbp)
  817e34:	75 0a                	jne    817e40 <sys_arch_sem_wait+0xfa>
	    return SYS_ARCH_TIMEOUT;
  817e36:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817e3b:	e9 2e 01 00 00       	jmpq   817f6e <sys_arch_sem_wait+0x228>
	} else {
	    uint32_t a = sys_time_msec();
  817e40:	48 b8 69 2a 80 00 00 	movabs $0x802a69,%rax
  817e47:	00 00 00 
  817e4a:	ff d0                	callq  *%rax
  817e4c:	89 45 f4             	mov    %eax,-0xc(%rbp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  817e4f:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  817e53:	74 11                	je     817e66 <sys_arch_sem_wait+0x120>
  817e55:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817e58:	8b 55 d8             	mov    -0x28(%rbp),%edx
  817e5b:	89 d1                	mov    %edx,%ecx
  817e5d:	29 c1                	sub    %eax,%ecx
  817e5f:	89 c8                	mov    %ecx,%eax
  817e61:	03 45 f4             	add    -0xc(%rbp),%eax
  817e64:	eb 05                	jmp    817e6b <sys_arch_sem_wait+0x125>
  817e66:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817e6b:	89 45 f0             	mov    %eax,-0x10(%rbp)
	    sems[sem].waiters = 1;
  817e6e:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  817e75:	00 00 00 
  817e78:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817e7b:	48 63 d2             	movslq %edx,%rdx
  817e7e:	48 c1 e2 05          	shl    $0x5,%rdx
  817e82:	48 01 d0             	add    %rdx,%rax
  817e85:	66 c7 40 0a 01 00    	movw   $0x1,0xa(%rax)
	    uint32_t cur_v = sems[sem].v;
  817e8b:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  817e92:	00 00 00 
  817e95:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817e98:	48 63 d2             	movslq %edx,%rdx
  817e9b:	48 c1 e2 05          	shl    $0x5,%rdx
  817e9f:	48 01 d0             	add    %rdx,%rax
  817ea2:	8b 40 08             	mov    0x8(%rax),%eax
  817ea5:	89 45 ec             	mov    %eax,-0x14(%rbp)
	    lwip_core_unlock();
  817ea8:	48 b8 aa 86 81 00 00 	movabs $0x8186aa,%rax
  817eaf:	00 00 00 
  817eb2:	ff d0                	callq  *%rax
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  817eb4:	8b 45 dc             	mov    -0x24(%rbp),%eax
  817eb7:	48 98                	cltq   
  817eb9:	48 89 c2             	mov    %rax,%rdx
  817ebc:	48 c1 e2 05          	shl    $0x5,%rdx
  817ec0:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  817ec7:	00 00 00 
  817eca:	48 01 d0             	add    %rdx,%rax
  817ecd:	48 8d 48 08          	lea    0x8(%rax),%rcx
  817ed1:	8b 55 f0             	mov    -0x10(%rbp),%edx
  817ed4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817ed7:	89 c6                	mov    %eax,%esi
  817ed9:	48 89 cf             	mov    %rcx,%rdi
  817edc:	48 b8 1f 88 81 00 00 	movabs $0x81881f,%rax
  817ee3:	00 00 00 
  817ee6:	ff d0                	callq  *%rax
	    lwip_core_lock();
  817ee8:	48 b8 a4 86 81 00 00 	movabs $0x8186a4,%rax
  817eef:	00 00 00 
  817ef2:	ff d0                	callq  *%rax
	    if (gen != sems[sem].gen) {
  817ef4:	48 b8 a0 b8 b4 00 00 	movabs $0xb4b8a0,%rax
  817efb:	00 00 00 
  817efe:	8b 55 dc             	mov    -0x24(%rbp),%edx
  817f01:	48 63 d2             	movslq %edx,%rdx
  817f04:	48 c1 e2 05          	shl    $0x5,%rdx
  817f08:	48 01 d0             	add    %rdx,%rax
  817f0b:	8b 40 04             	mov    0x4(%rax),%eax
  817f0e:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  817f11:	74 22                	je     817f35 <sys_arch_sem_wait+0x1ef>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  817f13:	48 bf d8 2a 82 00 00 	movabs $0x822ad8,%rdi
  817f1a:	00 00 00 
  817f1d:	b8 00 00 00 00       	mov    $0x0,%eax
  817f22:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  817f29:	00 00 00 
  817f2c:	ff d2                	callq  *%rdx
		return SYS_ARCH_TIMEOUT;
  817f2e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  817f33:	eb 39                	jmp    817f6e <sys_arch_sem_wait+0x228>
	    }
	    uint32_t b = sys_time_msec();
  817f35:	48 b8 69 2a 80 00 00 	movabs $0x802a69,%rax
  817f3c:	00 00 00 
  817f3f:	ff d0                	callq  *%rax
  817f41:	89 45 e8             	mov    %eax,-0x18(%rbp)
	    waited += (b - a);
  817f44:	8b 45 f4             	mov    -0xc(%rbp),%eax
  817f47:	8b 55 e8             	mov    -0x18(%rbp),%edx
  817f4a:	89 d1                	mov    %edx,%ecx
  817f4c:	29 c1                	sub    %eax,%ecx
  817f4e:	89 c8                	mov    %ecx,%eax
  817f50:	01 45 fc             	add    %eax,-0x4(%rbp)
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  817f53:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  817f57:	0f 84 72 fe ff ff    	je     817dcf <sys_arch_sem_wait+0x89>
  817f5d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  817f60:	3b 45 d8             	cmp    -0x28(%rbp),%eax
  817f63:	0f 82 66 fe ff ff    	jb     817dcf <sys_arch_sem_wait+0x89>
	    uint32_t b = sys_time_msec();
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
  817f69:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  817f6e:	c9                   	leaveq 
  817f6f:	c3                   	retq   

0000000000817f70 <sys_arch_mbox_fetch>:

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  817f70:	55                   	push   %rbp
  817f71:	48 89 e5             	mov    %rsp,%rbp
  817f74:	48 83 ec 20          	sub    $0x20,%rsp
  817f78:	89 7d ec             	mov    %edi,-0x14(%rbp)
  817f7b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  817f7f:	89 55 e8             	mov    %edx,-0x18(%rbp)
    assert(!mboxes[mbox].freed);
  817f82:	48 b9 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rcx
  817f89:	00 00 00 
  817f8c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817f8f:	48 63 d0             	movslq %eax,%rdx
  817f92:	48 89 d0             	mov    %rdx,%rax
  817f95:	48 c1 e0 03          	shl    $0x3,%rax
  817f99:	48 01 d0             	add    %rdx,%rax
  817f9c:	48 c1 e0 02          	shl    $0x2,%rax
  817fa0:	48 01 d0             	add    %rdx,%rax
  817fa3:	48 c1 e0 03          	shl    $0x3,%rax
  817fa7:	48 01 c8             	add    %rcx,%rax
  817faa:	8b 00                	mov    (%rax),%eax
  817fac:	85 c0                	test   %eax,%eax
  817fae:	74 35                	je     817fe5 <sys_arch_mbox_fetch+0x75>
  817fb0:	48 b9 51 2a 82 00 00 	movabs $0x822a51,%rcx
  817fb7:	00 00 00 
  817fba:	48 ba b9 29 82 00 00 	movabs $0x8229b9,%rdx
  817fc1:	00 00 00 
  817fc4:	be ce 00 00 00       	mov    $0xce,%esi
  817fc9:	48 bf ce 29 82 00 00 	movabs $0x8229ce,%rdi
  817fd0:	00 00 00 
  817fd3:	b8 00 00 00 00       	mov    $0x0,%eax
  817fd8:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  817fdf:	00 00 00 
  817fe2:	41 ff d0             	callq  *%r8

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  817fe5:	48 b9 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rcx
  817fec:	00 00 00 
  817fef:	8b 45 ec             	mov    -0x14(%rbp),%eax
  817ff2:	48 63 d0             	movslq %eax,%rdx
  817ff5:	48 89 d0             	mov    %rdx,%rax
  817ff8:	48 c1 e0 03          	shl    $0x3,%rax
  817ffc:	48 01 d0             	add    %rdx,%rax
  817fff:	48 c1 e0 02          	shl    $0x2,%rax
  818003:	48 01 d0             	add    %rdx,%rax
  818006:	48 c1 e0 03          	shl    $0x3,%rax
  81800a:	48 01 c8             	add    %rcx,%rax
  81800d:	48 05 10 01 00 00    	add    $0x110,%rax
  818013:	8b 00                	mov    (%rax),%eax
  818015:	8b 55 e8             	mov    -0x18(%rbp),%edx
  818018:	89 d6                	mov    %edx,%esi
  81801a:	89 c7                	mov    %eax,%edi
  81801c:	48 b8 46 7d 81 00 00 	movabs $0x817d46,%rax
  818023:	00 00 00 
  818026:	ff d0                	callq  *%rax
  818028:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (waited == SYS_ARCH_TIMEOUT)
  81802b:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  81802f:	75 08                	jne    818039 <sys_arch_mbox_fetch+0xc9>
	return waited;
  818031:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818034:	e9 af 01 00 00       	jmpq   8181e8 <sys_arch_mbox_fetch+0x278>

    int slot = mboxes[mbox].head;
  818039:	48 b9 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rcx
  818040:	00 00 00 
  818043:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818046:	48 63 d0             	movslq %eax,%rdx
  818049:	48 89 d0             	mov    %rdx,%rax
  81804c:	48 c1 e0 03          	shl    $0x3,%rax
  818050:	48 01 d0             	add    %rdx,%rax
  818053:	48 c1 e0 02          	shl    $0x2,%rax
  818057:	48 01 d0             	add    %rdx,%rax
  81805a:	48 c1 e0 03          	shl    $0x3,%rax
  81805e:	48 01 c8             	add    %rcx,%rax
  818061:	8b 40 04             	mov    0x4(%rax),%eax
  818064:	89 45 f8             	mov    %eax,-0x8(%rbp)
    if (slot == -1)
  818067:	83 7d f8 ff          	cmpl   $0xffffffff,-0x8(%rbp)
  81806b:	75 2a                	jne    818097 <sys_arch_mbox_fetch+0x127>
	panic("lwip: sys_arch_mbox_fetch: no message");
  81806d:	48 ba 08 2b 82 00 00 	movabs $0x822b08,%rdx
  818074:	00 00 00 
  818077:	be d6 00 00 00       	mov    $0xd6,%esi
  81807c:	48 bf ce 29 82 00 00 	movabs $0x8229ce,%rdi
  818083:	00 00 00 
  818086:	b8 00 00 00 00       	mov    $0x0,%eax
  81808b:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  818092:	00 00 00 
  818095:	ff d1                	callq  *%rcx
    if (msg)
  818097:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81809c:	74 39                	je     8180d7 <sys_arch_mbox_fetch+0x167>
	*msg = mboxes[mbox].msg[slot];
  81809e:	48 b9 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rcx
  8180a5:	00 00 00 
  8180a8:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8180ab:	48 63 f0             	movslq %eax,%rsi
  8180ae:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8180b1:	48 63 d0             	movslq %eax,%rdx
  8180b4:	48 89 d0             	mov    %rdx,%rax
  8180b7:	48 c1 e0 03          	shl    $0x3,%rax
  8180bb:	48 01 d0             	add    %rdx,%rax
  8180be:	48 c1 e0 02          	shl    $0x2,%rax
  8180c2:	48 01 d0             	add    %rdx,%rax
  8180c5:	48 01 f0             	add    %rsi,%rax
  8180c8:	48 83 c0 02          	add    $0x2,%rax
  8180cc:	48 8b 14 c1          	mov    (%rcx,%rax,8),%rdx
  8180d0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8180d4:	48 89 10             	mov    %rdx,(%rax)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  8180d7:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8180da:	8d 50 01             	lea    0x1(%rax),%edx
  8180dd:	89 d0                	mov    %edx,%eax
  8180df:	c1 f8 1f             	sar    $0x1f,%eax
  8180e2:	c1 e8 1b             	shr    $0x1b,%eax
  8180e5:	01 c2                	add    %eax,%edx
  8180e7:	83 e2 1f             	and    $0x1f,%edx
  8180ea:	89 d1                	mov    %edx,%ecx
  8180ec:	29 c1                	sub    %eax,%ecx
  8180ee:	89 c8                	mov    %ecx,%eax
  8180f0:	89 c1                	mov    %eax,%ecx
  8180f2:	48 be c0 d8 b4 00 00 	movabs $0xb4d8c0,%rsi
  8180f9:	00 00 00 
  8180fc:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8180ff:	48 63 d0             	movslq %eax,%rdx
  818102:	48 89 d0             	mov    %rdx,%rax
  818105:	48 c1 e0 03          	shl    $0x3,%rax
  818109:	48 01 d0             	add    %rdx,%rax
  81810c:	48 c1 e0 02          	shl    $0x2,%rax
  818110:	48 01 d0             	add    %rdx,%rax
  818113:	48 c1 e0 03          	shl    $0x3,%rax
  818117:	48 01 f0             	add    %rsi,%rax
  81811a:	89 48 04             	mov    %ecx,0x4(%rax)
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  81811d:	48 b9 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rcx
  818124:	00 00 00 
  818127:	8b 45 ec             	mov    -0x14(%rbp),%eax
  81812a:	48 63 d0             	movslq %eax,%rdx
  81812d:	48 89 d0             	mov    %rdx,%rax
  818130:	48 c1 e0 03          	shl    $0x3,%rax
  818134:	48 01 d0             	add    %rdx,%rax
  818137:	48 c1 e0 02          	shl    $0x2,%rax
  81813b:	48 01 d0             	add    %rdx,%rax
  81813e:	48 c1 e0 03          	shl    $0x3,%rax
  818142:	48 01 c8             	add    %rcx,%rax
  818145:	8b 48 04             	mov    0x4(%rax),%ecx
  818148:	48 be c0 d8 b4 00 00 	movabs $0xb4d8c0,%rsi
  81814f:	00 00 00 
  818152:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818155:	48 63 d0             	movslq %eax,%rdx
  818158:	48 89 d0             	mov    %rdx,%rax
  81815b:	48 c1 e0 03          	shl    $0x3,%rax
  81815f:	48 01 d0             	add    %rdx,%rax
  818162:	48 c1 e0 02          	shl    $0x2,%rax
  818166:	48 01 d0             	add    %rdx,%rax
  818169:	48 c1 e0 03          	shl    $0x3,%rax
  81816d:	48 01 f0             	add    %rsi,%rax
  818170:	8b 40 08             	mov    0x8(%rax),%eax
  818173:	39 c1                	cmp    %eax,%ecx
  818175:	75 2f                	jne    8181a6 <sys_arch_mbox_fetch+0x236>
	mboxes[mbox].head = -1;
  818177:	48 b9 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rcx
  81817e:	00 00 00 
  818181:	8b 45 ec             	mov    -0x14(%rbp),%eax
  818184:	48 63 d0             	movslq %eax,%rdx
  818187:	48 89 d0             	mov    %rdx,%rax
  81818a:	48 c1 e0 03          	shl    $0x3,%rax
  81818e:	48 01 d0             	add    %rdx,%rax
  818191:	48 c1 e0 02          	shl    $0x2,%rax
  818195:	48 01 d0             	add    %rdx,%rax
  818198:	48 c1 e0 03          	shl    $0x3,%rax
  81819c:	48 01 c8             	add    %rcx,%rax
  81819f:	c7 40 04 ff ff ff ff 	movl   $0xffffffff,0x4(%rax)

    sys_sem_signal(mboxes[mbox].free_msg);
  8181a6:	48 b9 c0 d8 b4 00 00 	movabs $0xb4d8c0,%rcx
  8181ad:	00 00 00 
  8181b0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8181b3:	48 63 d0             	movslq %eax,%rdx
  8181b6:	48 89 d0             	mov    %rdx,%rax
  8181b9:	48 c1 e0 03          	shl    $0x3,%rax
  8181bd:	48 01 d0             	add    %rdx,%rax
  8181c0:	48 c1 e0 02          	shl    $0x2,%rax
  8181c4:	48 01 d0             	add    %rdx,%rax
  8181c7:	48 c1 e0 03          	shl    $0x3,%rax
  8181cb:	48 01 c8             	add    %rcx,%rax
  8181ce:	48 05 10 01 00 00    	add    $0x110,%rax
  8181d4:	8b 40 04             	mov    0x4(%rax),%eax
  8181d7:	89 c7                	mov    %eax,%edi
  8181d9:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  8181e0:	00 00 00 
  8181e3:	ff d0                	callq  *%rax
    return waited;
  8181e5:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8181e8:	c9                   	leaveq 
  8181e9:	c3                   	retq   

00000000008181ea <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  8181ea:	55                   	push   %rbp
  8181eb:	48 89 e5             	mov    %rsp,%rbp
  8181ee:	48 83 ec 10          	sub    $0x10,%rsp
  8181f2:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8181f5:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  8181f9:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8181fd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818200:	ba fe ff ff ff       	mov    $0xfffffffe,%edx
  818205:	48 89 ce             	mov    %rcx,%rsi
  818208:	89 c7                	mov    %eax,%edi
  81820a:	48 b8 70 7f 81 00 00 	movabs $0x817f70,%rax
  818211:	00 00 00 
  818214:	ff d0                	callq  *%rax
}
  818216:	c9                   	leaveq 
  818217:	c3                   	retq   

0000000000818218 <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint64_t arg)
{
  818218:	55                   	push   %rbp
  818219:	48 89 e5             	mov    %rsp,%rbp
  81821c:	48 83 ec 20          	sub    $0x20,%rsp
  818220:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    struct lwip_thread *lt = (struct lwip_thread *)arg;
  818224:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818228:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    lwip_core_lock();
  81822c:	48 b8 a4 86 81 00 00 	movabs $0x8186a4,%rax
  818233:	00 00 00 
  818236:	ff d0                	callq  *%rax
    lt->func(lt->arg);
  818238:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81823c:	48 8b 10             	mov    (%rax),%rdx
  81823f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818243:	48 8b 40 08          	mov    0x8(%rax),%rax
  818247:	48 89 c7             	mov    %rax,%rdi
  81824a:	ff d2                	callq  *%rdx
    lwip_core_unlock();
  81824c:	48 b8 aa 86 81 00 00 	movabs $0x8186aa,%rax
  818253:	00 00 00 
  818256:	ff d0                	callq  *%rax
    free(lt);
  818258:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81825c:	48 89 c7             	mov    %rax,%rdi
  81825f:	48 b8 35 4d 80 00 00 	movabs $0x804d35,%rax
  818266:	00 00 00 
  818269:	ff d0                	callq  *%rax
}
  81826b:	c9                   	leaveq 
  81826c:	c3                   	retq   

000000000081826d <sys_thread_new>:

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  81826d:	55                   	push   %rbp
  81826e:	48 89 e5             	mov    %rsp,%rbp
  818271:	48 83 ec 30          	sub    $0x30,%rsp
  818275:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  818279:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81827d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  818281:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  818284:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
    struct lwip_thread *lt = malloc(sizeof(*lt));
  818288:	bf 10 00 00 00       	mov    $0x10,%edi
  81828d:	48 b8 b5 49 80 00 00 	movabs $0x8049b5,%rax
  818294:	00 00 00 
  818297:	ff d0                	callq  *%rax
  818299:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (lt == 0)
  81829d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8182a2:	75 2a                	jne    8182ce <sys_thread_new+0x61>
	panic("sys_thread_new: cannot allocate thread struct");
  8182a4:	48 ba 30 2b 82 00 00 	movabs $0x822b30,%rdx
  8182ab:	00 00 00 
  8182ae:	be fd 00 00 00       	mov    $0xfd,%esi
  8182b3:	48 bf ce 29 82 00 00 	movabs $0x8229ce,%rdi
  8182ba:	00 00 00 
  8182bd:	b8 00 00 00 00       	mov    $0x0,%eax
  8182c2:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8182c9:	00 00 00 
  8182cc:	ff d1                	callq  *%rcx

    if (stacksize > PGSIZE)
  8182ce:	81 7d d4 00 10 00 00 	cmpl   $0x1000,-0x2c(%rbp)
  8182d5:	7e 30                	jle    818307 <sys_thread_new+0x9a>
	panic("large stack %d", stacksize);
  8182d7:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8182da:	89 c1                	mov    %eax,%ecx
  8182dc:	48 ba 5e 2b 82 00 00 	movabs $0x822b5e,%rdx
  8182e3:	00 00 00 
  8182e6:	be 00 01 00 00       	mov    $0x100,%esi
  8182eb:	48 bf ce 29 82 00 00 	movabs $0x8229ce,%rdi
  8182f2:	00 00 00 
  8182f5:	b8 00 00 00 00       	mov    $0x0,%eax
  8182fa:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  818301:	00 00 00 
  818304:	41 ff d0             	callq  *%r8

    lt->func = thread;
  818307:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81830b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81830f:	48 89 10             	mov    %rdx,(%rax)
    lt->arg = arg;
  818312:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818316:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81831a:	48 89 50 08          	mov    %rdx,0x8(%rax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint64_t)lt);
  81831e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818322:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  818326:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  81832a:	48 89 d1             	mov    %rdx,%rcx
  81832d:	48 ba 18 82 81 00 00 	movabs $0x818218,%rdx
  818334:	00 00 00 
  818337:	48 89 c7             	mov    %rax,%rdi
  81833a:	48 b8 97 8a 81 00 00 	movabs $0x818a97,%rax
  818341:	00 00 00 
  818344:	ff d0                	callq  *%rax
  818346:	89 45 f4             	mov    %eax,-0xc(%rbp)

    if (r < 0)
  818349:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  81834d:	79 3f                	jns    81838e <sys_thread_new+0x121>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  81834f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  818352:	89 c7                	mov    %eax,%edi
  818354:	48 b8 27 91 81 00 00 	movabs $0x819127,%rax
  81835b:	00 00 00 
  81835e:	ff d0                	callq  *%rax
  818360:	48 89 c1             	mov    %rax,%rcx
  818363:	48 ba 70 2b 82 00 00 	movabs $0x822b70,%rdx
  81836a:	00 00 00 
  81836d:	be 09 01 00 00       	mov    $0x109,%esi
  818372:	48 bf ce 29 82 00 00 	movabs $0x8229ce,%rdi
  818379:	00 00 00 
  81837c:	b8 00 00 00 00       	mov    $0x0,%eax
  818381:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  818388:	00 00 00 
  81838b:	41 ff d0             	callq  *%r8

    return tid;
  81838e:	8b 45 f0             	mov    -0x10(%rbp),%eax
}
  818391:	c9                   	leaveq 
  818392:	c3                   	retq   

0000000000818393 <timeout_cleanup>:

static void
timeout_cleanup(thread_id_t tid)
{
  818393:	55                   	push   %rbp
  818394:	48 89 e5             	mov    %rsp,%rbp
  818397:	48 83 ec 20          	sub    $0x20,%rsp
  81839b:	89 7d ec             	mov    %edi,-0x14(%rbp)
    lwip_core_lock();
  81839e:	48 b8 a4 86 81 00 00 	movabs $0x8186a4,%rax
  8183a5:	00 00 00 
  8183a8:	ff d0                	callq  *%rax

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  8183aa:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  8183ad:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  8183b2:	89 c8                	mov    %ecx,%eax
  8183b4:	f7 e2                	mul    %edx
  8183b6:	c1 ea 08             	shr    $0x8,%edx
  8183b9:	89 d0                	mov    %edx,%eax
  8183bb:	c1 e0 08             	shl    $0x8,%eax
  8183be:	01 d0                	add    %edx,%eax
  8183c0:	89 ca                	mov    %ecx,%edx
  8183c2:	29 c2                	sub    %eax,%edx
  8183c4:	89 d0                	mov    %edx,%eax
  8183c6:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8183cd:	00 
  8183ce:	48 b8 e0 6c b5 00 00 	movabs $0xb56ce0,%rax
  8183d5:	00 00 00 
  8183d8:	48 01 d0             	add    %rdx,%rax
  8183db:	48 8b 00             	mov    (%rax),%rax
  8183de:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8183e2:	eb 60                	jmp    818444 <timeout_cleanup+0xb1>
	if (t->tid == tid) {
  8183e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8183e8:	8b 00                	mov    (%rax),%eax
  8183ea:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8183ed:	75 49                	jne    818438 <timeout_cleanup+0xa5>
	    LIST_REMOVE(t, link);
  8183ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8183f3:	48 8b 40 10          	mov    0x10(%rax),%rax
  8183f7:	48 85 c0             	test   %rax,%rax
  8183fa:	74 14                	je     818410 <timeout_cleanup+0x7d>
  8183fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818400:	48 8b 40 10          	mov    0x10(%rax),%rax
  818404:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818408:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  81840c:	48 89 50 18          	mov    %rdx,0x18(%rax)
  818410:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818414:	48 8b 40 18          	mov    0x18(%rax),%rax
  818418:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81841c:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  818420:	48 89 10             	mov    %rdx,(%rax)
	    free(t);
  818423:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818427:	48 89 c7             	mov    %rax,%rdi
  81842a:	48 b8 35 4d 80 00 00 	movabs $0x804d35,%rax
  818431:	00 00 00 
  818434:	ff d0                	callq  *%rax
	    goto done;
  818436:	eb 13                	jmp    81844b <timeout_cleanup+0xb8>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  818438:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81843c:	48 8b 40 10          	mov    0x10(%rax),%rax
  818440:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  818444:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818449:	75 99                	jne    8183e4 <timeout_cleanup+0x51>
	    goto done;
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
  81844b:	48 b8 aa 86 81 00 00 	movabs $0x8186aa,%rax
  818452:	00 00 00 
  818455:	ff d0                	callq  *%rax
}
  818457:	c9                   	leaveq 
  818458:	c3                   	retq   

0000000000818459 <sys_arch_timeouts>:

struct sys_timeouts *
sys_arch_timeouts(void)
{
  818459:	55                   	push   %rbp
  81845a:	48 89 e5             	mov    %rsp,%rbp
  81845d:	48 83 ec 10          	sub    $0x10,%rsp
    thread_id_t tid = thread_id();
  818461:	48 b8 b7 87 81 00 00 	movabs $0x8187b7,%rax
  818468:	00 00 00 
  81846b:	ff d0                	callq  *%rax
  81846d:	89 45 f4             	mov    %eax,-0xc(%rbp)

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  818470:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  818473:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  818478:	89 c8                	mov    %ecx,%eax
  81847a:	f7 e2                	mul    %edx
  81847c:	c1 ea 08             	shr    $0x8,%edx
  81847f:	89 d0                	mov    %edx,%eax
  818481:	c1 e0 08             	shl    $0x8,%eax
  818484:	01 d0                	add    %edx,%eax
  818486:	89 ca                	mov    %ecx,%edx
  818488:	29 c2                	sub    %eax,%edx
  81848a:	89 d0                	mov    %edx,%eax
  81848c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  818493:	00 
  818494:	48 b8 e0 6c b5 00 00 	movabs $0xb56ce0,%rax
  81849b:	00 00 00 
  81849e:	48 01 d0             	add    %rdx,%rax
  8184a1:	48 8b 00             	mov    (%rax),%rax
  8184a4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8184a8:	eb 1b                	jmp    8184c5 <sys_arch_timeouts+0x6c>
	if (t->tid == tid)
  8184aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8184ae:	8b 00                	mov    (%rax),%eax
  8184b0:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8184b3:	0f 84 e0 01 00 00    	je     818699 <sys_arch_timeouts+0x240>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  8184b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8184bd:	48 8b 40 10          	mov    0x10(%rax),%rax
  8184c1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8184c5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8184ca:	75 de                	jne    8184aa <sys_arch_timeouts+0x51>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  8184cc:	bf 20 00 00 00       	mov    $0x20,%edi
  8184d1:	48 b8 b5 49 80 00 00 	movabs $0x8049b5,%rax
  8184d8:	00 00 00 
  8184db:	ff d0                	callq  *%rax
  8184dd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (t == 0)
  8184e1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8184e6:	75 2a                	jne    818512 <sys_arch_timeouts+0xb9>
	panic("sys_arch_timeouts: cannot malloc");
  8184e8:	48 ba a0 2b 82 00 00 	movabs $0x822ba0,%rdx
  8184ef:	00 00 00 
  8184f2:	be 2c 01 00 00       	mov    $0x12c,%esi
  8184f7:	48 bf ce 29 82 00 00 	movabs $0x8229ce,%rdi
  8184fe:	00 00 00 
  818501:	b8 00 00 00 00       	mov    $0x0,%eax
  818506:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81850d:	00 00 00 
  818510:	ff d1                	callq  *%rcx

    int r = thread_onhalt(timeout_cleanup);
  818512:	48 bf 93 83 81 00 00 	movabs $0x818393,%rdi
  818519:	00 00 00 
  81851c:	48 b8 50 89 81 00 00 	movabs $0x818950,%rax
  818523:	00 00 00 
  818526:	ff d0                	callq  *%rax
  818528:	89 45 f0             	mov    %eax,-0x10(%rbp)
    if (r < 0)
  81852b:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  81852f:	79 3f                	jns    818570 <sys_arch_timeouts+0x117>
	panic("thread_onhalt failed: %s", e2s(r));
  818531:	8b 45 f0             	mov    -0x10(%rbp),%eax
  818534:	89 c7                	mov    %eax,%edi
  818536:	48 b8 27 91 81 00 00 	movabs $0x819127,%rax
  81853d:	00 00 00 
  818540:	ff d0                	callq  *%rax
  818542:	48 89 c1             	mov    %rax,%rcx
  818545:	48 ba c1 2b 82 00 00 	movabs $0x822bc1,%rdx
  81854c:	00 00 00 
  81854f:	be 30 01 00 00       	mov    $0x130,%esi
  818554:	48 bf ce 29 82 00 00 	movabs $0x8229ce,%rdi
  81855b:	00 00 00 
  81855e:	b8 00 00 00 00       	mov    $0x0,%eax
  818563:	49 b8 cc 10 80 00 00 	movabs $0x8010cc,%r8
  81856a:	00 00 00 
  81856d:	41 ff d0             	callq  *%r8

    t->tid = tid;
  818570:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818574:	8b 55 f4             	mov    -0xc(%rbp),%edx
  818577:	89 10                	mov    %edx,(%rax)
    memset(&t->tmo, 0, sizeof(t->tmo));
  818579:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81857d:	48 83 c0 08          	add    $0x8,%rax
  818581:	ba 08 00 00 00       	mov    $0x8,%edx
  818586:	be 00 00 00 00       	mov    $0x0,%esi
  81858b:	48 89 c7             	mov    %rax,%rdi
  81858e:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  818595:	00 00 00 
  818598:	ff d0                	callq  *%rax
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  81859a:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  81859d:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  8185a2:	89 c8                	mov    %ecx,%eax
  8185a4:	f7 e2                	mul    %edx
  8185a6:	c1 ea 08             	shr    $0x8,%edx
  8185a9:	89 d0                	mov    %edx,%eax
  8185ab:	c1 e0 08             	shl    $0x8,%eax
  8185ae:	01 d0                	add    %edx,%eax
  8185b0:	89 ca                	mov    %ecx,%edx
  8185b2:	29 c2                	sub    %eax,%edx
  8185b4:	89 d0                	mov    %edx,%eax
  8185b6:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8185bd:	00 
  8185be:	48 b8 e0 6c b5 00 00 	movabs $0xb56ce0,%rax
  8185c5:	00 00 00 
  8185c8:	48 01 d0             	add    %rdx,%rax
  8185cb:	48 8b 10             	mov    (%rax),%rdx
  8185ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8185d2:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8185d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8185da:	48 8b 40 10          	mov    0x10(%rax),%rax
  8185de:	48 85 c0             	test   %rax,%rax
  8185e1:	74 40                	je     818623 <sys_arch_timeouts+0x1ca>
  8185e3:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8185e6:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  8185eb:	89 c8                	mov    %ecx,%eax
  8185ed:	f7 e2                	mul    %edx
  8185ef:	c1 ea 08             	shr    $0x8,%edx
  8185f2:	89 d0                	mov    %edx,%eax
  8185f4:	c1 e0 08             	shl    $0x8,%eax
  8185f7:	01 d0                	add    %edx,%eax
  8185f9:	89 ca                	mov    %ecx,%edx
  8185fb:	29 c2                	sub    %eax,%edx
  8185fd:	89 d0                	mov    %edx,%eax
  8185ff:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  818606:	00 
  818607:	48 b8 e0 6c b5 00 00 	movabs $0xb56ce0,%rax
  81860e:	00 00 00 
  818611:	48 01 d0             	add    %rdx,%rax
  818614:	48 8b 00             	mov    (%rax),%rax
  818617:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81861b:	48 83 c2 10          	add    $0x10,%rdx
  81861f:	48 89 50 18          	mov    %rdx,0x18(%rax)
  818623:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  818626:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  81862b:	89 c8                	mov    %ecx,%eax
  81862d:	f7 e2                	mul    %edx
  81862f:	c1 ea 08             	shr    $0x8,%edx
  818632:	89 d0                	mov    %edx,%eax
  818634:	c1 e0 08             	shl    $0x8,%eax
  818637:	01 d0                	add    %edx,%eax
  818639:	89 ca                	mov    %ecx,%edx
  81863b:	29 c2                	sub    %eax,%edx
  81863d:	89 d0                	mov    %edx,%eax
  81863f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  818646:	00 
  818647:	48 b8 e0 6c b5 00 00 	movabs $0xb56ce0,%rax
  81864e:	00 00 00 
  818651:	48 01 c2             	add    %rax,%rdx
  818654:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818658:	48 89 02             	mov    %rax,(%rdx)
  81865b:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  81865e:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  818663:	89 c8                	mov    %ecx,%eax
  818665:	f7 e2                	mul    %edx
  818667:	c1 ea 08             	shr    $0x8,%edx
  81866a:	89 d0                	mov    %edx,%eax
  81866c:	c1 e0 08             	shl    $0x8,%eax
  81866f:	01 d0                	add    %edx,%eax
  818671:	89 ca                	mov    %ecx,%edx
  818673:	29 c2                	sub    %eax,%edx
  818675:	89 d0                	mov    %edx,%eax
  818677:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  81867e:	00 
  81867f:	48 b8 e0 6c b5 00 00 	movabs $0xb56ce0,%rax
  818686:	00 00 00 
  818689:	48 01 d0             	add    %rdx,%rax
  81868c:	48 89 c2             	mov    %rax,%rdx
  81868f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818693:	48 89 50 18          	mov    %rdx,0x18(%rax)
  818697:	eb 01                	jmp    81869a <sys_arch_timeouts+0x241>
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
	if (t->tid == tid)
	    goto out;
  818699:	90                   	nop
    t->tid = tid;
    memset(&t->tmo, 0, sizeof(t->tmo));
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);

out:
    return &t->tmo;
  81869a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81869e:	48 83 c0 08          	add    $0x8,%rax
}
  8186a2:	c9                   	leaveq 
  8186a3:	c3                   	retq   

00000000008186a4 <lwip_core_lock>:

void
lwip_core_lock(void)
{
  8186a4:	55                   	push   %rbp
  8186a5:	48 89 e5             	mov    %rsp,%rbp
}
  8186a8:	5d                   	pop    %rbp
  8186a9:	c3                   	retq   

00000000008186aa <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  8186aa:	55                   	push   %rbp
  8186ab:	48 89 e5             	mov    %rsp,%rbp
}
  8186ae:	5d                   	pop    %rbp
  8186af:	c3                   	retq   

00000000008186b0 <threadq_init>:
    struct thread_context *tc_queue_link;
};

static inline void 
threadq_init(struct thread_queue *tq)
{
  8186b0:	55                   	push   %rbp
  8186b1:	48 89 e5             	mov    %rsp,%rbp
  8186b4:	48 83 ec 08          	sub    $0x8,%rsp
  8186b8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    tq->tq_first = 0;
  8186bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8186c0:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    tq->tq_last = 0;
  8186c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8186cb:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8186d2:	00 
}
  8186d3:	c9                   	leaveq 
  8186d4:	c3                   	retq   

00000000008186d5 <threadq_push>:

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
  8186d5:	55                   	push   %rbp
  8186d6:	48 89 e5             	mov    %rsp,%rbp
  8186d9:	48 83 ec 10          	sub    $0x10,%rsp
  8186dd:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8186e1:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    tc->tc_queue_link = 0;
  8186e5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8186e9:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  8186f0:	00 00 00 00 
    if (!tq->tq_first) {
  8186f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8186f8:	48 8b 00             	mov    (%rax),%rax
  8186fb:	48 85 c0             	test   %rax,%rax
  8186fe:	75 19                	jne    818719 <threadq_push+0x44>
	tq->tq_first = tc;
  818700:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818704:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818708:	48 89 10             	mov    %rdx,(%rax)
	tq->tq_last = tc;
  81870b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81870f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818713:	48 89 50 08          	mov    %rdx,0x8(%rax)
  818717:	eb 1f                	jmp    818738 <threadq_push+0x63>
    } else {
	tq->tq_last->tc_queue_link = tc;
  818719:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81871d:	48 8b 40 08          	mov    0x8(%rax),%rax
  818721:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818725:	48 89 90 e8 00 00 00 	mov    %rdx,0xe8(%rax)
	tq->tq_last = tc;
  81872c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818730:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818734:	48 89 50 08          	mov    %rdx,0x8(%rax)
    }
}
  818738:	c9                   	leaveq 
  818739:	c3                   	retq   

000000000081873a <threadq_pop>:

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
  81873a:	55                   	push   %rbp
  81873b:	48 89 e5             	mov    %rsp,%rbp
  81873e:	48 83 ec 18          	sub    $0x18,%rsp
  818742:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    if (!tq->tq_first)
  818746:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81874a:	48 8b 00             	mov    (%rax),%rax
  81874d:	48 85 c0             	test   %rax,%rax
  818750:	75 07                	jne    818759 <threadq_pop+0x1f>
	return 0;
  818752:	b8 00 00 00 00       	mov    $0x0,%eax
  818757:	eb 30                	jmp    818789 <threadq_pop+0x4f>

    struct thread_context *tc = tq->tq_first;
  818759:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81875d:	48 8b 00             	mov    (%rax),%rax
  818760:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    tq->tq_first = tc->tc_queue_link;
  818764:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818768:	48 8b 90 e8 00 00 00 	mov    0xe8(%rax),%rdx
  81876f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818773:	48 89 10             	mov    %rdx,(%rax)
    tc->tc_queue_link = 0;
  818776:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81877a:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  818781:	00 00 00 00 
    return tc;
  818785:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  818789:	c9                   	leaveq 
  81878a:	c3                   	retq   

000000000081878b <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  81878b:	55                   	push   %rbp
  81878c:	48 89 e5             	mov    %rsp,%rbp
    threadq_init(&thread_queue);
  81878f:	48 bf 00 75 b5 00 00 	movabs $0xb57500,%rdi
  818796:	00 00 00 
  818799:	48 b8 b0 86 81 00 00 	movabs $0x8186b0,%rax
  8187a0:	00 00 00 
  8187a3:	ff d0                	callq  *%rax
    max_tid = 0;
  8187a5:	48 b8 f4 74 b5 00 00 	movabs $0xb574f4,%rax
  8187ac:	00 00 00 
  8187af:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
}
  8187b5:	5d                   	pop    %rbp
  8187b6:	c3                   	retq   

00000000008187b7 <thread_id>:

uint32_t
thread_id(void) {
  8187b7:	55                   	push   %rbp
  8187b8:	48 89 e5             	mov    %rsp,%rbp
    return cur_tc->tc_tid;
  8187bb:	48 b8 f8 74 b5 00 00 	movabs $0xb574f8,%rax
  8187c2:	00 00 00 
  8187c5:	48 8b 00             	mov    (%rax),%rax
  8187c8:	8b 00                	mov    (%rax),%eax
}
  8187ca:	5d                   	pop    %rbp
  8187cb:	c3                   	retq   

00000000008187cc <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  8187cc:	55                   	push   %rbp
  8187cd:	48 89 e5             	mov    %rsp,%rbp
  8187d0:	48 83 ec 18          	sub    $0x18,%rsp
  8187d4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    struct thread_context *tc = thread_queue.tq_first;
  8187d8:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  8187df:	00 00 00 
  8187e2:	48 8b 00             	mov    (%rax),%rax
  8187e5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (tc) {
  8187e9:	eb 2b                	jmp    818816 <thread_wakeup+0x4a>
	if (tc->tc_wait_addr == addr)
  8187eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8187ef:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  8187f6:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8187fa:	75 0b                	jne    818807 <thread_wakeup+0x3b>
	    tc->tc_wakeup = 1;
  8187fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818800:	c6 80 b8 00 00 00 01 	movb   $0x1,0xb8(%rax)
	tc = tc->tc_queue_link;
  818807:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81880b:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  818812:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  818816:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81881b:	75 ce                	jne    8187eb <thread_wakeup+0x1f>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  81881d:	c9                   	leaveq 
  81881e:	c3                   	retq   

000000000081881f <thread_wait>:

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  81881f:	55                   	push   %rbp
  818820:	48 89 e5             	mov    %rsp,%rbp
  818823:	48 83 ec 20          	sub    $0x20,%rsp
  818827:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81882b:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  81882e:	89 55 e0             	mov    %edx,-0x20(%rbp)
    uint32_t s = sys_time_msec();
  818831:	48 b8 69 2a 80 00 00 	movabs $0x802a69,%rax
  818838:	00 00 00 
  81883b:	ff d0                	callq  *%rax
  81883d:	89 45 f8             	mov    %eax,-0x8(%rbp)
    uint32_t p = s;
  818840:	8b 45 f8             	mov    -0x8(%rbp),%eax
  818843:	89 45 fc             	mov    %eax,-0x4(%rbp)

    cur_tc->tc_wait_addr = addr;
  818846:	48 b8 f8 74 b5 00 00 	movabs $0xb574f8,%rax
  81884d:	00 00 00 
  818850:	48 8b 00             	mov    (%rax),%rax
  818853:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  818857:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
    cur_tc->tc_wakeup = 0;
  81885e:	48 b8 f8 74 b5 00 00 	movabs $0xb574f8,%rax
  818865:	00 00 00 
  818868:	48 8b 00             	mov    (%rax),%rax
  81886b:	c6 80 b8 00 00 00 00 	movb   $0x0,0xb8(%rax)

    while (p < msec) {
  818872:	eb 4d                	jmp    8188c1 <thread_wait+0xa2>
	if (p < s)
  818874:	8b 45 fc             	mov    -0x4(%rbp),%eax
  818877:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  81887a:	72 4f                	jb     8188cb <thread_wait+0xac>
	    break;
	if (addr && *addr != val)
  81887c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  818881:	74 0b                	je     81888e <thread_wait+0x6f>
  818883:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818887:	8b 00                	mov    (%rax),%eax
  818889:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  81888c:	75 40                	jne    8188ce <thread_wait+0xaf>
	    break;
	if (cur_tc->tc_wakeup)
  81888e:	48 b8 f8 74 b5 00 00 	movabs $0xb574f8,%rax
  818895:	00 00 00 
  818898:	48 8b 00             	mov    (%rax),%rax
  81889b:	0f b6 80 b8 00 00 00 	movzbl 0xb8(%rax),%eax
  8188a2:	84 c0                	test   %al,%al
  8188a4:	75 2b                	jne    8188d1 <thread_wait+0xb2>
	    break;

	thread_yield();
  8188a6:	48 b8 18 8d 81 00 00 	movabs $0x818d18,%rax
  8188ad:	00 00 00 
  8188b0:	ff d0                	callq  *%rax
	p = sys_time_msec();
  8188b2:	48 b8 69 2a 80 00 00 	movabs $0x802a69,%rax
  8188b9:	00 00 00 
  8188bc:	ff d0                	callq  *%rax
  8188be:	89 45 fc             	mov    %eax,-0x4(%rbp)
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  8188c1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8188c4:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  8188c7:	72 ab                	jb     818874 <thread_wait+0x55>
  8188c9:	eb 07                	jmp    8188d2 <thread_wait+0xb3>
	if (p < s)
	    break;
  8188cb:	90                   	nop
  8188cc:	eb 04                	jmp    8188d2 <thread_wait+0xb3>
	if (addr && *addr != val)
	    break;
  8188ce:	90                   	nop
  8188cf:	eb 01                	jmp    8188d2 <thread_wait+0xb3>
	if (cur_tc->tc_wakeup)
	    break;
  8188d1:	90                   	nop

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  8188d2:	48 b8 f8 74 b5 00 00 	movabs $0xb574f8,%rax
  8188d9:	00 00 00 
  8188dc:	48 8b 00             	mov    (%rax),%rax
  8188df:	48 c7 80 b0 00 00 00 	movq   $0x0,0xb0(%rax)
  8188e6:	00 00 00 00 
    cur_tc->tc_wakeup = 0;
  8188ea:	48 b8 f8 74 b5 00 00 	movabs $0xb574f8,%rax
  8188f1:	00 00 00 
  8188f4:	48 8b 00             	mov    (%rax),%rax
  8188f7:	c6 80 b8 00 00 00 00 	movb   $0x0,0xb8(%rax)
}
  8188fe:	c9                   	leaveq 
  8188ff:	c3                   	retq   

0000000000818900 <thread_wakeups_pending>:

int
thread_wakeups_pending(void)
{
  818900:	55                   	push   %rbp
  818901:	48 89 e5             	mov    %rsp,%rbp
  818904:	48 83 ec 10          	sub    $0x10,%rsp
    struct thread_context *tc = thread_queue.tq_first;
  818908:	48 b8 00 75 b5 00 00 	movabs $0xb57500,%rax
  81890f:	00 00 00 
  818912:	48 8b 00             	mov    (%rax),%rax
  818915:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    int n = 0;
  818919:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    while (tc) {
  818920:	eb 22                	jmp    818944 <thread_wakeups_pending+0x44>
	if (tc->tc_wakeup)
  818922:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818926:	0f b6 80 b8 00 00 00 	movzbl 0xb8(%rax),%eax
  81892d:	84 c0                	test   %al,%al
  81892f:	74 04                	je     818935 <thread_wakeups_pending+0x35>
	    ++n;
  818931:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
	tc = tc->tc_queue_link;
  818935:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818939:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  818940:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  818944:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818949:	75 d7                	jne    818922 <thread_wakeups_pending+0x22>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
  81894b:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  81894e:	c9                   	leaveq 
  81894f:	c3                   	retq   

0000000000818950 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
  818950:	55                   	push   %rbp
  818951:	48 89 e5             	mov    %rsp,%rbp
  818954:	48 83 ec 08          	sub    $0x8,%rsp
  818958:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  81895c:	48 b8 f8 74 b5 00 00 	movabs $0xb574f8,%rax
  818963:	00 00 00 
  818966:	48 8b 00             	mov    (%rax),%rax
  818969:	8b 80 e0 00 00 00    	mov    0xe0(%rax),%eax
  81896f:	83 f8 03             	cmp    $0x3,%eax
  818972:	7e 07                	jle    81897b <thread_onhalt+0x2b>
	return -E_NO_MEM;
  818974:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  818979:	eb 3d                	jmp    8189b8 <thread_onhalt+0x68>

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  81897b:	48 b8 f8 74 b5 00 00 	movabs $0xb574f8,%rax
  818982:	00 00 00 
  818985:	48 8b 08             	mov    (%rax),%rcx
  818988:	48 b8 f8 74 b5 00 00 	movabs $0xb574f8,%rax
  81898f:	00 00 00 
  818992:	48 8b 00             	mov    (%rax),%rax
  818995:	8b 90 e0 00 00 00    	mov    0xe0(%rax),%edx
  81899b:	48 63 f2             	movslq %edx,%rsi
  81899e:	48 8d 7e 18          	lea    0x18(%rsi),%rdi
  8189a2:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8189a6:	48 89 34 f9          	mov    %rsi,(%rcx,%rdi,8)
  8189aa:	83 c2 01             	add    $0x1,%edx
  8189ad:	89 90 e0 00 00 00    	mov    %edx,0xe0(%rax)
    return 0;
  8189b3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8189b8:	c9                   	leaveq 
  8189b9:	c3                   	retq   

00000000008189ba <alloc_tid>:

static thread_id_t
alloc_tid(void) {
  8189ba:	55                   	push   %rbp
  8189bb:	48 89 e5             	mov    %rsp,%rbp
  8189be:	48 83 ec 10          	sub    $0x10,%rsp
    int tid = max_tid++;
  8189c2:	48 b8 f4 74 b5 00 00 	movabs $0xb574f4,%rax
  8189c9:	00 00 00 
  8189cc:	8b 00                	mov    (%rax),%eax
  8189ce:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8189d1:	8d 50 01             	lea    0x1(%rax),%edx
  8189d4:	48 b8 f4 74 b5 00 00 	movabs $0xb574f4,%rax
  8189db:	00 00 00 
  8189de:	89 10                	mov    %edx,(%rax)
    if (max_tid == (uint32_t)~0)
  8189e0:	48 b8 f4 74 b5 00 00 	movabs $0xb574f4,%rax
  8189e7:	00 00 00 
  8189ea:	8b 00                	mov    (%rax),%eax
  8189ec:	83 f8 ff             	cmp    $0xffffffff,%eax
  8189ef:	75 2a                	jne    818a1b <alloc_tid+0x61>
	panic("alloc_tid: no more thread ids");
  8189f1:	48 ba da 2b 82 00 00 	movabs $0x822bda,%rdx
  8189f8:	00 00 00 
  8189fb:	be 54 00 00 00       	mov    $0x54,%esi
  818a00:	48 bf f8 2b 82 00 00 	movabs $0x822bf8,%rdi
  818a07:	00 00 00 
  818a0a:	b8 00 00 00 00       	mov    $0x0,%eax
  818a0f:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  818a16:	00 00 00 
  818a19:	ff d1                	callq  *%rcx
    return tid;
  818a1b:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  818a1e:	c9                   	leaveq 
  818a1f:	c3                   	retq   

0000000000818a20 <thread_set_name>:

static void
thread_set_name(struct thread_context *tc, const char *name)
{
  818a20:	55                   	push   %rbp
  818a21:	48 89 e5             	mov    %rsp,%rbp
  818a24:	48 83 ec 10          	sub    $0x10,%rsp
  818a28:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  818a2c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    strncpy(tc->tc_name, name, name_size - 1);
  818a30:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818a34:	48 8d 48 10          	lea    0x10(%rax),%rcx
  818a38:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818a3c:	ba 1f 00 00 00       	mov    $0x1f,%edx
  818a41:	48 89 c6             	mov    %rax,%rsi
  818a44:	48 89 cf             	mov    %rcx,%rdi
  818a47:	48 b8 55 1f 80 00 00 	movabs $0x801f55,%rax
  818a4e:	00 00 00 
  818a51:	ff d0                	callq  *%rax
    tc->tc_name[name_size - 1] = 0;
  818a53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818a57:	c6 40 2f 00          	movb   $0x0,0x2f(%rax)
}
  818a5b:	c9                   	leaveq 
  818a5c:	c3                   	retq   

0000000000818a5d <thread_entry>:

static void
thread_entry(void) {
  818a5d:	55                   	push   %rbp
  818a5e:	48 89 e5             	mov    %rsp,%rbp
    cur_tc->tc_entry(cur_tc->tc_arg);
  818a61:	48 b8 f8 74 b5 00 00 	movabs $0xb574f8,%rax
  818a68:	00 00 00 
  818a6b:	48 8b 00             	mov    (%rax),%rax
  818a6e:	48 8b 50 30          	mov    0x30(%rax),%rdx
  818a72:	48 b8 f8 74 b5 00 00 	movabs $0xb574f8,%rax
  818a79:	00 00 00 
  818a7c:	48 8b 00             	mov    (%rax),%rax
  818a7f:	8b 40 38             	mov    0x38(%rax),%eax
  818a82:	89 c0                	mov    %eax,%eax
  818a84:	48 89 c7             	mov    %rax,%rdi
  818a87:	ff d2                	callq  *%rdx
    thread_halt();
  818a89:	48 b8 9e 8c 81 00 00 	movabs $0x818c9e,%rax
  818a90:	00 00 00 
  818a93:	ff d0                	callq  *%rax
}
  818a95:	5d                   	pop    %rbp
  818a96:	c3                   	retq   

0000000000818a97 <thread_create>:

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint64_t), uint64_t arg) {
  818a97:	55                   	push   %rbp
  818a98:	48 89 e5             	mov    %rsp,%rbp
  818a9b:	48 83 ec 30          	sub    $0x30,%rsp
  818a9f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  818aa3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  818aa7:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  818aab:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  818aaf:	bf f0 00 00 00       	mov    $0xf0,%edi
  818ab4:	48 b8 b5 49 80 00 00 	movabs $0x8049b5,%rax
  818abb:	00 00 00 
  818abe:	ff d0                	callq  *%rax
  818ac0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!tc)
  818ac4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818ac9:	75 0a                	jne    818ad5 <thread_create+0x3e>
	return -E_NO_MEM;
  818acb:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  818ad0:	e9 4d 01 00 00       	jmpq   818c22 <thread_create+0x18b>

    memset(tc, 0, sizeof(struct thread_context));
  818ad5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818ad9:	ba f0 00 00 00       	mov    $0xf0,%edx
  818ade:	be 00 00 00 00       	mov    $0x0,%esi
  818ae3:	48 89 c7             	mov    %rax,%rdi
  818ae6:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  818aed:	00 00 00 
  818af0:	ff d0                	callq  *%rax
    
    thread_set_name(tc, name);
  818af2:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  818af6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818afa:	48 89 d6             	mov    %rdx,%rsi
  818afd:	48 89 c7             	mov    %rax,%rdi
  818b00:	48 b8 20 8a 81 00 00 	movabs $0x818a20,%rax
  818b07:	00 00 00 
  818b0a:	ff d0                	callq  *%rax
    tc->tc_tid = alloc_tid();
  818b0c:	48 b8 ba 89 81 00 00 	movabs $0x8189ba,%rax
  818b13:	00 00 00 
  818b16:	ff d0                	callq  *%rax
  818b18:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818b1c:	89 02                	mov    %eax,(%rdx)

    tc->tc_stack_bottom = malloc(stack_size);
  818b1e:	bf 00 10 00 00       	mov    $0x1000,%edi
  818b23:	48 b8 b5 49 80 00 00 	movabs $0x8049b5,%rax
  818b2a:	00 00 00 
  818b2d:	ff d0                	callq  *%rax
  818b2f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818b33:	48 89 42 08          	mov    %rax,0x8(%rdx)
    if (!tc->tc_stack_bottom) {
  818b37:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818b3b:	48 8b 40 08          	mov    0x8(%rax),%rax
  818b3f:	48 85 c0             	test   %rax,%rax
  818b42:	75 1d                	jne    818b61 <thread_create+0xca>
	free(tc);
  818b44:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818b48:	48 89 c7             	mov    %rax,%rdi
  818b4b:	48 b8 35 4d 80 00 00 	movabs $0x804d35,%rax
  818b52:	00 00 00 
  818b55:	ff d0                	callq  *%rax
	return -E_NO_MEM;
  818b57:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  818b5c:	e9 c1 00 00 00       	jmpq   818c22 <thread_create+0x18b>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
  818b61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818b65:	48 8b 40 08          	mov    0x8(%rax),%rax
  818b69:	48 05 00 10 00 00    	add    $0x1000,%rax
  818b6f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    // Terminate stack unwinding
    stacktop = stacktop - 8;
  818b73:	48 83 6d f0 08       	subq   $0x8,-0x10(%rbp)
    memset(stacktop, 0, 8);
  818b78:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  818b7c:	ba 08 00 00 00       	mov    $0x8,%edx
  818b81:	be 00 00 00 00       	mov    $0x0,%esi
  818b86:	48 89 c7             	mov    %rax,%rdi
  818b89:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  818b90:	00 00 00 
  818b93:	ff d0                	callq  *%rax
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  818b95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818b99:	48 83 c0 40          	add    $0x40,%rax
  818b9d:	ba 70 00 00 00       	mov    $0x70,%edx
  818ba2:	be 00 00 00 00       	mov    $0x0,%esi
  818ba7:	48 89 c7             	mov    %rax,%rdi
  818baa:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  818bb1:	00 00 00 
  818bb4:	ff d0                	callq  *%rax
    tc->tc_jb.jb_rsp = (uint64_t)stacktop;
  818bb6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  818bba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818bbe:	48 89 50 48          	mov    %rdx,0x48(%rax)
    tc->tc_jb.jb_rip = (uint64_t)&thread_entry;
  818bc2:	48 ba 5d 8a 81 00 00 	movabs $0x818a5d,%rdx
  818bc9:	00 00 00 
  818bcc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818bd0:	48 89 50 40          	mov    %rdx,0x40(%rax)
    tc->tc_entry = entry;
  818bd4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818bd8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  818bdc:	48 89 50 30          	mov    %rdx,0x30(%rax)
    tc->tc_arg = arg;
  818be0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  818be4:	89 c2                	mov    %eax,%edx
  818be6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818bea:	89 50 38             	mov    %edx,0x38(%rax)

    threadq_push(&thread_queue, tc);
  818bed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818bf1:	48 89 c6             	mov    %rax,%rsi
  818bf4:	48 bf 00 75 b5 00 00 	movabs $0xb57500,%rdi
  818bfb:	00 00 00 
  818bfe:	48 b8 d5 86 81 00 00 	movabs $0x8186d5,%rax
  818c05:	00 00 00 
  818c08:	ff d0                	callq  *%rax

    if (tid)
  818c0a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  818c0f:	74 0c                	je     818c1d <thread_create+0x186>
	*tid = tc->tc_tid;
  818c11:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818c15:	8b 10                	mov    (%rax),%edx
  818c17:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818c1b:	89 10                	mov    %edx,(%rax)
    return 0;
  818c1d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  818c22:	c9                   	leaveq 
  818c23:	c3                   	retq   

0000000000818c24 <thread_clean>:

static void
thread_clean(struct thread_context *tc) {
  818c24:	55                   	push   %rbp
  818c25:	48 89 e5             	mov    %rsp,%rbp
  818c28:	48 83 ec 20          	sub    $0x20,%rsp
  818c2c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    if (!tc) return;
  818c30:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  818c35:	74 64                	je     818c9b <thread_clean+0x77>

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  818c37:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  818c3e:	eb 20                	jmp    818c60 <thread_clean+0x3c>
	tc->tc_onhalt[i](tc->tc_tid);
  818c40:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818c44:	8b 55 fc             	mov    -0x4(%rbp),%edx
  818c47:	48 63 d2             	movslq %edx,%rdx
  818c4a:	48 83 c2 18          	add    $0x18,%rdx
  818c4e:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  818c52:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818c56:	8b 00                	mov    (%rax),%eax
  818c58:	89 c7                	mov    %eax,%edi
  818c5a:	ff d2                	callq  *%rdx
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  818c5c:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  818c60:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818c64:	8b 80 e0 00 00 00    	mov    0xe0(%rax),%eax
  818c6a:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  818c6d:	7f d1                	jg     818c40 <thread_clean+0x1c>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  818c6f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818c73:	48 8b 40 08          	mov    0x8(%rax),%rax
  818c77:	48 89 c7             	mov    %rax,%rdi
  818c7a:	48 b8 35 4d 80 00 00 	movabs $0x804d35,%rax
  818c81:	00 00 00 
  818c84:	ff d0                	callq  *%rax
    free(tc);
  818c86:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  818c8a:	48 89 c7             	mov    %rax,%rdi
  818c8d:	48 b8 35 4d 80 00 00 	movabs $0x804d35,%rax
  818c94:	00 00 00 
  818c97:	ff d0                	callq  *%rax
  818c99:	eb 01                	jmp    818c9c <thread_clean+0x78>
    return 0;
}

static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;
  818c9b:	90                   	nop
    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
    free(tc);
}
  818c9c:	c9                   	leaveq 
  818c9d:	c3                   	retq   

0000000000818c9e <thread_halt>:

void
thread_halt() {
  818c9e:	55                   	push   %rbp
  818c9f:	48 89 e5             	mov    %rsp,%rbp
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));
  818ca2:	48 bf 10 75 b5 00 00 	movabs $0xb57510,%rdi
  818ca9:	00 00 00 
  818cac:	48 b8 3a 87 81 00 00 	movabs $0x81873a,%rax
  818cb3:	00 00 00 
  818cb6:	ff d0                	callq  *%rax
  818cb8:	48 89 c7             	mov    %rax,%rdi
  818cbb:	48 b8 24 8c 81 00 00 	movabs $0x818c24,%rax
  818cc2:	00 00 00 
  818cc5:	ff d0                	callq  *%rax

    threadq_push(&kill_queue, cur_tc);
  818cc7:	48 b8 f8 74 b5 00 00 	movabs $0xb574f8,%rax
  818cce:	00 00 00 
  818cd1:	48 8b 00             	mov    (%rax),%rax
  818cd4:	48 89 c6             	mov    %rax,%rsi
  818cd7:	48 bf 10 75 b5 00 00 	movabs $0xb57510,%rdi
  818cde:	00 00 00 
  818ce1:	48 b8 d5 86 81 00 00 	movabs $0x8186d5,%rax
  818ce8:	00 00 00 
  818ceb:	ff d0                	callq  *%rax
    cur_tc = NULL;
  818ced:	48 b8 f8 74 b5 00 00 	movabs $0xb574f8,%rax
  818cf4:	00 00 00 
  818cf7:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    thread_yield();
  818cfe:	48 b8 18 8d 81 00 00 	movabs $0x818d18,%rax
  818d05:	00 00 00 
  818d08:	ff d0                	callq  *%rax
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  818d0a:	48 b8 a8 10 80 00 00 	movabs $0x8010a8,%rax
  818d11:	00 00 00 
  818d14:	ff d0                	callq  *%rax
}
  818d16:	5d                   	pop    %rbp
  818d17:	c3                   	retq   

0000000000818d18 <thread_yield>:

void
thread_yield(void) {
  818d18:	55                   	push   %rbp
  818d19:	48 89 e5             	mov    %rsp,%rbp
  818d1c:	48 83 ec 10          	sub    $0x10,%rsp
    struct thread_context *next_tc = threadq_pop(&thread_queue);
  818d20:	48 bf 00 75 b5 00 00 	movabs $0xb57500,%rdi
  818d27:	00 00 00 
  818d2a:	48 b8 3a 87 81 00 00 	movabs $0x81873a,%rax
  818d31:	00 00 00 
  818d34:	ff d0                	callq  *%rax
  818d36:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    if (!next_tc)
  818d3a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  818d3f:	0f 84 92 00 00 00    	je     818dd7 <thread_yield+0xbf>
	return;

    if (cur_tc) {
  818d45:	48 b8 f8 74 b5 00 00 	movabs $0xb574f8,%rax
  818d4c:	00 00 00 
  818d4f:	48 8b 00             	mov    (%rax),%rax
  818d52:	48 85 c0             	test   %rax,%rax
  818d55:	74 4a                	je     818da1 <thread_yield+0x89>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  818d57:	48 b8 f8 74 b5 00 00 	movabs $0xb574f8,%rax
  818d5e:	00 00 00 
  818d61:	48 8b 00             	mov    (%rax),%rax
  818d64:	48 83 c0 40          	add    $0x40,%rax
  818d68:	48 89 c7             	mov    %rax,%rdi
  818d6b:	48 b8 40 90 81 00 00 	movabs $0x819040,%rax
  818d72:	00 00 00 
  818d75:	ff d0                	callq  *%rax
  818d77:	85 c0                	test   %eax,%eax
  818d79:	75 5f                	jne    818dda <thread_yield+0xc2>
	    return;
	threadq_push(&thread_queue, cur_tc);
  818d7b:	48 b8 f8 74 b5 00 00 	movabs $0xb574f8,%rax
  818d82:	00 00 00 
  818d85:	48 8b 00             	mov    (%rax),%rax
  818d88:	48 89 c6             	mov    %rax,%rsi
  818d8b:	48 bf 00 75 b5 00 00 	movabs $0xb57500,%rdi
  818d92:	00 00 00 
  818d95:	48 b8 d5 86 81 00 00 	movabs $0x8186d5,%rax
  818d9c:	00 00 00 
  818d9f:	ff d0                	callq  *%rax
    }

    cur_tc = next_tc;
  818da1:	48 b8 f8 74 b5 00 00 	movabs $0xb574f8,%rax
  818da8:	00 00 00 
  818dab:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  818daf:	48 89 10             	mov    %rdx,(%rax)
    jos_longjmp(&cur_tc->tc_jb, 1);
  818db2:	48 b8 f8 74 b5 00 00 	movabs $0xb574f8,%rax
  818db9:	00 00 00 
  818dbc:	48 8b 00             	mov    (%rax),%rax
  818dbf:	48 83 c0 40          	add    $0x40,%rax
  818dc3:	be 01 00 00 00       	mov    $0x1,%esi
  818dc8:	48 89 c7             	mov    %rax,%rdi
  818dcb:	48 b8 90 90 81 00 00 	movabs $0x819090,%rax
  818dd2:	00 00 00 
  818dd5:	ff d0                	callq  *%rax
void
thread_yield(void) {
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;
  818dd7:	90                   	nop
  818dd8:	eb 01                	jmp    818ddb <thread_yield+0xc3>

    if (cur_tc) {
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
	    return;
  818dda:	90                   	nop
	threadq_push(&thread_queue, cur_tc);
    }

    cur_tc = next_tc;
    jos_longjmp(&cur_tc->tc_jb, 1);
}
  818ddb:	c9                   	leaveq 
  818ddc:	c3                   	retq   

0000000000818ddd <print_jb>:

static void
print_jb(struct thread_context *tc) {
  818ddd:	55                   	push   %rbp
  818dde:	48 89 e5             	mov    %rsp,%rbp
  818de1:	48 83 ec 10          	sub    $0x10,%rsp
  818de5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    cprintf("jump buffer for thread %s:\n", tc->tc_name);
  818de9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818ded:	48 83 c0 10          	add    $0x10,%rax
  818df1:	48 89 c6             	mov    %rax,%rsi
  818df4:	48 bf 13 2c 82 00 00 	movabs $0x822c13,%rdi
  818dfb:	00 00 00 
  818dfe:	b8 00 00 00 00       	mov    $0x0,%eax
  818e03:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  818e0a:	00 00 00 
  818e0d:	ff d2                	callq  *%rdx
    cprintf("\trip: %x\n", tc->tc_jb.jb_rip);
  818e0f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818e13:	48 8b 40 40          	mov    0x40(%rax),%rax
  818e17:	48 89 c6             	mov    %rax,%rsi
  818e1a:	48 bf 2f 2c 82 00 00 	movabs $0x822c2f,%rdi
  818e21:	00 00 00 
  818e24:	b8 00 00 00 00       	mov    $0x0,%eax
  818e29:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  818e30:	00 00 00 
  818e33:	ff d2                	callq  *%rdx
    cprintf("\trsp: %x\n", tc->tc_jb.jb_rsp);
  818e35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818e39:	48 8b 40 48          	mov    0x48(%rax),%rax
  818e3d:	48 89 c6             	mov    %rax,%rsi
  818e40:	48 bf 39 2c 82 00 00 	movabs $0x822c39,%rdi
  818e47:	00 00 00 
  818e4a:	b8 00 00 00 00       	mov    $0x0,%eax
  818e4f:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  818e56:	00 00 00 
  818e59:	ff d2                	callq  *%rdx
    cprintf("\trbp: %x\n", tc->tc_jb.jb_rbp);
  818e5b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818e5f:	48 8b 40 50          	mov    0x50(%rax),%rax
  818e63:	48 89 c6             	mov    %rax,%rsi
  818e66:	48 bf 43 2c 82 00 00 	movabs $0x822c43,%rdi
  818e6d:	00 00 00 
  818e70:	b8 00 00 00 00       	mov    $0x0,%eax
  818e75:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  818e7c:	00 00 00 
  818e7f:	ff d2                	callq  *%rdx
    cprintf("\trbx: %x\n", tc->tc_jb.jb_rbx);
  818e81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818e85:	48 8b 40 58          	mov    0x58(%rax),%rax
  818e89:	48 89 c6             	mov    %rax,%rsi
  818e8c:	48 bf 4d 2c 82 00 00 	movabs $0x822c4d,%rdi
  818e93:	00 00 00 
  818e96:	b8 00 00 00 00       	mov    $0x0,%eax
  818e9b:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  818ea2:	00 00 00 
  818ea5:	ff d2                	callq  *%rdx
    cprintf("\trsi: %x\n", tc->tc_jb.jb_rsi);
  818ea7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818eab:	48 8b 40 60          	mov    0x60(%rax),%rax
  818eaf:	48 89 c6             	mov    %rax,%rsi
  818eb2:	48 bf 57 2c 82 00 00 	movabs $0x822c57,%rdi
  818eb9:	00 00 00 
  818ebc:	b8 00 00 00 00       	mov    $0x0,%eax
  818ec1:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  818ec8:	00 00 00 
  818ecb:	ff d2                	callq  *%rdx
    cprintf("\trdi: %x\n", tc->tc_jb.jb_rdi);
  818ecd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818ed1:	48 8b 40 68          	mov    0x68(%rax),%rax
  818ed5:	48 89 c6             	mov    %rax,%rsi
  818ed8:	48 bf 61 2c 82 00 00 	movabs $0x822c61,%rdi
  818edf:	00 00 00 
  818ee2:	b8 00 00 00 00       	mov    $0x0,%eax
  818ee7:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  818eee:	00 00 00 
  818ef1:	ff d2                	callq  *%rdx
    cprintf("\tr15: %x\n", tc->tc_jb.jb_r15);
  818ef3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818ef7:	48 8b 40 70          	mov    0x70(%rax),%rax
  818efb:	48 89 c6             	mov    %rax,%rsi
  818efe:	48 bf 6b 2c 82 00 00 	movabs $0x822c6b,%rdi
  818f05:	00 00 00 
  818f08:	b8 00 00 00 00       	mov    $0x0,%eax
  818f0d:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  818f14:	00 00 00 
  818f17:	ff d2                	callq  *%rdx
    cprintf("\tr14: %x\n", tc->tc_jb.jb_r14);
  818f19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f1d:	48 8b 40 78          	mov    0x78(%rax),%rax
  818f21:	48 89 c6             	mov    %rax,%rsi
  818f24:	48 bf 75 2c 82 00 00 	movabs $0x822c75,%rdi
  818f2b:	00 00 00 
  818f2e:	b8 00 00 00 00       	mov    $0x0,%eax
  818f33:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  818f3a:	00 00 00 
  818f3d:	ff d2                	callq  *%rdx
    cprintf("\tr13: %x\n", tc->tc_jb.jb_r13);
  818f3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f43:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  818f4a:	48 89 c6             	mov    %rax,%rsi
  818f4d:	48 bf 7f 2c 82 00 00 	movabs $0x822c7f,%rdi
  818f54:	00 00 00 
  818f57:	b8 00 00 00 00       	mov    $0x0,%eax
  818f5c:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  818f63:	00 00 00 
  818f66:	ff d2                	callq  *%rdx
    cprintf("\tr12: %x\n", tc->tc_jb.jb_r12);
  818f68:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f6c:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  818f73:	48 89 c6             	mov    %rax,%rsi
  818f76:	48 bf 89 2c 82 00 00 	movabs $0x822c89,%rdi
  818f7d:	00 00 00 
  818f80:	b8 00 00 00 00       	mov    $0x0,%eax
  818f85:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  818f8c:	00 00 00 
  818f8f:	ff d2                	callq  *%rdx
    cprintf("\tr11: %x\n", tc->tc_jb.jb_r11);
  818f91:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818f95:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  818f9c:	48 89 c6             	mov    %rax,%rsi
  818f9f:	48 bf 93 2c 82 00 00 	movabs $0x822c93,%rdi
  818fa6:	00 00 00 
  818fa9:	b8 00 00 00 00       	mov    $0x0,%eax
  818fae:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  818fb5:	00 00 00 
  818fb8:	ff d2                	callq  *%rdx
    cprintf("\tr10: %x\n", tc->tc_jb.jb_r10);
  818fba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818fbe:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  818fc5:	48 89 c6             	mov    %rax,%rsi
  818fc8:	48 bf 9d 2c 82 00 00 	movabs $0x822c9d,%rdi
  818fcf:	00 00 00 
  818fd2:	b8 00 00 00 00       	mov    $0x0,%eax
  818fd7:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  818fde:	00 00 00 
  818fe1:	ff d2                	callq  *%rdx
    cprintf("\tr9: %x\n", tc->tc_jb.jb_r9);
  818fe3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  818fe7:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  818fee:	48 89 c6             	mov    %rax,%rsi
  818ff1:	48 bf a7 2c 82 00 00 	movabs $0x822ca7,%rdi
  818ff8:	00 00 00 
  818ffb:	b8 00 00 00 00       	mov    $0x0,%eax
  819000:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  819007:	00 00 00 
  81900a:	ff d2                	callq  *%rdx
    cprintf("\tr8: %x\n", tc->tc_jb.jb_r8);
  81900c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819010:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  819017:	48 89 c6             	mov    %rax,%rsi
  81901a:	48 bf b0 2c 82 00 00 	movabs $0x822cb0,%rdi
  819021:	00 00 00 
  819024:	b8 00 00 00 00       	mov    $0x0,%eax
  819029:	48 ba 07 13 80 00 00 	movabs $0x801307,%rdx
  819030:	00 00 00 
  819033:	ff d2                	callq  *%rdx
}
  819035:	c9                   	leaveq 
  819036:	c3                   	retq   
	...

0000000000819040 <jos_setjmp>:


ENTRY(jos_setjmp)
	//movq	4(%esp), %ecx	// jos_jmp_buf

	movq	%rdi, %rcx	// jos_jmp_buf
  819040:	48 89 f9             	mov    %rdi,%rcx
	movq	0(%rsp), %rdx	// %rip as pushed by call
  819043:	48 8b 14 24          	mov    (%rsp),%rdx
	movq	%rdx,  0(%rcx)
  819047:	48 89 11             	mov    %rdx,(%rcx)

	leaq	8(%rsp), %rdx	// where %esp will point when we return
  81904a:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx
	movq	%rdx,  8(%rcx)
  81904f:	48 89 51 08          	mov    %rdx,0x8(%rcx)

	movq	%rbp,  16(%rcx)
  819053:	48 89 69 10          	mov    %rbp,0x10(%rcx)
	movq	%rbx, 24(%rcx)
  819057:	48 89 59 18          	mov    %rbx,0x18(%rcx)
	movq	%rsi, 32(%rcx)
  81905b:	48 89 71 20          	mov    %rsi,0x20(%rcx)
	movq	%rdi, 40(%rcx)
  81905f:	48 89 79 28          	mov    %rdi,0x28(%rcx)
	movq	%r15, 48(%rcx)
  819063:	4c 89 79 30          	mov    %r15,0x30(%rcx)
	movq	%r14, 56(%rcx)
  819067:	4c 89 71 38          	mov    %r14,0x38(%rcx)
	movq	%r13, 64(%rcx)
  81906b:	4c 89 69 40          	mov    %r13,0x40(%rcx)
	movq	%r12, 72(%rcx)
  81906f:	4c 89 61 48          	mov    %r12,0x48(%rcx)
	movq	%r11, 80(%rcx)
  819073:	4c 89 59 50          	mov    %r11,0x50(%rcx)
	movq	%r10, 88(%rcx)
  819077:	4c 89 51 58          	mov    %r10,0x58(%rcx)
	movq	%r9, 96(%rcx)
  81907b:	4c 89 49 60          	mov    %r9,0x60(%rcx)
	movq	%r8, 104(%rcx)
  81907f:	4c 89 41 68          	mov    %r8,0x68(%rcx)

	movq	$0, %rax
  819083:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
	ret
  81908a:	c3                   	retq   
  81908b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000819090 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value
	movq     %rdi, %rax
  819090:	48 89 f8             	mov    %rdi,%rax
	movq	 %rsi, %rdx
  819093:	48 89 f2             	mov    %rsi,%rdx
	movq	 0(%rax), %rcx	// %rip
  819096:	48 8b 08             	mov    (%rax),%rcx
	movq	 8(%rax), %rsp
  819099:	48 8b 60 08          	mov    0x8(%rax),%rsp
	movq	 16(%rax), %rbp
  81909d:	48 8b 68 10          	mov    0x10(%rax),%rbp
	movq	24(%rax), %rbx
  8190a1:	48 8b 58 18          	mov    0x18(%rax),%rbx
	movq	32(%rax), %rsi
  8190a5:	48 8b 70 20          	mov    0x20(%rax),%rsi
	movq	40(%rax), %rdi
  8190a9:	48 8b 78 28          	mov    0x28(%rax),%rdi
	movq	48(%rax), %r15
  8190ad:	4c 8b 78 30          	mov    0x30(%rax),%r15
	movq	56(%rax), %r14
  8190b1:	4c 8b 70 38          	mov    0x38(%rax),%r14
	movq	64(%rax), %r13
  8190b5:	4c 8b 68 40          	mov    0x40(%rax),%r13
	movq	72(%rax), %r12
  8190b9:	4c 8b 60 48          	mov    0x48(%rax),%r12
	movq	80(%rax), %r11
  8190bd:	4c 8b 58 50          	mov    0x50(%rax),%r11
	movq	88(%rax), %r10
  8190c1:	4c 8b 50 58          	mov    0x58(%rax),%r10
	movq	96(%rax), %r9
  8190c5:	4c 8b 48 60          	mov    0x60(%rax),%r9
	movq	104(%rax), %r8
  8190c9:	4c 8b 40 68          	mov    0x68(%rax),%r8

	movq	%rdx, %rax
  8190cd:	48 89 d0             	mov    %rdx,%rax
	jmp	*%rcx
  8190d0:	ff e1                	jmpq   *%rcx
	...

00000000008190d4 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  8190d4:	55                   	push   %rbp
  8190d5:	48 89 e5             	mov    %rsp,%rbp
  8190d8:	48 83 ec 20          	sub    $0x20,%rsp
  8190dc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int err = errno;
  8190e0:	48 b8 a0 75 b5 00 00 	movabs $0xb575a0,%rax
  8190e7:	00 00 00 
  8190ea:	8b 00                	mov    (%rax),%eax
  8190ec:	89 45 fc             	mov    %eax,-0x4(%rbp)
	cprintf("%s: %s\n", s, e2s(err));
  8190ef:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8190f2:	89 c7                	mov    %eax,%edi
  8190f4:	48 b8 27 91 81 00 00 	movabs $0x819127,%rax
  8190fb:	00 00 00 
  8190fe:	ff d0                	callq  *%rax
  819100:	48 89 c2             	mov    %rax,%rdx
  819103:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819107:	48 89 c6             	mov    %rax,%rsi
  81910a:	48 bf 9d 31 82 00 00 	movabs $0x82319d,%rdi
  819111:	00 00 00 
  819114:	b8 00 00 00 00       	mov    $0x0,%eax
  819119:	48 b9 07 13 80 00 00 	movabs $0x801307,%rcx
  819120:	00 00 00 
  819123:	ff d1                	callq  *%rcx
}
  819125:	c9                   	leaveq 
  819126:	c3                   	retq   

0000000000819127 <e2s>:

const char *
e2s(int err) {
  819127:	55                   	push   %rbp
  819128:	48 89 e5             	mov    %rsp,%rbp
  81912b:	48 83 ec 08          	sub    $0x8,%rsp
  81912f:	89 7d fc             	mov    %edi,-0x4(%rbp)
	return sys_errlist[err];
  819132:	48 b8 00 82 82 00 00 	movabs $0x828200,%rax
  819139:	00 00 00 
  81913c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  81913f:	48 63 d2             	movslq %edx,%rdx
  819142:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
}
  819146:	c9                   	leaveq 
  819147:	c3                   	retq   

0000000000819148 <low_level_init>:
    envid_t envid;
};

static void
low_level_init(struct netif *netif)
{
  819148:	55                   	push   %rbp
  819149:	48 89 e5             	mov    %rsp,%rbp
  81914c:	48 83 ec 08          	sub    $0x8,%rsp
  819150:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    int r;

    netif->hwaddr_len = 6;
  819154:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819158:	c6 40 40 06          	movb   $0x6,0x40(%rax)
    netif->mtu = 1500;
  81915c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819160:	66 c7 40 48 dc 05    	movw   $0x5dc,0x48(%rax)
    netif->flags = NETIF_FLAG_BROADCAST;
  819166:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81916a:	c6 40 4a 02          	movb   $0x2,0x4a(%rax)

    // MAC address is hardcoded to eliminate a system call
    netif->hwaddr[0] = 0x52;
  81916e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819172:	c6 40 41 52          	movb   $0x52,0x41(%rax)
    netif->hwaddr[1] = 0x54;
  819176:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81917a:	c6 40 42 54          	movb   $0x54,0x42(%rax)
    netif->hwaddr[2] = 0x00;
  81917e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819182:	c6 40 43 00          	movb   $0x0,0x43(%rax)
    netif->hwaddr[3] = 0x12;
  819186:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81918a:	c6 40 44 12          	movb   $0x12,0x44(%rax)
    netif->hwaddr[4] = 0x34;
  81918e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819192:	c6 40 45 34          	movb   $0x34,0x45(%rax)
    netif->hwaddr[5] = 0x56;
  819196:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81919a:	c6 40 46 56          	movb   $0x56,0x46(%rax)
}
  81919e:	c9                   	leaveq 
  81919f:	c3                   	retq   

00000000008191a0 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  8191a0:	55                   	push   %rbp
  8191a1:	48 89 e5             	mov    %rsp,%rbp
  8191a4:	48 83 ec 40          	sub    $0x40,%rsp
  8191a8:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8191ac:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  8191b0:	ba 07 00 00 00       	mov    $0x7,%edx
  8191b5:	be 00 00 00 10       	mov    $0x10000000,%esi
  8191ba:	bf 00 00 00 00       	mov    $0x0,%edi
  8191bf:	48 b8 fc 27 80 00 00 	movabs $0x8027fc,%rax
  8191c6:	00 00 00 
  8191c9:	ff d0                	callq  *%rax
  8191cb:	89 45 ec             	mov    %eax,-0x14(%rbp)
    if (r < 0)
  8191ce:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8191d2:	79 2a                	jns    8191fe <low_level_output+0x5e>
	panic("jif: could not allocate page of memory");
  8191d4:	48 ba a8 31 82 00 00 	movabs $0x8231a8,%rdx
  8191db:	00 00 00 
  8191de:	be 55 00 00 00       	mov    $0x55,%esi
  8191e3:	48 bf cf 31 82 00 00 	movabs $0x8231cf,%rdi
  8191ea:	00 00 00 
  8191ed:	b8 00 00 00 00       	mov    $0x0,%eax
  8191f2:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8191f9:	00 00 00 
  8191fc:	ff d1                	callq  *%rcx
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;
  8191fe:	48 c7 45 e0 00 00 00 	movq   $0x10000000,-0x20(%rbp)
  819205:	10 

    struct jif *jif;
    jif = netif->state;
  819206:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81920a:	48 8b 40 30          	mov    0x30(%rax),%rax
  81920e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

    char *txbuf = pkt->jp_data;
  819212:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  819216:	48 83 c0 04          	add    $0x4,%rax
  81921a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    int txsize = 0;
  81921e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  819225:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819229:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  81922d:	e9 9a 00 00 00       	jmpq   8192cc <low_level_output+0x12c>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  819232:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819236:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81923a:	0f b7 c0             	movzwl %ax,%eax
  81923d:	03 45 fc             	add    -0x4(%rbp),%eax
  819240:	3d d0 07 00 00       	cmp    $0x7d0,%eax
  819245:	7e 3e                	jle    819285 <low_level_output+0xe5>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  819247:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81924b:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81924f:	0f b7 c0             	movzwl %ax,%eax
  819252:	8b 55 fc             	mov    -0x4(%rbp),%edx
  819255:	41 89 d0             	mov    %edx,%r8d
  819258:	89 c1                	mov    %eax,%ecx
  81925a:	48 ba e8 31 82 00 00 	movabs $0x8231e8,%rdx
  819261:	00 00 00 
  819264:	be 64 00 00 00       	mov    $0x64,%esi
  819269:	48 bf cf 31 82 00 00 	movabs $0x8231cf,%rdi
  819270:	00 00 00 
  819273:	b8 00 00 00 00       	mov    $0x0,%eax
  819278:	49 b9 cc 10 80 00 00 	movabs $0x8010cc,%r9
  81927f:	00 00 00 
  819282:	41 ff d1             	callq  *%r9
	memcpy(&txbuf[txsize], q->payload, q->len);
  819285:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819289:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81928d:	0f b7 d0             	movzwl %ax,%edx
  819290:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819294:	48 8b 48 08          	mov    0x8(%rax),%rcx
  819298:	8b 45 fc             	mov    -0x4(%rbp),%eax
  81929b:	48 98                	cltq   
  81929d:	48 03 45 d0          	add    -0x30(%rbp),%rax
  8192a1:	48 89 ce             	mov    %rcx,%rsi
  8192a4:	48 89 c7             	mov    %rax,%rdi
  8192a7:	48 b8 fd 22 80 00 00 	movabs $0x8022fd,%rax
  8192ae:	00 00 00 
  8192b1:	ff d0                	callq  *%rax
	txsize += q->len;
  8192b3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8192b7:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8192bb:	0f b7 c0             	movzwl %ax,%eax
  8192be:	01 45 fc             	add    %eax,-0x4(%rbp)
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  8192c1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8192c5:	48 8b 00             	mov    (%rax),%rax
  8192c8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8192cc:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8192d1:	0f 85 5b ff ff ff    	jne    819232 <low_level_output+0x92>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  8192d7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8192db:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8192de:	89 10                	mov    %edx,(%rax)

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  8192e0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8192e4:	8b 40 08             	mov    0x8(%rax),%eax
  8192e7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8192eb:	b9 07 00 00 00       	mov    $0x7,%ecx
  8192f0:	be 0b 00 00 00       	mov    $0xb,%esi
  8192f5:	89 c7                	mov    %eax,%edi
  8192f7:	48 b8 c0 32 80 00 00 	movabs $0x8032c0,%rax
  8192fe:	00 00 00 
  819301:	ff d0                	callq  *%rax
    sys_page_unmap(0, (void *)pkt);
  819303:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  819307:	48 89 c6             	mov    %rax,%rsi
  81930a:	bf 00 00 00 00       	mov    $0x0,%edi
  81930f:	48 b8 a7 28 80 00 00 	movabs $0x8028a7,%rax
  819316:	00 00 00 
  819319:	ff d0                	callq  *%rax

    return ERR_OK;
  81931b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  819320:	c9                   	leaveq 
  819321:	c3                   	retq   

0000000000819322 <low_level_input>:
 * packet from the interface into the pbuf.
 *
 */
static struct pbuf *
low_level_input(void *va)
{
  819322:	55                   	push   %rbp
  819323:	48 89 e5             	mov    %rsp,%rbp
  819326:	48 83 ec 50          	sub    $0x50,%rsp
  81932a:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
    struct jif_pkt *pkt = (struct jif_pkt *)va;
  81932e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819332:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    s16_t len = pkt->jp_len;
  819336:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81933a:	8b 00                	mov    (%rax),%eax
  81933c:	66 89 45 de          	mov    %ax,-0x22(%rbp)

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  819340:	0f b7 45 de          	movzwl -0x22(%rbp),%eax
  819344:	0f b7 c0             	movzwl %ax,%eax
  819347:	ba 03 00 00 00       	mov    $0x3,%edx
  81934c:	89 c6                	mov    %eax,%esi
  81934e:	bf 03 00 00 00       	mov    $0x3,%edi
  819353:	48 b8 4c d0 80 00 00 	movabs $0x80d04c,%rax
  81935a:	00 00 00 
  81935d:	ff d0                	callq  *%rax
  81935f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (p == 0)
  819363:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  819368:	75 0a                	jne    819374 <low_level_input+0x52>
	return 0;
  81936a:	b8 00 00 00 00       	mov    $0x0,%eax
  81936f:	e9 89 00 00 00       	jmpq   8193fd <low_level_input+0xdb>

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  819374:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  819378:	48 83 c0 04          	add    $0x4,%rax
  81937c:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    int copied = 0;
  819380:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  819387:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81938b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  81938f:	eb 61                	jmp    8193f2 <low_level_input+0xd0>
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  819391:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819395:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  819399:	0f b7 c0             	movzwl %ax,%eax
  81939c:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if (bytes > (len - copied))
  81939f:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  8193a3:	2b 45 fc             	sub    -0x4(%rbp),%eax
  8193a6:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8193a9:	7d 0a                	jge    8193b5 <low_level_input+0x93>
	    bytes = len - copied;
  8193ab:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  8193af:	2b 45 fc             	sub    -0x4(%rbp),%eax
  8193b2:	89 45 ec             	mov    %eax,-0x14(%rbp)
	memcpy(q->payload, rxbuf + copied, bytes);
  8193b5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8193b8:	48 63 d0             	movslq %eax,%rdx
  8193bb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8193be:	48 98                	cltq   
  8193c0:	48 89 c1             	mov    %rax,%rcx
  8193c3:	48 03 4d c8          	add    -0x38(%rbp),%rcx
  8193c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8193cb:	48 8b 40 08          	mov    0x8(%rax),%rax
  8193cf:	48 89 ce             	mov    %rcx,%rsi
  8193d2:	48 89 c7             	mov    %rax,%rdi
  8193d5:	48 b8 fd 22 80 00 00 	movabs $0x8022fd,%rax
  8193dc:	00 00 00 
  8193df:	ff d0                	callq  *%rax
	copied += bytes;
  8193e1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8193e4:	01 45 fc             	add    %eax,-0x4(%rbp)
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  8193e7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8193eb:	48 8b 00             	mov    (%rax),%rax
  8193ee:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8193f2:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8193f7:	75 98                	jne    819391 <low_level_input+0x6f>
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
	copied += bytes;
    }

    return p;
  8193f9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
}
  8193fd:	c9                   	leaveq 
  8193fe:	c3                   	retq   

00000000008193ff <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  8193ff:	55                   	push   %rbp
  819400:	48 89 e5             	mov    %rsp,%rbp
  819403:	48 83 ec 20          	sub    $0x20,%rsp
  819407:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81940b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  81940f:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  819413:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  819417:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  81941b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81941f:	48 89 ce             	mov    %rcx,%rsi
  819422:	48 89 c7             	mov    %rax,%rdi
  819425:	48 b8 e9 66 81 00 00 	movabs $0x8166e9,%rax
  81942c:	00 00 00 
  81942f:	ff d0                	callq  *%rax
}
  819431:	c9                   	leaveq 
  819432:	c3                   	retq   

0000000000819433 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  819433:	55                   	push   %rbp
  819434:	48 89 e5             	mov    %rsp,%rbp
  819437:	48 83 ec 30          	sub    $0x30,%rsp
  81943b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81943f:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  819443:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819447:	48 8b 40 30          	mov    0x30(%rax),%rax
  81944b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
    /* move received packet into a new pbuf */
    p = low_level_input(va);
  81944f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  819453:	48 89 c7             	mov    %rax,%rdi
  819456:	48 b8 22 93 81 00 00 	movabs $0x819322,%rax
  81945d:	00 00 00 
  819460:	ff d0                	callq  *%rax
  819462:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
  819466:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81946b:	0f 84 bc 00 00 00    	je     81952d <jif_input+0xfa>
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;
  819471:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819475:	48 8b 40 08          	mov    0x8(%rax),%rax
  819479:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    switch (htons(ethhdr->type)) {
  81947d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819481:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  819485:	0f b7 c0             	movzwl %ax,%eax
  819488:	89 c7                	mov    %eax,%edi
  81948a:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  819491:	00 00 00 
  819494:	ff d0                	callq  *%rax
  819496:	0f b7 c0             	movzwl %ax,%eax
  819499:	3d 00 08 00 00       	cmp    $0x800,%eax
  81949e:	74 09                	je     8194a9 <jif_input+0x76>
  8194a0:	3d 06 08 00 00       	cmp    $0x806,%eax
  8194a5:	74 4e                	je     8194f5 <jif_input+0xc2>
  8194a7:	eb 6f                	jmp    819518 <jif_input+0xe5>
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  8194a9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8194ad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8194b1:	48 89 d6             	mov    %rdx,%rsi
  8194b4:	48 89 c7             	mov    %rax,%rdi
  8194b7:	48 b8 12 63 81 00 00 	movabs $0x816312,%rax
  8194be:	00 00 00 
  8194c1:	ff d0                	callq  *%rax
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  8194c3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8194c7:	be f2 ff ff ff       	mov    $0xfffffff2,%esi
  8194cc:	48 89 c7             	mov    %rax,%rdi
  8194cf:	48 b8 6f d7 80 00 00 	movabs $0x80d76f,%rax
  8194d6:	00 00 00 
  8194d9:	ff d0                	callq  *%rax
	/* pass to network layer */
	netif->input(p, netif);
  8194db:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8194df:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8194e3:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8194e7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8194eb:	48 89 d6             	mov    %rdx,%rsi
  8194ee:	48 89 c7             	mov    %rax,%rdi
  8194f1:	ff d1                	callq  *%rcx
	break;
  8194f3:	eb 39                	jmp    81952e <jif_input+0xfb>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  8194f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8194f9:	48 8b 08             	mov    (%rax),%rcx
  8194fc:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  819500:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819504:	48 89 ce             	mov    %rcx,%rsi
  819507:	48 89 c7             	mov    %rax,%rdi
  81950a:	48 b8 a9 63 81 00 00 	movabs $0x8163a9,%rax
  819511:	00 00 00 
  819514:	ff d0                	callq  *%rax
	break;
  819516:	eb 16                	jmp    81952e <jif_input+0xfb>

    default:
	pbuf_free(p);
  819518:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81951c:	48 89 c7             	mov    %rax,%rdi
  81951f:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  819526:	00 00 00 
  819529:	ff d0                	callq  *%rax
  81952b:	eb 01                	jmp    81952e <jif_input+0xfb>
  
    /* move received packet into a new pbuf */
    p = low_level_input(va);

    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
  81952d:	90                   	nop
	break;

    default:
	pbuf_free(p);
    }
}
  81952e:	c9                   	leaveq 
  81952f:	c3                   	retq   

0000000000819530 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  819530:	55                   	push   %rbp
  819531:	48 89 e5             	mov    %rsp,%rbp
  819534:	48 83 ec 30          	sub    $0x30,%rsp
  819538:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  81953c:	bf 10 00 00 00       	mov    $0x10,%edi
  819541:	48 b8 79 c5 80 00 00 	movabs $0x80c579,%rax
  819548:	00 00 00 
  81954b:	ff d0                	callq  *%rax
  81954d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    if (jif == NULL) {
  819551:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819556:	75 0a                	jne    819562 <jif_init+0x32>
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
  819558:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81955d:	e9 ce 00 00 00       	jmpq   819630 <jif_init+0x100>
    }

    output_envid = (envid_t *)netif->state;
  819562:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819566:	48 8b 40 30          	mov    0x30(%rax),%rax
  81956a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

    netif->state = jif;
  81956e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819572:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  819576:	48 89 50 30          	mov    %rdx,0x30(%rax)
    netif->output = jif_output;
  81957a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81957e:	48 ba ff 93 81 00 00 	movabs $0x8193ff,%rdx
  819585:	00 00 00 
  819588:	48 89 50 20          	mov    %rdx,0x20(%rax)
    netif->linkoutput = low_level_output;
  81958c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819590:	48 ba a0 91 81 00 00 	movabs $0x8191a0,%rdx
  819597:	00 00 00 
  81959a:	48 89 50 28          	mov    %rdx,0x28(%rax)
    memcpy(&netif->name[0], "en", 2);
  81959e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8195a2:	48 83 c0 4b          	add    $0x4b,%rax
  8195a6:	ba 02 00 00 00       	mov    $0x2,%edx
  8195ab:	48 be 11 32 82 00 00 	movabs $0x823211,%rsi
  8195b2:	00 00 00 
  8195b5:	48 89 c7             	mov    %rax,%rdi
  8195b8:	48 b8 fd 22 80 00 00 	movabs $0x8022fd,%rax
  8195bf:	00 00 00 
  8195c2:	ff d0                	callq  *%rax

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  8195c4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8195c8:	48 8d 50 41          	lea    0x41(%rax),%rdx
  8195cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8195d0:	48 89 10             	mov    %rdx,(%rax)
    jif->envid = *output_envid; 
  8195d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8195d7:	8b 10                	mov    (%rax),%edx
  8195d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8195dd:	89 50 08             	mov    %edx,0x8(%rax)

    low_level_init(netif);
  8195e0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8195e4:	48 89 c7             	mov    %rax,%rdi
  8195e7:	48 b8 48 91 81 00 00 	movabs $0x819148,%rax
  8195ee:	00 00 00 
  8195f1:	ff d0                	callq  *%rax
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  8195f3:	48 bf 14 32 82 00 00 	movabs $0x823214,%rdi
  8195fa:	00 00 00 
  8195fd:	48 b8 7c 28 81 00 00 	movabs $0x81287c,%rax
  819604:	00 00 00 
  819607:	ff d0                	callq  *%rax
  819609:	89 45 ec             	mov    %eax,-0x14(%rbp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  81960c:	48 8d 4d ec          	lea    -0x14(%rbp),%rcx
  819610:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  819614:	ba 00 00 00 00       	mov    $0x0,%edx
  819619:	48 89 ce             	mov    %rcx,%rsi
  81961c:	48 89 c7             	mov    %rax,%rdi
  81961f:	48 b8 7b 68 81 00 00 	movabs $0x81687b,%rax
  819626:	00 00 00 
  819629:	ff d0                	callq  *%rax

    return ERR_OK;
  81962b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  819630:	c9                   	leaveq 
  819631:	c3                   	retq   
	...

0000000000819634 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  819634:	55                   	push   %rbp
  819635:	48 89 e5             	mov    %rsp,%rbp
  819638:	48 83 ec 40          	sub    $0x40,%rsp
  81963c:	89 7d cc             	mov    %edi,-0x34(%rbp)
  81963f:	89 f0                	mov    %esi,%eax
  819641:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  819645:	88 45 c8             	mov    %al,-0x38(%rbp)
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  819648:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  81964c:	8b 45 cc             	mov    -0x34(%rbp),%eax
  81964f:	48 89 d6             	mov    %rdx,%rsi
  819652:	89 c7                	mov    %eax,%edi
  819654:	48 b8 b8 ac 81 00 00 	movabs $0x81acb8,%rax
  81965b:	00 00 00 
  81965e:	ff d0                	callq  *%rax
  819660:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  
  if (conn != NULL ) {
  819664:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819669:	0f 84 62 01 00 00    	je     8197d1 <netconn_new_with_proto_and_callback+0x19d>
    msg.function = do_newconn;
  81966f:	48 b8 6f ac 81 00 00 	movabs $0x81ac6f,%rax
  819676:	00 00 00 
  819679:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    msg.msg.msg.n.proto = proto;
  81967d:	0f b6 45 c8          	movzbl -0x38(%rbp),%eax
  819681:	88 45 e0             	mov    %al,-0x20(%rbp)
    msg.msg.conn = conn;
  819684:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819688:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    TCPIP_APIMSG(&msg);
  81968c:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819690:	48 89 c7             	mov    %rax,%rdi
  819693:	48 b8 b7 88 80 00 00 	movabs $0x8088b7,%rax
  81969a:	00 00 00 
  81969d:	ff d0                	callq  *%rax

    if (conn->err != ERR_OK) {
  81969f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8196a3:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  8196a7:	84 c0                	test   %al,%al
  8196a9:	0f 84 22 01 00 00    	je     8197d1 <netconn_new_with_proto_and_callback+0x19d>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  8196af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8196b3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8196b7:	48 85 c0             	test   %rax,%rax
  8196ba:	74 2a                	je     8196e6 <netconn_new_with_proto_and_callback+0xb2>
  8196bc:	48 ba 20 32 82 00 00 	movabs $0x823220,%rdx
  8196c3:	00 00 00 
  8196c6:	be 52 00 00 00       	mov    $0x52,%esi
  8196cb:	48 bf 41 32 82 00 00 	movabs $0x823241,%rdi
  8196d2:	00 00 00 
  8196d5:	b8 00 00 00 00       	mov    $0x0,%eax
  8196da:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8196e1:	00 00 00 
  8196e4:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  8196e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8196ea:	8b 40 14             	mov    0x14(%rax),%eax
  8196ed:	83 f8 ff             	cmp    $0xffffffff,%eax
  8196f0:	75 2a                	jne    81971c <netconn_new_with_proto_and_callback+0xe8>
  8196f2:	48 ba 58 32 82 00 00 	movabs $0x823258,%rdx
  8196f9:	00 00 00 
  8196fc:	be 53 00 00 00       	mov    $0x53,%esi
  819701:	48 bf 41 32 82 00 00 	movabs $0x823241,%rdi
  819708:	00 00 00 
  81970b:	b8 00 00 00 00       	mov    $0x0,%eax
  819710:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  819717:	00 00 00 
  81971a:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  81971c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819720:	8b 40 18             	mov    0x18(%rax),%eax
  819723:	83 f8 ff             	cmp    $0xffffffff,%eax
  819726:	75 2a                	jne    819752 <netconn_new_with_proto_and_callback+0x11e>
  819728:	48 ba 71 32 82 00 00 	movabs $0x823271,%rdx
  81972f:	00 00 00 
  819732:	be 54 00 00 00       	mov    $0x54,%esi
  819737:	48 bf 41 32 82 00 00 	movabs $0x823241,%rdi
  81973e:	00 00 00 
  819741:	b8 00 00 00 00       	mov    $0x0,%eax
  819746:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81974d:	00 00 00 
  819750:	ff d1                	callq  *%rcx
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  819752:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819756:	8b 40 1c             	mov    0x1c(%rax),%eax
  819759:	83 f8 ff             	cmp    $0xffffffff,%eax
  81975c:	74 2a                	je     819788 <netconn_new_with_proto_and_callback+0x154>
  81975e:	48 ba 88 32 82 00 00 	movabs $0x823288,%rdx
  819765:	00 00 00 
  819768:	be 55 00 00 00       	mov    $0x55,%esi
  81976d:	48 bf 41 32 82 00 00 	movabs $0x823241,%rdi
  819774:	00 00 00 
  819777:	b8 00 00 00 00       	mov    $0x0,%eax
  81977c:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  819783:	00 00 00 
  819786:	ff d1                	callq  *%rcx
      sys_sem_free(conn->op_completed);
  819788:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81978c:	8b 40 14             	mov    0x14(%rax),%eax
  81978f:	89 c7                	mov    %eax,%edi
  819791:	48 b8 e3 7a 81 00 00 	movabs $0x817ae3,%rax
  819798:	00 00 00 
  81979b:	ff d0                	callq  *%rax
      sys_mbox_free(conn->recvmbox);
  81979d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8197a1:	8b 40 18             	mov    0x18(%rax),%eax
  8197a4:	89 c7                	mov    %eax,%edi
  8197a6:	48 b8 f9 74 81 00 00 	movabs $0x8174f9,%rax
  8197ad:	00 00 00 
  8197b0:	ff d0                	callq  *%rax
      memp_free(MEMP_NETCONN, conn);
  8197b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8197b6:	48 89 c6             	mov    %rax,%rsi
  8197b9:	bf 07 00 00 00       	mov    $0x7,%edi
  8197be:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  8197c5:	00 00 00 
  8197c8:	ff d0                	callq  *%rax
      return NULL;
  8197ca:	b8 00 00 00 00       	mov    $0x0,%eax
  8197cf:	eb 04                	jmp    8197d5 <netconn_new_with_proto_and_callback+0x1a1>
    }
  }
  return conn;
  8197d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8197d5:	c9                   	leaveq 
  8197d6:	c3                   	retq   

00000000008197d7 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  8197d7:	55                   	push   %rbp
  8197d8:	48 89 e5             	mov    %rsp,%rbp
  8197db:	48 83 ec 40          	sub    $0x40,%rsp
  8197df:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  8197e3:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8197e8:	75 07                	jne    8197f1 <netconn_delete+0x1a>
    return ERR_OK;
  8197ea:	b8 00 00 00 00       	mov    $0x0,%eax
  8197ef:	eb 4d                	jmp    81983e <netconn_delete+0x67>
  }

  msg.function = do_delconn;
  8197f1:	48 b8 82 b2 81 00 00 	movabs $0x81b282,%rax
  8197f8:	00 00 00 
  8197fb:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  8197ff:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819803:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  tcpip_apimsg(&msg);
  819807:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81980b:	48 89 c7             	mov    %rax,%rdi
  81980e:	48 b8 b7 88 80 00 00 	movabs $0x8088b7,%rax
  819815:	00 00 00 
  819818:	ff d0                	callq  *%rax

  conn->pcb.tcp = NULL;
  81981a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81981e:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  819825:	00 
  netconn_free(conn);
  819826:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81982a:	48 89 c7             	mov    %rax,%rdi
  81982d:	48 b8 ec ad 81 00 00 	movabs $0x81adec,%rax
  819834:	00 00 00 
  819837:	ff d0                	callq  *%rax

  return ERR_OK;
  819839:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81983e:	c9                   	leaveq 
  81983f:	c3                   	retq   

0000000000819840 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  819840:	55                   	push   %rbp
  819841:	48 89 e5             	mov    %rsp,%rbp
  819844:	48 83 ec 10          	sub    $0x10,%rsp
  819848:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  81984c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  819851:	75 2a                	jne    81987d <netconn_type+0x3d>
  819853:	48 ba a9 32 82 00 00 	movabs $0x8232a9,%rdx
  81985a:	00 00 00 
  81985d:	be 84 00 00 00       	mov    $0x84,%esi
  819862:	48 bf 41 32 82 00 00 	movabs $0x823241,%rdi
  819869:	00 00 00 
  81986c:	b8 00 00 00 00       	mov    $0x0,%eax
  819871:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  819878:	00 00 00 
  81987b:	ff d1                	callq  *%rcx
  return conn->type;
  81987d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819881:	8b 00                	mov    (%rax),%eax
}
  819883:	c9                   	leaveq 
  819884:	c3                   	retq   

0000000000819885 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  819885:	55                   	push   %rbp
  819886:	48 89 e5             	mov    %rsp,%rbp
  819889:	48 83 ec 50          	sub    $0x50,%rsp
  81988d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819891:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  819895:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  819899:	89 c8                	mov    %ecx,%eax
  81989b:	88 45 b4             	mov    %al,-0x4c(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  81989e:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8198a3:	75 2a                	jne    8198cf <netconn_getaddr+0x4a>
  8198a5:	48 ba c4 32 82 00 00 	movabs $0x8232c4,%rdx
  8198ac:	00 00 00 
  8198af:	be 98 00 00 00       	mov    $0x98,%esi
  8198b4:	48 bf 41 32 82 00 00 	movabs $0x823241,%rdi
  8198bb:	00 00 00 
  8198be:	b8 00 00 00 00       	mov    $0x0,%eax
  8198c3:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8198ca:	00 00 00 
  8198cd:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  8198cf:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8198d4:	75 2a                	jne    819900 <netconn_getaddr+0x7b>
  8198d6:	48 ba e2 32 82 00 00 	movabs $0x8232e2,%rdx
  8198dd:	00 00 00 
  8198e0:	be 99 00 00 00       	mov    $0x99,%esi
  8198e5:	48 bf 41 32 82 00 00 	movabs $0x823241,%rdi
  8198ec:	00 00 00 
  8198ef:	b8 00 00 00 00       	mov    $0x0,%eax
  8198f4:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8198fb:	00 00 00 
  8198fe:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  819900:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  819905:	75 2a                	jne    819931 <netconn_getaddr+0xac>
  819907:	48 ba 00 33 82 00 00 	movabs $0x823300,%rdx
  81990e:	00 00 00 
  819911:	be 9a 00 00 00       	mov    $0x9a,%esi
  819916:	48 bf 41 32 82 00 00 	movabs $0x823241,%rdi
  81991d:	00 00 00 
  819920:	b8 00 00 00 00       	mov    $0x0,%eax
  819925:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81992c:	00 00 00 
  81992f:	ff d1                	callq  *%rcx

  msg.function = do_getaddr;
  819931:	48 b8 36 be 81 00 00 	movabs $0x81be36,%rax
  819938:	00 00 00 
  81993b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81993f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819943:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.ad.ipaddr = addr;
  819947:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81994b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.ad.port = port;
  81994f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819953:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  msg.msg.msg.ad.local = local;
  819957:	0f b6 45 b4          	movzbl -0x4c(%rbp),%eax
  81995b:	88 45 f0             	mov    %al,-0x10(%rbp)
  TCPIP_APIMSG(&msg);
  81995e:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819962:	48 89 c7             	mov    %rax,%rdi
  819965:	48 b8 b7 88 80 00 00 	movabs $0x8088b7,%rax
  81996c:	00 00 00 
  81996f:	ff d0                	callq  *%rax

  return conn->err;
  819971:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819975:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819979:	c9                   	leaveq 
  81997a:	c3                   	retq   

000000000081997b <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  81997b:	55                   	push   %rbp
  81997c:	48 89 e5             	mov    %rsp,%rbp
  81997f:	48 83 ec 50          	sub    $0x50,%rsp
  819983:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819987:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  81998b:	89 d0                	mov    %edx,%eax
  81998d:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  819991:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819996:	75 2a                	jne    8199c2 <netconn_bind+0x47>
  819998:	48 ba 1e 33 82 00 00 	movabs $0x82331e,%rdx
  81999f:	00 00 00 
  8199a2:	be b5 00 00 00       	mov    $0xb5,%esi
  8199a7:	48 bf 41 32 82 00 00 	movabs $0x823241,%rdi
  8199ae:	00 00 00 
  8199b1:	b8 00 00 00 00       	mov    $0x0,%eax
  8199b6:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8199bd:	00 00 00 
  8199c0:	ff d1                	callq  *%rcx

  msg.function = do_bind;
  8199c2:	48 b8 c1 b3 81 00 00 	movabs $0x81b3c1,%rax
  8199c9:	00 00 00 
  8199cc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  8199d0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8199d4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.bc.ipaddr = addr;
  8199d8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8199dc:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.bc.port = port;
  8199e0:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  8199e4:	66 89 45 e8          	mov    %ax,-0x18(%rbp)
  TCPIP_APIMSG(&msg);
  8199e8:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8199ec:	48 89 c7             	mov    %rax,%rdi
  8199ef:	48 b8 b7 88 80 00 00 	movabs $0x8088b7,%rax
  8199f6:	00 00 00 
  8199f9:	ff d0                	callq  *%rax
  return conn->err;
  8199fb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8199ff:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819a03:	c9                   	leaveq 
  819a04:	c3                   	retq   

0000000000819a05 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  819a05:	55                   	push   %rbp
  819a06:	48 89 e5             	mov    %rsp,%rbp
  819a09:	48 83 ec 50          	sub    $0x50,%rsp
  819a0d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819a11:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  819a15:	89 d0                	mov    %edx,%eax
  819a17:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  819a1b:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819a20:	75 2a                	jne    819a4c <netconn_connect+0x47>
  819a22:	48 ba 39 33 82 00 00 	movabs $0x823339,%rdx
  819a29:	00 00 00 
  819a2c:	be cc 00 00 00       	mov    $0xcc,%esi
  819a31:	48 bf 41 32 82 00 00 	movabs $0x823241,%rdi
  819a38:	00 00 00 
  819a3b:	b8 00 00 00 00       	mov    $0x0,%eax
  819a40:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  819a47:	00 00 00 
  819a4a:	ff d1                	callq  *%rcx

  msg.function = do_connect;
  819a4c:	48 b8 71 b5 81 00 00 	movabs $0x81b571,%rax
  819a53:	00 00 00 
  819a56:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819a5a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819a5e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.bc.ipaddr = addr;
  819a62:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819a66:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.bc.port = port;
  819a6a:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
  819a6e:	66 89 45 e8          	mov    %ax,-0x18(%rbp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  819a72:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819a76:	48 89 c7             	mov    %rax,%rdi
  819a79:	48 b8 b7 88 80 00 00 	movabs $0x8088b7,%rax
  819a80:	00 00 00 
  819a83:	ff d0                	callq  *%rax
  return conn->err;
  819a85:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819a89:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819a8d:	c9                   	leaveq 
  819a8e:	c3                   	retq   

0000000000819a8f <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  819a8f:	55                   	push   %rbp
  819a90:	48 89 e5             	mov    %rsp,%rbp
  819a93:	48 83 ec 40          	sub    $0x40,%rsp
  819a97:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  819a9b:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819aa0:	75 2a                	jne    819acc <netconn_disconnect+0x3d>
  819aa2:	48 ba 58 33 82 00 00 	movabs $0x823358,%rdx
  819aa9:	00 00 00 
  819aac:	be e2 00 00 00       	mov    $0xe2,%esi
  819ab1:	48 bf 41 32 82 00 00 	movabs $0x823241,%rdi
  819ab8:	00 00 00 
  819abb:	b8 00 00 00 00       	mov    $0x0,%eax
  819ac0:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  819ac7:	00 00 00 
  819aca:	ff d1                	callq  *%rcx

  msg.function = do_disconnect;
  819acc:	48 b8 e0 b6 81 00 00 	movabs $0x81b6e0,%rax
  819ad3:	00 00 00 
  819ad6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819ada:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819ade:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  TCPIP_APIMSG(&msg);
  819ae2:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819ae6:	48 89 c7             	mov    %rax,%rdi
  819ae9:	48 b8 b7 88 80 00 00 	movabs $0x8088b7,%rax
  819af0:	00 00 00 
  819af3:	ff d0                	callq  *%rax
  return conn->err;
  819af5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819af9:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819afd:	c9                   	leaveq 
  819afe:	c3                   	retq   

0000000000819aff <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  819aff:	55                   	push   %rbp
  819b00:	48 89 e5             	mov    %rsp,%rbp
  819b03:	48 83 ec 40          	sub    $0x40,%rsp
  819b07:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819b0b:	89 f0                	mov    %esi,%eax
  819b0d:	88 45 c4             	mov    %al,-0x3c(%rbp)
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  819b10:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819b15:	75 2a                	jne    819b41 <netconn_listen_with_backlog+0x42>
  819b17:	48 ba 79 33 82 00 00 	movabs $0x823379,%rdx
  819b1e:	00 00 00 
  819b21:	be fa 00 00 00       	mov    $0xfa,%esi
  819b26:	48 bf 41 32 82 00 00 	movabs $0x823241,%rdi
  819b2d:	00 00 00 
  819b30:	b8 00 00 00 00       	mov    $0x0,%eax
  819b35:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  819b3c:	00 00 00 
  819b3f:	ff d1                	callq  *%rcx

  msg.function = do_listen;
  819b41:	48 b8 33 b7 81 00 00 	movabs $0x81b733,%rax
  819b48:	00 00 00 
  819b4b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819b4f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819b53:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  819b57:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819b5b:	48 89 c7             	mov    %rax,%rdi
  819b5e:	48 b8 b7 88 80 00 00 	movabs $0x8088b7,%rax
  819b65:	00 00 00 
  819b68:	ff d0                	callq  *%rax
  return conn->err;
  819b6a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819b6e:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819b72:	c9                   	leaveq 
  819b73:	c3                   	retq   

0000000000819b74 <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  819b74:	55                   	push   %rbp
  819b75:	48 89 e5             	mov    %rsp,%rbp
  819b78:	48 83 ec 20          	sub    $0x20,%rsp
  819b7c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  819b80:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  819b85:	75 2a                	jne    819bb1 <netconn_accept+0x3d>
  819b87:	48 ba 96 33 82 00 00 	movabs $0x823396,%rdx
  819b8e:	00 00 00 
  819b91:	be 10 01 00 00       	mov    $0x110,%esi
  819b96:	48 bf 41 32 82 00 00 	movabs $0x823241,%rdi
  819b9d:	00 00 00 
  819ba0:	b8 00 00 00 00       	mov    $0x0,%eax
  819ba5:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  819bac:	00 00 00 
  819baf:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  819bb1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819bb5:	8b 40 1c             	mov    0x1c(%rax),%eax
  819bb8:	83 f8 ff             	cmp    $0xffffffff,%eax
  819bbb:	75 2a                	jne    819be7 <netconn_accept+0x73>
  819bbd:	48 ba b8 33 82 00 00 	movabs $0x8233b8,%rdx
  819bc4:	00 00 00 
  819bc7:	be 11 01 00 00       	mov    $0x111,%esi
  819bcc:	48 bf 41 32 82 00 00 	movabs $0x823241,%rdi
  819bd3:	00 00 00 
  819bd6:	b8 00 00 00 00       	mov    $0x0,%eax
  819bdb:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  819be2:	00 00 00 
  819be5:	ff d1                	callq  *%rcx
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  819be7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819beb:	8b 40 1c             	mov    0x1c(%rax),%eax
  819bee:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  819bf2:	ba 00 00 00 00       	mov    $0x0,%edx
  819bf7:	48 89 ce             	mov    %rcx,%rsi
  819bfa:	89 c7                	mov    %eax,%edi
  819bfc:	48 b8 70 7f 81 00 00 	movabs $0x817f70,%rax
  819c03:	00 00 00 
  819c06:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  819c08:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819c0c:	48 8b 40 38          	mov    0x38(%rax),%rax
  819c10:	48 85 c0             	test   %rax,%rax
  819c13:	74 1b                	je     819c30 <netconn_accept+0xbc>
  819c15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819c19:	48 8b 48 38          	mov    0x38(%rax),%rcx
  819c1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  819c21:	ba 00 00 00 00       	mov    $0x0,%edx
  819c26:	be 01 00 00 00       	mov    $0x1,%esi
  819c2b:	48 89 c7             	mov    %rax,%rdi
  819c2e:	ff d1                	callq  *%rcx
      TCPIP_APIMSG(&msg);
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
  819c30:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  819c34:	c9                   	leaveq 
  819c35:	c3                   	retq   

0000000000819c36 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  819c36:	55                   	push   %rbp
  819c37:	48 89 e5             	mov    %rsp,%rbp
  819c3a:	48 83 ec 50          	sub    $0x50,%rsp
  819c3e:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  struct api_msg msg;
  struct netbuf *buf = NULL;
  819c42:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  819c49:	00 
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  819c4a:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  819c4f:	75 2a                	jne    819c7b <netconn_recv+0x45>
  819c51:	48 ba db 33 82 00 00 	movabs $0x8233db,%rdx
  819c58:	00 00 00 
  819c5b:	be 3a 01 00 00       	mov    $0x13a,%esi
  819c60:	48 bf 41 32 82 00 00 	movabs $0x823241,%rdi
  819c67:	00 00 00 
  819c6a:	b8 00 00 00 00       	mov    $0x0,%eax
  819c6f:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  819c76:	00 00 00 
  819c79:	ff d1                	callq  *%rcx

  if (conn->recvmbox == SYS_MBOX_NULL) {
  819c7b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819c7f:	8b 40 18             	mov    0x18(%rax),%eax
  819c82:	83 f8 ff             	cmp    $0xffffffff,%eax
  819c85:	75 12                	jne    819c99 <netconn_recv+0x63>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  819c87:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819c8b:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
    return NULL;
  819c8f:	b8 00 00 00 00       	mov    $0x0,%eax
  819c94:	e9 22 02 00 00       	jmpq   819ebb <netconn_recv+0x285>
  }

  if (ERR_IS_FATAL(conn->err)) {
  819c99:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819c9d:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  819ca1:	3c fc                	cmp    $0xfc,%al
  819ca3:	7d 0a                	jge    819caf <netconn_recv+0x79>
    return NULL;
  819ca5:	b8 00 00 00 00       	mov    $0x0,%eax
  819caa:	e9 0c 02 00 00       	jmpq   819ebb <netconn_recv+0x285>
  }

  if (conn->type == NETCONN_TCP) {
  819caf:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819cb3:	8b 00                	mov    (%rax),%eax
  819cb5:	83 f8 10             	cmp    $0x10,%eax
  819cb8:	0f 85 80 01 00 00    	jne    819e3e <netconn_recv+0x208>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  819cbe:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819cc2:	8b 40 04             	mov    0x4(%rax),%eax
  819cc5:	83 f8 02             	cmp    $0x2,%eax
  819cc8:	75 12                	jne    819cdc <netconn_recv+0xa6>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  819cca:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819cce:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
      return NULL;
  819cd2:	b8 00 00 00 00       	mov    $0x0,%eax
  819cd7:	e9 df 01 00 00       	jmpq   819ebb <netconn_recv+0x285>
    }

    buf = memp_malloc(MEMP_NETBUF);
  819cdc:	bf 06 00 00 00       	mov    $0x6,%edi
  819ce1:	48 b8 41 ca 80 00 00 	movabs $0x80ca41,%rax
  819ce8:	00 00 00 
  819ceb:	ff d0                	callq  *%rax
  819ced:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

    if (buf == NULL) {
  819cf1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819cf5:	48 85 c0             	test   %rax,%rax
  819cf8:	75 12                	jne    819d0c <netconn_recv+0xd6>
      conn->err = ERR_MEM;
  819cfa:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819cfe:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
      return NULL;
  819d02:	b8 00 00 00 00       	mov    $0x0,%eax
  819d07:	e9 af 01 00 00       	jmpq   819ebb <netconn_recv+0x285>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  819d0c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819d10:	8b 40 18             	mov    0x18(%rax),%eax
  819d13:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  819d17:	ba 00 00 00 00       	mov    $0x0,%edx
  819d1c:	48 89 ce             	mov    %rcx,%rsi
  819d1f:	89 c7                	mov    %eax,%edi
  819d21:	48 b8 70 7f 81 00 00 	movabs $0x817f70,%rax
  819d28:	00 00 00 
  819d2b:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  819d2d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819d31:	48 85 c0             	test   %rax,%rax
  819d34:	74 24                	je     819d5a <netconn_recv+0x124>
      len = p->tot_len;
  819d36:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819d3a:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  819d3e:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
      SYS_ARCH_DEC(conn->recv_avail, len);
  819d42:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819d46:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  819d4a:	89 c2                	mov    %eax,%edx
  819d4c:	66 2b 55 fe          	sub    -0x2(%rbp),%dx
  819d50:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819d54:	66 89 50 24          	mov    %dx,0x24(%rax)
  819d58:	eb 06                	jmp    819d60 <netconn_recv+0x12a>
    } else {
      len = 0;
  819d5a:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  819d60:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819d64:	48 8b 40 38          	mov    0x38(%rax),%rax
  819d68:	48 85 c0             	test   %rax,%rax
  819d6b:	74 1a                	je     819d87 <netconn_recv+0x151>
  819d6d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819d71:	48 8b 48 38          	mov    0x38(%rax),%rcx
  819d75:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  819d79:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819d7d:	be 01 00 00 00       	mov    $0x1,%esi
  819d82:	48 89 c7             	mov    %rax,%rdi
  819d85:	ff d1                	callq  *%rcx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  819d87:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819d8b:	48 85 c0             	test   %rax,%rax
  819d8e:	75 36                	jne    819dc6 <netconn_recv+0x190>
      memp_free(MEMP_NETBUF, buf);
  819d90:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819d94:	48 89 c6             	mov    %rax,%rsi
  819d97:	bf 06 00 00 00       	mov    $0x6,%edi
  819d9c:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  819da3:	00 00 00 
  819da6:	ff d0                	callq  *%rax
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  819da8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819dac:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  819db0:	84 c0                	test   %al,%al
  819db2:	75 08                	jne    819dbc <netconn_recv+0x186>
        conn->err = ERR_CLSD;
  819db4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819db8:	c6 40 10 f9          	movb   $0xf9,0x10(%rax)
      }
      return NULL;
  819dbc:	b8 00 00 00 00       	mov    $0x0,%eax
  819dc1:	e9 f5 00 00 00       	jmpq   819ebb <netconn_recv+0x285>
    }

    buf->p = p;
  819dc6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819dca:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  819dce:	48 89 10             	mov    %rdx,(%rax)
    buf->ptr = p;
  819dd1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819dd5:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  819dd9:	48 89 50 08          	mov    %rdx,0x8(%rax)
    buf->port = 0;
  819ddd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819de1:	66 c7 40 18 00 00    	movw   $0x0,0x18(%rax)
    buf->addr = NULL;
  819de7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819deb:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  819df2:	00 

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  819df3:	48 b8 6b ba 81 00 00 	movabs $0x81ba6b,%rax
  819dfa:	00 00 00 
  819dfd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    msg.msg.conn = conn;
  819e01:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819e05:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    if (buf != NULL) {
  819e09:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819e0d:	48 85 c0             	test   %rax,%rax
  819e10:	74 11                	je     819e23 <netconn_recv+0x1ed>
      msg.msg.msg.r.len = buf->p->tot_len;
  819e12:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819e16:	48 8b 00             	mov    (%rax),%rax
  819e19:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  819e1d:	66 89 45 e0          	mov    %ax,-0x20(%rbp)
  819e21:	eb 06                	jmp    819e29 <netconn_recv+0x1f3>
    } else {
      msg.msg.msg.r.len = 1;
  819e23:	66 c7 45 e0 01 00    	movw   $0x1,-0x20(%rbp)
    }
    TCPIP_APIMSG(&msg);
  819e29:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819e2d:	48 89 c7             	mov    %rax,%rdi
  819e30:	48 b8 b7 88 80 00 00 	movabs $0x8088b7,%rax
  819e37:	00 00 00 
  819e3a:	ff d0                	callq  *%rax
  819e3c:	eb 79                	jmp    819eb7 <netconn_recv+0x281>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  819e3e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819e42:	8b 40 18             	mov    0x18(%rax),%eax
  819e45:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
  819e49:	ba 00 00 00 00       	mov    $0x0,%edx
  819e4e:	48 89 ce             	mov    %rcx,%rsi
  819e51:	89 c7                	mov    %eax,%edi
  819e53:	48 b8 70 7f 81 00 00 	movabs $0x817f70,%rax
  819e5a:	00 00 00 
  819e5d:	ff d0                	callq  *%rax
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  819e5f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819e63:	48 85 c0             	test   %rax,%rax
  819e66:	74 4f                	je     819eb7 <netconn_recv+0x281>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  819e68:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819e6c:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  819e70:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819e74:	48 8b 00             	mov    (%rax),%rax
  819e77:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  819e7b:	66 29 c2             	sub    %ax,%dx
  819e7e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819e82:	66 89 50 24          	mov    %dx,0x24(%rax)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  819e86:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819e8a:	48 8b 40 38          	mov    0x38(%rax),%rax
  819e8e:	48 85 c0             	test   %rax,%rax
  819e91:	74 24                	je     819eb7 <netconn_recv+0x281>
  819e93:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819e97:	48 8b 48 38          	mov    0x38(%rax),%rcx
  819e9b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819e9f:	48 8b 00             	mov    (%rax),%rax
  819ea2:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  819ea6:	0f b7 d0             	movzwl %ax,%edx
  819ea9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  819ead:	be 01 00 00 00       	mov    $0x1,%esi
  819eb2:	48 89 c7             	mov    %rax,%rdi
  819eb5:	ff d1                	callq  *%rcx
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  819eb7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
}
  819ebb:	c9                   	leaveq 
  819ebc:	c3                   	retq   

0000000000819ebd <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  819ebd:	55                   	push   %rbp
  819ebe:	48 89 e5             	mov    %rsp,%rbp
  819ec1:	48 83 ec 20          	sub    $0x20,%rsp
  819ec5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  819ec9:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  819ecd:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  819ed1:	89 c8                	mov    %ecx,%eax
  819ed3:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
  if (buf != NULL) {
  819ed7:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  819edc:	74 34                	je     819f12 <netconn_sendto+0x55>
    buf->addr = addr;
  819ede:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819ee2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  819ee6:	48 89 50 10          	mov    %rdx,0x10(%rax)
    buf->port = port;
  819eea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  819eee:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  819ef2:	66 89 50 18          	mov    %dx,0x18(%rax)
    return netconn_send(conn, buf);
  819ef6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  819efa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  819efe:	48 89 d6             	mov    %rdx,%rsi
  819f01:	48 89 c7             	mov    %rax,%rdi
  819f04:	48 b8 19 9f 81 00 00 	movabs $0x819f19,%rax
  819f0b:	00 00 00 
  819f0e:	ff d0                	callq  *%rax
  819f10:	eb 05                	jmp    819f17 <netconn_sendto+0x5a>
  }
  return ERR_VAL;
  819f12:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  819f17:	c9                   	leaveq 
  819f18:	c3                   	retq   

0000000000819f19 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  819f19:	55                   	push   %rbp
  819f1a:	48 89 e5             	mov    %rsp,%rbp
  819f1d:	48 83 ec 40          	sub    $0x40,%rsp
  819f21:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819f25:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  819f29:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819f2e:	75 2a                	jne    819f5a <netconn_send+0x41>
  819f30:	48 ba f6 33 82 00 00 	movabs $0x8233f6,%rdx
  819f37:	00 00 00 
  819f3a:	be b9 01 00 00       	mov    $0x1b9,%esi
  819f3f:	48 bf 41 32 82 00 00 	movabs $0x823241,%rdi
  819f46:	00 00 00 
  819f49:	b8 00 00 00 00       	mov    $0x0,%eax
  819f4e:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  819f55:	00 00 00 
  819f58:	ff d1                	callq  *%rcx

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  819f5a:	48 b8 db b8 81 00 00 	movabs $0x81b8db,%rax
  819f61:	00 00 00 
  819f64:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  819f68:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819f6c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.b = buf;
  819f70:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  819f74:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  TCPIP_APIMSG(&msg);
  819f78:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  819f7c:	48 89 c7             	mov    %rax,%rdi
  819f7f:	48 b8 b7 88 80 00 00 	movabs $0x8088b7,%rax
  819f86:	00 00 00 
  819f89:	ff d0                	callq  *%rax
  return conn->err;
  819f8b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819f8f:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  819f93:	c9                   	leaveq 
  819f94:	c3                   	retq   

0000000000819f95 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  819f95:	55                   	push   %rbp
  819f96:	48 89 e5             	mov    %rsp,%rbp
  819f99:	48 83 ec 50          	sub    $0x50,%rsp
  819f9d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  819fa1:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  819fa5:	89 55 bc             	mov    %edx,-0x44(%rbp)
  819fa8:	89 c8                	mov    %ecx,%eax
  819faa:	88 45 b8             	mov    %al,-0x48(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  819fad:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  819fb2:	75 2a                	jne    819fde <netconn_write+0x49>
  819fb4:	48 ba 11 34 82 00 00 	movabs $0x823411,%rdx
  819fbb:	00 00 00 
  819fbe:	be d3 01 00 00       	mov    $0x1d3,%esi
  819fc3:	48 bf 41 32 82 00 00 	movabs $0x823241,%rdi
  819fca:	00 00 00 
  819fcd:	b8 00 00 00 00       	mov    $0x0,%eax
  819fd2:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  819fd9:	00 00 00 
  819fdc:	ff d1                	callq  *%rcx
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  819fde:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  819fe2:	8b 00                	mov    (%rax),%eax
  819fe4:	83 f8 10             	cmp    $0x10,%eax
  819fe7:	74 2a                	je     81a013 <netconn_write+0x7e>
  819fe9:	48 ba 30 34 82 00 00 	movabs $0x823430,%rdx
  819ff0:	00 00 00 
  819ff3:	be d4 01 00 00       	mov    $0x1d4,%esi
  819ff8:	48 bf 41 32 82 00 00 	movabs $0x823241,%rdi
  819fff:	00 00 00 
  81a002:	b8 00 00 00 00       	mov    $0x0,%eax
  81a007:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81a00e:	00 00 00 
  81a011:	ff d1                	callq  *%rcx

  msg.function = do_write;
  81a013:	48 b8 95 bd 81 00 00 	movabs $0x81bd95,%rax
  81a01a:	00 00 00 
  81a01d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81a021:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a025:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  msg.msg.msg.w.dataptr = dataptr;
  81a029:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81a02d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  msg.msg.msg.w.apiflags = apiflags;
  81a031:	0f b6 45 b8          	movzbl -0x48(%rbp),%eax
  81a035:	88 45 ec             	mov    %al,-0x14(%rbp)
  msg.msg.msg.w.len = size;
  81a038:	8b 45 bc             	mov    -0x44(%rbp),%eax
  81a03b:	89 45 e8             	mov    %eax,-0x18(%rbp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  81a03e:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a042:	48 89 c7             	mov    %rax,%rdi
  81a045:	48 b8 b7 88 80 00 00 	movabs $0x8088b7,%rax
  81a04c:	00 00 00 
  81a04f:	ff d0                	callq  *%rax
  return conn->err;
  81a051:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a055:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81a059:	c9                   	leaveq 
  81a05a:	c3                   	retq   

000000000081a05b <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  81a05b:	55                   	push   %rbp
  81a05c:	48 89 e5             	mov    %rsp,%rbp
  81a05f:	48 83 ec 40          	sub    $0x40,%rsp
  81a063:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  81a067:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  81a06c:	75 2a                	jne    81a098 <netconn_close+0x3d>
  81a06e:	48 ba 52 34 82 00 00 	movabs $0x823452,%rdx
  81a075:	00 00 00 
  81a078:	be ed 01 00 00       	mov    $0x1ed,%esi
  81a07d:	48 bf 41 32 82 00 00 	movabs $0x823241,%rdi
  81a084:	00 00 00 
  81a087:	b8 00 00 00 00       	mov    $0x0,%eax
  81a08c:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81a093:	00 00 00 
  81a096:	ff d1                	callq  *%rcx

  msg.function = do_close;
  81a098:	48 b8 bb bf 81 00 00 	movabs $0x81bfbb,%rax
  81a09f:	00 00 00 
  81a0a2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  msg.msg.conn = conn;
  81a0a6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a0aa:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  tcpip_apimsg(&msg);
  81a0ae:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  81a0b2:	48 89 c7             	mov    %rax,%rdi
  81a0b5:	48 b8 b7 88 80 00 00 	movabs $0x8088b7,%rax
  81a0bc:	00 00 00 
  81a0bf:	ff d0                	callq  *%rax
  return conn->err;
  81a0c1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a0c5:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81a0c9:	c9                   	leaveq 
  81a0ca:	c3                   	retq   
	...

000000000081a0cc <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  81a0cc:	55                   	push   %rbp
  81a0cd:	48 89 e5             	mov    %rsp,%rbp
  81a0d0:	48 83 ec 40          	sub    $0x40,%rsp
  81a0d4:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81a0d8:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  81a0dc:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  81a0e0:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(addr);
  conn = arg;
  81a0e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a0e8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  81a0ec:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a0f1:	0f 84 74 01 00 00    	je     81a26b <recv_raw+0x19f>
  81a0f7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a0fb:	8b 40 18             	mov    0x18(%rax),%eax
  81a0fe:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a101:	0f 84 64 01 00 00    	je     81a26b <recv_raw+0x19f>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  81a107:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81a10b:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a10f:	0f b7 c0             	movzwl %ax,%eax
  81a112:	ba 00 00 00 00       	mov    $0x0,%edx
  81a117:	89 c6                	mov    %eax,%esi
  81a119:	bf 03 00 00 00       	mov    $0x3,%edi
  81a11e:	48 b8 4c d0 80 00 00 	movabs $0x80d04c,%rax
  81a125:	00 00 00 
  81a128:	ff d0                	callq  *%rax
  81a12a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if(q != NULL) {
  81a12e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a133:	74 39                	je     81a16e <recv_raw+0xa2>
      if (pbuf_copy(q, p) != ERR_OK) {
  81a135:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81a139:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a13d:	48 89 d6             	mov    %rdx,%rsi
  81a140:	48 89 c7             	mov    %rax,%rdi
  81a143:	48 b8 b4 dd 80 00 00 	movabs $0x80ddb4,%rax
  81a14a:	00 00 00 
  81a14d:	ff d0                	callq  *%rax
  81a14f:	84 c0                	test   %al,%al
  81a151:	74 1b                	je     81a16e <recv_raw+0xa2>
        pbuf_free(q);
  81a153:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a157:	48 89 c7             	mov    %rax,%rdi
  81a15a:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81a161:	00 00 00 
  81a164:	ff d0                	callq  *%rax
        q = NULL;
  81a166:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  81a16d:	00 
      }
    }

    if(q != NULL) {
  81a16e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a173:	0f 84 f2 00 00 00    	je     81a26b <recv_raw+0x19f>
      buf = memp_malloc(MEMP_NETBUF);
  81a179:	bf 06 00 00 00       	mov    $0x6,%edi
  81a17e:	48 b8 41 ca 80 00 00 	movabs $0x80ca41,%rax
  81a185:	00 00 00 
  81a188:	ff d0                	callq  *%rax
  81a18a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      if (buf == NULL) {
  81a18e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81a193:	75 1d                	jne    81a1b2 <recv_raw+0xe6>
        pbuf_free(q);
  81a195:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a199:	48 89 c7             	mov    %rax,%rdi
  81a19c:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81a1a3:	00 00 00 
  81a1a6:	ff d0                	callq  *%rax
        return 0;
  81a1a8:	b8 00 00 00 00       	mov    $0x0,%eax
  81a1ad:	e9 be 00 00 00       	jmpq   81a270 <recv_raw+0x1a4>
      }

      buf->p = q;
  81a1b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a1b6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81a1ba:	48 89 10             	mov    %rdx,(%rax)
      buf->ptr = q;
  81a1bd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a1c1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81a1c5:	48 89 50 08          	mov    %rdx,0x8(%rax)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  81a1c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a1cd:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a1d1:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  81a1d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a1d9:	48 89 50 10          	mov    %rdx,0x10(%rax)
      buf->port = pcb->protocol;
  81a1dd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81a1e1:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81a1e5:	0f b6 d0             	movzbl %al,%edx
  81a1e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a1ec:	66 89 50 18          	mov    %dx,0x18(%rax)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  81a1f0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a1f4:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  81a1f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a1fc:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a200:	01 c2                	add    %eax,%edx
  81a202:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a206:	66 89 50 24          	mov    %dx,0x24(%rax)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  81a20a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a20e:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a212:	48 85 c0             	test   %rax,%rax
  81a215:	74 21                	je     81a238 <recv_raw+0x16c>
  81a217:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a21b:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81a21f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a223:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a227:	0f b7 d0             	movzwl %ax,%edx
  81a22a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a22e:	be 00 00 00 00       	mov    $0x0,%esi
  81a233:	48 89 c7             	mov    %rax,%rdi
  81a236:	ff d1                	callq  *%rcx
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  81a238:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a23c:	8b 40 18             	mov    0x18(%rax),%eax
  81a23f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81a243:	48 89 d6             	mov    %rdx,%rsi
  81a246:	89 c7                	mov    %eax,%edi
  81a248:	48 b8 7a 77 81 00 00 	movabs $0x81777a,%rax
  81a24f:	00 00 00 
  81a252:	ff d0                	callq  *%rax
  81a254:	84 c0                	test   %al,%al
  81a256:	74 13                	je     81a26b <recv_raw+0x19f>
        netbuf_delete(buf);
  81a258:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a25c:	48 89 c7             	mov    %rax,%rdi
  81a25f:	48 b8 9c 8a 80 00 00 	movabs $0x808a9c,%rax
  81a266:	00 00 00 
  81a269:	ff d0                	callq  *%rax
      }
    }
  }

  return 0; /* do not eat the packet */
  81a26b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81a270:	c9                   	leaveq 
  81a271:	c3                   	retq   

000000000081a272 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  81a272:	55                   	push   %rbp
  81a273:	48 89 e5             	mov    %rsp,%rbp
  81a276:	48 83 ec 40          	sub    $0x40,%rsp
  81a27a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a27e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81a282:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  81a286:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  81a28a:	44 89 c0             	mov    %r8d,%eax
  81a28d:	66 89 45 cc          	mov    %ax,-0x34(%rbp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  81a291:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81a296:	75 2a                	jne    81a2c2 <recv_udp+0x50>
  81a298:	48 ba 70 34 82 00 00 	movabs $0x823470,%rdx
  81a29f:	00 00 00 
  81a2a2:	be 8e 00 00 00       	mov    $0x8e,%esi
  81a2a7:	48 bf 92 34 82 00 00 	movabs $0x823492,%rdi
  81a2ae:	00 00 00 
  81a2b1:	b8 00 00 00 00       	mov    $0x0,%eax
  81a2b6:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81a2bd:	00 00 00 
  81a2c0:	ff d1                	callq  *%rcx
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  81a2c2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81a2c7:	75 2a                	jne    81a2f3 <recv_udp+0x81>
  81a2c9:	48 ba b0 34 82 00 00 	movabs $0x8234b0,%rdx
  81a2d0:	00 00 00 
  81a2d3:	be 8f 00 00 00       	mov    $0x8f,%esi
  81a2d8:	48 bf 92 34 82 00 00 	movabs $0x823492,%rdi
  81a2df:	00 00 00 
  81a2e2:	b8 00 00 00 00       	mov    $0x0,%eax
  81a2e7:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81a2ee:	00 00 00 
  81a2f1:	ff d1                	callq  *%rcx
  conn = arg;
  81a2f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a2f7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  81a2fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a2ff:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a303:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  81a307:	74 2a                	je     81a333 <recv_udp+0xc1>
  81a309:	48 ba cf 34 82 00 00 	movabs $0x8234cf,%rdx
  81a310:	00 00 00 
  81a313:	be 91 00 00 00       	mov    $0x91,%esi
  81a318:	48 bf 92 34 82 00 00 	movabs $0x823492,%rdi
  81a31f:	00 00 00 
  81a322:	b8 00 00 00 00       	mov    $0x0,%eax
  81a327:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81a32e:	00 00 00 
  81a331:	ff d1                	callq  *%rcx
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  81a333:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a338:	74 0c                	je     81a346 <recv_udp+0xd4>
  81a33a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a33e:	8b 40 18             	mov    0x18(%rax),%eax
  81a341:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a344:	75 18                	jne    81a35e <recv_udp+0xec>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  81a346:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a34a:	48 89 c7             	mov    %rax,%rdi
  81a34d:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81a354:	00 00 00 
  81a357:	ff d0                	callq  *%rax
    return;
  81a359:	e9 df 00 00 00       	jmpq   81a43d <recv_udp+0x1cb>
  }

  buf = memp_malloc(MEMP_NETBUF);
  81a35e:	bf 06 00 00 00       	mov    $0x6,%edi
  81a363:	48 b8 41 ca 80 00 00 	movabs $0x80ca41,%rax
  81a36a:	00 00 00 
  81a36d:	ff d0                	callq  *%rax
  81a36f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (buf == NULL) {
  81a373:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a378:	75 18                	jne    81a392 <recv_udp+0x120>
    pbuf_free(p);
  81a37a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a37e:	48 89 c7             	mov    %rax,%rdi
  81a381:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81a388:	00 00 00 
  81a38b:	ff d0                	callq  *%rax
    return;
  81a38d:	e9 ab 00 00 00       	jmpq   81a43d <recv_udp+0x1cb>
  } else {
    buf->p = p;
  81a392:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a396:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a39a:	48 89 10             	mov    %rdx,(%rax)
    buf->ptr = p;
  81a39d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a3a1:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a3a5:	48 89 50 08          	mov    %rdx,0x8(%rax)
    buf->addr = addr;
  81a3a9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a3ad:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81a3b1:	48 89 50 10          	mov    %rdx,0x10(%rax)
    buf->port = port;
  81a3b5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a3b9:	0f b7 55 cc          	movzwl -0x34(%rbp),%edx
  81a3bd:	66 89 50 18          	mov    %dx,0x18(%rax)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  81a3c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a3c5:	0f b7 50 24          	movzwl 0x24(%rax),%edx
  81a3c9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a3cd:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a3d1:	01 c2                	add    %eax,%edx
  81a3d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a3d7:	66 89 50 24          	mov    %dx,0x24(%rax)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  81a3db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a3df:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a3e3:	48 85 c0             	test   %rax,%rax
  81a3e6:	74 21                	je     81a409 <recv_udp+0x197>
  81a3e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a3ec:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81a3f0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a3f4:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a3f8:	0f b7 d0             	movzwl %ax,%edx
  81a3fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a3ff:	be 00 00 00 00       	mov    $0x0,%esi
  81a404:	48 89 c7             	mov    %rax,%rdi
  81a407:	ff d1                	callq  *%rcx
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  81a409:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a40d:	8b 40 18             	mov    0x18(%rax),%eax
  81a410:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81a414:	48 89 d6             	mov    %rdx,%rsi
  81a417:	89 c7                	mov    %eax,%edi
  81a419:	48 b8 7a 77 81 00 00 	movabs $0x81777a,%rax
  81a420:	00 00 00 
  81a423:	ff d0                	callq  *%rax
  81a425:	84 c0                	test   %al,%al
  81a427:	74 14                	je     81a43d <recv_udp+0x1cb>
    netbuf_delete(buf);
  81a429:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a42d:	48 89 c7             	mov    %rax,%rdi
  81a430:	48 b8 9c 8a 80 00 00 	movabs $0x808a9c,%rax
  81a437:	00 00 00 
  81a43a:	ff d0                	callq  *%rax
    return;
  81a43c:	90                   	nop
  }
}
  81a43d:	c9                   	leaveq 
  81a43e:	c3                   	retq   

000000000081a43f <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  81a43f:	55                   	push   %rbp
  81a440:	48 89 e5             	mov    %rsp,%rbp
  81a443:	48 83 ec 30          	sub    $0x30,%rsp
  81a447:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a44b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81a44f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  81a453:	89 c8                	mov    %ecx,%eax
  81a455:	88 45 d4             	mov    %al,-0x2c(%rbp)
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  81a458:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81a45d:	75 2a                	jne    81a489 <recv_tcp+0x4a>
  81a45f:	48 ba f0 34 82 00 00 	movabs $0x8234f0,%rdx
  81a466:	00 00 00 
  81a469:	be c1 00 00 00       	mov    $0xc1,%esi
  81a46e:	48 bf 92 34 82 00 00 	movabs $0x823492,%rdi
  81a475:	00 00 00 
  81a478:	b8 00 00 00 00       	mov    $0x0,%eax
  81a47d:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81a484:	00 00 00 
  81a487:	ff d1                	callq  *%rcx
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  81a489:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81a48e:	75 2a                	jne    81a4ba <recv_tcp+0x7b>
  81a490:	48 ba 18 35 82 00 00 	movabs $0x823518,%rdx
  81a497:	00 00 00 
  81a49a:	be c2 00 00 00       	mov    $0xc2,%esi
  81a49f:	48 bf 92 34 82 00 00 	movabs $0x823492,%rdi
  81a4a6:	00 00 00 
  81a4a9:	b8 00 00 00 00       	mov    $0x0,%eax
  81a4ae:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81a4b5:	00 00 00 
  81a4b8:	ff d1                	callq  *%rcx
  conn = arg;
  81a4ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a4be:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  81a4c2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a4c6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a4ca:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  81a4ce:	74 2a                	je     81a4fa <recv_tcp+0xbb>
  81a4d0:	48 ba 37 35 82 00 00 	movabs $0x823537,%rdx
  81a4d7:	00 00 00 
  81a4da:	be c4 00 00 00       	mov    $0xc4,%esi
  81a4df:	48 bf 92 34 82 00 00 	movabs $0x823492,%rdi
  81a4e6:	00 00 00 
  81a4e9:	b8 00 00 00 00       	mov    $0x0,%eax
  81a4ee:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81a4f5:	00 00 00 
  81a4f8:	ff d1                	callq  *%rcx

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  81a4fa:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a4ff:	74 0c                	je     81a50d <recv_tcp+0xce>
  81a501:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a505:	8b 40 18             	mov    0x18(%rax),%eax
  81a508:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a50b:	75 0a                	jne    81a517 <recv_tcp+0xd8>
    return ERR_VAL;
  81a50d:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  81a512:	e9 8f 00 00 00       	jmpq   81a5a6 <recv_tcp+0x167>
  }

  conn->err = err;
  81a517:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a51b:	0f b6 55 d4          	movzbl -0x2c(%rbp),%edx
  81a51f:	88 50 10             	mov    %dl,0x10(%rax)
  if (p != NULL) {
  81a522:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81a527:	74 24                	je     81a54d <recv_tcp+0x10e>
    len = p->tot_len;
  81a529:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81a52d:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81a531:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    SYS_ARCH_INC(conn->recv_avail, len);
  81a535:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a539:	0f b7 40 24          	movzwl 0x24(%rax),%eax
  81a53d:	89 c2                	mov    %eax,%edx
  81a53f:	66 03 55 fe          	add    -0x2(%rbp),%dx
  81a543:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a547:	66 89 50 24          	mov    %dx,0x24(%rax)
  81a54b:	eb 06                	jmp    81a553 <recv_tcp+0x114>
  } else {
    len = 0;
  81a54d:	66 c7 45 fe 00 00    	movw   $0x0,-0x2(%rbp)
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  81a553:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a557:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a55b:	48 85 c0             	test   %rax,%rax
  81a55e:	74 1a                	je     81a57a <recv_tcp+0x13b>
  81a560:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a564:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81a568:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81a56c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a570:	be 00 00 00 00       	mov    $0x0,%esi
  81a575:	48 89 c7             	mov    %rax,%rdi
  81a578:	ff d1                	callq  *%rcx
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  81a57a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a57e:	8b 40 18             	mov    0x18(%rax),%eax
  81a581:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81a585:	48 89 d6             	mov    %rdx,%rsi
  81a588:	89 c7                	mov    %eax,%edi
  81a58a:	48 b8 7a 77 81 00 00 	movabs $0x81777a,%rax
  81a591:	00 00 00 
  81a594:	ff d0                	callq  *%rax
  81a596:	84 c0                	test   %al,%al
  81a598:	74 07                	je     81a5a1 <recv_tcp+0x162>
    return ERR_MEM;
  81a59a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81a59f:	eb 05                	jmp    81a5a6 <recv_tcp+0x167>
  }

  return ERR_OK;
  81a5a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81a5a6:	c9                   	leaveq 
  81a5a7:	c3                   	retq   

000000000081a5a8 <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  81a5a8:	55                   	push   %rbp
  81a5a9:	48 89 e5             	mov    %rsp,%rbp
  81a5ac:	48 83 ec 20          	sub    $0x20,%rsp
  81a5b0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a5b4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct netconn *conn = arg;
  81a5b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a5bc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  81a5c0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a5c5:	75 2a                	jne    81a5f1 <poll_tcp+0x49>
  81a5c7:	48 ba 55 35 82 00 00 	movabs $0x823555,%rdx
  81a5ce:	00 00 00 
  81a5d1:	be eb 00 00 00       	mov    $0xeb,%esi
  81a5d6:	48 bf 92 34 82 00 00 	movabs $0x823492,%rdi
  81a5dd:	00 00 00 
  81a5e0:	b8 00 00 00 00       	mov    $0x0,%eax
  81a5e5:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81a5ec:	00 00 00 
  81a5ef:	ff d1                	callq  *%rcx

  if (conn->state == NETCONN_WRITE) {
  81a5f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a5f5:	8b 40 04             	mov    0x4(%rax),%eax
  81a5f8:	83 f8 01             	cmp    $0x1,%eax
  81a5fb:	75 15                	jne    81a612 <poll_tcp+0x6a>
    do_writemore(conn);
  81a5fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a601:	48 89 c7             	mov    %rax,%rdi
  81a604:	48 b8 e5 ba 81 00 00 	movabs $0x81bae5,%rax
  81a60b:	00 00 00 
  81a60e:	ff d0                	callq  *%rax
  81a610:	eb 1f                	jmp    81a631 <poll_tcp+0x89>
  } else if (conn->state == NETCONN_CLOSE) {
  81a612:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a616:	8b 40 04             	mov    0x4(%rax),%eax
  81a619:	83 f8 04             	cmp    $0x4,%eax
  81a61c:	75 13                	jne    81a631 <poll_tcp+0x89>
    do_close_internal(conn);
  81a61e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a622:	48 89 c7             	mov    %rax,%rdi
  81a625:	48 b8 56 af 81 00 00 	movabs $0x81af56,%rax
  81a62c:	00 00 00 
  81a62f:	ff d0                	callq  *%rax
  }

  return ERR_OK;
  81a631:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81a636:	c9                   	leaveq 
  81a637:	c3                   	retq   

000000000081a638 <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  81a638:	55                   	push   %rbp
  81a639:	48 89 e5             	mov    %rsp,%rbp
  81a63c:	48 83 ec 30          	sub    $0x30,%rsp
  81a640:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a644:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81a648:	89 d0                	mov    %edx,%eax
  81a64a:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
  struct netconn *conn = arg;
  81a64e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a652:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  81a656:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a65b:	75 2a                	jne    81a687 <sent_tcp+0x4f>
  81a65d:	48 ba 55 35 82 00 00 	movabs $0x823555,%rdx
  81a664:	00 00 00 
  81a667:	be 03 01 00 00       	mov    $0x103,%esi
  81a66c:	48 bf 92 34 82 00 00 	movabs $0x823492,%rdi
  81a673:	00 00 00 
  81a676:	b8 00 00 00 00       	mov    $0x0,%eax
  81a67b:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81a682:	00 00 00 
  81a685:	ff d1                	callq  *%rcx

  if (conn->state == NETCONN_WRITE) {
  81a687:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a68b:	8b 40 04             	mov    0x4(%rax),%eax
  81a68e:	83 f8 01             	cmp    $0x1,%eax
  81a691:	75 4c                	jne    81a6df <sent_tcp+0xa7>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  81a693:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a697:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a69b:	48 85 c0             	test   %rax,%rax
  81a69e:	75 2a                	jne    81a6ca <sent_tcp+0x92>
  81a6a0:	48 ba 62 35 82 00 00 	movabs $0x823562,%rdx
  81a6a7:	00 00 00 
  81a6aa:	be 06 01 00 00       	mov    $0x106,%esi
  81a6af:	48 bf 92 34 82 00 00 	movabs $0x823492,%rdi
  81a6b6:	00 00 00 
  81a6b9:	b8 00 00 00 00       	mov    $0x0,%eax
  81a6be:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81a6c5:	00 00 00 
  81a6c8:	ff d1                	callq  *%rcx
    do_writemore(conn);
  81a6ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a6ce:	48 89 c7             	mov    %rax,%rdi
  81a6d1:	48 b8 e5 ba 81 00 00 	movabs $0x81bae5,%rax
  81a6d8:	00 00 00 
  81a6db:	ff d0                	callq  *%rax
  81a6dd:	eb 1f                	jmp    81a6fe <sent_tcp+0xc6>
  } else if (conn->state == NETCONN_CLOSE) {
  81a6df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a6e3:	8b 40 04             	mov    0x4(%rax),%eax
  81a6e6:	83 f8 04             	cmp    $0x4,%eax
  81a6e9:	75 13                	jne    81a6fe <sent_tcp+0xc6>
    do_close_internal(conn);
  81a6eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a6ef:	48 89 c7             	mov    %rax,%rdi
  81a6f2:	48 b8 56 af 81 00 00 	movabs $0x81af56,%rax
  81a6f9:	00 00 00 
  81a6fc:	ff d0                	callq  *%rax
  }

  if (conn) {
  81a6fe:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a703:	74 46                	je     81a74b <sent_tcp+0x113>
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  81a705:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a709:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a70d:	48 85 c0             	test   %rax,%rax
  81a710:	74 39                	je     81a74b <sent_tcp+0x113>
  81a712:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a716:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a71a:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81a71e:	66 3d a0 2d          	cmp    $0x2da0,%ax
  81a722:	76 27                	jbe    81a74b <sent_tcp+0x113>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  81a724:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a728:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a72c:	48 85 c0             	test   %rax,%rax
  81a72f:	74 1a                	je     81a74b <sent_tcp+0x113>
  81a731:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a735:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81a739:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  81a73d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a741:	be 02 00 00 00       	mov    $0x2,%esi
  81a746:	48 89 c7             	mov    %rax,%rdi
  81a749:	ff d1                	callq  *%rcx
    }
  }
  
  return ERR_OK;
  81a74b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81a750:	c9                   	leaveq 
  81a751:	c3                   	retq   

000000000081a752 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  81a752:	55                   	push   %rbp
  81a753:	48 89 e5             	mov    %rsp,%rbp
  81a756:	48 83 ec 20          	sub    $0x20,%rsp
  81a75a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a75e:	89 f0                	mov    %esi,%eax
  81a760:	88 45 e4             	mov    %al,-0x1c(%rbp)
  struct netconn *conn;

  conn = arg;
  81a763:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a767:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  81a76b:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81a770:	75 2a                	jne    81a79c <err_tcp+0x4a>
  81a772:	48 ba 55 35 82 00 00 	movabs $0x823555,%rdx
  81a779:	00 00 00 
  81a77c:	be 22 01 00 00       	mov    $0x122,%esi
  81a781:	48 bf 92 34 82 00 00 	movabs $0x823492,%rdi
  81a788:	00 00 00 
  81a78b:	b8 00 00 00 00       	mov    $0x0,%eax
  81a790:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81a797:	00 00 00 
  81a79a:	ff d1                	callq  *%rcx

  conn->pcb.tcp = NULL;
  81a79c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a7a0:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81a7a7:	00 

  conn->err = err;
  81a7a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a7ac:	0f b6 55 e4          	movzbl -0x1c(%rbp),%edx
  81a7b0:	88 50 10             	mov    %dl,0x10(%rax)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  81a7b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a7b7:	8b 40 18             	mov    0x18(%rax),%eax
  81a7ba:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a7bd:	74 42                	je     81a801 <err_tcp+0xaf>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81a7bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a7c3:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a7c7:	48 85 c0             	test   %rax,%rax
  81a7ca:	74 1b                	je     81a7e7 <err_tcp+0x95>
  81a7cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a7d0:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81a7d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a7d8:	ba 00 00 00 00       	mov    $0x0,%edx
  81a7dd:	be 00 00 00 00       	mov    $0x0,%esi
  81a7e2:	48 89 c7             	mov    %rax,%rdi
  81a7e5:	ff d1                	callq  *%rcx
    sys_mbox_post(conn->recvmbox, NULL);
  81a7e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a7eb:	8b 40 18             	mov    0x18(%rax),%eax
  81a7ee:	be 00 00 00 00       	mov    $0x0,%esi
  81a7f3:	89 c7                	mov    %eax,%edi
  81a7f5:	48 b8 18 77 81 00 00 	movabs $0x817718,%rax
  81a7fc:	00 00 00 
  81a7ff:	ff d0                	callq  *%rax
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  81a801:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a805:	8b 40 14             	mov    0x14(%rax),%eax
  81a808:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a80b:	74 2c                	je     81a839 <err_tcp+0xe7>
  81a80d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a811:	8b 40 04             	mov    0x4(%rax),%eax
  81a814:	83 f8 03             	cmp    $0x3,%eax
  81a817:	75 20                	jne    81a839 <err_tcp+0xe7>
    conn->state = NETCONN_NONE;
  81a819:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a81d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    sys_sem_signal(conn->op_completed);
  81a824:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a828:	8b 40 14             	mov    0x14(%rax),%eax
  81a82b:	89 c7                	mov    %eax,%edi
  81a82d:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  81a834:	00 00 00 
  81a837:	ff d0                	callq  *%rax
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  81a839:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a83d:	8b 40 1c             	mov    0x1c(%rax),%eax
  81a840:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a843:	74 42                	je     81a887 <err_tcp+0x135>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81a845:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a849:	48 8b 40 38          	mov    0x38(%rax),%rax
  81a84d:	48 85 c0             	test   %rax,%rax
  81a850:	74 1b                	je     81a86d <err_tcp+0x11b>
  81a852:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a856:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81a85a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a85e:	ba 00 00 00 00       	mov    $0x0,%edx
  81a863:	be 00 00 00 00       	mov    $0x0,%esi
  81a868:	48 89 c7             	mov    %rax,%rdi
  81a86b:	ff d1                	callq  *%rcx
    sys_mbox_post(conn->acceptmbox, NULL);
  81a86d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a871:	8b 40 1c             	mov    0x1c(%rax),%eax
  81a874:	be 00 00 00 00       	mov    $0x0,%esi
  81a879:	89 c7                	mov    %eax,%edi
  81a87b:	48 b8 18 77 81 00 00 	movabs $0x817718,%rax
  81a882:	00 00 00 
  81a885:	ff d0                	callq  *%rax
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  81a887:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a88b:	8b 40 04             	mov    0x4(%rax),%eax
  81a88e:	83 f8 01             	cmp    $0x1,%eax
  81a891:	74 0c                	je     81a89f <err_tcp+0x14d>
  81a893:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a897:	8b 40 04             	mov    0x4(%rax),%eax
  81a89a:	83 f8 04             	cmp    $0x4,%eax
  81a89d:	75 20                	jne    81a8bf <err_tcp+0x16d>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  81a89f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a8a3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  81a8aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a8ae:	8b 40 14             	mov    0x14(%rax),%eax
  81a8b1:	89 c7                	mov    %eax,%edi
  81a8b3:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  81a8ba:	00 00 00 
  81a8bd:	ff d0                	callq  *%rax
  }
}
  81a8bf:	c9                   	leaveq 
  81a8c0:	c3                   	retq   

000000000081a8c1 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  81a8c1:	55                   	push   %rbp
  81a8c2:	48 89 e5             	mov    %rsp,%rbp
  81a8c5:	48 83 ec 20          	sub    $0x20,%rsp
  81a8c9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  81a8cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a8d1:	48 8b 40 08          	mov    0x8(%rax),%rax
  81a8d5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  tcp_arg(pcb, conn);
  81a8d9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81a8dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a8e1:	48 89 d6             	mov    %rdx,%rsi
  81a8e4:	48 89 c7             	mov    %rax,%rdi
  81a8e7:	48 b8 16 05 81 00 00 	movabs $0x810516,%rax
  81a8ee:	00 00 00 
  81a8f1:	ff d0                	callq  *%rax
  tcp_recv(pcb, recv_tcp);
  81a8f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a8f7:	48 be 3f a4 81 00 00 	movabs $0x81a43f,%rsi
  81a8fe:	00 00 00 
  81a901:	48 89 c7             	mov    %rax,%rdi
  81a904:	48 b8 34 05 81 00 00 	movabs $0x810534,%rax
  81a90b:	00 00 00 
  81a90e:	ff d0                	callq  *%rax
  tcp_sent(pcb, sent_tcp);
  81a910:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a914:	48 be 38 a6 81 00 00 	movabs $0x81a638,%rsi
  81a91b:	00 00 00 
  81a91e:	48 89 c7             	mov    %rax,%rdi
  81a921:	48 b8 55 05 81 00 00 	movabs $0x810555,%rax
  81a928:	00 00 00 
  81a92b:	ff d0                	callq  *%rax
  tcp_poll(pcb, poll_tcp, 4);
  81a92d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a931:	ba 04 00 00 00       	mov    $0x4,%edx
  81a936:	48 be a8 a5 81 00 00 	movabs $0x81a5a8,%rsi
  81a93d:	00 00 00 
  81a940:	48 89 c7             	mov    %rax,%rdi
  81a943:	48 b8 b5 05 81 00 00 	movabs $0x8105b5,%rax
  81a94a:	00 00 00 
  81a94d:	ff d0                	callq  *%rax
  tcp_err(pcb, err_tcp);
  81a94f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a953:	48 be 52 a7 81 00 00 	movabs $0x81a752,%rsi
  81a95a:	00 00 00 
  81a95d:	48 89 c7             	mov    %rax,%rdi
  81a960:	48 b8 76 05 81 00 00 	movabs $0x810576,%rax
  81a967:	00 00 00 
  81a96a:	ff d0                	callq  *%rax
}
  81a96c:	c9                   	leaveq 
  81a96d:	c3                   	retq   

000000000081a96e <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  81a96e:	55                   	push   %rbp
  81a96f:	48 89 e5             	mov    %rsp,%rbp
  81a972:	48 83 ec 30          	sub    $0x30,%rsp
  81a976:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81a97a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81a97e:	89 d0                	mov    %edx,%eax
  81a980:	88 45 dc             	mov    %al,-0x24(%rbp)
#if API_MSG_DEBUG
#if TCP_DEBUG
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;
  81a983:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81a987:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  81a98b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a98f:	8b 40 1c             	mov    0x1c(%rax),%eax
  81a992:	83 f8 ff             	cmp    $0xffffffff,%eax
  81a995:	75 2a                	jne    81a9c1 <accept_function+0x53>
  81a997:	48 ba 78 35 82 00 00 	movabs $0x823578,%rdx
  81a99e:	00 00 00 
  81a9a1:	be 65 01 00 00       	mov    $0x165,%esi
  81a9a6:	48 bf 92 34 82 00 00 	movabs $0x823492,%rdi
  81a9ad:	00 00 00 
  81a9b0:	b8 00 00 00 00       	mov    $0x0,%eax
  81a9b5:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81a9bc:	00 00 00 
  81a9bf:	ff d1                	callq  *%rcx
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  81a9c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a9c5:	48 8b 50 38          	mov    0x38(%rax),%rdx
  81a9c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81a9cd:	8b 00                	mov    (%rax),%eax
  81a9cf:	48 89 d6             	mov    %rdx,%rsi
  81a9d2:	89 c7                	mov    %eax,%edi
  81a9d4:	48 b8 b8 ac 81 00 00 	movabs $0x81acb8,%rax
  81a9db:	00 00 00 
  81a9de:	ff d0                	callq  *%rax
  81a9e0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (newconn == NULL) {
  81a9e4:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81a9e9:	75 0a                	jne    81a9f5 <accept_function+0x87>
    return ERR_MEM;
  81a9eb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81a9f0:	e9 9d 00 00 00       	jmpq   81aa92 <accept_function+0x124>
  }
  newconn->pcb.tcp = newpcb;
  81a9f5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81a9f9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81a9fd:	48 89 50 08          	mov    %rdx,0x8(%rax)
  setup_tcp(newconn);
  81aa01:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81aa05:	48 89 c7             	mov    %rax,%rdi
  81aa08:	48 b8 c1 a8 81 00 00 	movabs $0x81a8c1,%rax
  81aa0f:	00 00 00 
  81aa12:	ff d0                	callq  *%rax
  newconn->err = err;
  81aa14:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81aa18:	0f b6 55 dc          	movzbl -0x24(%rbp),%edx
  81aa1c:	88 50 10             	mov    %dl,0x10(%rax)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81aa1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aa23:	48 8b 40 38          	mov    0x38(%rax),%rax
  81aa27:	48 85 c0             	test   %rax,%rax
  81aa2a:	74 1b                	je     81aa47 <accept_function+0xd9>
  81aa2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aa30:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81aa34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aa38:	ba 00 00 00 00       	mov    $0x0,%edx
  81aa3d:	be 00 00 00 00       	mov    $0x0,%esi
  81aa42:	48 89 c7             	mov    %rax,%rdi
  81aa45:	ff d1                	callq  *%rcx

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  81aa47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aa4b:	8b 40 1c             	mov    0x1c(%rax),%eax
  81aa4e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81aa52:	48 89 d6             	mov    %rdx,%rsi
  81aa55:	89 c7                	mov    %eax,%edi
  81aa57:	48 b8 7a 77 81 00 00 	movabs $0x81777a,%rax
  81aa5e:	00 00 00 
  81aa61:	ff d0                	callq  *%rax
  81aa63:	84 c0                	test   %al,%al
  81aa65:	74 26                	je     81aa8d <accept_function+0x11f>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  81aa67:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81aa6b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81aa72:	00 
    netconn_free(newconn);
  81aa73:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81aa77:	48 89 c7             	mov    %rax,%rdi
  81aa7a:	48 b8 ec ad 81 00 00 	movabs $0x81adec,%rax
  81aa81:	00 00 00 
  81aa84:	ff d0                	callq  *%rax
    return ERR_MEM;
  81aa86:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81aa8b:	eb 05                	jmp    81aa92 <accept_function+0x124>
  }
  return ERR_OK;
  81aa8d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81aa92:	c9                   	leaveq 
  81aa93:	c3                   	retq   

000000000081aa94 <pcb_new>:
 * @param msg the api_msg_msg describing the connection type
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
  81aa94:	55                   	push   %rbp
  81aa95:	48 89 e5             	mov    %rsp,%rbp
  81aa98:	53                   	push   %rbx
  81aa99:	48 83 ec 18          	sub    $0x18,%rsp
  81aa9d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   msg->conn->err = ERR_OK;
  81aaa1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aaa5:	48 8b 00             	mov    (%rax),%rax
  81aaa8:	c6 40 10 00          	movb   $0x0,0x10(%rax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  81aaac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aab0:	48 8b 00             	mov    (%rax),%rax
  81aab3:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aab7:	48 85 c0             	test   %rax,%rax
  81aaba:	74 2a                	je     81aae6 <pcb_new+0x52>
  81aabc:	48 ba a8 35 82 00 00 	movabs $0x8235a8,%rdx
  81aac3:	00 00 00 
  81aac6:	be 8a 01 00 00       	mov    $0x18a,%esi
  81aacb:	48 bf 92 34 82 00 00 	movabs $0x823492,%rdi
  81aad2:	00 00 00 
  81aad5:	b8 00 00 00 00       	mov    $0x0,%eax
  81aada:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81aae1:	00 00 00 
  81aae4:	ff d1                	callq  *%rcx

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  81aae6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aaea:	48 8b 00             	mov    (%rax),%rax
  81aaed:	8b 00                	mov    (%rax),%eax
  81aaef:	25 f0 00 00 00       	and    $0xf0,%eax
  81aaf4:	83 f8 20             	cmp    $0x20,%eax
  81aaf7:	0f 84 87 00 00 00    	je     81ab84 <pcb_new+0xf0>
  81aafd:	83 f8 40             	cmp    $0x40,%eax
  81ab00:	74 0e                	je     81ab10 <pcb_new+0x7c>
  81ab02:	83 f8 10             	cmp    $0x10,%eax
  81ab05:	0f 84 fa 00 00 00    	je     81ac05 <pcb_new+0x171>
  81ab0b:	e9 41 01 00 00       	jmpq   81ac51 <pcb_new+0x1bd>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  81ab10:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ab14:	48 8b 18             	mov    (%rax),%rbx
  81ab17:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ab1b:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  81ab1f:	0f b6 c0             	movzbl %al,%eax
  81ab22:	89 c7                	mov    %eax,%edi
  81ab24:	48 b8 10 fe 81 00 00 	movabs $0x81fe10,%rax
  81ab2b:	00 00 00 
  81ab2e:	ff d0                	callq  *%rax
  81ab30:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.raw == NULL) {
  81ab34:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ab38:	48 8b 00             	mov    (%rax),%rax
  81ab3b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ab3f:	48 85 c0             	test   %rax,%rax
  81ab42:	75 10                	jne    81ab54 <pcb_new+0xc0>
       msg->conn->err = ERR_MEM;
  81ab44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ab48:	48 8b 00             	mov    (%rax),%rax
  81ab4b:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81ab4f:	e9 09 01 00 00       	jmpq   81ac5d <pcb_new+0x1c9>
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  81ab54:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ab58:	48 8b 10             	mov    (%rax),%rdx
  81ab5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ab5f:	48 8b 00             	mov    (%rax),%rax
  81ab62:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ab66:	48 be cc a0 81 00 00 	movabs $0x81a0cc,%rsi
  81ab6d:	00 00 00 
  81ab70:	48 89 c7             	mov    %rax,%rdi
  81ab73:	48 b8 60 fb 81 00 00 	movabs $0x81fb60,%rax
  81ab7a:	00 00 00 
  81ab7d:	ff d0                	callq  *%rax
     break;
  81ab7f:	e9 d9 00 00 00       	jmpq   81ac5d <pcb_new+0x1c9>
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  81ab84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ab88:	48 8b 18             	mov    (%rax),%rbx
  81ab8b:	48 b8 e9 55 81 00 00 	movabs $0x8155e9,%rax
  81ab92:	00 00 00 
  81ab95:	ff d0                	callq  *%rax
  81ab97:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.udp == NULL) {
  81ab9b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ab9f:	48 8b 00             	mov    (%rax),%rax
  81aba2:	48 8b 40 08          	mov    0x8(%rax),%rax
  81aba6:	48 85 c0             	test   %rax,%rax
  81aba9:	75 10                	jne    81abbb <pcb_new+0x127>
       msg->conn->err = ERR_MEM;
  81abab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81abaf:	48 8b 00             	mov    (%rax),%rax
  81abb2:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81abb6:	e9 a2 00 00 00       	jmpq   81ac5d <pcb_new+0x1c9>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  81abbb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81abbf:	48 8b 00             	mov    (%rax),%rax
  81abc2:	8b 00                	mov    (%rax),%eax
  81abc4:	83 f8 22             	cmp    $0x22,%eax
  81abc7:	75 0f                	jne    81abd8 <pcb_new+0x144>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  81abc9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81abcd:	48 8b 00             	mov    (%rax),%rax
  81abd0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81abd4:	c6 40 18 01          	movb   $0x1,0x18(%rax)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  81abd8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81abdc:	48 8b 10             	mov    (%rax),%rdx
  81abdf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81abe3:	48 8b 00             	mov    (%rax),%rax
  81abe6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81abea:	48 be 72 a2 81 00 00 	movabs $0x81a272,%rsi
  81abf1:	00 00 00 
  81abf4:	48 89 c7             	mov    %rax,%rdi
  81abf7:	48 b8 11 55 81 00 00 	movabs $0x815511,%rax
  81abfe:	00 00 00 
  81ac01:	ff d0                	callq  *%rax
     break;
  81ac03:	eb 58                	jmp    81ac5d <pcb_new+0x1c9>
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  81ac05:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac09:	48 8b 18             	mov    (%rax),%rbx
  81ac0c:	48 b8 ff 04 81 00 00 	movabs $0x8104ff,%rax
  81ac13:	00 00 00 
  81ac16:	ff d0                	callq  *%rax
  81ac18:	48 89 43 08          	mov    %rax,0x8(%rbx)
     if(msg->conn->pcb.tcp == NULL) {
  81ac1c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac20:	48 8b 00             	mov    (%rax),%rax
  81ac23:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ac27:	48 85 c0             	test   %rax,%rax
  81ac2a:	75 0d                	jne    81ac39 <pcb_new+0x1a5>
       msg->conn->err = ERR_MEM;
  81ac2c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac30:	48 8b 00             	mov    (%rax),%rax
  81ac33:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
       break;
  81ac37:	eb 24                	jmp    81ac5d <pcb_new+0x1c9>
     }
     setup_tcp(msg->conn);
  81ac39:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac3d:	48 8b 00             	mov    (%rax),%rax
  81ac40:	48 89 c7             	mov    %rax,%rdi
  81ac43:	48 b8 c1 a8 81 00 00 	movabs $0x81a8c1,%rax
  81ac4a:	00 00 00 
  81ac4d:	ff d0                	callq  *%rax
     break;
  81ac4f:	eb 0c                	jmp    81ac5d <pcb_new+0x1c9>
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  81ac51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac55:	48 8b 00             	mov    (%rax),%rax
  81ac58:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
     break;
  81ac5c:	90                   	nop
   }

  return msg->conn->err;
  81ac5d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ac61:	48 8b 00             	mov    (%rax),%rax
  81ac64:	0f b6 40 10          	movzbl 0x10(%rax),%eax
}
  81ac68:	48 83 c4 18          	add    $0x18,%rsp
  81ac6c:	5b                   	pop    %rbx
  81ac6d:	5d                   	pop    %rbp
  81ac6e:	c3                   	retq   

000000000081ac6f <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  81ac6f:	55                   	push   %rbp
  81ac70:	48 89 e5             	mov    %rsp,%rbp
  81ac73:	48 83 ec 10          	sub    $0x10,%rsp
  81ac77:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   if(msg->conn->pcb.tcp == NULL) {
  81ac7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac7f:	48 8b 00             	mov    (%rax),%rax
  81ac82:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ac86:	48 85 c0             	test   %rax,%rax
  81ac89:	75 13                	jne    81ac9e <do_newconn+0x2f>
     pcb_new(msg);
  81ac8b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ac8f:	48 89 c7             	mov    %rax,%rdi
  81ac92:	48 b8 94 aa 81 00 00 	movabs $0x81aa94,%rax
  81ac99:	00 00 00 
  81ac9c:	ff d0                	callq  *%rax
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  81ac9e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aca2:	48 8b 00             	mov    (%rax),%rax
  81aca5:	8b 40 14             	mov    0x14(%rax),%eax
  81aca8:	89 c7                	mov    %eax,%edi
  81acaa:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  81acb1:	00 00 00 
  81acb4:	ff d0                	callq  *%rax
}
  81acb6:	c9                   	leaveq 
  81acb7:	c3                   	retq   

000000000081acb8 <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  81acb8:	55                   	push   %rbp
  81acb9:	48 89 e5             	mov    %rsp,%rbp
  81acbc:	48 83 ec 20          	sub    $0x20,%rsp
  81acc0:	89 7d ec             	mov    %edi,-0x14(%rbp)
  81acc3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  81acc7:	bf 07 00 00 00       	mov    $0x7,%edi
  81accc:	48 b8 41 ca 80 00 00 	movabs $0x80ca41,%rax
  81acd3:	00 00 00 
  81acd6:	ff d0                	callq  *%rax
  81acd8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  if (conn == NULL) {
  81acdc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81ace1:	75 0a                	jne    81aced <netconn_alloc+0x35>
    return NULL;
  81ace3:	b8 00 00 00 00       	mov    $0x0,%eax
  81ace8:	e9 fd 00 00 00       	jmpq   81adea <netconn_alloc+0x132>
  }

  conn->err = ERR_OK;
  81aced:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81acf1:	c6 40 10 00          	movb   $0x0,0x10(%rax)
  conn->type = t;
  81acf5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81acf9:	8b 55 ec             	mov    -0x14(%rbp),%edx
  81acfc:	89 10                	mov    %edx,(%rax)
  conn->pcb.tcp = NULL;
  81acfe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad02:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81ad09:	00 

#if (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_UDP_RECVMBOX_SIZE) && \
    (DEFAULT_RAW_RECVMBOX_SIZE == DEFAULT_TCP_RECVMBOX_SIZE)
  size = DEFAULT_RAW_RECVMBOX_SIZE;
  81ad0a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  81ad11:	bf 00 00 00 00       	mov    $0x0,%edi
  81ad16:	48 b8 e2 79 81 00 00 	movabs $0x8179e2,%rax
  81ad1d:	00 00 00 
  81ad20:	ff d0                	callq  *%rax
  81ad22:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81ad26:	89 42 14             	mov    %eax,0x14(%rdx)
  81ad29:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad2d:	8b 40 14             	mov    0x14(%rax),%eax
  81ad30:	83 f8 ff             	cmp    $0xffffffff,%eax
  81ad33:	75 22                	jne    81ad57 <netconn_alloc+0x9f>
    memp_free(MEMP_NETCONN, conn);
  81ad35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad39:	48 89 c6             	mov    %rax,%rsi
  81ad3c:	bf 07 00 00 00       	mov    $0x7,%edi
  81ad41:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  81ad48:	00 00 00 
  81ad4b:	ff d0                	callq  *%rax
    return NULL;
  81ad4d:	b8 00 00 00 00       	mov    $0x0,%eax
  81ad52:	e9 93 00 00 00       	jmpq   81adea <netconn_alloc+0x132>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  81ad57:	8b 45 f4             	mov    -0xc(%rbp),%eax
  81ad5a:	89 c7                	mov    %eax,%edi
  81ad5c:	48 b8 16 73 81 00 00 	movabs $0x817316,%rax
  81ad63:	00 00 00 
  81ad66:	ff d0                	callq  *%rax
  81ad68:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81ad6c:	89 42 18             	mov    %eax,0x18(%rdx)
  81ad6f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad73:	8b 40 18             	mov    0x18(%rax),%eax
  81ad76:	83 f8 ff             	cmp    $0xffffffff,%eax
  81ad79:	75 34                	jne    81adaf <netconn_alloc+0xf7>
    sys_sem_free(conn->op_completed);
  81ad7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad7f:	8b 40 14             	mov    0x14(%rax),%eax
  81ad82:	89 c7                	mov    %eax,%edi
  81ad84:	48 b8 e3 7a 81 00 00 	movabs $0x817ae3,%rax
  81ad8b:	00 00 00 
  81ad8e:	ff d0                	callq  *%rax
    memp_free(MEMP_NETCONN, conn);
  81ad90:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ad94:	48 89 c6             	mov    %rax,%rsi
  81ad97:	bf 07 00 00 00       	mov    $0x7,%edi
  81ad9c:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  81ada3:	00 00 00 
  81ada6:	ff d0                	callq  *%rax
    return NULL;
  81ada8:	b8 00 00 00 00       	mov    $0x0,%eax
  81adad:	eb 3b                	jmp    81adea <netconn_alloc+0x132>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  81adaf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81adb3:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%rax)
  conn->state        = NETCONN_NONE;
  81adba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81adbe:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  81adc5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81adc9:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%rax)
  conn->callback     = callback;
  81add0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81add4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  81add8:	48 89 50 38          	mov    %rdx,0x38(%rax)
  conn->recv_avail   = 0;
  81addc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ade0:	66 c7 40 24 00 00    	movw   $0x0,0x24(%rax)
  conn->recv_timeout = 0;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
  81ade6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81adea:	c9                   	leaveq 
  81adeb:	c3                   	retq   

000000000081adec <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  81adec:	55                   	push   %rbp
  81aded:	48 89 e5             	mov    %rsp,%rbp
  81adf0:	48 83 ec 20          	sub    $0x20,%rsp
  81adf4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  81adf8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81adfc:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ae00:	48 85 c0             	test   %rax,%rax
  81ae03:	74 2a                	je     81ae2f <netconn_free+0x43>
  81ae05:	48 ba c8 35 82 00 00 	movabs $0x8235c8,%rdx
  81ae0c:	00 00 00 
  81ae0f:	be 26 02 00 00       	mov    $0x226,%esi
  81ae14:	48 bf 92 34 82 00 00 	movabs $0x823492,%rdi
  81ae1b:	00 00 00 
  81ae1e:	b8 00 00 00 00       	mov    $0x0,%eax
  81ae23:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81ae2a:	00 00 00 
  81ae2d:	ff d1                	callq  *%rcx

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  81ae2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae33:	8b 40 18             	mov    0x18(%rax),%eax
  81ae36:	83 f8 ff             	cmp    $0xffffffff,%eax
  81ae39:	74 7f                	je     81aeba <netconn_free+0xce>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  81ae3b:	eb 3c                	jmp    81ae79 <netconn_free+0x8d>
      if (conn->type == NETCONN_TCP) {
  81ae3d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae41:	8b 00                	mov    (%rax),%eax
  81ae43:	83 f8 10             	cmp    $0x10,%eax
  81ae46:	75 1e                	jne    81ae66 <netconn_free+0x7a>
        if(mem != NULL) {
  81ae48:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae4c:	48 85 c0             	test   %rax,%rax
  81ae4f:	74 28                	je     81ae79 <netconn_free+0x8d>
          pbuf_free((struct pbuf *)mem);
  81ae51:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae55:	48 89 c7             	mov    %rax,%rdi
  81ae58:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81ae5f:	00 00 00 
  81ae62:	ff d0                	callq  *%rax
  81ae64:	eb 13                	jmp    81ae79 <netconn_free+0x8d>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  81ae66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ae6a:	48 89 c7             	mov    %rax,%rdi
  81ae6d:	48 b8 9c 8a 80 00 00 	movabs $0x808a9c,%rax
  81ae74:	00 00 00 
  81ae77:	ff d0                	callq  *%rax
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  81ae79:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae7d:	8b 40 18             	mov    0x18(%rax),%eax
  81ae80:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  81ae84:	48 89 d6             	mov    %rdx,%rsi
  81ae87:	89 c7                	mov    %eax,%edi
  81ae89:	48 b8 ea 81 81 00 00 	movabs $0x8181ea,%rax
  81ae90:	00 00 00 
  81ae93:	ff d0                	callq  *%rax
  81ae95:	83 f8 ff             	cmp    $0xffffffff,%eax
  81ae98:	75 a3                	jne    81ae3d <netconn_free+0x51>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  81ae9a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ae9e:	8b 40 18             	mov    0x18(%rax),%eax
  81aea1:	89 c7                	mov    %eax,%edi
  81aea3:	48 b8 f9 74 81 00 00 	movabs $0x8174f9,%rax
  81aeaa:	00 00 00 
  81aead:	ff d0                	callq  *%rax
    conn->recvmbox = SYS_MBOX_NULL;
  81aeaf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aeb3:	c7 40 18 ff ff ff ff 	movl   $0xffffffff,0x18(%rax)
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  81aeba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aebe:	8b 40 1c             	mov    0x1c(%rax),%eax
  81aec1:	83 f8 ff             	cmp    $0xffffffff,%eax
  81aec4:	74 56                	je     81af1c <netconn_free+0x130>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  81aec6:	eb 13                	jmp    81aedb <netconn_free+0xef>
      netconn_delete((struct netconn *)mem);
  81aec8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81aecc:	48 89 c7             	mov    %rax,%rdi
  81aecf:	48 b8 d7 97 81 00 00 	movabs $0x8197d7,%rax
  81aed6:	00 00 00 
  81aed9:	ff d0                	callq  *%rax
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  81aedb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81aedf:	8b 40 1c             	mov    0x1c(%rax),%eax
  81aee2:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  81aee6:	48 89 d6             	mov    %rdx,%rsi
  81aee9:	89 c7                	mov    %eax,%edi
  81aeeb:	48 b8 ea 81 81 00 00 	movabs $0x8181ea,%rax
  81aef2:	00 00 00 
  81aef5:	ff d0                	callq  *%rax
  81aef7:	83 f8 ff             	cmp    $0xffffffff,%eax
  81aefa:	75 cc                	jne    81aec8 <netconn_free+0xdc>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  81aefc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af00:	8b 40 1c             	mov    0x1c(%rax),%eax
  81af03:	89 c7                	mov    %eax,%edi
  81af05:	48 b8 f9 74 81 00 00 	movabs $0x8174f9,%rax
  81af0c:	00 00 00 
  81af0f:	ff d0                	callq  *%rax
    conn->acceptmbox = SYS_MBOX_NULL;
  81af11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af15:	c7 40 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%rax)
  }

  sys_sem_free(conn->op_completed);
  81af1c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af20:	8b 40 14             	mov    0x14(%rax),%eax
  81af23:	89 c7                	mov    %eax,%edi
  81af25:	48 b8 e3 7a 81 00 00 	movabs $0x817ae3,%rax
  81af2c:	00 00 00 
  81af2f:	ff d0                	callq  *%rax
  conn->op_completed = SYS_SEM_NULL;
  81af31:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af35:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%rax)

  memp_free(MEMP_NETCONN, conn);
  81af3c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af40:	48 89 c6             	mov    %rax,%rsi
  81af43:	bf 07 00 00 00       	mov    $0x7,%edi
  81af48:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  81af4f:	00 00 00 
  81af52:	ff d0                	callq  *%rax
}
  81af54:	c9                   	leaveq 
  81af55:	c3                   	retq   

000000000081af56 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  81af56:	55                   	push   %rbp
  81af57:	48 89 e5             	mov    %rsp,%rbp
  81af5a:	48 83 ec 20          	sub    $0x20,%rsp
  81af5e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  81af62:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81af67:	75 2a                	jne    81af93 <do_close_internal+0x3d>
  81af69:	48 ba f6 35 82 00 00 	movabs $0x8235f6,%rdx
  81af70:	00 00 00 
  81af73:	be 53 02 00 00       	mov    $0x253,%esi
  81af78:	48 bf 92 34 82 00 00 	movabs $0x823492,%rdi
  81af7f:	00 00 00 
  81af82:	b8 00 00 00 00       	mov    $0x0,%eax
  81af87:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81af8e:	00 00 00 
  81af91:	ff d1                	callq  *%rcx
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  81af93:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81af97:	8b 00                	mov    (%rax),%eax
  81af99:	83 f8 10             	cmp    $0x10,%eax
  81af9c:	74 2a                	je     81afc8 <do_close_internal+0x72>
  81af9e:	48 ba 03 36 82 00 00 	movabs $0x823603,%rdx
  81afa5:	00 00 00 
  81afa8:	be 54 02 00 00       	mov    $0x254,%esi
  81afad:	48 bf 92 34 82 00 00 	movabs $0x823492,%rdi
  81afb4:	00 00 00 
  81afb7:	b8 00 00 00 00       	mov    $0x0,%eax
  81afbc:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81afc3:	00 00 00 
  81afc6:	ff d1                	callq  *%rcx
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  81afc8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81afcc:	8b 40 04             	mov    0x4(%rax),%eax
  81afcf:	83 f8 04             	cmp    $0x4,%eax
  81afd2:	74 2a                	je     81affe <do_close_internal+0xa8>
  81afd4:	48 ba 28 36 82 00 00 	movabs $0x823628,%rdx
  81afdb:	00 00 00 
  81afde:	be 55 02 00 00       	mov    $0x255,%esi
  81afe3:	48 bf 92 34 82 00 00 	movabs $0x823492,%rdi
  81afea:	00 00 00 
  81afed:	b8 00 00 00 00       	mov    $0x0,%eax
  81aff2:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81aff9:	00 00 00 
  81affc:	ff d1                	callq  *%rcx
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  81affe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b002:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b006:	48 85 c0             	test   %rax,%rax
  81b009:	75 2a                	jne    81b035 <do_close_internal+0xdf>
  81b00b:	48 ba 4c 36 82 00 00 	movabs $0x82364c,%rdx
  81b012:	00 00 00 
  81b015:	be 56 02 00 00       	mov    $0x256,%esi
  81b01a:	48 bf 92 34 82 00 00 	movabs $0x823492,%rdi
  81b021:	00 00 00 
  81b024:	b8 00 00 00 00       	mov    $0x0,%eax
  81b029:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81b030:	00 00 00 
  81b033:	ff d1                	callq  *%rcx

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  81b035:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b039:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b03d:	be 00 00 00 00       	mov    $0x0,%esi
  81b042:	48 89 c7             	mov    %rax,%rdi
  81b045:	48 b8 16 05 81 00 00 	movabs $0x810516,%rax
  81b04c:	00 00 00 
  81b04f:	ff d0                	callq  *%rax
  if (conn->pcb.tcp->state == LISTEN) {
  81b051:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b055:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b059:	8b 40 18             	mov    0x18(%rax),%eax
  81b05c:	83 f8 01             	cmp    $0x1,%eax
  81b05f:	75 21                	jne    81b082 <do_close_internal+0x12c>
    tcp_accept(conn->pcb.tcp, NULL);
  81b061:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b065:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b069:	be 00 00 00 00       	mov    $0x0,%esi
  81b06e:	48 89 c7             	mov    %rax,%rdi
  81b071:	48 b8 97 05 81 00 00 	movabs $0x810597,%rax
  81b078:	00 00 00 
  81b07b:	ff d0                	callq  *%rax
  81b07d:	e9 91 00 00 00       	jmpq   81b113 <do_close_internal+0x1bd>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  81b082:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b086:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b08a:	be 00 00 00 00       	mov    $0x0,%esi
  81b08f:	48 89 c7             	mov    %rax,%rdi
  81b092:	48 b8 34 05 81 00 00 	movabs $0x810534,%rax
  81b099:	00 00 00 
  81b09c:	ff d0                	callq  *%rax
    tcp_accept(conn->pcb.tcp, NULL);
  81b09e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b0a2:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b0a6:	be 00 00 00 00       	mov    $0x0,%esi
  81b0ab:	48 89 c7             	mov    %rax,%rdi
  81b0ae:	48 b8 97 05 81 00 00 	movabs $0x810597,%rax
  81b0b5:	00 00 00 
  81b0b8:	ff d0                	callq  *%rax
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  81b0ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b0be:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b0c2:	be 00 00 00 00       	mov    $0x0,%esi
  81b0c7:	48 89 c7             	mov    %rax,%rdi
  81b0ca:	48 b8 55 05 81 00 00 	movabs $0x810555,%rax
  81b0d1:	00 00 00 
  81b0d4:	ff d0                	callq  *%rax
    tcp_poll(conn->pcb.tcp, NULL, 4);
  81b0d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b0da:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b0de:	ba 04 00 00 00       	mov    $0x4,%edx
  81b0e3:	be 00 00 00 00       	mov    $0x0,%esi
  81b0e8:	48 89 c7             	mov    %rax,%rdi
  81b0eb:	48 b8 b5 05 81 00 00 	movabs $0x8105b5,%rax
  81b0f2:	00 00 00 
  81b0f5:	ff d0                	callq  *%rax
    tcp_err(conn->pcb.tcp, NULL);
  81b0f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b0fb:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b0ff:	be 00 00 00 00       	mov    $0x0,%esi
  81b104:	48 89 c7             	mov    %rax,%rdi
  81b107:	48 b8 76 05 81 00 00 	movabs $0x810576,%rax
  81b10e:	00 00 00 
  81b111:	ff d0                	callq  *%rax
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  81b113:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b117:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b11b:	48 89 c7             	mov    %rax,%rdi
  81b11e:	48 b8 89 e8 80 00 00 	movabs $0x80e889,%rax
  81b125:	00 00 00 
  81b128:	ff d0                	callq  *%rax
  81b12a:	88 45 ff             	mov    %al,-0x1(%rbp)
  if (err == ERR_OK) {
  81b12d:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  81b131:	0f 85 89 00 00 00    	jne    81b1c0 <do_close_internal+0x26a>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  81b137:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b13b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  81b142:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b146:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81b14d:	00 
    conn->err = ERR_OK;
  81b14e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b152:	c6 40 10 00          	movb   $0x0,0x10(%rax)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  81b156:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b15a:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b15e:	48 85 c0             	test   %rax,%rax
  81b161:	74 1b                	je     81b17e <do_close_internal+0x228>
  81b163:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b167:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81b16b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b16f:	ba 00 00 00 00       	mov    $0x0,%edx
  81b174:	be 00 00 00 00       	mov    $0x0,%esi
  81b179:	48 89 c7             	mov    %rax,%rdi
  81b17c:	ff d1                	callq  *%rcx
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  81b17e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b182:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b186:	48 85 c0             	test   %rax,%rax
  81b189:	74 1b                	je     81b1a6 <do_close_internal+0x250>
  81b18b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b18f:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81b193:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b197:	ba 00 00 00 00       	mov    $0x0,%edx
  81b19c:	be 02 00 00 00       	mov    $0x2,%esi
  81b1a1:	48 89 c7             	mov    %rax,%rdi
  81b1a4:	ff d1                	callq  *%rcx
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  81b1a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b1aa:	8b 40 14             	mov    0x14(%rax),%eax
  81b1ad:	89 c7                	mov    %eax,%edi
  81b1af:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  81b1b6:	00 00 00 
  81b1b9:	ff d0                	callq  *%rax
  81b1bb:	e9 c0 00 00 00       	jmpq   81b280 <do_close_internal+0x32a>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  81b1c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b1c4:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b1c8:	8b 40 18             	mov    0x18(%rax),%eax
  81b1cb:	83 f8 01             	cmp    $0x1,%eax
  81b1ce:	75 2a                	jne    81b1fa <do_close_internal+0x2a4>
  81b1d0:	48 ba 60 36 82 00 00 	movabs $0x823660,%rdx
  81b1d7:	00 00 00 
  81b1da:	be 75 02 00 00       	mov    $0x275,%esi
  81b1df:	48 bf 92 34 82 00 00 	movabs $0x823492,%rdi
  81b1e6:	00 00 00 
  81b1e9:	b8 00 00 00 00       	mov    $0x0,%eax
  81b1ee:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81b1f5:	00 00 00 
  81b1f8:	ff d1                	callq  *%rcx
    tcp_sent(conn->pcb.tcp, sent_tcp);
  81b1fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b1fe:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b202:	48 be 38 a6 81 00 00 	movabs $0x81a638,%rsi
  81b209:	00 00 00 
  81b20c:	48 89 c7             	mov    %rax,%rdi
  81b20f:	48 b8 55 05 81 00 00 	movabs $0x810555,%rax
  81b216:	00 00 00 
  81b219:	ff d0                	callq  *%rax
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  81b21b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b21f:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b223:	ba 04 00 00 00       	mov    $0x4,%edx
  81b228:	48 be a8 a5 81 00 00 	movabs $0x81a5a8,%rsi
  81b22f:	00 00 00 
  81b232:	48 89 c7             	mov    %rax,%rdi
  81b235:	48 b8 b5 05 81 00 00 	movabs $0x8105b5,%rax
  81b23c:	00 00 00 
  81b23f:	ff d0                	callq  *%rax
    tcp_err(conn->pcb.tcp, err_tcp);
  81b241:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b245:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b249:	48 be 52 a7 81 00 00 	movabs $0x81a752,%rsi
  81b250:	00 00 00 
  81b253:	48 89 c7             	mov    %rax,%rdi
  81b256:	48 b8 76 05 81 00 00 	movabs $0x810576,%rax
  81b25d:	00 00 00 
  81b260:	ff d0                	callq  *%rax
    tcp_arg(conn->pcb.tcp, conn);
  81b262:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b266:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b26a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81b26e:	48 89 d6             	mov    %rdx,%rsi
  81b271:	48 89 c7             	mov    %rax,%rdi
  81b274:	48 b8 16 05 81 00 00 	movabs $0x810516,%rax
  81b27b:	00 00 00 
  81b27e:	ff d0                	callq  *%rax
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  81b280:	c9                   	leaveq 
  81b281:	c3                   	retq   

000000000081b282 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  81b282:	55                   	push   %rbp
  81b283:	48 89 e5             	mov    %rsp,%rbp
  81b286:	48 83 ec 10          	sub    $0x10,%rsp
  81b28a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (msg->conn->pcb.tcp != NULL) {
  81b28e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b292:	48 8b 00             	mov    (%rax),%rax
  81b295:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b299:	48 85 c0             	test   %rax,%rax
  81b29c:	0f 84 94 00 00 00    	je     81b336 <do_delconn+0xb4>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b2a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b2a6:	48 8b 00             	mov    (%rax),%rax
  81b2a9:	8b 00                	mov    (%rax),%eax
  81b2ab:	25 f0 00 00 00       	and    $0xf0,%eax
  81b2b0:	83 f8 20             	cmp    $0x20,%eax
  81b2b3:	74 28                	je     81b2dd <do_delconn+0x5b>
  81b2b5:	83 f8 40             	cmp    $0x40,%eax
  81b2b8:	74 07                	je     81b2c1 <do_delconn+0x3f>
  81b2ba:	83 f8 10             	cmp    $0x10,%eax
  81b2bd:	74 4d                	je     81b30c <do_delconn+0x8a>
  81b2bf:	eb 74                	jmp    81b335 <do_delconn+0xb3>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  81b2c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b2c5:	48 8b 00             	mov    (%rax),%rax
  81b2c8:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b2cc:	48 89 c7             	mov    %rax,%rdi
  81b2cf:	48 b8 66 fd 81 00 00 	movabs $0x81fd66,%rax
  81b2d6:	00 00 00 
  81b2d9:	ff d0                	callq  *%rax
      break;
  81b2db:	eb 59                	jmp    81b336 <do_delconn+0xb4>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  81b2dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b2e1:	48 8b 00             	mov    (%rax),%rax
  81b2e4:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b2e8:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  81b2ef:	00 
      udp_remove(msg->conn->pcb.udp);
  81b2f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b2f4:	48 8b 00             	mov    (%rax),%rax
  81b2f7:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b2fb:	48 89 c7             	mov    %rax,%rdi
  81b2fe:	48 b8 3f 55 81 00 00 	movabs $0x81553f,%rax
  81b305:	00 00 00 
  81b308:	ff d0                	callq  *%rax
      break;
  81b30a:	eb 2a                	jmp    81b336 <do_delconn+0xb4>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  81b30c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b310:	48 8b 00             	mov    (%rax),%rax
  81b313:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%rax)
      do_close_internal(msg->conn);
  81b31a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b31e:	48 8b 00             	mov    (%rax),%rax
  81b321:	48 89 c7             	mov    %rax,%rdi
  81b324:	48 b8 56 af 81 00 00 	movabs $0x81af56,%rax
  81b32b:	00 00 00 
  81b32e:	ff d0                	callq  *%rax
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  81b330:	e9 8a 00 00 00       	jmpq   81b3bf <do_delconn+0x13d>
#endif /* LWIP_TCP */
    default:
      break;
  81b335:	90                   	nop
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  81b336:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b33a:	48 8b 00             	mov    (%rax),%rax
  81b33d:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b341:	48 85 c0             	test   %rax,%rax
  81b344:	74 21                	je     81b367 <do_delconn+0xe5>
  81b346:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b34a:	48 8b 00             	mov    (%rax),%rax
  81b34d:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81b351:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b355:	48 8b 00             	mov    (%rax),%rax
  81b358:	ba 00 00 00 00       	mov    $0x0,%edx
  81b35d:	be 00 00 00 00       	mov    $0x0,%esi
  81b362:	48 89 c7             	mov    %rax,%rdi
  81b365:	ff d1                	callq  *%rcx
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  81b367:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b36b:	48 8b 00             	mov    (%rax),%rax
  81b36e:	48 8b 40 38          	mov    0x38(%rax),%rax
  81b372:	48 85 c0             	test   %rax,%rax
  81b375:	74 21                	je     81b398 <do_delconn+0x116>
  81b377:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b37b:	48 8b 00             	mov    (%rax),%rax
  81b37e:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81b382:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b386:	48 8b 00             	mov    (%rax),%rax
  81b389:	ba 00 00 00 00       	mov    $0x0,%edx
  81b38e:	be 02 00 00 00       	mov    $0x2,%esi
  81b393:	48 89 c7             	mov    %rax,%rdi
  81b396:	ff d1                	callq  *%rcx

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  81b398:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b39c:	48 8b 00             	mov    (%rax),%rax
  81b39f:	8b 40 14             	mov    0x14(%rax),%eax
  81b3a2:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b3a5:	74 18                	je     81b3bf <do_delconn+0x13d>
    sys_sem_signal(msg->conn->op_completed);
  81b3a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b3ab:	48 8b 00             	mov    (%rax),%rax
  81b3ae:	8b 40 14             	mov    0x14(%rax),%eax
  81b3b1:	89 c7                	mov    %eax,%edi
  81b3b3:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  81b3ba:	00 00 00 
  81b3bd:	ff d0                	callq  *%rax
  }
}
  81b3bf:	c9                   	leaveq 
  81b3c0:	c3                   	retq   

000000000081b3c1 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  81b3c1:	55                   	push   %rbp
  81b3c2:	48 89 e5             	mov    %rsp,%rbp
  81b3c5:	53                   	push   %rbx
  81b3c6:	48 83 ec 18          	sub    $0x18,%rsp
  81b3ca:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81b3ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b3d2:	48 8b 00             	mov    (%rax),%rax
  81b3d5:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81b3d9:	3c fc                	cmp    $0xfc,%al
  81b3db:	0f 8c f0 00 00 00    	jl     81b4d1 <do_bind+0x110>
    if (msg->conn->pcb.tcp != NULL) {
  81b3e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b3e5:	48 8b 00             	mov    (%rax),%rax
  81b3e8:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b3ec:	48 85 c0             	test   %rax,%rax
  81b3ef:	0f 84 d1 00 00 00    	je     81b4c6 <do_bind+0x105>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b3f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b3f9:	48 8b 00             	mov    (%rax),%rax
  81b3fc:	8b 00                	mov    (%rax),%eax
  81b3fe:	25 f0 00 00 00       	and    $0xf0,%eax
  81b403:	83 f8 20             	cmp    $0x20,%eax
  81b406:	74 43                	je     81b44b <do_bind+0x8a>
  81b408:	83 f8 40             	cmp    $0x40,%eax
  81b40b:	74 0a                	je     81b417 <do_bind+0x56>
  81b40d:	83 f8 10             	cmp    $0x10,%eax
  81b410:	74 75                	je     81b487 <do_bind+0xc6>
  81b412:	e9 ad 00 00 00       	jmpq   81b4c4 <do_bind+0x103>
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  81b417:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b41b:	48 8b 18             	mov    (%rax),%rbx
  81b41e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b422:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81b426:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b42a:	48 8b 00             	mov    (%rax),%rax
  81b42d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b431:	48 89 d6             	mov    %rdx,%rsi
  81b434:	48 89 c7             	mov    %rax,%rdi
  81b437:	48 b8 fd fa 81 00 00 	movabs $0x81fafd,%rax
  81b43e:	00 00 00 
  81b441:	ff d0                	callq  *%rax
  81b443:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81b446:	e9 86 00 00 00       	jmpq   81b4d1 <do_bind+0x110>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81b44b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b44f:	48 8b 18             	mov    (%rax),%rbx
  81b452:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b456:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81b45a:	0f b7 d0             	movzwl %ax,%edx
  81b45d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b461:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81b465:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b469:	48 8b 00             	mov    (%rax),%rax
  81b46c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b470:	48 89 ce             	mov    %rcx,%rsi
  81b473:	48 89 c7             	mov    %rax,%rdi
  81b476:	48 b8 93 52 81 00 00 	movabs $0x815293,%rax
  81b47d:	00 00 00 
  81b480:	ff d0                	callq  *%rax
  81b482:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81b485:	eb 4a                	jmp    81b4d1 <do_bind+0x110>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81b487:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b48b:	48 8b 18             	mov    (%rax),%rbx
  81b48e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b492:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81b496:	0f b7 d0             	movzwl %ax,%edx
  81b499:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b49d:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81b4a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b4a5:	48 8b 00             	mov    (%rax),%rax
  81b4a8:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b4ac:	48 89 ce             	mov    %rcx,%rsi
  81b4af:	48 89 c7             	mov    %rax,%rdi
  81b4b2:	48 b8 da ec 80 00 00 	movabs $0x80ecda,%rax
  81b4b9:	00 00 00 
  81b4bc:	ff d0                	callq  *%rax
  81b4be:	88 43 10             	mov    %al,0x10(%rbx)
        break;
  81b4c1:	90                   	nop
  81b4c2:	eb 0d                	jmp    81b4d1 <do_bind+0x110>
#endif /* LWIP_TCP */
      default:
        break;
  81b4c4:	eb 0b                	jmp    81b4d1 <do_bind+0x110>
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  81b4c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b4ca:	48 8b 00             	mov    (%rax),%rax
  81b4cd:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81b4d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b4d5:	48 8b 00             	mov    (%rax),%rax
  81b4d8:	8b 40 14             	mov    0x14(%rax),%eax
  81b4db:	89 c7                	mov    %eax,%edi
  81b4dd:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  81b4e4:	00 00 00 
  81b4e7:	ff d0                	callq  *%rax
}
  81b4e9:	48 83 c4 18          	add    $0x18,%rsp
  81b4ed:	5b                   	pop    %rbx
  81b4ee:	5d                   	pop    %rbp
  81b4ef:	c3                   	retq   

000000000081b4f0 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  81b4f0:	55                   	push   %rbp
  81b4f1:	48 89 e5             	mov    %rsp,%rbp
  81b4f4:	48 83 ec 30          	sub    $0x30,%rsp
  81b4f8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  81b4fc:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  81b500:	89 d0                	mov    %edx,%eax
  81b502:	88 45 dc             	mov    %al,-0x24(%rbp)
  struct netconn *conn;

  LWIP_UNUSED_ARG(pcb);

  conn = arg;
  81b505:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b509:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  if (conn == NULL) {
  81b50d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81b512:	75 07                	jne    81b51b <do_connected+0x2b>
    return ERR_VAL;
  81b514:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  81b519:	eb 54                	jmp    81b56f <do_connected+0x7f>
  }

  conn->err = err;
  81b51b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b51f:	0f b6 55 dc          	movzbl -0x24(%rbp),%edx
  81b523:	88 50 10             	mov    %dl,0x10(%rax)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  81b526:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b52a:	8b 00                	mov    (%rax),%eax
  81b52c:	83 f8 10             	cmp    $0x10,%eax
  81b52f:	75 19                	jne    81b54a <do_connected+0x5a>
  81b531:	80 7d dc 00          	cmpb   $0x0,-0x24(%rbp)
  81b535:	75 13                	jne    81b54a <do_connected+0x5a>
    setup_tcp(conn);
  81b537:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b53b:	48 89 c7             	mov    %rax,%rdi
  81b53e:	48 b8 c1 a8 81 00 00 	movabs $0x81a8c1,%rax
  81b545:	00 00 00 
  81b548:	ff d0                	callq  *%rax
  }
  conn->state = NETCONN_NONE;
  81b54a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b54e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
  sys_sem_signal(conn->op_completed);
  81b555:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b559:	8b 40 14             	mov    0x14(%rax),%eax
  81b55c:	89 c7                	mov    %eax,%edi
  81b55e:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  81b565:	00 00 00 
  81b568:	ff d0                	callq  *%rax
  return ERR_OK;
  81b56a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81b56f:	c9                   	leaveq 
  81b570:	c3                   	retq   

000000000081b571 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  81b571:	55                   	push   %rbp
  81b572:	48 89 e5             	mov    %rsp,%rbp
  81b575:	53                   	push   %rbx
  81b576:	48 83 ec 18          	sub    $0x18,%rsp
  81b57a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (msg->conn->pcb.tcp == NULL) {
  81b57e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b582:	48 8b 00             	mov    (%rax),%rax
  81b585:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b589:	48 85 c0             	test   %rax,%rax
  81b58c:	75 1d                	jne    81b5ab <do_connect+0x3a>
    sys_sem_signal(msg->conn->op_completed);
  81b58e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b592:	48 8b 00             	mov    (%rax),%rax
  81b595:	8b 40 14             	mov    0x14(%rax),%eax
  81b598:	89 c7                	mov    %eax,%edi
  81b59a:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  81b5a1:	00 00 00 
  81b5a4:	ff d0                	callq  *%rax
    return;
  81b5a6:	e9 2e 01 00 00       	jmpq   81b6d9 <do_connect+0x168>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b5ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b5af:	48 8b 00             	mov    (%rax),%rax
  81b5b2:	8b 00                	mov    (%rax),%eax
  81b5b4:	25 f0 00 00 00       	and    $0xf0,%eax
  81b5b9:	83 f8 20             	cmp    $0x20,%eax
  81b5bc:	74 5f                	je     81b61d <do_connect+0xac>
  81b5be:	83 f8 40             	cmp    $0x40,%eax
  81b5c1:	74 0e                	je     81b5d1 <do_connect+0x60>
  81b5c3:	83 f8 10             	cmp    $0x10,%eax
  81b5c6:	0f 84 a5 00 00 00    	je     81b671 <do_connect+0x100>
  81b5cc:	e9 07 01 00 00       	jmpq   81b6d8 <do_connect+0x167>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  81b5d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b5d5:	48 8b 18             	mov    (%rax),%rbx
  81b5d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b5dc:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81b5e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b5e4:	48 8b 00             	mov    (%rax),%rax
  81b5e7:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b5eb:	48 89 d6             	mov    %rdx,%rsi
  81b5ee:	48 89 c7             	mov    %rax,%rdi
  81b5f1:	48 b8 2e fb 81 00 00 	movabs $0x81fb2e,%rax
  81b5f8:	00 00 00 
  81b5fb:	ff d0                	callq  *%rax
  81b5fd:	88 43 10             	mov    %al,0x10(%rbx)
    sys_sem_signal(msg->conn->op_completed);
  81b600:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b604:	48 8b 00             	mov    (%rax),%rax
  81b607:	8b 40 14             	mov    0x14(%rax),%eax
  81b60a:	89 c7                	mov    %eax,%edi
  81b60c:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  81b613:	00 00 00 
  81b616:	ff d0                	callq  *%rax
    break;
  81b618:	e9 bc 00 00 00       	jmpq   81b6d9 <do_connect+0x168>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81b61d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b621:	48 8b 18             	mov    (%rax),%rbx
  81b624:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b628:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81b62c:	0f b7 d0             	movzwl %ax,%edx
  81b62f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b633:	48 8b 48 08          	mov    0x8(%rax),%rcx
  81b637:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b63b:	48 8b 00             	mov    (%rax),%rax
  81b63e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b642:	48 89 ce             	mov    %rcx,%rsi
  81b645:	48 89 c7             	mov    %rax,%rdi
  81b648:	48 b8 d9 53 81 00 00 	movabs $0x8153d9,%rax
  81b64f:	00 00 00 
  81b652:	ff d0                	callq  *%rax
  81b654:	88 43 10             	mov    %al,0x10(%rbx)
    sys_sem_signal(msg->conn->op_completed);
  81b657:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b65b:	48 8b 00             	mov    (%rax),%rax
  81b65e:	8b 40 14             	mov    0x14(%rax),%eax
  81b661:	89 c7                	mov    %eax,%edi
  81b663:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  81b66a:	00 00 00 
  81b66d:	ff d0                	callq  *%rax
    break;
  81b66f:	eb 68                	jmp    81b6d9 <do_connect+0x168>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  81b671:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b675:	48 8b 00             	mov    (%rax),%rax
  81b678:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%rax)
    setup_tcp(msg->conn);
  81b67f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b683:	48 8b 00             	mov    (%rax),%rax
  81b686:	48 89 c7             	mov    %rax,%rdi
  81b689:	48 b8 c1 a8 81 00 00 	movabs $0x81a8c1,%rax
  81b690:	00 00 00 
  81b693:	ff d0                	callq  *%rax
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  81b695:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b699:	48 8b 18             	mov    (%rax),%rbx
  81b69c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6a0:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81b6a4:	0f b7 d0             	movzwl %ax,%edx
  81b6a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6ab:	48 8b 70 08          	mov    0x8(%rax),%rsi
  81b6af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b6b3:	48 8b 00             	mov    (%rax),%rax
  81b6b6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b6ba:	48 b9 f0 b4 81 00 00 	movabs $0x81b4f0,%rcx
  81b6c1:	00 00 00 
  81b6c4:	48 89 c7             	mov    %rax,%rdi
  81b6c7:	48 b8 11 f4 80 00 00 	movabs $0x80f411,%rax
  81b6ce:	00 00 00 
  81b6d1:	ff d0                	callq  *%rax
  81b6d3:	88 43 10             	mov    %al,0x10(%rbx)
                                 do_connected);
    /* sys_sem_signal() is called from do_connected (or err_tcp()),
     * when the connection is established! */
    break;
  81b6d6:	eb 01                	jmp    81b6d9 <do_connect+0x168>
#endif /* LWIP_TCP */
  default:
    break;
  81b6d8:	90                   	nop
  }
}
  81b6d9:	48 83 c4 18          	add    $0x18,%rsp
  81b6dd:	5b                   	pop    %rbx
  81b6de:	5d                   	pop    %rbp
  81b6df:	c3                   	retq   

000000000081b6e0 <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  81b6e0:	55                   	push   %rbp
  81b6e1:	48 89 e5             	mov    %rsp,%rbp
  81b6e4:	48 83 ec 10          	sub    $0x10,%rsp
  81b6e8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  81b6ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b6f0:	48 8b 00             	mov    (%rax),%rax
  81b6f3:	8b 00                	mov    (%rax),%eax
  81b6f5:	25 f0 00 00 00       	and    $0xf0,%eax
  81b6fa:	83 f8 20             	cmp    $0x20,%eax
  81b6fd:	75 1a                	jne    81b719 <do_disconnect+0x39>
    udp_disconnect(msg->conn->pcb.udp);
  81b6ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b703:	48 8b 00             	mov    (%rax),%rax
  81b706:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b70a:	48 89 c7             	mov    %rax,%rdi
  81b70d:	48 b8 d2 54 81 00 00 	movabs $0x8154d2,%rax
  81b714:	00 00 00 
  81b717:	ff d0                	callq  *%rax
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  81b719:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81b71d:	48 8b 00             	mov    (%rax),%rax
  81b720:	8b 40 14             	mov    0x14(%rax),%eax
  81b723:	89 c7                	mov    %eax,%edi
  81b725:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  81b72c:	00 00 00 
  81b72f:	ff d0                	callq  *%rax
}
  81b731:	c9                   	leaveq 
  81b732:	c3                   	retq   

000000000081b733 <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  81b733:	55                   	push   %rbp
  81b734:	48 89 e5             	mov    %rsp,%rbp
  81b737:	53                   	push   %rbx
  81b738:	48 83 ec 28          	sub    $0x28,%rsp
  81b73c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81b740:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b744:	48 8b 00             	mov    (%rax),%rax
  81b747:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81b74b:	3c fc                	cmp    $0xfc,%al
  81b74d:	0f 8c 69 01 00 00    	jl     81b8bc <do_listen+0x189>
    if (msg->conn->pcb.tcp != NULL) {
  81b753:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b757:	48 8b 00             	mov    (%rax),%rax
  81b75a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b75e:	48 85 c0             	test   %rax,%rax
  81b761:	0f 84 55 01 00 00    	je     81b8bc <do_listen+0x189>
      if (msg->conn->type == NETCONN_TCP) {
  81b767:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b76b:	48 8b 00             	mov    (%rax),%rax
  81b76e:	8b 00                	mov    (%rax),%eax
  81b770:	83 f8 10             	cmp    $0x10,%eax
  81b773:	0f 85 43 01 00 00    	jne    81b8bc <do_listen+0x189>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  81b779:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b77d:	48 8b 00             	mov    (%rax),%rax
  81b780:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b784:	8b 40 18             	mov    0x18(%rax),%eax
  81b787:	85 c0                	test   %eax,%eax
  81b789:	0f 85 22 01 00 00    	jne    81b8b1 <do_listen+0x17e>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  81b78f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b793:	48 8b 00             	mov    (%rax),%rax
  81b796:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b79a:	be ff 00 00 00       	mov    $0xff,%esi
  81b79f:	48 89 c7             	mov    %rax,%rdi
  81b7a2:	48 b8 5b ef 80 00 00 	movabs $0x80ef5b,%rax
  81b7a9:	00 00 00 
  81b7ac:	ff d0                	callq  *%rax
  81b7ae:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  81b7b2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81b7b7:	75 10                	jne    81b7c9 <do_listen+0x96>
            msg->conn->err = ERR_MEM;
  81b7b9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b7bd:	48 8b 00             	mov    (%rax),%rax
  81b7c0:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
  81b7c4:	e9 f3 00 00 00       	jmpq   81b8bc <do_listen+0x189>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  81b7c9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b7cd:	48 8b 00             	mov    (%rax),%rax
  81b7d0:	8b 40 18             	mov    0x18(%rax),%eax
  81b7d3:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b7d6:	74 26                	je     81b7fe <do_listen+0xcb>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  81b7d8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b7dc:	48 8b 00             	mov    (%rax),%rax
  81b7df:	8b 40 18             	mov    0x18(%rax),%eax
  81b7e2:	89 c7                	mov    %eax,%edi
  81b7e4:	48 b8 f9 74 81 00 00 	movabs $0x8174f9,%rax
  81b7eb:	00 00 00 
  81b7ee:	ff d0                	callq  *%rax
              msg->conn->recvmbox = SYS_MBOX_NULL;
  81b7f0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b7f4:	48 8b 00             	mov    (%rax),%rax
  81b7f7:	c7 40 18 ff ff ff ff 	movl   $0xffffffff,0x18(%rax)
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  81b7fe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b802:	48 8b 00             	mov    (%rax),%rax
  81b805:	8b 40 1c             	mov    0x1c(%rax),%eax
  81b808:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b80b:	75 2e                	jne    81b83b <do_listen+0x108>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  81b80d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b811:	48 8b 18             	mov    (%rax),%rbx
  81b814:	bf 00 00 00 00       	mov    $0x0,%edi
  81b819:	48 b8 16 73 81 00 00 	movabs $0x817316,%rax
  81b820:	00 00 00 
  81b823:	ff d0                	callq  *%rax
  81b825:	89 43 1c             	mov    %eax,0x1c(%rbx)
  81b828:	8b 43 1c             	mov    0x1c(%rbx),%eax
  81b82b:	83 f8 ff             	cmp    $0xffffffff,%eax
  81b82e:	75 0b                	jne    81b83b <do_listen+0x108>
                msg->conn->err = ERR_MEM;
  81b830:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b834:	48 8b 00             	mov    (%rax),%rax
  81b837:	c6 40 10 ff          	movb   $0xff,0x10(%rax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  81b83b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b83f:	48 8b 00             	mov    (%rax),%rax
  81b842:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81b846:	84 c0                	test   %al,%al
  81b848:	75 72                	jne    81b8bc <do_listen+0x189>
              msg->conn->state = NETCONN_LISTEN;
  81b84a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b84e:	48 8b 00             	mov    (%rax),%rax
  81b851:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%rax)
              msg->conn->pcb.tcp = lpcb;
  81b858:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b85c:	48 8b 00             	mov    (%rax),%rax
  81b85f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81b863:	48 89 50 08          	mov    %rdx,0x8(%rax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  81b867:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b86b:	48 8b 10             	mov    (%rax),%rdx
  81b86e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b872:	48 8b 00             	mov    (%rax),%rax
  81b875:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b879:	48 89 d6             	mov    %rdx,%rsi
  81b87c:	48 89 c7             	mov    %rax,%rdi
  81b87f:	48 b8 16 05 81 00 00 	movabs $0x810516,%rax
  81b886:	00 00 00 
  81b889:	ff d0                	callq  *%rax
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  81b88b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b88f:	48 8b 00             	mov    (%rax),%rax
  81b892:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b896:	48 be 6e a9 81 00 00 	movabs $0x81a96e,%rsi
  81b89d:	00 00 00 
  81b8a0:	48 89 c7             	mov    %rax,%rdi
  81b8a3:	48 b8 97 05 81 00 00 	movabs $0x810597,%rax
  81b8aa:	00 00 00 
  81b8ad:	ff d0                	callq  *%rax
  81b8af:	eb 0b                	jmp    81b8bc <do_listen+0x189>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  81b8b1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b8b5:	48 8b 00             	mov    (%rax),%rax
  81b8b8:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  81b8bc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81b8c0:	48 8b 00             	mov    (%rax),%rax
  81b8c3:	8b 40 14             	mov    0x14(%rax),%eax
  81b8c6:	89 c7                	mov    %eax,%edi
  81b8c8:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  81b8cf:	00 00 00 
  81b8d2:	ff d0                	callq  *%rax
}
  81b8d4:	48 83 c4 28          	add    $0x28,%rsp
  81b8d8:	5b                   	pop    %rbx
  81b8d9:	5d                   	pop    %rbp
  81b8da:	c3                   	retq   

000000000081b8db <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  81b8db:	55                   	push   %rbp
  81b8dc:	48 89 e5             	mov    %rsp,%rbp
  81b8df:	53                   	push   %rbx
  81b8e0:	48 83 ec 18          	sub    $0x18,%rsp
  81b8e4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81b8e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b8ec:	48 8b 00             	mov    (%rax),%rax
  81b8ef:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81b8f3:	3c fc                	cmp    $0xfc,%al
  81b8f5:	0f 8c 51 01 00 00    	jl     81ba4c <do_send+0x171>
    if (msg->conn->pcb.tcp != NULL) {
  81b8fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b8ff:	48 8b 00             	mov    (%rax),%rax
  81b902:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b906:	48 85 c0             	test   %rax,%rax
  81b909:	0f 84 3d 01 00 00    	je     81ba4c <do_send+0x171>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81b90f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b913:	48 8b 00             	mov    (%rax),%rax
  81b916:	8b 00                	mov    (%rax),%eax
  81b918:	25 f0 00 00 00       	and    $0xf0,%eax
  81b91d:	83 f8 20             	cmp    $0x20,%eax
  81b920:	0f 84 94 00 00 00    	je     81b9ba <do_send+0xdf>
  81b926:	83 f8 40             	cmp    $0x40,%eax
  81b929:	0f 85 1c 01 00 00    	jne    81ba4b <do_send+0x170>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  81b92f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b933:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b937:	48 8b 40 10          	mov    0x10(%rax),%rax
  81b93b:	48 85 c0             	test   %rax,%rax
  81b93e:	75 37                	jne    81b977 <do_send+0x9c>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  81b940:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b944:	48 8b 18             	mov    (%rax),%rbx
  81b947:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b94b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b94f:	48 8b 10             	mov    (%rax),%rdx
  81b952:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b956:	48 8b 00             	mov    (%rax),%rax
  81b959:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b95d:	48 89 d6             	mov    %rdx,%rsi
  81b960:	48 89 c7             	mov    %rax,%rdi
  81b963:	48 b8 32 fd 81 00 00 	movabs $0x81fd32,%rax
  81b96a:	00 00 00 
  81b96d:	ff d0                	callq  *%rax
  81b96f:	88 43 10             	mov    %al,0x10(%rbx)
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
        }
        break;
  81b972:	e9 d5 00 00 00       	jmpq   81ba4c <do_send+0x171>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  81b977:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b97b:	48 8b 18             	mov    (%rax),%rbx
  81b97e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b982:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b986:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81b98a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b98e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b992:	48 8b 08             	mov    (%rax),%rcx
  81b995:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b999:	48 8b 00             	mov    (%rax),%rax
  81b99c:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b9a0:	48 89 ce             	mov    %rcx,%rsi
  81b9a3:	48 89 c7             	mov    %rax,%rdi
  81b9a6:	48 b8 8e fb 81 00 00 	movabs $0x81fb8e,%rax
  81b9ad:	00 00 00 
  81b9b0:	ff d0                	callq  *%rax
  81b9b2:	88 43 10             	mov    %al,0x10(%rbx)
        }
        break;
  81b9b5:	e9 92 00 00 00       	jmpq   81ba4c <do_send+0x171>
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  81b9ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9be:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b9c2:	48 8b 40 10          	mov    0x10(%rax),%rax
  81b9c6:	48 85 c0             	test   %rax,%rax
  81b9c9:	75 34                	jne    81b9ff <do_send+0x124>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  81b9cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9cf:	48 8b 18             	mov    (%rax),%rbx
  81b9d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9d6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b9da:	48 8b 10             	mov    (%rax),%rdx
  81b9dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81b9e1:	48 8b 00             	mov    (%rax),%rax
  81b9e4:	48 8b 40 08          	mov    0x8(%rax),%rax
  81b9e8:	48 89 d6             	mov    %rdx,%rsi
  81b9eb:	48 89 c7             	mov    %rax,%rdi
  81b9ee:	48 b8 3a 4f 81 00 00 	movabs $0x814f3a,%rax
  81b9f5:	00 00 00 
  81b9f8:	ff d0                	callq  *%rax
  81b9fa:	88 43 10             	mov    %al,0x10(%rbx)
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
        }
        break;
  81b9fd:	eb 4d                	jmp    81ba4c <do_send+0x171>
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  81b9ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba03:	48 8b 18             	mov    (%rax),%rbx
  81ba06:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba0a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ba0e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ba12:	0f b7 c8             	movzwl %ax,%ecx
  81ba15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba19:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ba1d:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81ba21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba25:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ba29:	48 8b 30             	mov    (%rax),%rsi
  81ba2c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba30:	48 8b 00             	mov    (%rax),%rax
  81ba33:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ba37:	48 89 c7             	mov    %rax,%rdi
  81ba3a:	48 b8 7b 4f 81 00 00 	movabs $0x814f7b,%rax
  81ba41:	00 00 00 
  81ba44:	ff d0                	callq  *%rax
  81ba46:	88 43 10             	mov    %al,0x10(%rbx)
        }
        break;
  81ba49:	eb 01                	jmp    81ba4c <do_send+0x171>
#endif /* LWIP_UDP */
      default:
        break;
  81ba4b:	90                   	nop
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81ba4c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ba50:	48 8b 00             	mov    (%rax),%rax
  81ba53:	8b 40 14             	mov    0x14(%rax),%eax
  81ba56:	89 c7                	mov    %eax,%edi
  81ba58:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  81ba5f:	00 00 00 
  81ba62:	ff d0                	callq  *%rax
}
  81ba64:	48 83 c4 18          	add    $0x18,%rsp
  81ba68:	5b                   	pop    %rbx
  81ba69:	5d                   	pop    %rbp
  81ba6a:	c3                   	retq   

000000000081ba6b <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  81ba6b:	55                   	push   %rbp
  81ba6c:	48 89 e5             	mov    %rsp,%rbp
  81ba6f:	48 83 ec 10          	sub    $0x10,%rsp
  81ba73:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81ba77:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ba7b:	48 8b 00             	mov    (%rax),%rax
  81ba7e:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81ba82:	3c fc                	cmp    $0xfc,%al
  81ba84:	7c 45                	jl     81bacb <do_recv+0x60>
    if (msg->conn->pcb.tcp != NULL) {
  81ba86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ba8a:	48 8b 00             	mov    (%rax),%rax
  81ba8d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ba91:	48 85 c0             	test   %rax,%rax
  81ba94:	74 35                	je     81bacb <do_recv+0x60>
      if (msg->conn->type == NETCONN_TCP) {
  81ba96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ba9a:	48 8b 00             	mov    (%rax),%rax
  81ba9d:	8b 00                	mov    (%rax),%eax
  81ba9f:	83 f8 10             	cmp    $0x10,%eax
  81baa2:	75 27                	jne    81bacb <do_recv+0x60>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  81baa4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81baa8:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81baac:	0f b7 d0             	movzwl %ax,%edx
  81baaf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bab3:	48 8b 00             	mov    (%rax),%rax
  81bab6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81baba:	89 d6                	mov    %edx,%esi
  81babc:	48 89 c7             	mov    %rax,%rdi
  81babf:	48 b8 9e f1 80 00 00 	movabs $0x80f19e,%rax
  81bac6:	00 00 00 
  81bac9:	ff d0                	callq  *%rax
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  81bacb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bacf:	48 8b 00             	mov    (%rax),%rax
  81bad2:	8b 40 14             	mov    0x14(%rax),%eax
  81bad5:	89 c7                	mov    %eax,%edi
  81bad7:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  81bade:	00 00 00 
  81bae1:	ff d0                	callq  *%rax
}
  81bae3:	c9                   	leaveq 
  81bae4:	c3                   	retq   

000000000081bae5 <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  81bae5:	55                   	push   %rbp
  81bae6:	48 89 e5             	mov    %rsp,%rbp
  81bae9:	48 83 ec 30          	sub    $0x30,%rsp
  81baed:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  81baf1:	c6 45 fd 00          	movb   $0x0,-0x3(%rbp)

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  81baf5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81baf9:	8b 40 04             	mov    0x4(%rax),%eax
  81bafc:	83 f8 01             	cmp    $0x1,%eax
  81baff:	74 2a                	je     81bb2b <do_writemore+0x46>
  81bb01:	48 ba 83 36 82 00 00 	movabs $0x823683,%rdx
  81bb08:	00 00 00 
  81bb0b:	be b8 03 00 00       	mov    $0x3b8,%esi
  81bb10:	48 bf 92 34 82 00 00 	movabs $0x823492,%rdi
  81bb17:	00 00 00 
  81bb1a:	b8 00 00 00 00       	mov    $0x0,%eax
  81bb1f:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81bb26:	00 00 00 
  81bb29:	ff d1                	callq  *%rcx

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  81bb2b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb2f:	48 8b 40 28          	mov    0x28(%rax),%rax
  81bb33:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81bb37:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb3b:	8b 40 30             	mov    0x30(%rax),%eax
  81bb3e:	48 98                	cltq   
  81bb40:	48 01 d0             	add    %rdx,%rax
  81bb43:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  81bb47:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb4b:	48 8b 40 28          	mov    0x28(%rax),%rax
  81bb4f:	8b 50 10             	mov    0x10(%rax),%edx
  81bb52:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb56:	8b 40 30             	mov    0x30(%rax),%eax
  81bb59:	89 d1                	mov    %edx,%ecx
  81bb5b:	29 c1                	sub    %eax,%ecx
  81bb5d:	89 c8                	mov    %ecx,%eax
  81bb5f:	3d ff ff 00 00       	cmp    $0xffff,%eax
  81bb64:	7e 08                	jle    81bb6e <do_writemore+0x89>
    len = 0xffff;
  81bb66:	66 c7 45 fe ff ff    	movw   $0xffff,-0x2(%rbp)
  81bb6c:	eb 1f                	jmp    81bb8d <do_writemore+0xa8>
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  81bb6e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb72:	48 8b 40 28          	mov    0x28(%rax),%rax
  81bb76:	8b 40 10             	mov    0x10(%rax),%eax
  81bb79:	89 c2                	mov    %eax,%edx
  81bb7b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb7f:	8b 40 30             	mov    0x30(%rax),%eax
  81bb82:	89 d1                	mov    %edx,%ecx
  81bb84:	66 29 c1             	sub    %ax,%cx
  81bb87:	89 c8                	mov    %ecx,%eax
  81bb89:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  81bb8d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bb91:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bb95:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81bb99:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
  if (available < len) {
  81bb9d:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  81bba1:	66 3b 45 fe          	cmp    -0x2(%rbp),%ax
  81bba5:	73 08                	jae    81bbaf <do_writemore+0xca>
    /* don't try to write more than sendbuf */
    len = available;
  81bba7:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  81bbab:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  81bbaf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bbb3:	48 8b 40 28          	mov    0x28(%rax),%rax
  81bbb7:	0f b6 40 14          	movzbl 0x14(%rax),%eax
  81bbbb:	0f b6 c8             	movzbl %al,%ecx
  81bbbe:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81bbc2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bbc6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bbca:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  81bbce:	48 89 c7             	mov    %rax,%rdi
  81bbd1:	48 b8 69 2d 81 00 00 	movabs $0x812d69,%rax
  81bbd8:	00 00 00 
  81bbdb:	ff d0                	callq  *%rax
  81bbdd:	88 45 ed             	mov    %al,-0x13(%rbp)
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  81bbe0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bbe4:	8b 50 30             	mov    0x30(%rax),%edx
  81bbe7:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81bbeb:	01 c2                	add    %eax,%edx
  81bbed:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bbf1:	48 8b 40 28          	mov    0x28(%rax),%rax
  81bbf5:	8b 40 10             	mov    0x10(%rax),%eax
  81bbf8:	39 c2                	cmp    %eax,%edx
  81bbfa:	7e 2a                	jle    81bc26 <do_writemore+0x141>
  81bbfc:	48 ba a0 36 82 00 00 	movabs $0x8236a0,%rdx
  81bc03:	00 00 00 
  81bc06:	be cd 03 00 00       	mov    $0x3cd,%esi
  81bc0b:	48 bf 92 34 82 00 00 	movabs $0x823492,%rdi
  81bc12:	00 00 00 
  81bc15:	b8 00 00 00 00       	mov    $0x0,%eax
  81bc1a:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81bc21:	00 00 00 
  81bc24:	ff d1                	callq  *%rcx
  if (err == ERR_OK) {
  81bc26:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81bc2a:	0f 85 07 01 00 00    	jne    81bd37 <do_writemore+0x252>
    conn->write_offset += len;
  81bc30:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc34:	8b 50 30             	mov    0x30(%rax),%edx
  81bc37:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
  81bc3b:	01 c2                	add    %eax,%edx
  81bc3d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc41:	89 50 30             	mov    %edx,0x30(%rax)
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  81bc44:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc48:	8b 50 30             	mov    0x30(%rax),%edx
  81bc4b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc4f:	48 8b 40 28          	mov    0x28(%rax),%rax
  81bc53:	8b 40 10             	mov    0x10(%rax),%eax
  81bc56:	39 c2                	cmp    %eax,%edx
  81bc58:	75 1b                	jne    81bc75 <do_writemore+0x190>
      /* everything was written */
      write_finished = 1;
  81bc5a:	c6 45 fd 01          	movb   $0x1,-0x3(%rbp)
      conn->write_msg = NULL;
  81bc5e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc62:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  81bc69:	00 
      conn->write_offset = 0;
  81bc6a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc6e:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  81bc75:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc79:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bc7d:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81bc84:	48 85 c0             	test   %rax,%rax
  81bc87:	74 41                	je     81bcca <do_writemore+0x1e5>
  81bc89:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bc8d:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bc91:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81bc95:	0f b6 c0             	movzbl %al,%eax
  81bc98:	83 e0 40             	and    $0x40,%eax
  81bc9b:	85 c0                	test   %eax,%eax
  81bc9d:	75 2b                	jne    81bcca <do_writemore+0x1e5>
  81bc9f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bca3:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bca7:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81bcae:	48 85 c0             	test   %rax,%rax
  81bcb1:	74 30                	je     81bce3 <do_writemore+0x1fe>
  81bcb3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bcb7:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bcbb:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81bcc2:	48 8b 00             	mov    (%rax),%rax
  81bcc5:	48 85 c0             	test   %rax,%rax
  81bcc8:	74 19                	je     81bce3 <do_writemore+0x1fe>
  81bcca:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bcce:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bcd2:	48 89 c7             	mov    %rax,%rdi
  81bcd5:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  81bcdc:	00 00 00 
  81bcdf:	ff d0                	callq  *%rax
  81bce1:	eb 05                	jmp    81bce8 <do_writemore+0x203>
  81bce3:	b8 00 00 00 00       	mov    $0x0,%eax
  81bce8:	88 45 ed             	mov    %al,-0x13(%rbp)
    conn->err = err;
  81bceb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bcef:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  81bcf3:	88 50 10             	mov    %dl,0x10(%rax)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  81bcf6:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81bcfa:	75 6c                	jne    81bd68 <do_writemore+0x283>
  81bcfc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd00:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bd04:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81bd08:	66 3d a0 2d          	cmp    $0x2da0,%ax
  81bd0c:	77 5a                	ja     81bd68 <do_writemore+0x283>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  81bd0e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd12:	48 8b 40 38          	mov    0x38(%rax),%rax
  81bd16:	48 85 c0             	test   %rax,%rax
  81bd19:	74 4d                	je     81bd68 <do_writemore+0x283>
  81bd1b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd1f:	48 8b 48 38          	mov    0x38(%rax),%rcx
  81bd23:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
  81bd27:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd2b:	be 03 00 00 00       	mov    $0x3,%esi
  81bd30:	48 89 c7             	mov    %rax,%rdi
  81bd33:	ff d1                	callq  *%rcx
  81bd35:	eb 31                	jmp    81bd68 <do_writemore+0x283>
    }
  } else if (err == ERR_MEM) {
  81bd37:	80 7d ed ff          	cmpb   $0xff,-0x13(%rbp)
  81bd3b:	75 1c                	jne    81bd59 <do_writemore+0x274>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  81bd3d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd41:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bd45:	48 89 c7             	mov    %rax,%rdi
  81bd48:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  81bd4f:	00 00 00 
  81bd52:	ff d0                	callq  *%rax
  81bd54:	88 45 ed             	mov    %al,-0x13(%rbp)
  81bd57:	eb 0f                	jmp    81bd68 <do_writemore+0x283>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  81bd59:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd5d:	0f b6 55 ed          	movzbl -0x13(%rbp),%edx
  81bd61:	88 50 10             	mov    %dl,0x10(%rax)
    write_finished = 1;
  81bd64:	c6 45 fd 01          	movb   $0x1,-0x3(%rbp)
  }

  if (write_finished) {
  81bd68:	80 7d fd 00          	cmpb   $0x0,-0x3(%rbp)
  81bd6c:	74 20                	je     81bd8e <do_writemore+0x2a9>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  81bd6e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd72:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  81bd79:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81bd7d:	8b 40 14             	mov    0x14(%rax),%eax
  81bd80:	89 c7                	mov    %eax,%edi
  81bd82:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  81bd89:	00 00 00 
  81bd8c:	ff d0                	callq  *%rax
  }
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
  81bd8e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81bd93:	c9                   	leaveq 
  81bd94:	c3                   	retq   

000000000081bd95 <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  81bd95:	55                   	push   %rbp
  81bd96:	48 89 e5             	mov    %rsp,%rbp
  81bd99:	48 83 ec 10          	sub    $0x10,%rsp
  81bd9d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (!ERR_IS_FATAL(msg->conn->err)) {
  81bda1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bda5:	48 8b 00             	mov    (%rax),%rax
  81bda8:	0f b6 40 10          	movzbl 0x10(%rax),%eax
  81bdac:	3c fc                	cmp    $0xfc,%al
  81bdae:	7c 6c                	jl     81be1c <do_write+0x87>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  81bdb0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bdb4:	48 8b 00             	mov    (%rax),%rax
  81bdb7:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bdbb:	48 85 c0             	test   %rax,%rax
  81bdbe:	74 51                	je     81be11 <do_write+0x7c>
  81bdc0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bdc4:	48 8b 00             	mov    (%rax),%rax
  81bdc7:	8b 00                	mov    (%rax),%eax
  81bdc9:	83 f8 10             	cmp    $0x10,%eax
  81bdcc:	75 43                	jne    81be11 <do_write+0x7c>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  81bdce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bdd2:	48 8b 00             	mov    (%rax),%rax
  81bdd5:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  81bddc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bde0:	48 8b 00             	mov    (%rax),%rax
  81bde3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81bde7:	48 89 50 28          	mov    %rdx,0x28(%rax)
      msg->conn->write_offset = 0;
  81bdeb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bdef:	48 8b 00             	mov    (%rax),%rax
  81bdf2:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%rax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  81bdf9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bdfd:	48 8b 00             	mov    (%rax),%rax
  81be00:	48 89 c7             	mov    %rax,%rdi
  81be03:	48 b8 e5 ba 81 00 00 	movabs $0x81bae5,%rax
  81be0a:	00 00 00 
  81be0d:	ff d0                	callq  *%rax
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  81be0f:	eb 23                	jmp    81be34 <do_write+0x9f>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  81be11:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81be15:	48 8b 00             	mov    (%rax),%rax
  81be18:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81be1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81be20:	48 8b 00             	mov    (%rax),%rax
  81be23:	8b 40 14             	mov    0x14(%rax),%eax
  81be26:	89 c7                	mov    %eax,%edi
  81be28:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  81be2f:	00 00 00 
  81be32:	ff d0                	callq  *%rax
}
  81be34:	c9                   	leaveq 
  81be35:	c3                   	retq   

000000000081be36 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  81be36:	55                   	push   %rbp
  81be37:	48 89 e5             	mov    %rsp,%rbp
  81be3a:	48 83 ec 10          	sub    $0x10,%rsp
  81be3e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (msg->conn->pcb.ip != NULL) {
  81be42:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81be46:	48 8b 00             	mov    (%rax),%rax
  81be49:	48 8b 40 08          	mov    0x8(%rax),%rax
  81be4d:	48 85 c0             	test   %rax,%rax
  81be50:	0f 84 40 01 00 00    	je     81bf96 <do_getaddr+0x160>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  81be56:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81be5a:	48 8b 40 08          	mov    0x8(%rax),%rax
  81be5e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81be62:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  81be66:	84 d2                	test   %dl,%dl
  81be68:	74 11                	je     81be7b <do_getaddr+0x45>
  81be6a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81be6e:	48 8b 12             	mov    (%rdx),%rdx
  81be71:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81be75:	8b 12                	mov    (%rdx),%edx
  81be77:	89 10                	mov    %edx,(%rax)
  81be79:	eb 10                	jmp    81be8b <do_getaddr+0x55>
  81be7b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81be7f:	48 8b 12             	mov    (%rdx),%rdx
  81be82:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81be86:	8b 52 04             	mov    0x4(%rdx),%edx
  81be89:	89 10                	mov    %edx,(%rax)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  81be8b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81be8f:	48 8b 00             	mov    (%rax),%rax
  81be92:	8b 00                	mov    (%rax),%eax
  81be94:	25 f0 00 00 00       	and    $0xf0,%eax
  81be99:	83 f8 20             	cmp    $0x20,%eax
  81be9c:	74 51                	je     81beef <do_getaddr+0xb9>
  81be9e:	83 f8 40             	cmp    $0x40,%eax
  81bea1:	74 0e                	je     81beb1 <do_getaddr+0x7b>
  81bea3:	83 f8 10             	cmp    $0x10,%eax
  81bea6:	0f 84 b1 00 00 00    	je     81bf5d <do_getaddr+0x127>
  81beac:	e9 f0 00 00 00       	jmpq   81bfa1 <do_getaddr+0x16b>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  81beb1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81beb5:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81beb9:	84 c0                	test   %al,%al
  81bebb:	74 22                	je     81bedf <do_getaddr+0xa9>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  81bebd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bec1:	48 8b 40 10          	mov    0x10(%rax),%rax
  81bec5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81bec9:	48 8b 12             	mov    (%rdx),%rdx
  81becc:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81bed0:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
  81bed4:	0f b6 d2             	movzbl %dl,%edx
  81bed7:	66 89 10             	mov    %dx,(%rax)
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
      }
      break;
  81beda:	e9 c2 00 00 00       	jmpq   81bfa1 <do_getaddr+0x16b>
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  81bedf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bee3:	48 8b 00             	mov    (%rax),%rax
  81bee6:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
      }
      break;
  81beea:	e9 b2 00 00 00       	jmpq   81bfa1 <do_getaddr+0x16b>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  81beef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bef3:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81bef7:	84 c0                	test   %al,%al
  81bef9:	74 1f                	je     81bf1a <do_getaddr+0xe4>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  81befb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81beff:	48 8b 40 10          	mov    0x10(%rax),%rax
  81bf03:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81bf07:	48 8b 12             	mov    (%rdx),%rdx
  81bf0a:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81bf0e:	0f b7 52 1a          	movzwl 0x1a(%rdx),%edx
  81bf12:	66 89 10             	mov    %dx,(%rax)
          msg->conn->err = ERR_CONN;
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
        }
      }
      break;
  81bf15:	e9 87 00 00 00       	jmpq   81bfa1 <do_getaddr+0x16b>
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  81bf1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bf1e:	48 8b 00             	mov    (%rax),%rax
  81bf21:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf25:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81bf29:	0f b6 c0             	movzbl %al,%eax
  81bf2c:	83 e0 04             	and    $0x4,%eax
  81bf2f:	85 c0                	test   %eax,%eax
  81bf31:	75 0d                	jne    81bf40 <do_getaddr+0x10a>
          msg->conn->err = ERR_CONN;
  81bf33:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bf37:	48 8b 00             	mov    (%rax),%rax
  81bf3a:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
        }
      }
      break;
  81bf3e:	eb 61                	jmp    81bfa1 <do_getaddr+0x16b>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
          msg->conn->err = ERR_CONN;
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  81bf40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bf44:	48 8b 40 10          	mov    0x10(%rax),%rax
  81bf48:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81bf4c:	48 8b 12             	mov    (%rdx),%rdx
  81bf4f:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  81bf53:	0f b7 52 1c          	movzwl 0x1c(%rdx),%edx
  81bf57:	66 89 10             	mov    %dx,(%rax)
        }
      }
      break;
  81bf5a:	90                   	nop
  81bf5b:	eb 44                	jmp    81bfa1 <do_getaddr+0x16b>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  81bf5d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bf61:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81bf65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bf69:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81bf6d:	84 c0                	test   %al,%al
  81bf6f:	74 11                	je     81bf82 <do_getaddr+0x14c>
  81bf71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bf75:	48 8b 00             	mov    (%rax),%rax
  81bf78:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf7c:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  81bf80:	eb 0f                	jmp    81bf91 <do_getaddr+0x15b>
  81bf82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bf86:	48 8b 00             	mov    (%rax),%rax
  81bf89:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bf8d:	0f b7 40 2a          	movzwl 0x2a(%rax),%eax
  81bf91:	66 89 02             	mov    %ax,(%rdx)
      break;
  81bf94:	eb 0b                	jmp    81bfa1 <do_getaddr+0x16b>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  81bf96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bf9a:	48 8b 00             	mov    (%rax),%rax
  81bf9d:	c6 40 10 f8          	movb   $0xf8,0x10(%rax)
  }
  TCPIP_APIMSG_ACK(msg);
  81bfa1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bfa5:	48 8b 00             	mov    (%rax),%rax
  81bfa8:	8b 40 14             	mov    0x14(%rax),%eax
  81bfab:	89 c7                	mov    %eax,%edi
  81bfad:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  81bfb4:	00 00 00 
  81bfb7:	ff d0                	callq  *%rax
}
  81bfb9:	c9                   	leaveq 
  81bfba:	c3                   	retq   

000000000081bfbb <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  81bfbb:	55                   	push   %rbp
  81bfbc:	48 89 e5             	mov    %rsp,%rbp
  81bfbf:	48 83 ec 10          	sub    $0x10,%rsp
  81bfc3:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  81bfc7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bfcb:	48 8b 00             	mov    (%rax),%rax
  81bfce:	48 8b 40 08          	mov    0x8(%rax),%rax
  81bfd2:	48 85 c0             	test   %rax,%rax
  81bfd5:	74 34                	je     81c00b <do_close+0x50>
  81bfd7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bfdb:	48 8b 00             	mov    (%rax),%rax
  81bfde:	8b 00                	mov    (%rax),%eax
  81bfe0:	83 f8 10             	cmp    $0x10,%eax
  81bfe3:	75 26                	jne    81c00b <do_close+0x50>
      msg->conn->state = NETCONN_CLOSE;
  81bfe5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bfe9:	48 8b 00             	mov    (%rax),%rax
  81bfec:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%rax)
      do_close_internal(msg->conn);
  81bff3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81bff7:	48 8b 00             	mov    (%rax),%rax
  81bffa:	48 89 c7             	mov    %rax,%rdi
  81bffd:	48 b8 56 af 81 00 00 	movabs $0x81af56,%rax
  81c004:	00 00 00 
  81c007:	ff d0                	callq  *%rax
  81c009:	eb 23                	jmp    81c02e <do_close+0x73>
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  81c00b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c00f:	48 8b 00             	mov    (%rax),%rax
  81c012:	c6 40 10 f7          	movb   $0xf7,0x10(%rax)
    TCPIP_APIMSG_ACK(msg);
  81c016:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81c01a:	48 8b 00             	mov    (%rax),%rax
  81c01d:	8b 40 14             	mov    0x14(%rax),%eax
  81c020:	89 c7                	mov    %eax,%edi
  81c022:	48 b8 45 7c 81 00 00 	movabs $0x817c45,%rax
  81c029:	00 00 00 
  81c02c:	ff d0                	callq  *%rax
  }
}
  81c02e:	c9                   	leaveq 
  81c02f:	c3                   	retq   

000000000081c030 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  81c030:	55                   	push   %rbp
  81c031:	48 89 e5             	mov    %rsp,%rbp
  81c034:	53                   	push   %rbx
  81c035:	48 83 ec 38          	sub    $0x38,%rsp
  81c039:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81c03d:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  81c041:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c045:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81c049:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81c050:	00 00 00 
  81c053:	48 89 10             	mov    %rdx,(%rax)
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  81c056:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c05a:	48 8b 58 08          	mov    0x8(%rax),%rbx
  81c05e:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81c065:	00 00 00 
  81c068:	48 8b 00             	mov    (%rax),%rax
  81c06b:	0f b7 00             	movzwl (%rax),%eax
  81c06e:	0f b7 c0             	movzwl %ax,%eax
  81c071:	89 c7                	mov    %eax,%edi
  81c073:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81c07a:	00 00 00 
  81c07d:	ff d0                	callq  *%rax
  81c07f:	66 c1 e8 08          	shr    $0x8,%ax
  81c083:	0f b7 c0             	movzwl %ax,%eax
  81c086:	83 e0 0f             	and    $0xf,%eax
  81c089:	c1 e0 02             	shl    $0x2,%eax
  81c08c:	48 98                	cltq   
  81c08e:	48 8d 14 03          	lea    (%rbx,%rax,1),%rdx
  81c092:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81c099:	00 00 00 
  81c09c:	48 89 10             	mov    %rdx,(%rax)
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  81c09f:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81c0a6:	00 00 00 
  81c0a9:	48 8b 00             	mov    (%rax),%rax
  81c0ac:	0f b7 00             	movzwl (%rax),%eax
  81c0af:	0f b7 c0             	movzwl %ax,%eax
  81c0b2:	89 c7                	mov    %eax,%edi
  81c0b4:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81c0bb:	00 00 00 
  81c0be:	ff d0                	callq  *%rax
  81c0c0:	66 c1 e8 08          	shr    $0x8,%ax
  81c0c4:	83 e0 0f             	and    $0xf,%eax
  81c0c7:	c1 e0 02             	shl    $0x2,%eax
  81c0ca:	f7 d8                	neg    %eax
  81c0cc:	0f bf d0             	movswl %ax,%edx
  81c0cf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c0d3:	89 d6                	mov    %edx,%esi
  81c0d5:	48 89 c7             	mov    %rax,%rdi
  81c0d8:	48 b8 6f d7 80 00 00 	movabs $0x80d76f,%rax
  81c0df:	00 00 00 
  81c0e2:	ff d0                	callq  *%rax
  81c0e4:	84 c0                	test   %al,%al
  81c0e6:	75 0e                	jne    81c0f6 <tcp_input+0xc6>
  81c0e8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c0ec:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81c0f0:	66 83 f8 13          	cmp    $0x13,%ax
  81c0f4:	77 18                	ja     81c10e <tcp_input+0xde>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c0f6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c0fa:	48 89 c7             	mov    %rax,%rdi
  81c0fd:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81c104:	00 00 00 
  81c107:	ff d0                	callq  *%rax
    return;
  81c109:	e9 fd 0b 00 00       	jmpq   81cd0b <tcp_input+0xcdb>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  81c10e:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81c115:	00 00 00 
  81c118:	48 8b 00             	mov    (%rax),%rax
  81c11b:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81c11f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  81c123:	48 89 c6             	mov    %rax,%rsi
  81c126:	48 89 d7             	mov    %rdx,%rdi
  81c129:	48 b8 80 09 81 00 00 	movabs $0x810980,%rax
  81c130:	00 00 00 
  81c133:	ff d0                	callq  *%rax
  81c135:	84 c0                	test   %al,%al
  81c137:	75 38                	jne    81c171 <tcp_input+0x141>
      ip_addr_ismulticast(&(iphdr->dest))) {
  81c139:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81c140:	00 00 00 
  81c143:	48 8b 00             	mov    (%rax),%rax
  81c146:	8b 58 10             	mov    0x10(%rax),%ebx
  81c149:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  81c14e:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81c155:	00 00 00 
  81c158:	ff d0                	callq  *%rax
  81c15a:	21 c3                	and    %eax,%ebx
  81c15c:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  81c161:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81c168:	00 00 00 
  81c16b:	ff d0                	callq  *%rax
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  81c16d:	39 c3                	cmp    %eax,%ebx
  81c16f:	75 18                	jne    81c189 <tcp_input+0x159>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c171:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c175:	48 89 c7             	mov    %rax,%rdi
  81c178:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81c17f:	00 00 00 
  81c182:	ff d0                	callq  *%rax
    return;
  81c184:	e9 82 0b 00 00       	jmpq   81cd0b <tcp_input+0xcdb>

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
      IP_PROTO_TCP, p->tot_len) != 0) {
  81c189:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c18d:	0f b7 40 10          	movzwl 0x10(%rax),%eax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  81c191:	0f b7 c8             	movzwl %ax,%ecx
      (struct ip_addr *)&(iphdr->dest),
  81c194:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81c19b:	00 00 00 
  81c19e:	48 8b 00             	mov    (%rax),%rax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  81c1a1:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81c1a5:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81c1ac:	00 00 00 
  81c1af:	48 8b 00             	mov    (%rax),%rax
  81c1b2:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  81c1b6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c1ba:	41 89 c8             	mov    %ecx,%r8d
  81c1bd:	b9 06 00 00 00       	mov    $0x6,%ecx
  81c1c2:	48 89 c7             	mov    %rax,%rdi
  81c1c5:	48 b8 29 24 81 00 00 	movabs $0x812429,%rax
  81c1cc:	00 00 00 
  81c1cf:	ff d0                	callq  *%rax
  81c1d1:	66 85 c0             	test   %ax,%ax
  81c1d4:	74 18                	je     81c1ee <tcp_input+0x1be>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c1d6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c1da:	48 89 c7             	mov    %rax,%rdi
  81c1dd:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81c1e4:	00 00 00 
  81c1e7:	ff d0                	callq  *%rax
    return;
  81c1e9:	e9 1d 0b 00 00       	jmpq   81cd0b <tcp_input+0xcdb>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  81c1ee:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81c1f5:	00 00 00 
  81c1f8:	48 8b 00             	mov    (%rax),%rax
  81c1fb:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81c1ff:	0f b7 c0             	movzwl %ax,%eax
  81c202:	89 c7                	mov    %eax,%edi
  81c204:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81c20b:	00 00 00 
  81c20e:	ff d0                	callq  *%rax
  81c210:	66 c1 e8 0c          	shr    $0xc,%ax
  81c214:	88 45 d6             	mov    %al,-0x2a(%rbp)
  if(pbuf_header(p, -(hdrlen * 4))){
  81c217:	0f b6 55 d6          	movzbl -0x2a(%rbp),%edx
  81c21b:	b8 00 00 00 00       	mov    $0x0,%eax
  81c220:	66 29 d0             	sub    %dx,%ax
  81c223:	c1 e0 02             	shl    $0x2,%eax
  81c226:	0f bf d0             	movswl %ax,%edx
  81c229:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c22d:	89 d6                	mov    %edx,%esi
  81c22f:	48 89 c7             	mov    %rax,%rdi
  81c232:	48 b8 6f d7 80 00 00 	movabs $0x80d76f,%rax
  81c239:	00 00 00 
  81c23c:	ff d0                	callq  *%rax
  81c23e:	84 c0                	test   %al,%al
  81c240:	74 18                	je     81c25a <tcp_input+0x22a>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81c242:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c246:	48 89 c7             	mov    %rax,%rdi
  81c249:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81c250:	00 00 00 
  81c253:	ff d0                	callq  *%rax
    return;
  81c255:	e9 b1 0a 00 00       	jmpq   81cd0b <tcp_input+0xcdb>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  81c25a:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81c261:	00 00 00 
  81c264:	48 8b 18             	mov    (%rax),%rbx
  81c267:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81c26e:	00 00 00 
  81c271:	48 8b 00             	mov    (%rax),%rax
  81c274:	0f b7 00             	movzwl (%rax),%eax
  81c277:	0f b7 c0             	movzwl %ax,%eax
  81c27a:	89 c7                	mov    %eax,%edi
  81c27c:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81c283:	00 00 00 
  81c286:	ff d0                	callq  *%rax
  81c288:	66 89 03             	mov    %ax,(%rbx)
  tcphdr->dest = ntohs(tcphdr->dest);
  81c28b:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81c292:	00 00 00 
  81c295:	48 8b 18             	mov    (%rax),%rbx
  81c298:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81c29f:	00 00 00 
  81c2a2:	48 8b 00             	mov    (%rax),%rax
  81c2a5:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  81c2a9:	0f b7 c0             	movzwl %ax,%eax
  81c2ac:	89 c7                	mov    %eax,%edi
  81c2ae:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81c2b5:	00 00 00 
  81c2b8:	ff d0                	callq  *%rax
  81c2ba:	66 89 43 02          	mov    %ax,0x2(%rbx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  81c2be:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81c2c5:	00 00 00 
  81c2c8:	48 8b 18             	mov    (%rax),%rbx
  81c2cb:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81c2d2:	00 00 00 
  81c2d5:	48 8b 00             	mov    (%rax),%rax
  81c2d8:	8b 40 04             	mov    0x4(%rax),%eax
  81c2db:	89 c7                	mov    %eax,%edi
  81c2dd:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81c2e4:	00 00 00 
  81c2e7:	ff d0                	callq  *%rax
  81c2e9:	89 43 04             	mov    %eax,0x4(%rbx)
  81c2ec:	8b 53 04             	mov    0x4(%rbx),%edx
  81c2ef:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81c2f6:	00 00 00 
  81c2f9:	89 10                	mov    %edx,(%rax)
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  81c2fb:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81c302:	00 00 00 
  81c305:	48 8b 18             	mov    (%rax),%rbx
  81c308:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81c30f:	00 00 00 
  81c312:	48 8b 00             	mov    (%rax),%rax
  81c315:	8b 40 08             	mov    0x8(%rax),%eax
  81c318:	89 c7                	mov    %eax,%edi
  81c31a:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81c321:	00 00 00 
  81c324:	ff d0                	callq  *%rax
  81c326:	89 43 08             	mov    %eax,0x8(%rbx)
  81c329:	8b 53 08             	mov    0x8(%rbx),%edx
  81c32c:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81c333:	00 00 00 
  81c336:	89 10                	mov    %edx,(%rax)
  tcphdr->wnd = ntohs(tcphdr->wnd);
  81c338:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81c33f:	00 00 00 
  81c342:	48 8b 18             	mov    (%rax),%rbx
  81c345:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81c34c:	00 00 00 
  81c34f:	48 8b 00             	mov    (%rax),%rax
  81c352:	0f b7 40 0e          	movzwl 0xe(%rax),%eax
  81c356:	0f b7 c0             	movzwl %ax,%eax
  81c359:	89 c7                	mov    %eax,%edi
  81c35b:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81c362:	00 00 00 
  81c365:	ff d0                	callq  *%rax
  81c367:	66 89 43 0e          	mov    %ax,0xe(%rbx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  81c36b:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81c372:	00 00 00 
  81c375:	48 8b 00             	mov    (%rax),%rax
  81c378:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81c37c:	0f b7 c0             	movzwl %ax,%eax
  81c37f:	89 c7                	mov    %eax,%edi
  81c381:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81c388:	00 00 00 
  81c38b:	ff d0                	callq  *%rax
  81c38d:	89 c2                	mov    %eax,%edx
  81c38f:	83 e2 3f             	and    $0x3f,%edx
  81c392:	48 b8 80 75 b5 00 00 	movabs $0xb57580,%rax
  81c399:	00 00 00 
  81c39c:	88 10                	mov    %dl,(%rax)
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  81c39e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c3a2:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81c3a6:	48 b8 80 75 b5 00 00 	movabs $0xb57580,%rax
  81c3ad:	00 00 00 
  81c3b0:	0f b6 00             	movzbl (%rax),%eax
  81c3b3:	0f b6 c0             	movzbl %al,%eax
  81c3b6:	83 e0 01             	and    $0x1,%eax
  81c3b9:	84 c0                	test   %al,%al
  81c3bb:	75 17                	jne    81c3d4 <tcp_input+0x3a4>
  81c3bd:	48 b8 80 75 b5 00 00 	movabs $0xb57580,%rax
  81c3c4:	00 00 00 
  81c3c7:	0f b6 00             	movzbl (%rax),%eax
  81c3ca:	0f b6 c0             	movzbl %al,%eax
  81c3cd:	83 e0 02             	and    $0x2,%eax
  81c3d0:	85 c0                	test   %eax,%eax
  81c3d2:	74 07                	je     81c3db <tcp_input+0x3ab>
  81c3d4:	b8 01 00 00 00       	mov    $0x1,%eax
  81c3d9:	eb 05                	jmp    81c3e0 <tcp_input+0x3b0>
  81c3db:	b8 00 00 00 00       	mov    $0x0,%eax
  81c3e0:	01 c2                	add    %eax,%edx
  81c3e2:	48 b8 82 75 b5 00 00 	movabs $0xb57582,%rax
  81c3e9:	00 00 00 
  81c3ec:	66 89 10             	mov    %dx,(%rax)

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
  81c3ef:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  81c3f6:	00 

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  81c3f7:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81c3fe:	00 00 00 
  81c401:	48 8b 00             	mov    (%rax),%rax
  81c404:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81c408:	e9 e2 01 00 00       	jmpq   81c5ef <tcp_input+0x5bf>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  81c40d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c411:	8b 40 18             	mov    0x18(%rax),%eax
  81c414:	85 c0                	test   %eax,%eax
  81c416:	75 2a                	jne    81c442 <tcp_input+0x412>
  81c418:	48 ba c0 36 82 00 00 	movabs $0x8236c0,%rdx
  81c41f:	00 00 00 
  81c422:	be b5 00 00 00       	mov    $0xb5,%esi
  81c427:	48 bf e7 36 82 00 00 	movabs $0x8236e7,%rdi
  81c42e:	00 00 00 
  81c431:	b8 00 00 00 00       	mov    $0x0,%eax
  81c436:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81c43d:	00 00 00 
  81c440:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  81c442:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c446:	8b 40 18             	mov    0x18(%rax),%eax
  81c449:	83 f8 0a             	cmp    $0xa,%eax
  81c44c:	75 2a                	jne    81c478 <tcp_input+0x448>
  81c44e:	48 ba 00 37 82 00 00 	movabs $0x823700,%rdx
  81c455:	00 00 00 
  81c458:	be b6 00 00 00       	mov    $0xb6,%esi
  81c45d:	48 bf e7 36 82 00 00 	movabs $0x8236e7,%rdi
  81c464:	00 00 00 
  81c467:	b8 00 00 00 00       	mov    $0x0,%eax
  81c46c:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81c473:	00 00 00 
  81c476:	ff d1                	callq  *%rcx
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  81c478:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c47c:	8b 40 18             	mov    0x18(%rax),%eax
  81c47f:	83 f8 01             	cmp    $0x1,%eax
  81c482:	75 2a                	jne    81c4ae <tcp_input+0x47e>
  81c484:	48 ba 30 37 82 00 00 	movabs $0x823730,%rdx
  81c48b:	00 00 00 
  81c48e:	be b7 00 00 00       	mov    $0xb7,%esi
  81c493:	48 bf e7 36 82 00 00 	movabs $0x8236e7,%rdi
  81c49a:	00 00 00 
  81c49d:	b8 00 00 00 00       	mov    $0x0,%eax
  81c4a2:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81c4a9:	00 00 00 
  81c4ac:	ff d1                	callq  *%rcx
    if (pcb->remote_port == tcphdr->src &&
  81c4ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c4b2:	0f b7 50 2a          	movzwl 0x2a(%rax),%edx
  81c4b6:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81c4bd:	00 00 00 
  81c4c0:	48 8b 00             	mov    (%rax),%rax
  81c4c3:	0f b7 00             	movzwl (%rax),%eax
  81c4c6:	66 39 c2             	cmp    %ax,%dx
  81c4c9:	0f 85 0c 01 00 00    	jne    81c5db <tcp_input+0x5ab>
       pcb->local_port == tcphdr->dest &&
  81c4cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c4d3:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81c4d7:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81c4de:	00 00 00 
  81c4e1:	48 8b 00             	mov    (%rax),%rax
  81c4e4:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  81c4e8:	66 39 c2             	cmp    %ax,%dx
  81c4eb:	0f 85 ea 00 00 00    	jne    81c5db <tcp_input+0x5ab>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81c4f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c4f5:	8b 50 04             	mov    0x4(%rax),%edx
  81c4f8:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81c4ff:	00 00 00 
  81c502:	48 8b 00             	mov    (%rax),%rax
  81c505:	8b 40 0c             	mov    0xc(%rax),%eax
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
  81c508:	39 c2                	cmp    %eax,%edx
  81c50a:	0f 85 cb 00 00 00    	jne    81c5db <tcp_input+0x5ab>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  81c510:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c514:	8b 10                	mov    (%rax),%edx
  81c516:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81c51d:	00 00 00 
  81c520:	48 8b 00             	mov    (%rax),%rax
  81c523:	8b 40 10             	mov    0x10(%rax),%eax
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81c526:	39 c2                	cmp    %eax,%edx
  81c528:	0f 85 ad 00 00 00    	jne    81c5db <tcp_input+0x5ab>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  81c52e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c532:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c536:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81c53a:	75 2a                	jne    81c566 <tcp_input+0x536>
  81c53c:	48 ba 58 37 82 00 00 	movabs $0x823758,%rdx
  81c543:	00 00 00 
  81c546:	be c0 00 00 00       	mov    $0xc0,%esi
  81c54b:	48 bf e7 36 82 00 00 	movabs $0x8236e7,%rdi
  81c552:	00 00 00 
  81c555:	b8 00 00 00 00       	mov    $0x0,%eax
  81c55a:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81c561:	00 00 00 
  81c564:	ff d1                	callq  *%rcx
      if (prev != NULL) {
  81c566:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81c56b:	74 36                	je     81c5a3 <tcp_input+0x573>
        prev->next = pcb->next;
  81c56d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c571:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81c575:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81c579:	48 89 50 10          	mov    %rdx,0x10(%rax)
        pcb->next = tcp_active_pcbs;
  81c57d:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81c584:	00 00 00 
  81c587:	48 8b 10             	mov    (%rax),%rdx
  81c58a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c58e:	48 89 50 10          	mov    %rdx,0x10(%rax)
        tcp_active_pcbs = pcb;
  81c592:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81c599:	00 00 00 
  81c59c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81c5a0:	48 89 10             	mov    %rdx,(%rax)
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  81c5a3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c5a7:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c5ab:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81c5af:	75 4b                	jne    81c5fc <tcp_input+0x5cc>
  81c5b1:	48 ba 88 37 82 00 00 	movabs $0x823788,%rdx
  81c5b8:	00 00 00 
  81c5bb:	be c6 00 00 00       	mov    $0xc6,%esi
  81c5c0:	48 bf e7 36 82 00 00 	movabs $0x8236e7,%rdi
  81c5c7:	00 00 00 
  81c5ca:	b8 00 00 00 00       	mov    $0x0,%eax
  81c5cf:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81c5d6:	00 00 00 
  81c5d9:	ff d1                	callq  *%rcx
      break;
    }
    prev = pcb;
  81c5db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c5df:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  81c5e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c5e7:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c5eb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81c5ef:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81c5f4:	0f 85 13 fe ff ff    	jne    81c40d <tcp_input+0x3dd>
  81c5fa:	eb 01                	jmp    81c5fd <tcp_input+0x5cd>
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = pcb;
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
      break;
  81c5fc:	90                   	nop
    }
    prev = pcb;
  }

  if (pcb == NULL) {
  81c5fd:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81c602:	0f 85 f2 01 00 00    	jne    81c7fa <tcp_input+0x7ca>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  81c608:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81c60f:	00 00 00 
  81c612:	48 8b 00             	mov    (%rax),%rax
  81c615:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81c619:	e9 dd 00 00 00       	jmpq   81c6fb <tcp_input+0x6cb>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  81c61e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c622:	8b 40 18             	mov    0x18(%rax),%eax
  81c625:	83 f8 0a             	cmp    $0xa,%eax
  81c628:	74 2a                	je     81c654 <tcp_input+0x624>
  81c62a:	48 ba b8 37 82 00 00 	movabs $0x8237b8,%rdx
  81c631:	00 00 00 
  81c634:	be d0 00 00 00       	mov    $0xd0,%esi
  81c639:	48 bf e7 36 82 00 00 	movabs $0x8236e7,%rdi
  81c640:	00 00 00 
  81c643:	b8 00 00 00 00       	mov    $0x0,%eax
  81c648:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81c64f:	00 00 00 
  81c652:	ff d1                	callq  *%rcx
      if (pcb->remote_port == tcphdr->src &&
  81c654:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c658:	0f b7 50 2a          	movzwl 0x2a(%rax),%edx
  81c65c:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81c663:	00 00 00 
  81c666:	48 8b 00             	mov    (%rax),%rax
  81c669:	0f b7 00             	movzwl (%rax),%eax
  81c66c:	66 39 c2             	cmp    %ax,%dx
  81c66f:	75 7e                	jne    81c6ef <tcp_input+0x6bf>
         pcb->local_port == tcphdr->dest &&
  81c671:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c675:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81c679:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81c680:	00 00 00 
  81c683:	48 8b 00             	mov    (%rax),%rax
  81c686:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
  81c68a:	66 39 c2             	cmp    %ax,%dx
  81c68d:	75 60                	jne    81c6ef <tcp_input+0x6bf>
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81c68f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c693:	8b 50 04             	mov    0x4(%rax),%edx
  81c696:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81c69d:	00 00 00 
  81c6a0:	48 8b 00             	mov    (%rax),%rax
  81c6a3:	8b 40 0c             	mov    0xc(%rax),%eax
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
  81c6a6:	39 c2                	cmp    %eax,%edx
  81c6a8:	75 45                	jne    81c6ef <tcp_input+0x6bf>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  81c6aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c6ae:	8b 10                	mov    (%rax),%edx
  81c6b0:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81c6b7:	00 00 00 
  81c6ba:	48 8b 00             	mov    (%rax),%rax
  81c6bd:	8b 40 10             	mov    0x10(%rax),%eax
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81c6c0:	39 c2                	cmp    %eax,%edx
  81c6c2:	75 2b                	jne    81c6ef <tcp_input+0x6bf>
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
  81c6c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c6c8:	48 89 c7             	mov    %rax,%rdi
  81c6cb:	48 b8 12 d0 81 00 00 	movabs $0x81d012,%rax
  81c6d2:	00 00 00 
  81c6d5:	ff d0                	callq  *%rax
        pbuf_free(p);
  81c6d7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c6db:	48 89 c7             	mov    %rax,%rdi
  81c6de:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81c6e5:	00 00 00 
  81c6e8:	ff d0                	callq  *%rax
        return;
  81c6ea:	e9 1c 06 00 00       	jmpq   81cd0b <tcp_input+0xcdb>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  81c6ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c6f3:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c6f7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81c6fb:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81c700:	0f 85 18 ff ff ff    	jne    81c61e <tcp_input+0x5ee>
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
  81c706:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  81c70d:	00 
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  81c70e:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  81c715:	00 00 00 
  81c718:	48 8b 00             	mov    (%rax),%rax
  81c71b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81c71f:	e9 cb 00 00 00       	jmpq   81c7ef <tcp_input+0x7bf>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  81c724:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c728:	48 85 c0             	test   %rax,%rax
  81c72b:	74 28                	je     81c755 <tcp_input+0x725>
  81c72d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c731:	8b 00                	mov    (%rax),%eax
  81c733:	85 c0                	test   %eax,%eax
  81c735:	74 1e                	je     81c755 <tcp_input+0x725>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  81c737:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c73b:	8b 10                	mov    (%rax),%edx
  81c73d:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81c744:	00 00 00 
  81c747:	48 8b 00             	mov    (%rax),%rax
  81c74a:	8b 40 10             	mov    0x10(%rax),%eax

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  81c74d:	39 c2                	cmp    %eax,%edx
  81c74f:	0f 85 86 00 00 00    	jne    81c7db <tcp_input+0x7ab>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
        lpcb->local_port == tcphdr->dest) {
  81c755:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c759:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81c75d:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81c764:	00 00 00 
  81c767:	48 8b 00             	mov    (%rax),%rax
  81c76a:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  81c76e:	66 39 c2             	cmp    %ax,%dx
  81c771:	75 68                	jne    81c7db <tcp_input+0x7ab>
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  81c773:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  81c778:	74 36                	je     81c7b0 <tcp_input+0x780>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  81c77a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c77e:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81c782:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81c786:	48 89 50 10          	mov    %rdx,0x10(%rax)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  81c78a:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  81c791:	00 00 00 
  81c794:	48 8b 10             	mov    (%rax),%rdx
  81c797:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c79b:	48 89 50 10          	mov    %rdx,0x10(%rax)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  81c79f:	48 b8 28 b0 b5 00 00 	movabs $0xb5b028,%rax
  81c7a6:	00 00 00 
  81c7a9:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81c7ad:	48 89 10             	mov    %rdx,(%rax)
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
  81c7b0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c7b4:	48 89 c7             	mov    %rax,%rdi
  81c7b7:	48 b8 12 cd 81 00 00 	movabs $0x81cd12,%rax
  81c7be:	00 00 00 
  81c7c1:	ff d0                	callq  *%rax
        pbuf_free(p);
  81c7c3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c7c7:	48 89 c7             	mov    %rax,%rdi
  81c7ca:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81c7d1:	00 00 00 
  81c7d4:	ff d0                	callq  *%rax
        return;
  81c7d6:	e9 30 05 00 00       	jmpq   81cd0b <tcp_input+0xcdb>
      }
      prev = (struct tcp_pcb *)lpcb;
  81c7db:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c7df:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  81c7e3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81c7e7:	48 8b 40 10          	mov    0x10(%rax),%rax
  81c7eb:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81c7ef:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81c7f4:	0f 85 2a ff ff ff    	jne    81c724 <tcp_input+0x6f4>
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
  81c7fa:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81c7ff:	0f 84 3b 04 00 00    	je     81cc40 <tcp_input+0xc10>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  81c805:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81c80c:	00 00 00 
  81c80f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    inseg.len = p->tot_len;
  81c816:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c81a:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81c81e:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81c825:	00 00 00 
  81c828:	66 89 50 18          	mov    %dx,0x18(%rax)
    inseg.dataptr = p->payload;
  81c82c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c830:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81c834:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81c83b:	00 00 00 
  81c83e:	48 89 50 10          	mov    %rdx,0x10(%rax)
    inseg.p = p;
  81c842:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81c849:	00 00 00 
  81c84c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81c850:	48 89 50 08          	mov    %rdx,0x8(%rax)
    inseg.tcphdr = tcphdr;
  81c854:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81c85b:	00 00 00 
  81c85e:	48 8b 10             	mov    (%rax),%rdx
  81c861:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81c868:	00 00 00 
  81c86b:	48 89 50 20          	mov    %rdx,0x20(%rax)

    recv_data = NULL;
  81c86f:	48 b8 88 75 b5 00 00 	movabs $0xb57588,%rax
  81c876:	00 00 00 
  81c879:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    recv_flags = 0;
  81c880:	48 b8 84 75 b5 00 00 	movabs $0xb57584,%rax
  81c887:	00 00 00 
  81c88a:	c6 00 00             	movb   $0x0,(%rax)

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  81c88d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c891:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81c898:	48 85 c0             	test   %rax,%rax
  81c89b:	0f 84 9f 00 00 00    	je     81c940 <tcp_input+0x910>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  81c8a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c8a5:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81c8ac:	48 85 c0             	test   %rax,%rax
  81c8af:	74 32                	je     81c8e3 <tcp_input+0x8b3>
  81c8b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c8b5:	4c 8b 80 a8 00 00 00 	mov    0xa8(%rax),%r8
  81c8bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c8c0:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  81c8c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c8cb:	48 8b 40 20          	mov    0x20(%rax),%rax
  81c8cf:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81c8d3:	b9 00 00 00 00       	mov    $0x0,%ecx
  81c8d8:	48 89 c7             	mov    %rax,%rdi
  81c8db:	41 ff d0             	callq  *%r8
  81c8de:	88 45 d7             	mov    %al,-0x29(%rbp)
  81c8e1:	eb 2e                	jmp    81c911 <tcp_input+0x8e1>
  81c8e3:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
  81c8e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c8eb:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81c8f2:	48 85 c0             	test   %rax,%rax
  81c8f5:	74 1a                	je     81c911 <tcp_input+0x8e1>
  81c8f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c8fb:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  81c902:	48 89 c7             	mov    %rax,%rdi
  81c905:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81c90c:	00 00 00 
  81c90f:	ff d0                	callq  *%rax
      if (err == ERR_OK) {
  81c911:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81c915:	75 11                	jne    81c928 <tcp_input+0x8f8>
        pcb->refused_data = NULL;
  81c917:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c91b:	48 c7 80 98 00 00 00 	movq   $0x0,0x98(%rax)
  81c922:	00 00 00 00 
  81c926:	eb 18                	jmp    81c940 <tcp_input+0x910>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  81c928:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81c92c:	48 89 c7             	mov    %rax,%rdi
  81c92f:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81c936:	00 00 00 
  81c939:	ff d0                	callq  *%rax
        return;
  81c93b:	e9 cb 03 00 00       	jmpq   81cd0b <tcp_input+0xcdb>
      }
    }

    tcp_input_pcb = pcb;
  81c940:	48 b8 50 b0 b5 00 00 	movabs $0xb5b050,%rax
  81c947:	00 00 00 
  81c94a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81c94e:	48 89 10             	mov    %rdx,(%rax)
    err = tcp_process(pcb);
  81c951:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c955:	48 89 c7             	mov    %rax,%rdi
  81c958:	48 b8 c0 d0 81 00 00 	movabs $0x81d0c0,%rax
  81c95f:	00 00 00 
  81c962:	ff d0                	callq  *%rax
  81c964:	88 45 d7             	mov    %al,-0x29(%rbp)
    tcp_input_pcb = NULL;
  81c967:	48 b8 50 b0 b5 00 00 	movabs $0xb5b050,%rax
  81c96e:	00 00 00 
  81c971:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
  81c978:	80 7d d7 fb          	cmpb   $0xfb,-0x29(%rbp)
  81c97c:	0f 84 73 02 00 00    	je     81cbf5 <tcp_input+0xbc5>
      if (recv_flags & TF_RESET) {
  81c982:	48 b8 84 75 b5 00 00 	movabs $0xb57584,%rax
  81c989:	00 00 00 
  81c98c:	0f b6 00             	movzbl (%rax),%eax
  81c98f:	0f b6 c0             	movzbl %al,%eax
  81c992:	83 e0 08             	and    $0x8,%eax
  81c995:	85 c0                	test   %eax,%eax
  81c997:	74 67                	je     81ca00 <tcp_input+0x9d0>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  81c999:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c99d:	48 8b 80 c8 00 00 00 	mov    0xc8(%rax),%rax
  81c9a4:	48 85 c0             	test   %rax,%rax
  81c9a7:	74 1d                	je     81c9c6 <tcp_input+0x996>
  81c9a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c9ad:	48 8b 90 c8 00 00 00 	mov    0xc8(%rax),%rdx
  81c9b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c9b8:	48 8b 40 20          	mov    0x20(%rax),%rax
  81c9bc:	be fa ff ff ff       	mov    $0xfffffffa,%esi
  81c9c1:	48 89 c7             	mov    %rax,%rdi
  81c9c4:	ff d2                	callq  *%rdx
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  81c9c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c9ca:	48 89 c6             	mov    %rax,%rsi
  81c9cd:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  81c9d4:	00 00 00 
  81c9d7:	48 b8 e8 06 81 00 00 	movabs $0x8106e8,%rax
  81c9de:	00 00 00 
  81c9e1:	ff d0                	callq  *%rax
        memp_free(MEMP_TCP_PCB, pcb);
  81c9e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81c9e7:	48 89 c6             	mov    %rax,%rsi
  81c9ea:	bf 02 00 00 00       	mov    $0x2,%edi
  81c9ef:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  81c9f6:	00 00 00 
  81c9f9:	ff d0                	callq  *%rax
  81c9fb:	e9 f5 01 00 00       	jmpq   81cbf5 <tcp_input+0xbc5>
      } else if (recv_flags & TF_CLOSED) {
  81ca00:	48 b8 84 75 b5 00 00 	movabs $0xb57584,%rax
  81ca07:	00 00 00 
  81ca0a:	0f b6 00             	movzbl (%rax),%eax
  81ca0d:	0f b6 c0             	movzbl %al,%eax
  81ca10:	83 e0 10             	and    $0x10,%eax
  81ca13:	85 c0                	test   %eax,%eax
  81ca15:	74 3a                	je     81ca51 <tcp_input+0xa21>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  81ca17:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca1b:	48 89 c6             	mov    %rax,%rsi
  81ca1e:	48 bf 18 b0 b5 00 00 	movabs $0xb5b018,%rdi
  81ca25:	00 00 00 
  81ca28:	48 b8 e8 06 81 00 00 	movabs $0x8106e8,%rax
  81ca2f:	00 00 00 
  81ca32:	ff d0                	callq  *%rax
        memp_free(MEMP_TCP_PCB, pcb);
  81ca34:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca38:	48 89 c6             	mov    %rax,%rsi
  81ca3b:	bf 02 00 00 00       	mov    $0x2,%edi
  81ca40:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  81ca47:	00 00 00 
  81ca4a:	ff d0                	callq  *%rax
  81ca4c:	e9 a4 01 00 00       	jmpq   81cbf5 <tcp_input+0xbc5>
      } else {
        err = ERR_OK;
  81ca51:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  81ca55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca59:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  81ca5d:	66 85 c0             	test   %ax,%ax
  81ca60:	74 3e                	je     81caa0 <tcp_input+0xa70>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  81ca62:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca66:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
  81ca6d:	48 85 c0             	test   %rax,%rax
  81ca70:	74 2e                	je     81caa0 <tcp_input+0xa70>
  81ca72:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca76:	4c 8b 80 a0 00 00 00 	mov    0xa0(%rax),%r8
  81ca7d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca81:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  81ca85:	0f b7 d0             	movzwl %ax,%edx
  81ca88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ca8c:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ca90:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  81ca94:	48 89 ce             	mov    %rcx,%rsi
  81ca97:	48 89 c7             	mov    %rax,%rdi
  81ca9a:	41 ff d0             	callq  *%r8
  81ca9d:	88 45 d7             	mov    %al,-0x29(%rbp)
        }
      
        if (recv_data != NULL) {
  81caa0:	48 b8 88 75 b5 00 00 	movabs $0xb57588,%rax
  81caa7:	00 00 00 
  81caaa:	48 8b 00             	mov    (%rax),%rax
  81caad:	48 85 c0             	test   %rax,%rax
  81cab0:	0f 84 cf 00 00 00    	je     81cb85 <tcp_input+0xb55>
          if(flags & TCP_PSH) {
  81cab6:	48 b8 80 75 b5 00 00 	movabs $0xb57580,%rax
  81cabd:	00 00 00 
  81cac0:	0f b6 00             	movzbl (%rax),%eax
  81cac3:	0f b6 c0             	movzbl %al,%eax
  81cac6:	83 e0 08             	and    $0x8,%eax
  81cac9:	85 c0                	test   %eax,%eax
  81cacb:	74 24                	je     81caf1 <tcp_input+0xac1>
            recv_data->flags |= PBUF_FLAG_PUSH;
  81cacd:	48 b8 88 75 b5 00 00 	movabs $0xb57588,%rax
  81cad4:	00 00 00 
  81cad7:	48 8b 00             	mov    (%rax),%rax
  81cada:	48 ba 88 75 b5 00 00 	movabs $0xb57588,%rdx
  81cae1:	00 00 00 
  81cae4:	48 8b 12             	mov    (%rdx),%rdx
  81cae7:	0f b6 52 15          	movzbl 0x15(%rdx),%edx
  81caeb:	83 ca 01             	or     $0x1,%edx
  81caee:	88 50 15             	mov    %dl,0x15(%rax)
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  81caf1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81caf5:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81cafc:	48 85 c0             	test   %rax,%rax
  81caff:	74 34                	je     81cb35 <tcp_input+0xb05>
  81cb01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb05:	4c 8b 80 a8 00 00 00 	mov    0xa8(%rax),%r8
  81cb0c:	48 b8 88 75 b5 00 00 	movabs $0xb57588,%rax
  81cb13:	00 00 00 
  81cb16:	48 8b 10             	mov    (%rax),%rdx
  81cb19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb1d:	48 8b 40 20          	mov    0x20(%rax),%rax
  81cb21:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81cb25:	b9 00 00 00 00       	mov    $0x0,%ecx
  81cb2a:	48 89 c7             	mov    %rax,%rdi
  81cb2d:	41 ff d0             	callq  *%r8
  81cb30:	88 45 d7             	mov    %al,-0x29(%rbp)
  81cb33:	eb 32                	jmp    81cb67 <tcp_input+0xb37>
  81cb35:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
  81cb39:	48 b8 88 75 b5 00 00 	movabs $0xb57588,%rax
  81cb40:	00 00 00 
  81cb43:	48 8b 00             	mov    (%rax),%rax
  81cb46:	48 85 c0             	test   %rax,%rax
  81cb49:	74 1c                	je     81cb67 <tcp_input+0xb37>
  81cb4b:	48 b8 88 75 b5 00 00 	movabs $0xb57588,%rax
  81cb52:	00 00 00 
  81cb55:	48 8b 00             	mov    (%rax),%rax
  81cb58:	48 89 c7             	mov    %rax,%rdi
  81cb5b:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81cb62:	00 00 00 
  81cb65:	ff d0                	callq  *%rax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  81cb67:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81cb6b:	74 18                	je     81cb85 <tcp_input+0xb55>
            pcb->refused_data = recv_data;
  81cb6d:	48 b8 88 75 b5 00 00 	movabs $0xb57588,%rax
  81cb74:	00 00 00 
  81cb77:	48 8b 10             	mov    (%rax),%rdx
  81cb7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cb7e:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  81cb85:	48 b8 84 75 b5 00 00 	movabs $0xb57584,%rax
  81cb8c:	00 00 00 
  81cb8f:	0f b6 00             	movzbl (%rax),%eax
  81cb92:	0f b6 c0             	movzbl %al,%eax
  81cb95:	83 e0 20             	and    $0x20,%eax
  81cb98:	85 c0                	test   %eax,%eax
  81cb9a:	74 40                	je     81cbdc <tcp_input+0xbac>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  81cb9c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cba0:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  81cba7:	48 85 c0             	test   %rax,%rax
  81cbaa:	74 2c                	je     81cbd8 <tcp_input+0xba8>
  81cbac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cbb0:	4c 8b 80 a8 00 00 00 	mov    0xa8(%rax),%r8
  81cbb7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cbbb:	48 8b 40 20          	mov    0x20(%rax),%rax
  81cbbf:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  81cbc3:	b9 00 00 00 00       	mov    $0x0,%ecx
  81cbc8:	ba 00 00 00 00       	mov    $0x0,%edx
  81cbcd:	48 89 c7             	mov    %rax,%rdi
  81cbd0:	41 ff d0             	callq  *%r8
  81cbd3:	88 45 d7             	mov    %al,-0x29(%rbp)
  81cbd6:	eb 04                	jmp    81cbdc <tcp_input+0xbac>
  81cbd8:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  81cbdc:	80 7d d7 00          	cmpb   $0x0,-0x29(%rbp)
  81cbe0:	75 13                	jne    81cbf5 <tcp_input+0xbc5>
          tcp_output(pcb);
  81cbe2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cbe6:	48 89 c7             	mov    %rax,%rdi
  81cbe9:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  81cbf0:	00 00 00 
  81cbf3:	ff d0                	callq  *%rax
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  81cbf5:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81cbfc:	00 00 00 
  81cbff:	48 8b 40 08          	mov    0x8(%rax),%rax
  81cc03:	48 85 c0             	test   %rax,%rax
  81cc06:	0f 84 ff 00 00 00    	je     81cd0b <tcp_input+0xcdb>
    {
      pbuf_free(inseg.p);
  81cc0c:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81cc13:	00 00 00 
  81cc16:	48 8b 40 08          	mov    0x8(%rax),%rax
  81cc1a:	48 89 c7             	mov    %rax,%rdi
  81cc1d:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81cc24:	00 00 00 
  81cc27:	ff d0                	callq  *%rax
      inseg.p = NULL;
  81cc29:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81cc30:	00 00 00 
  81cc33:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81cc3a:	00 
  81cc3b:	e9 cb 00 00 00       	jmpq   81cd0b <tcp_input+0xcdb>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  81cc40:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81cc47:	00 00 00 
  81cc4a:	48 8b 00             	mov    (%rax),%rax
  81cc4d:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81cc51:	0f b7 c0             	movzwl %ax,%eax
  81cc54:	89 c7                	mov    %eax,%edi
  81cc56:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81cc5d:	00 00 00 
  81cc60:	ff d0                	callq  *%rax
  81cc62:	0f b7 c0             	movzwl %ax,%eax
  81cc65:	83 e0 04             	and    $0x4,%eax
  81cc68:	85 c0                	test   %eax,%eax
  81cc6a:	0f 85 88 00 00 00    	jne    81ccf8 <tcp_input+0xcc8>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81cc70:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81cc77:	00 00 00 
  81cc7a:	48 8b 00             	mov    (%rax),%rax
  81cc7d:	0f b7 00             	movzwl (%rax),%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81cc80:	44 0f b7 c0          	movzwl %ax,%r8d
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81cc84:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81cc8b:	00 00 00 
  81cc8e:	48 8b 00             	mov    (%rax),%rax
  81cc91:	0f b7 40 02          	movzwl 0x2(%rax),%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81cc95:	0f b7 f8             	movzwl %ax,%edi
        &(iphdr->dest), &(iphdr->src),
  81cc98:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81cc9f:	00 00 00 
  81cca2:	48 8b 00             	mov    (%rax),%rax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81cca5:	48 8d 48 0c          	lea    0xc(%rax),%rcx
        &(iphdr->dest), &(iphdr->src),
  81cca9:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81ccb0:	00 00 00 
  81ccb3:	48 8b 00             	mov    (%rax),%rax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  81ccb6:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81ccba:	48 b8 82 75 b5 00 00 	movabs $0xb57582,%rax
  81ccc1:	00 00 00 
  81ccc4:	0f b7 00             	movzwl (%rax),%eax
  81ccc7:	0f b7 f0             	movzwl %ax,%esi
  81ccca:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81ccd1:	00 00 00 
  81ccd4:	8b 00                	mov    (%rax),%eax
  81ccd6:	01 c6                	add    %eax,%esi
  81ccd8:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81ccdf:	00 00 00 
  81cce2:	8b 00                	mov    (%rax),%eax
  81cce4:	45 89 c1             	mov    %r8d,%r9d
  81cce7:	41 89 f8             	mov    %edi,%r8d
  81ccea:	89 c7                	mov    %eax,%edi
  81ccec:	48 b8 d9 41 81 00 00 	movabs $0x8141d9,%rax
  81ccf3:	00 00 00 
  81ccf6:	ff d0                	callq  *%rax
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  81ccf8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81ccfc:	48 89 c7             	mov    %rax,%rdi
  81ccff:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81cd06:	00 00 00 
  81cd09:	ff d0                	callq  *%rax
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  81cd0b:	48 83 c4 38          	add    $0x38,%rsp
  81cd0f:	5b                   	pop    %rbx
  81cd10:	5d                   	pop    %rbp
  81cd11:	c3                   	retq   

000000000081cd12 <tcp_listen_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
  81cd12:	55                   	push   %rbp
  81cd13:	48 89 e5             	mov    %rsp,%rbp
  81cd16:	48 83 ec 30          	sub    $0x30,%rsp
  81cd1a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  81cd1e:	48 b8 80 75 b5 00 00 	movabs $0xb57580,%rax
  81cd25:	00 00 00 
  81cd28:	0f b6 00             	movzbl (%rax),%eax
  81cd2b:	0f b6 c0             	movzbl %al,%eax
  81cd2e:	83 e0 10             	and    $0x10,%eax
  81cd31:	85 c0                	test   %eax,%eax
  81cd33:	0f 84 90 00 00 00    	je     81cdc9 <tcp_listen_input+0xb7>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  81cd39:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81cd40:	00 00 00 
  81cd43:	48 8b 00             	mov    (%rax),%rax
  81cd46:	0f b7 00             	movzwl (%rax),%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81cd49:	44 0f b7 c0          	movzwl %ax,%r8d
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  81cd4d:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81cd54:	00 00 00 
  81cd57:	48 8b 00             	mov    (%rax),%rax
  81cd5a:	0f b7 40 02          	movzwl 0x2(%rax),%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81cd5e:	0f b7 f8             	movzwl %ax,%edi
      &(iphdr->dest), &(iphdr->src),
  81cd61:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81cd68:	00 00 00 
  81cd6b:	48 8b 00             	mov    (%rax),%rax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81cd6e:	48 8d 48 0c          	lea    0xc(%rax),%rcx
      &(iphdr->dest), &(iphdr->src),
  81cd72:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81cd79:	00 00 00 
  81cd7c:	48 8b 00             	mov    (%rax),%rax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  81cd7f:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81cd83:	48 b8 82 75 b5 00 00 	movabs $0xb57582,%rax
  81cd8a:	00 00 00 
  81cd8d:	0f b7 00             	movzwl (%rax),%eax
  81cd90:	0f b7 f0             	movzwl %ax,%esi
  81cd93:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81cd9a:	00 00 00 
  81cd9d:	8b 00                	mov    (%rax),%eax
  81cd9f:	01 c6                	add    %eax,%esi
  81cda1:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81cda8:	00 00 00 
  81cdab:	8b 00                	mov    (%rax),%eax
  81cdad:	83 c0 01             	add    $0x1,%eax
  81cdb0:	45 89 c1             	mov    %r8d,%r9d
  81cdb3:	41 89 f8             	mov    %edi,%r8d
  81cdb6:	89 c7                	mov    %eax,%edi
  81cdb8:	48 b8 d9 41 81 00 00 	movabs $0x8141d9,%rax
  81cdbf:	00 00 00 
  81cdc2:	ff d0                	callq  *%rax
  81cdc4:	e9 42 02 00 00       	jmpq   81d00b <tcp_listen_input+0x2f9>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  81cdc9:	48 b8 80 75 b5 00 00 	movabs $0xb57580,%rax
  81cdd0:	00 00 00 
  81cdd3:	0f b6 00             	movzbl (%rax),%eax
  81cdd6:	0f b6 c0             	movzbl %al,%eax
  81cdd9:	83 e0 02             	and    $0x2,%eax
  81cddc:	85 c0                	test   %eax,%eax
  81cdde:	0f 84 27 02 00 00    	je     81d00b <tcp_listen_input+0x2f9>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  81cde4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cde8:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  81cdec:	0f b6 c0             	movzbl %al,%eax
  81cdef:	89 c7                	mov    %eax,%edi
  81cdf1:	48 b8 53 03 81 00 00 	movabs $0x810353,%rax
  81cdf8:	00 00 00 
  81cdfb:	ff d0                	callq  *%rax
  81cdfd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  81ce01:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81ce06:	75 0a                	jne    81ce12 <tcp_listen_input+0x100>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
      TCP_STATS_INC(tcp.memerr);
      return ERR_MEM;
  81ce08:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81ce0d:	e9 fe 01 00 00       	jmpq   81d010 <tcp_listen_input+0x2fe>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  81ce12:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81ce19:	00 00 00 
  81ce1c:	48 8b 00             	mov    (%rax),%rax
  81ce1f:	48 83 c0 10          	add    $0x10,%rax
  81ce23:	48 85 c0             	test   %rax,%rax
  81ce26:	74 12                	je     81ce3a <tcp_listen_input+0x128>
  81ce28:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81ce2f:	00 00 00 
  81ce32:	48 8b 00             	mov    (%rax),%rax
  81ce35:	8b 40 10             	mov    0x10(%rax),%eax
  81ce38:	eb 05                	jmp    81ce3f <tcp_listen_input+0x12d>
  81ce3a:	b8 00 00 00 00       	mov    $0x0,%eax
  81ce3f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81ce43:	89 02                	mov    %eax,(%rdx)
    npcb->local_port = pcb->local_port;
  81ce45:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ce49:	0f b7 50 28          	movzwl 0x28(%rax),%edx
  81ce4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ce51:	66 89 50 28          	mov    %dx,0x28(%rax)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  81ce55:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81ce5c:	00 00 00 
  81ce5f:	48 8b 00             	mov    (%rax),%rax
  81ce62:	48 83 c0 0c          	add    $0xc,%rax
  81ce66:	48 85 c0             	test   %rax,%rax
  81ce69:	74 12                	je     81ce7d <tcp_listen_input+0x16b>
  81ce6b:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81ce72:	00 00 00 
  81ce75:	48 8b 00             	mov    (%rax),%rax
  81ce78:	8b 40 0c             	mov    0xc(%rax),%eax
  81ce7b:	eb 05                	jmp    81ce82 <tcp_listen_input+0x170>
  81ce7d:	b8 00 00 00 00       	mov    $0x0,%eax
  81ce82:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81ce86:	89 42 04             	mov    %eax,0x4(%rdx)
    npcb->remote_port = tcphdr->src;
  81ce89:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81ce90:	00 00 00 
  81ce93:	48 8b 00             	mov    (%rax),%rax
  81ce96:	0f b7 10             	movzwl (%rax),%edx
  81ce99:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ce9d:	66 89 50 2a          	mov    %dx,0x2a(%rax)
    npcb->state = SYN_RCVD;
  81cea1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cea5:	c7 40 18 03 00 00 00 	movl   $0x3,0x18(%rax)
    npcb->rcv_nxt = seqno + 1;
  81ceac:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81ceb3:	00 00 00 
  81ceb6:	8b 00                	mov    (%rax),%eax
  81ceb8:	8d 50 01             	lea    0x1(%rax),%edx
  81cebb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cebf:	89 50 30             	mov    %edx,0x30(%rax)
    npcb->snd_wnd = tcphdr->wnd;
  81cec2:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81cec9:	00 00 00 
  81cecc:	48 8b 00             	mov    (%rax),%rax
  81cecf:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81ced3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81ced7:	66 89 50 68          	mov    %dx,0x68(%rax)
    npcb->ssthresh = npcb->snd_wnd;
  81cedb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cedf:	0f b7 50 68          	movzwl 0x68(%rax),%edx
  81cee3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cee7:	66 89 50 5c          	mov    %dx,0x5c(%rax)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  81ceeb:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81cef2:	00 00 00 
  81cef5:	8b 00                	mov    (%rax),%eax
  81cef7:	8d 50 ff             	lea    -0x1(%rax),%edx
  81cefa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cefe:	89 50 6c             	mov    %edx,0x6c(%rax)
    npcb->callback_arg = pcb->callback_arg;
  81cf01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cf05:	48 8b 50 20          	mov    0x20(%rax),%rdx
  81cf09:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cf0d:	48 89 50 20          	mov    %rdx,0x20(%rax)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  81cf11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cf15:	48 8b 50 30          	mov    0x30(%rax),%rdx
  81cf19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cf1d:	48 89 90 b8 00 00 00 	mov    %rdx,0xb8(%rax)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  81cf24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81cf28:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81cf2c:	89 c2                	mov    %eax,%edx
  81cf2e:	66 81 e2 99 01       	and    $0x199,%dx
  81cf33:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cf37:	66 89 50 08          	mov    %dx,0x8(%rax)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  81cf3b:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81cf42:	00 00 00 
  81cf45:	48 8b 10             	mov    (%rax),%rdx
  81cf48:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cf4c:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81cf50:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81cf57:	00 00 00 
  81cf5a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81cf5e:	48 89 10             	mov    %rdx,(%rax)
  81cf61:	48 b8 d4 82 80 00 00 	movabs $0x8082d4,%rax
  81cf68:	00 00 00 
  81cf6b:	ff d0                	callq  *%rax

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  81cf6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cf71:	48 89 c7             	mov    %rax,%rdi
  81cf74:	48 b8 81 f8 81 00 00 	movabs $0x81f881,%rax
  81cf7b:	00 00 00 
  81cf7e:	ff d0                	callq  *%rax
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  81cf80:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cf84:	48 8d 50 04          	lea    0x4(%rax),%rdx
  81cf88:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cf8c:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81cf90:	0f b7 c0             	movzwl %ax,%eax
  81cf93:	48 89 d6             	mov    %rdx,%rsi
  81cf96:	89 c7                	mov    %eax,%edi
  81cf98:	48 b8 1d 09 81 00 00 	movabs $0x81091d,%rax
  81cf9f:	00 00 00 
  81cfa2:	ff d0                	callq  *%rax
  81cfa4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81cfa8:	66 89 42 40          	mov    %ax,0x40(%rdx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  81cfac:	bf b4 05 04 02       	mov    $0x20405b4,%edi
  81cfb1:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  81cfb8:	00 00 00 
  81cfbb:	ff d0                	callq  *%rax
  81cfbd:	89 45 f4             	mov    %eax,-0xc(%rbp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  81cfc0:	48 8d 55 f4          	lea    -0xc(%rbp),%rdx
  81cfc4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cfc8:	c7 04 24 04 00 00 00 	movl   $0x4,(%rsp)
  81cfcf:	49 89 d1             	mov    %rdx,%r9
  81cfd2:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  81cfd8:	b9 12 00 00 00       	mov    $0x12,%ecx
  81cfdd:	ba 00 00 00 00       	mov    $0x0,%edx
  81cfe2:	be 00 00 00 00       	mov    $0x0,%esi
  81cfe7:	48 89 c7             	mov    %rax,%rdi
  81cfea:	48 b8 fd 2d 81 00 00 	movabs $0x812dfd,%rax
  81cff1:	00 00 00 
  81cff4:	ff d0                	callq  *%rax
    return tcp_output(npcb);
  81cff6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81cffa:	48 89 c7             	mov    %rax,%rdi
  81cffd:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  81d004:	00 00 00 
  81d007:	ff d0                	callq  *%rax
  81d009:	eb 05                	jmp    81d010 <tcp_listen_input+0x2fe>
  }
  return ERR_OK;
  81d00b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81d010:	c9                   	leaveq 
  81d011:	c3                   	retq   

000000000081d012 <tcp_timewait_input>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  81d012:	55                   	push   %rbp
  81d013:	48 89 e5             	mov    %rsp,%rbp
  81d016:	48 83 ec 10          	sub    $0x10,%rsp
  81d01a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  81d01e:	48 b8 82 75 b5 00 00 	movabs $0xb57582,%rax
  81d025:	00 00 00 
  81d028:	0f b7 00             	movzwl (%rax),%eax
  81d02b:	0f b7 d0             	movzwl %ax,%edx
  81d02e:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81d035:	00 00 00 
  81d038:	8b 00                	mov    (%rax),%eax
  81d03a:	01 c2                	add    %eax,%edx
  81d03c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d040:	8b 40 30             	mov    0x30(%rax),%eax
  81d043:	89 d1                	mov    %edx,%ecx
  81d045:	29 c1                	sub    %eax,%ecx
  81d047:	89 c8                	mov    %ecx,%eax
  81d049:	85 c0                	test   %eax,%eax
  81d04b:	7e 25                	jle    81d072 <tcp_timewait_input+0x60>
    pcb->rcv_nxt = seqno + tcplen;
  81d04d:	48 b8 82 75 b5 00 00 	movabs $0xb57582,%rax
  81d054:	00 00 00 
  81d057:	0f b7 00             	movzwl (%rax),%eax
  81d05a:	0f b7 d0             	movzwl %ax,%edx
  81d05d:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81d064:	00 00 00 
  81d067:	8b 00                	mov    (%rax),%eax
  81d069:	01 c2                	add    %eax,%edx
  81d06b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d06f:	89 50 30             	mov    %edx,0x30(%rax)
  }
  if (tcplen > 0) {
  81d072:	48 b8 82 75 b5 00 00 	movabs $0xb57582,%rax
  81d079:	00 00 00 
  81d07c:	0f b7 00             	movzwl (%rax),%eax
  81d07f:	66 85 c0             	test   %ax,%ax
  81d082:	74 27                	je     81d0ab <tcp_timewait_input+0x99>
    tcp_ack_now(pcb);
  81d084:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d088:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d08c:	89 c2                	mov    %eax,%edx
  81d08e:	83 ca 02             	or     $0x2,%edx
  81d091:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d095:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d098:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d09c:	48 89 c7             	mov    %rax,%rdi
  81d09f:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  81d0a6:	00 00 00 
  81d0a9:	ff d0                	callq  *%rax
  }
  return tcp_output(pcb);
  81d0ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81d0af:	48 89 c7             	mov    %rax,%rdi
  81d0b2:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  81d0b9:	00 00 00 
  81d0bc:	ff d0                	callq  *%rax
}
  81d0be:	c9                   	leaveq 
  81d0bf:	c3                   	retq   

000000000081d0c0 <tcp_process>:
 * @note the segment which arrived is saved in global variables, therefore only the pcb
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
  81d0c0:	55                   	push   %rbp
  81d0c1:	48 89 e5             	mov    %rsp,%rbp
  81d0c4:	48 83 ec 30          	sub    $0x30,%rsp
  81d0c8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
  81d0cc:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
  err_t err;
  u8_t accepted_inseq;

  err = ERR_OK;
  81d0d0:	c6 45 fe 00          	movb   $0x0,-0x2(%rbp)

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  81d0d4:	48 b8 80 75 b5 00 00 	movabs $0xb57580,%rax
  81d0db:	00 00 00 
  81d0de:	0f b6 00             	movzbl (%rax),%eax
  81d0e1:	0f b6 c0             	movzbl %al,%eax
  81d0e4:	83 e0 04             	and    $0x4,%eax
  81d0e7:	85 c0                	test   %eax,%eax
  81d0e9:	0f 84 e4 00 00 00    	je     81d1d3 <tcp_process+0x113>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  81d0ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d0f3:	8b 40 18             	mov    0x18(%rax),%eax
  81d0f6:	83 f8 02             	cmp    $0x2,%eax
  81d0f9:	75 1d                	jne    81d118 <tcp_process+0x58>
      if (ackno == pcb->snd_nxt) {
  81d0fb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d0ff:	8b 50 60             	mov    0x60(%rax),%edx
  81d102:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81d109:	00 00 00 
  81d10c:	8b 00                	mov    (%rax),%eax
  81d10e:	39 c2                	cmp    %eax,%edx
  81d110:	75 51                	jne    81d163 <tcp_process+0xa3>
        acceptable = 1;
  81d112:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
  81d116:	eb 4b                	jmp    81d163 <tcp_process+0xa3>
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  81d118:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81d11f:	00 00 00 
  81d122:	8b 10                	mov    (%rax),%edx
  81d124:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d128:	8b 40 30             	mov    0x30(%rax),%eax
  81d12b:	89 d1                	mov    %edx,%ecx
  81d12d:	29 c1                	sub    %eax,%ecx
  81d12f:	89 c8                	mov    %ecx,%eax
  81d131:	85 c0                	test   %eax,%eax
  81d133:	78 2e                	js     81d163 <tcp_process+0xa3>
  81d135:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81d13c:	00 00 00 
  81d13f:	8b 10                	mov    (%rax),%edx
  81d141:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d145:	8b 48 30             	mov    0x30(%rax),%ecx
  81d148:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d14c:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81d150:	0f b7 c0             	movzwl %ax,%eax
  81d153:	01 c8                	add    %ecx,%eax
  81d155:	89 d1                	mov    %edx,%ecx
  81d157:	29 c1                	sub    %eax,%ecx
  81d159:	89 c8                	mov    %ecx,%eax
  81d15b:	85 c0                	test   %eax,%eax
  81d15d:	7f 04                	jg     81d163 <tcp_process+0xa3>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
  81d15f:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
      }
    }

    if (acceptable) {
  81d163:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  81d167:	74 60                	je     81d1c9 <tcp_process+0x109>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  81d169:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d16d:	8b 40 18             	mov    0x18(%rax),%eax
  81d170:	85 c0                	test   %eax,%eax
  81d172:	75 2a                	jne    81d19e <tcp_process+0xde>
  81d174:	48 ba e8 37 82 00 00 	movabs $0x8237e8,%rdx
  81d17b:	00 00 00 
  81d17e:	be 09 02 00 00       	mov    $0x209,%esi
  81d183:	48 bf e7 36 82 00 00 	movabs $0x8236e7,%rdi
  81d18a:	00 00 00 
  81d18d:	b8 00 00 00 00       	mov    $0x0,%eax
  81d192:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81d199:	00 00 00 
  81d19c:	ff d1                	callq  *%rcx
      recv_flags = TF_RESET;
  81d19e:	48 b8 84 75 b5 00 00 	movabs $0xb57584,%rax
  81d1a5:	00 00 00 
  81d1a8:	c6 00 08             	movb   $0x8,(%rax)
      pcb->flags &= ~TF_ACK_DELAY;
  81d1ab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d1af:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d1b3:	89 c2                	mov    %eax,%edx
  81d1b5:	83 e2 fe             	and    $0xfffffffe,%edx
  81d1b8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d1bc:	88 50 2c             	mov    %dl,0x2c(%rax)
      return ERR_RST;
  81d1bf:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  81d1c4:	e9 e7 0b 00 00       	jmpq   81ddb0 <tcp_process+0xcf0>
    } else {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
       seqno, pcb->rcv_nxt));
      return ERR_OK;
  81d1c9:	b8 00 00 00 00       	mov    $0x0,%eax
  81d1ce:	e9 dd 0b 00 00       	jmpq   81ddb0 <tcp_process+0xcf0>
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  81d1d3:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81d1da:	00 00 00 
  81d1dd:	8b 10                	mov    (%rax),%edx
  81d1df:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d1e3:	89 50 38             	mov    %edx,0x38(%rax)
  pcb->keep_cnt_sent = 0;
  81d1e6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d1ea:	c6 80 d9 00 00 00 00 	movb   $0x0,0xd9(%rax)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  81d1f1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d1f5:	8b 40 18             	mov    0x18(%rax),%eax
  81d1f8:	83 f8 09             	cmp    $0x9,%eax
  81d1fb:	0f 87 94 0b 00 00    	ja     81dd95 <tcp_process+0xcd5>
  81d201:	89 c0                	mov    %eax,%eax
  81d203:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  81d20a:	00 
  81d20b:	48 b8 38 38 82 00 00 	movabs $0x823838,%rax
  81d212:	00 00 00 
  81d215:	48 01 d0             	add    %rdx,%rax
  81d218:	48 8b 00             	mov    (%rax),%rax
  81d21b:	ff e0                	jmpq   *%rax
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  81d21d:	48 b8 80 75 b5 00 00 	movabs $0xb57580,%rax
  81d224:	00 00 00 
  81d227:	0f b6 00             	movzbl (%rax),%eax
  81d22a:	0f b6 c0             	movzbl %al,%eax
  81d22d:	83 e0 10             	and    $0x10,%eax
  81d230:	85 c0                	test   %eax,%eax
  81d232:	0f 84 5c 02 00 00    	je     81d494 <tcp_process+0x3d4>
  81d238:	48 b8 80 75 b5 00 00 	movabs $0xb57580,%rax
  81d23f:	00 00 00 
  81d242:	0f b6 00             	movzbl (%rax),%eax
  81d245:	0f b6 c0             	movzbl %al,%eax
  81d248:	83 e0 02             	and    $0x2,%eax
  81d24b:	85 c0                	test   %eax,%eax
  81d24d:	0f 84 41 02 00 00    	je     81d494 <tcp_process+0x3d4>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  81d253:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d257:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81d25e:	48 8b 40 20          	mov    0x20(%rax),%rax
  81d262:	8b 40 04             	mov    0x4(%rax),%eax
  81d265:	89 c7                	mov    %eax,%edi
  81d267:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81d26e:	00 00 00 
  81d271:	ff d0                	callq  *%rax
  81d273:	8d 50 01             	lea    0x1(%rax),%edx
  81d276:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81d27d:	00 00 00 
  81d280:	8b 00                	mov    (%rax),%eax
  81d282:	39 c2                	cmp    %eax,%edx
  81d284:	0f 85 0a 02 00 00    	jne    81d494 <tcp_process+0x3d4>
      pcb->snd_buf++;
  81d28a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d28e:	0f b7 40 7a          	movzwl 0x7a(%rax),%eax
  81d292:	8d 50 01             	lea    0x1(%rax),%edx
  81d295:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d299:	66 89 50 7a          	mov    %dx,0x7a(%rax)
      pcb->rcv_nxt = seqno + 1;
  81d29d:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81d2a4:	00 00 00 
  81d2a7:	8b 00                	mov    (%rax),%eax
  81d2a9:	8d 50 01             	lea    0x1(%rax),%edx
  81d2ac:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d2b0:	89 50 30             	mov    %edx,0x30(%rax)
      pcb->lastack = ackno;
  81d2b3:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81d2ba:	00 00 00 
  81d2bd:	8b 10                	mov    (%rax),%edx
  81d2bf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d2c3:	89 50 54             	mov    %edx,0x54(%rax)
      pcb->snd_wnd = tcphdr->wnd;
  81d2c6:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81d2cd:	00 00 00 
  81d2d0:	48 8b 00             	mov    (%rax),%rax
  81d2d3:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81d2d7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d2db:	66 89 50 68          	mov    %dx,0x68(%rax)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  81d2df:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81d2e6:	00 00 00 
  81d2e9:	8b 00                	mov    (%rax),%eax
  81d2eb:	8d 50 ff             	lea    -0x1(%rax),%edx
  81d2ee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d2f2:	89 50 6c             	mov    %edx,0x6c(%rax)
      pcb->state = ESTABLISHED;
  81d2f5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d2f9:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%rax)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  81d300:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d304:	48 89 c7             	mov    %rax,%rdi
  81d307:	48 b8 81 f8 81 00 00 	movabs $0x81f881,%rax
  81d30e:	00 00 00 
  81d311:	ff d0                	callq  *%rax
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  81d313:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d317:	48 8d 50 04          	lea    0x4(%rax),%rdx
  81d31b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d31f:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d323:	0f b7 c0             	movzwl %ax,%eax
  81d326:	48 89 d6             	mov    %rdx,%rsi
  81d329:	89 c7                	mov    %eax,%edi
  81d32b:	48 b8 1d 09 81 00 00 	movabs $0x81091d,%rax
  81d332:	00 00 00 
  81d335:	ff d0                	callq  *%rax
  81d337:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d33b:	66 89 42 40          	mov    %ax,0x40(%rdx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  81d33f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d343:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  81d347:	89 d0                	mov    %edx,%eax
  81d349:	c1 e0 02             	shl    $0x2,%eax
  81d34c:	01 d0                	add    %edx,%eax
  81d34e:	01 c0                	add    %eax,%eax
  81d350:	89 c2                	mov    %eax,%edx
  81d352:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d356:	66 89 50 5c          	mov    %dx,0x5c(%rax)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  81d35a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d35e:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81d362:	66 83 f8 01          	cmp    $0x1,%ax
  81d366:	75 0c                	jne    81d374 <tcp_process+0x2b4>
  81d368:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d36c:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d370:	01 c0                	add    %eax,%eax
  81d372:	eb 08                	jmp    81d37c <tcp_process+0x2bc>
  81d374:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d378:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d37c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d380:	66 89 42 5a          	mov    %ax,0x5a(%rdx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  81d384:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d388:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81d38c:	66 85 c0             	test   %ax,%ax
  81d38f:	75 2a                	jne    81d3bb <tcp_process+0x2fb>
  81d391:	48 ba 08 38 82 00 00 	movabs $0x823808,%rdx
  81d398:	00 00 00 
  81d39b:	be 35 02 00 00       	mov    $0x235,%esi
  81d3a0:	48 bf e7 36 82 00 00 	movabs $0x8236e7,%rdi
  81d3a7:	00 00 00 
  81d3aa:	b8 00 00 00 00       	mov    $0x0,%eax
  81d3af:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81d3b6:	00 00 00 
  81d3b9:	ff d1                	callq  *%rcx
      --pcb->snd_queuelen;
  81d3bb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d3bf:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81d3c3:	8d 50 ff             	lea    -0x1(%rax),%edx
  81d3c6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d3ca:	66 89 50 7c          	mov    %dx,0x7c(%rax)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  81d3ce:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d3d2:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81d3d9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
      pcb->unacked = rseg->next;
  81d3dd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81d3e1:	48 8b 10             	mov    (%rax),%rdx
  81d3e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d3e8:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  81d3ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d3f3:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81d3fa:	48 85 c0             	test   %rax,%rax
  81d3fd:	75 0c                	jne    81d40b <tcp_process+0x34b>
        pcb->rtime = -1;
  81d3ff:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d403:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
  81d409:	eb 12                	jmp    81d41d <tcp_process+0x35d>
      else {
        pcb->rtime = 0;
  81d40b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d40f:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)
        pcb->nrtx = 0;
  81d415:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d419:	c6 40 52 00          	movb   $0x0,0x52(%rax)
      }

      tcp_seg_free(rseg);
  81d41d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81d421:	48 89 c7             	mov    %rax,%rdi
  81d424:	48 b8 b3 00 81 00 00 	movabs $0x8100b3,%rax
  81d42b:	00 00 00 
  81d42e:	ff d0                	callq  *%rax

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  81d430:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d434:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  81d43b:	48 85 c0             	test   %rax,%rax
  81d43e:	74 28                	je     81d468 <tcp_process+0x3a8>
  81d440:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d444:	4c 8b 80 b0 00 00 00 	mov    0xb0(%rax),%r8
  81d44b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d44f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81d453:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  81d457:	ba 00 00 00 00       	mov    $0x0,%edx
  81d45c:	48 89 ce             	mov    %rcx,%rsi
  81d45f:	48 89 c7             	mov    %rax,%rdi
  81d462:	41 ff d0             	callq  *%r8
  81d465:	88 45 fe             	mov    %al,-0x2(%rbp)
      tcp_ack_now(pcb);
  81d468:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d46c:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d470:	89 c2                	mov    %eax,%edx
  81d472:	83 ca 02             	or     $0x2,%edx
  81d475:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d479:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d47c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d480:	48 89 c7             	mov    %rax,%rdi
  81d483:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  81d48a:	00 00 00 
  81d48d:	ff d0                	callq  *%rax
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
  81d48f:	e9 04 09 00 00       	jmpq   81dd98 <tcp_process+0xcd8>
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  81d494:	48 b8 80 75 b5 00 00 	movabs $0xb57580,%rax
  81d49b:	00 00 00 
  81d49e:	0f b6 00             	movzbl (%rax),%eax
  81d4a1:	0f b6 c0             	movzbl %al,%eax
  81d4a4:	83 e0 10             	and    $0x10,%eax
  81d4a7:	85 c0                	test   %eax,%eax
  81d4a9:	0f 84 e9 08 00 00    	je     81dd98 <tcp_process+0xcd8>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81d4af:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81d4b6:	00 00 00 
  81d4b9:	48 8b 00             	mov    (%rax),%rax
  81d4bc:	0f b7 00             	movzwl (%rax),%eax
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81d4bf:	44 0f b7 c0          	movzwl %ax,%r8d
        tcphdr->dest, tcphdr->src);
  81d4c3:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81d4ca:	00 00 00 
  81d4cd:	48 8b 00             	mov    (%rax),%rax
  81d4d0:	0f b7 40 02          	movzwl 0x2(%rax),%eax
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81d4d4:	0f b7 f8             	movzwl %ax,%edi
  81d4d7:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81d4de:	00 00 00 
  81d4e1:	48 8b 00             	mov    (%rax),%rax
  81d4e4:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  81d4e8:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81d4ef:	00 00 00 
  81d4f2:	48 8b 00             	mov    (%rax),%rax
  81d4f5:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81d4f9:	48 b8 82 75 b5 00 00 	movabs $0xb57582,%rax
  81d500:	00 00 00 
  81d503:	0f b7 00             	movzwl (%rax),%eax
  81d506:	0f b7 f0             	movzwl %ax,%esi
  81d509:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81d510:	00 00 00 
  81d513:	8b 00                	mov    (%rax),%eax
  81d515:	01 c6                	add    %eax,%esi
  81d517:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81d51e:	00 00 00 
  81d521:	8b 00                	mov    (%rax),%eax
  81d523:	45 89 c1             	mov    %r8d,%r9d
  81d526:	41 89 f8             	mov    %edi,%r8d
  81d529:	89 c7                	mov    %eax,%edi
  81d52b:	48 b8 d9 41 81 00 00 	movabs $0x8141d9,%rax
  81d532:	00 00 00 
  81d535:	ff d0                	callq  *%rax
        tcphdr->dest, tcphdr->src);
    }
    break;
  81d537:	e9 5c 08 00 00       	jmpq   81dd98 <tcp_process+0xcd8>
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  81d53c:	48 b8 80 75 b5 00 00 	movabs $0xb57580,%rax
  81d543:	00 00 00 
  81d546:	0f b6 00             	movzbl (%rax),%eax
  81d549:	0f b6 c0             	movzbl %al,%eax
  81d54c:	83 e0 10             	and    $0x10,%eax
  81d54f:	85 c0                	test   %eax,%eax
  81d551:	0f 84 44 08 00 00    	je     81dd9b <tcp_process+0xcdb>
       !(flags & TCP_RST)) {
  81d557:	48 b8 80 75 b5 00 00 	movabs $0xb57580,%rax
  81d55e:	00 00 00 
  81d561:	0f b6 00             	movzbl (%rax),%eax
  81d564:	0f b6 c0             	movzbl %al,%eax
  81d567:	83 e0 04             	and    $0x4,%eax
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  81d56a:	85 c0                	test   %eax,%eax
  81d56c:	0f 85 29 08 00 00    	jne    81dd9b <tcp_process+0xcdb>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  81d572:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d576:	8b 40 54             	mov    0x54(%rax),%eax
  81d579:	89 c2                	mov    %eax,%edx
  81d57b:	f7 d2                	not    %edx
  81d57d:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81d584:	00 00 00 
  81d587:	8b 00                	mov    (%rax),%eax
  81d589:	01 d0                	add    %edx,%eax
  81d58b:	85 c0                	test   %eax,%eax
  81d58d:	0f 88 62 01 00 00    	js     81d6f5 <tcp_process+0x635>
  81d593:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81d59a:	00 00 00 
  81d59d:	8b 10                	mov    (%rax),%edx
  81d59f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d5a3:	8b 40 60             	mov    0x60(%rax),%eax
  81d5a6:	89 d1                	mov    %edx,%ecx
  81d5a8:	29 c1                	sub    %eax,%ecx
  81d5aa:	89 c8                	mov    %ecx,%eax
  81d5ac:	85 c0                	test   %eax,%eax
  81d5ae:	0f 8f 41 01 00 00    	jg     81d6f5 <tcp_process+0x635>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  81d5b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d5b8:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%rax)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  81d5bf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d5c3:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
  81d5ca:	48 85 c0             	test   %rax,%rax
  81d5cd:	75 2a                	jne    81d5f9 <tcp_process+0x539>
  81d5cf:	48 ba 1e 38 82 00 00 	movabs $0x82381e,%rdx
  81d5d6:	00 00 00 
  81d5d9:	be 5b 02 00 00       	mov    $0x25b,%esi
  81d5de:	48 bf e7 36 82 00 00 	movabs $0x8236e7,%rdi
  81d5e5:	00 00 00 
  81d5e8:	b8 00 00 00 00       	mov    $0x0,%eax
  81d5ed:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81d5f4:	00 00 00 
  81d5f7:	ff d1                	callq  *%rcx
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  81d5f9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d5fd:	48 8b 80 b8 00 00 00 	mov    0xb8(%rax),%rax
  81d604:	48 85 c0             	test   %rax,%rax
  81d607:	74 28                	je     81d631 <tcp_process+0x571>
  81d609:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d60d:	4c 8b 80 b8 00 00 00 	mov    0xb8(%rax),%r8
  81d614:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d618:	48 8b 40 20          	mov    0x20(%rax),%rax
  81d61c:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  81d620:	ba 00 00 00 00       	mov    $0x0,%edx
  81d625:	48 89 ce             	mov    %rcx,%rsi
  81d628:	48 89 c7             	mov    %rax,%rdi
  81d62b:	41 ff d0             	callq  *%r8
  81d62e:	88 45 fe             	mov    %al,-0x2(%rbp)
        if (err != ERR_OK) {
  81d631:	80 7d fe 00          	cmpb   $0x0,-0x2(%rbp)
  81d635:	74 1d                	je     81d654 <tcp_process+0x594>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  81d637:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d63b:	48 89 c7             	mov    %rax,%rdi
  81d63e:	48 b8 11 eb 80 00 00 	movabs $0x80eb11,%rax
  81d645:	00 00 00 
  81d648:	ff d0                	callq  *%rax
          return ERR_ABRT;
  81d64a:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  81d64f:	e9 5c 07 00 00       	jmpq   81ddb0 <tcp_process+0xcf0>
        }
        old_cwnd = pcb->cwnd;
  81d654:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d658:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81d65c:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  81d660:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d664:	48 89 c7             	mov    %rax,%rdi
  81d667:	48 b8 b2 dd 81 00 00 	movabs $0x81ddb2,%rax
  81d66e:	00 00 00 
  81d671:	ff d0                	callq  *%rax
  81d673:	88 45 ed             	mov    %al,-0x13(%rbp)

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  81d676:	66 83 7d ee 01       	cmpw   $0x1,-0x12(%rbp)
  81d67b:	75 0c                	jne    81d689 <tcp_process+0x5c9>
  81d67d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d681:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d685:	01 c0                	add    %eax,%eax
  81d687:	eb 08                	jmp    81d691 <tcp_process+0x5d1>
  81d689:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d68d:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81d691:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d695:	66 89 42 5a          	mov    %ax,0x5a(%rdx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  81d699:	48 b8 80 75 b5 00 00 	movabs $0xb57580,%rax
  81d6a0:	00 00 00 
  81d6a3:	0f b6 00             	movzbl (%rax),%eax
  81d6a6:	0f b6 c0             	movzbl %al,%eax
  81d6a9:	83 e0 01             	and    $0x1,%eax
  81d6ac:	84 c0                	test   %al,%al
  81d6ae:	0f 84 ce 00 00 00    	je     81d782 <tcp_process+0x6c2>
  81d6b4:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81d6b8:	0f 84 c4 00 00 00    	je     81d782 <tcp_process+0x6c2>
          tcp_ack_now(pcb);
  81d6be:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d6c2:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d6c6:	89 c2                	mov    %eax,%edx
  81d6c8:	83 ca 02             	or     $0x2,%edx
  81d6cb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d6cf:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d6d2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d6d6:	48 89 c7             	mov    %rax,%rdi
  81d6d9:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  81d6e0:	00 00 00 
  81d6e3:	ff d0                	callq  *%rax
          pcb->state = CLOSE_WAIT;
  81d6e5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d6e9:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  81d6f0:	e9 8d 00 00 00       	jmpq   81d782 <tcp_process+0x6c2>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  81d6f5:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81d6fc:	00 00 00 
  81d6ff:	48 8b 00             	mov    (%rax),%rax
  81d702:	0f b7 00             	movzwl (%rax),%eax
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81d705:	44 0f b7 c0          	movzwl %ax,%r8d
                tcphdr->dest, tcphdr->src);
  81d709:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81d710:	00 00 00 
  81d713:	48 8b 00             	mov    (%rax),%rax
  81d716:	0f b7 40 02          	movzwl 0x2(%rax),%eax
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  81d71a:	0f b7 f8             	movzwl %ax,%edi
  81d71d:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81d724:	00 00 00 
  81d727:	48 8b 00             	mov    (%rax),%rax
  81d72a:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  81d72e:	48 b8 70 75 b5 00 00 	movabs $0xb57570,%rax
  81d735:	00 00 00 
  81d738:	48 8b 00             	mov    (%rax),%rax
  81d73b:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81d73f:	48 b8 82 75 b5 00 00 	movabs $0xb57582,%rax
  81d746:	00 00 00 
  81d749:	0f b7 00             	movzwl (%rax),%eax
  81d74c:	0f b7 f0             	movzwl %ax,%esi
  81d74f:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81d756:	00 00 00 
  81d759:	8b 00                	mov    (%rax),%eax
  81d75b:	01 c6                	add    %eax,%esi
  81d75d:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81d764:	00 00 00 
  81d767:	8b 00                	mov    (%rax),%eax
  81d769:	45 89 c1             	mov    %r8d,%r9d
  81d76c:	41 89 f8             	mov    %edi,%r8d
  81d76f:	89 c7                	mov    %eax,%edi
  81d771:	48 b8 d9 41 81 00 00 	movabs $0x8141d9,%rax
  81d778:	00 00 00 
  81d77b:	ff d0                	callq  *%rax
                tcphdr->dest, tcphdr->src);
      }
    }
    break;
  81d77d:	e9 19 06 00 00       	jmpq   81dd9b <tcp_process+0xcdb>
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  81d782:	90                   	nop
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
      }
    }
    break;
  81d783:	e9 13 06 00 00       	jmpq   81dd9b <tcp_process+0xcdb>
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  81d788:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d78c:	48 89 c7             	mov    %rax,%rdi
  81d78f:	48 b8 b2 dd 81 00 00 	movabs $0x81ddb2,%rax
  81d796:	00 00 00 
  81d799:	ff d0                	callq  *%rax
  81d79b:	88 45 ed             	mov    %al,-0x13(%rbp)
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  81d79e:	48 b8 80 75 b5 00 00 	movabs $0xb57580,%rax
  81d7a5:	00 00 00 
  81d7a8:	0f b6 00             	movzbl (%rax),%eax
  81d7ab:	0f b6 c0             	movzbl %al,%eax
  81d7ae:	83 e0 01             	and    $0x1,%eax
  81d7b1:	84 c0                	test   %al,%al
  81d7b3:	0f 84 e5 05 00 00    	je     81dd9e <tcp_process+0xcde>
  81d7b9:	80 7d ed 00          	cmpb   $0x0,-0x13(%rbp)
  81d7bd:	0f 84 db 05 00 00    	je     81dd9e <tcp_process+0xcde>
      tcp_ack_now(pcb);
  81d7c3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d7c7:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d7cb:	89 c2                	mov    %eax,%edx
  81d7cd:	83 ca 02             	or     $0x2,%edx
  81d7d0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d7d4:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d7d7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d7db:	48 89 c7             	mov    %rax,%rdi
  81d7de:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  81d7e5:	00 00 00 
  81d7e8:	ff d0                	callq  *%rax
      pcb->state = CLOSE_WAIT;
  81d7ea:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d7ee:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
    }
    break;
  81d7f5:	e9 a4 05 00 00       	jmpq   81dd9e <tcp_process+0xcde>
  case FIN_WAIT_1:
    tcp_receive(pcb);
  81d7fa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d7fe:	48 89 c7             	mov    %rax,%rdi
  81d801:	48 b8 b2 dd 81 00 00 	movabs $0x81ddb2,%rax
  81d808:	00 00 00 
  81d80b:	ff d0                	callq  *%rax
    if (flags & TCP_FIN) {
  81d80d:	48 b8 80 75 b5 00 00 	movabs $0xb57580,%rax
  81d814:	00 00 00 
  81d817:	0f b6 00             	movzbl (%rax),%eax
  81d81a:	0f b6 c0             	movzbl %al,%eax
  81d81d:	83 e0 01             	and    $0x1,%eax
  81d820:	84 c0                	test   %al,%al
  81d822:	0f 84 bf 01 00 00    	je     81d9e7 <tcp_process+0x927>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81d828:	48 b8 80 75 b5 00 00 	movabs $0xb57580,%rax
  81d82f:	00 00 00 
  81d832:	0f b6 00             	movzbl (%rax),%eax
  81d835:	0f b6 c0             	movzbl %al,%eax
  81d838:	83 e0 10             	and    $0x10,%eax
  81d83b:	85 c0                	test   %eax,%eax
  81d83d:	0f 84 6d 01 00 00    	je     81d9b0 <tcp_process+0x8f0>
  81d843:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d847:	8b 50 60             	mov    0x60(%rax),%edx
  81d84a:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81d851:	00 00 00 
  81d854:	8b 00                	mov    (%rax),%eax
  81d856:	39 c2                	cmp    %eax,%edx
  81d858:	0f 85 52 01 00 00    	jne    81d9b0 <tcp_process+0x8f0>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  81d85e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d862:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d866:	89 c2                	mov    %eax,%edx
  81d868:	83 ca 02             	or     $0x2,%edx
  81d86b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d86f:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d872:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d876:	48 89 c7             	mov    %rax,%rdi
  81d879:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  81d880:	00 00 00 
  81d883:	ff d0                	callq  *%rax
        tcp_pcb_purge(pcb);
  81d885:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d889:	48 89 c7             	mov    %rax,%rdi
  81d88c:	48 b8 e6 05 81 00 00 	movabs $0x8105e6,%rax
  81d893:	00 00 00 
  81d896:	ff d0                	callq  *%rax
        TCP_RMV(&tcp_active_pcbs, pcb);
  81d898:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d89f:	00 00 00 
  81d8a2:	48 8b 00             	mov    (%rax),%rax
  81d8a5:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81d8a9:	75 23                	jne    81d8ce <tcp_process+0x80e>
  81d8ab:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d8b2:	00 00 00 
  81d8b5:	48 8b 00             	mov    (%rax),%rax
  81d8b8:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81d8bc:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d8c3:	00 00 00 
  81d8c6:	48 89 10             	mov    %rdx,(%rax)
  81d8c9:	e9 94 00 00 00       	jmpq   81d962 <tcp_process+0x8a2>
  81d8ce:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81d8d5:	00 00 00 
  81d8d8:	48 8b 10             	mov    (%rax),%rdx
  81d8db:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d8e2:	00 00 00 
  81d8e5:	48 89 10             	mov    %rdx,(%rax)
  81d8e8:	eb 66                	jmp    81d950 <tcp_process+0x890>
  81d8ea:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d8f1:	00 00 00 
  81d8f4:	48 8b 00             	mov    (%rax),%rax
  81d8f7:	48 8b 40 10          	mov    0x10(%rax),%rax
  81d8fb:	48 85 c0             	test   %rax,%rax
  81d8fe:	74 32                	je     81d932 <tcp_process+0x872>
  81d900:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d907:	00 00 00 
  81d90a:	48 8b 00             	mov    (%rax),%rax
  81d90d:	48 8b 40 10          	mov    0x10(%rax),%rax
  81d911:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81d915:	75 1b                	jne    81d932 <tcp_process+0x872>
  81d917:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d91e:	00 00 00 
  81d921:	48 8b 00             	mov    (%rax),%rax
  81d924:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d928:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81d92c:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81d930:	eb 30                	jmp    81d962 <tcp_process+0x8a2>
  81d932:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d939:	00 00 00 
  81d93c:	48 8b 00             	mov    (%rax),%rax
  81d93f:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81d943:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d94a:	00 00 00 
  81d94d:	48 89 10             	mov    %rdx,(%rax)
  81d950:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81d957:	00 00 00 
  81d95a:	48 8b 00             	mov    (%rax),%rax
  81d95d:	48 85 c0             	test   %rax,%rax
  81d960:	75 88                	jne    81d8ea <tcp_process+0x82a>
  81d962:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d966:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81d96d:	00 
        pcb->state = TIME_WAIT;
  81d96e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d972:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
        TCP_REG(&tcp_tw_pcbs, pcb);
  81d979:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81d980:	00 00 00 
  81d983:	48 8b 10             	mov    (%rax),%rdx
  81d986:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d98a:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81d98e:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81d995:	00 00 00 
  81d998:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81d99c:	48 89 10             	mov    %rdx,(%rax)
  81d99f:	48 b8 d4 82 80 00 00 	movabs $0x8082d4,%rax
  81d9a6:	00 00 00 
  81d9a9:	ff d0                	callq  *%rax
        pcb->state = CLOSING;
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      pcb->state = FIN_WAIT_2;
    }
    break;
  81d9ab:	e9 f1 03 00 00       	jmpq   81dda1 <tcp_process+0xce1>
        tcp_pcb_purge(pcb);
        TCP_RMV(&tcp_active_pcbs, pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
  81d9b0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d9b4:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81d9b8:	89 c2                	mov    %eax,%edx
  81d9ba:	83 ca 02             	or     $0x2,%edx
  81d9bd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d9c1:	88 50 2c             	mov    %dl,0x2c(%rax)
  81d9c4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d9c8:	48 89 c7             	mov    %rax,%rdi
  81d9cb:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  81d9d2:	00 00 00 
  81d9d5:	ff d0                	callq  *%rax
        pcb->state = CLOSING;
  81d9d7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81d9db:	c7 40 18 08 00 00 00 	movl   $0x8,0x18(%rax)
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      pcb->state = FIN_WAIT_2;
    }
    break;
  81d9e2:	e9 ba 03 00 00       	jmpq   81dda1 <tcp_process+0xce1>
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
        pcb->state = CLOSING;
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81d9e7:	48 b8 80 75 b5 00 00 	movabs $0xb57580,%rax
  81d9ee:	00 00 00 
  81d9f1:	0f b6 00             	movzbl (%rax),%eax
  81d9f4:	0f b6 c0             	movzbl %al,%eax
  81d9f7:	83 e0 10             	and    $0x10,%eax
  81d9fa:	85 c0                	test   %eax,%eax
  81d9fc:	0f 84 9f 03 00 00    	je     81dda1 <tcp_process+0xce1>
  81da02:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da06:	8b 50 60             	mov    0x60(%rax),%edx
  81da09:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81da10:	00 00 00 
  81da13:	8b 00                	mov    (%rax),%eax
  81da15:	39 c2                	cmp    %eax,%edx
  81da17:	0f 85 84 03 00 00    	jne    81dda1 <tcp_process+0xce1>
      pcb->state = FIN_WAIT_2;
  81da1d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da21:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%rax)
    }
    break;
  81da28:	e9 74 03 00 00       	jmpq   81dda1 <tcp_process+0xce1>
  case FIN_WAIT_2:
    tcp_receive(pcb);
  81da2d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da31:	48 89 c7             	mov    %rax,%rdi
  81da34:	48 b8 b2 dd 81 00 00 	movabs $0x81ddb2,%rax
  81da3b:	00 00 00 
  81da3e:	ff d0                	callq  *%rax
    if (flags & TCP_FIN) {
  81da40:	48 b8 80 75 b5 00 00 	movabs $0xb57580,%rax
  81da47:	00 00 00 
  81da4a:	0f b6 00             	movzbl (%rax),%eax
  81da4d:	0f b6 c0             	movzbl %al,%eax
  81da50:	83 e0 01             	and    $0x1,%eax
  81da53:	84 c0                	test   %al,%al
  81da55:	0f 84 49 03 00 00    	je     81dda4 <tcp_process+0xce4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  81da5b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da5f:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81da63:	89 c2                	mov    %eax,%edx
  81da65:	83 ca 02             	or     $0x2,%edx
  81da68:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da6c:	88 50 2c             	mov    %dl,0x2c(%rax)
  81da6f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da73:	48 89 c7             	mov    %rax,%rdi
  81da76:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  81da7d:	00 00 00 
  81da80:	ff d0                	callq  *%rax
      tcp_pcb_purge(pcb);
  81da82:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81da86:	48 89 c7             	mov    %rax,%rdi
  81da89:	48 b8 e6 05 81 00 00 	movabs $0x8105e6,%rax
  81da90:	00 00 00 
  81da93:	ff d0                	callq  *%rax
      TCP_RMV(&tcp_active_pcbs, pcb);
  81da95:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81da9c:	00 00 00 
  81da9f:	48 8b 00             	mov    (%rax),%rax
  81daa2:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81daa6:	75 23                	jne    81dacb <tcp_process+0xa0b>
  81daa8:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81daaf:	00 00 00 
  81dab2:	48 8b 00             	mov    (%rax),%rax
  81dab5:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81dab9:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81dac0:	00 00 00 
  81dac3:	48 89 10             	mov    %rdx,(%rax)
  81dac6:	e9 94 00 00 00       	jmpq   81db5f <tcp_process+0xa9f>
  81dacb:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81dad2:	00 00 00 
  81dad5:	48 8b 10             	mov    (%rax),%rdx
  81dad8:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dadf:	00 00 00 
  81dae2:	48 89 10             	mov    %rdx,(%rax)
  81dae5:	eb 66                	jmp    81db4d <tcp_process+0xa8d>
  81dae7:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81daee:	00 00 00 
  81daf1:	48 8b 00             	mov    (%rax),%rax
  81daf4:	48 8b 40 10          	mov    0x10(%rax),%rax
  81daf8:	48 85 c0             	test   %rax,%rax
  81dafb:	74 32                	je     81db2f <tcp_process+0xa6f>
  81dafd:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81db04:	00 00 00 
  81db07:	48 8b 00             	mov    (%rax),%rax
  81db0a:	48 8b 40 10          	mov    0x10(%rax),%rax
  81db0e:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81db12:	75 1b                	jne    81db2f <tcp_process+0xa6f>
  81db14:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81db1b:	00 00 00 
  81db1e:	48 8b 00             	mov    (%rax),%rax
  81db21:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81db25:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81db29:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81db2d:	eb 30                	jmp    81db5f <tcp_process+0xa9f>
  81db2f:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81db36:	00 00 00 
  81db39:	48 8b 00             	mov    (%rax),%rax
  81db3c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81db40:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81db47:	00 00 00 
  81db4a:	48 89 10             	mov    %rdx,(%rax)
  81db4d:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81db54:	00 00 00 
  81db57:	48 8b 00             	mov    (%rax),%rax
  81db5a:	48 85 c0             	test   %rax,%rax
  81db5d:	75 88                	jne    81dae7 <tcp_process+0xa27>
  81db5f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81db63:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81db6a:	00 
      pcb->state = TIME_WAIT;
  81db6b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81db6f:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
      TCP_REG(&tcp_tw_pcbs, pcb);
  81db76:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81db7d:	00 00 00 
  81db80:	48 8b 10             	mov    (%rax),%rdx
  81db83:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81db87:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81db8b:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81db92:	00 00 00 
  81db95:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81db99:	48 89 10             	mov    %rdx,(%rax)
  81db9c:	48 b8 d4 82 80 00 00 	movabs $0x8082d4,%rax
  81dba3:	00 00 00 
  81dba6:	ff d0                	callq  *%rax
    }
    break;
  81dba8:	e9 f7 01 00 00       	jmpq   81dda4 <tcp_process+0xce4>
  case CLOSING:
    tcp_receive(pcb);
  81dbad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dbb1:	48 89 c7             	mov    %rax,%rdi
  81dbb4:	48 b8 b2 dd 81 00 00 	movabs $0x81ddb2,%rax
  81dbbb:	00 00 00 
  81dbbe:	ff d0                	callq  *%rax
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81dbc0:	48 b8 80 75 b5 00 00 	movabs $0xb57580,%rax
  81dbc7:	00 00 00 
  81dbca:	0f b6 00             	movzbl (%rax),%eax
  81dbcd:	0f b6 c0             	movzbl %al,%eax
  81dbd0:	83 e0 10             	and    $0x10,%eax
  81dbd3:	85 c0                	test   %eax,%eax
  81dbd5:	0f 84 cc 01 00 00    	je     81dda7 <tcp_process+0xce7>
  81dbdb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dbdf:	8b 50 60             	mov    0x60(%rax),%edx
  81dbe2:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81dbe9:	00 00 00 
  81dbec:	8b 00                	mov    (%rax),%eax
  81dbee:	39 c2                	cmp    %eax,%edx
  81dbf0:	0f 85 b1 01 00 00    	jne    81dda7 <tcp_process+0xce7>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  81dbf6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dbfa:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81dbfe:	89 c2                	mov    %eax,%edx
  81dc00:	83 ca 02             	or     $0x2,%edx
  81dc03:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dc07:	88 50 2c             	mov    %dl,0x2c(%rax)
  81dc0a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dc0e:	48 89 c7             	mov    %rax,%rdi
  81dc11:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  81dc18:	00 00 00 
  81dc1b:	ff d0                	callq  *%rax
      tcp_pcb_purge(pcb);
  81dc1d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dc21:	48 89 c7             	mov    %rax,%rdi
  81dc24:	48 b8 e6 05 81 00 00 	movabs $0x8105e6,%rax
  81dc2b:	00 00 00 
  81dc2e:	ff d0                	callq  *%rax
      TCP_RMV(&tcp_active_pcbs, pcb);
  81dc30:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81dc37:	00 00 00 
  81dc3a:	48 8b 00             	mov    (%rax),%rax
  81dc3d:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81dc41:	75 23                	jne    81dc66 <tcp_process+0xba6>
  81dc43:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81dc4a:	00 00 00 
  81dc4d:	48 8b 00             	mov    (%rax),%rax
  81dc50:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81dc54:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81dc5b:	00 00 00 
  81dc5e:	48 89 10             	mov    %rdx,(%rax)
  81dc61:	e9 94 00 00 00       	jmpq   81dcfa <tcp_process+0xc3a>
  81dc66:	48 b8 18 b0 b5 00 00 	movabs $0xb5b018,%rax
  81dc6d:	00 00 00 
  81dc70:	48 8b 10             	mov    (%rax),%rdx
  81dc73:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dc7a:	00 00 00 
  81dc7d:	48 89 10             	mov    %rdx,(%rax)
  81dc80:	eb 66                	jmp    81dce8 <tcp_process+0xc28>
  81dc82:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dc89:	00 00 00 
  81dc8c:	48 8b 00             	mov    (%rax),%rax
  81dc8f:	48 8b 40 10          	mov    0x10(%rax),%rax
  81dc93:	48 85 c0             	test   %rax,%rax
  81dc96:	74 32                	je     81dcca <tcp_process+0xc0a>
  81dc98:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dc9f:	00 00 00 
  81dca2:	48 8b 00             	mov    (%rax),%rax
  81dca5:	48 8b 40 10          	mov    0x10(%rax),%rax
  81dca9:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  81dcad:	75 1b                	jne    81dcca <tcp_process+0xc0a>
  81dcaf:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dcb6:	00 00 00 
  81dcb9:	48 8b 00             	mov    (%rax),%rax
  81dcbc:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81dcc0:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  81dcc4:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81dcc8:	eb 30                	jmp    81dcfa <tcp_process+0xc3a>
  81dcca:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dcd1:	00 00 00 
  81dcd4:	48 8b 00             	mov    (%rax),%rax
  81dcd7:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81dcdb:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dce2:	00 00 00 
  81dce5:	48 89 10             	mov    %rdx,(%rax)
  81dce8:	48 b8 30 b0 b5 00 00 	movabs $0xb5b030,%rax
  81dcef:	00 00 00 
  81dcf2:	48 8b 00             	mov    (%rax),%rax
  81dcf5:	48 85 c0             	test   %rax,%rax
  81dcf8:	75 88                	jne    81dc82 <tcp_process+0xbc2>
  81dcfa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dcfe:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  81dd05:	00 
      pcb->state = TIME_WAIT;
  81dd06:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dd0a:	c7 40 18 0a 00 00 00 	movl   $0xa,0x18(%rax)
      TCP_REG(&tcp_tw_pcbs, pcb);
  81dd11:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81dd18:	00 00 00 
  81dd1b:	48 8b 10             	mov    (%rax),%rdx
  81dd1e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dd22:	48 89 50 10          	mov    %rdx,0x10(%rax)
  81dd26:	48 b8 40 b0 b5 00 00 	movabs $0xb5b040,%rax
  81dd2d:	00 00 00 
  81dd30:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81dd34:	48 89 10             	mov    %rdx,(%rax)
  81dd37:	48 b8 d4 82 80 00 00 	movabs $0x8082d4,%rax
  81dd3e:	00 00 00 
  81dd41:	ff d0                	callq  *%rax
    }
    break;
  81dd43:	eb 62                	jmp    81dda7 <tcp_process+0xce7>
  case LAST_ACK:
    tcp_receive(pcb);
  81dd45:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dd49:	48 89 c7             	mov    %rax,%rdi
  81dd4c:	48 b8 b2 dd 81 00 00 	movabs $0x81ddb2,%rax
  81dd53:	00 00 00 
  81dd56:	ff d0                	callq  *%rax
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81dd58:	48 b8 80 75 b5 00 00 	movabs $0xb57580,%rax
  81dd5f:	00 00 00 
  81dd62:	0f b6 00             	movzbl (%rax),%eax
  81dd65:	0f b6 c0             	movzbl %al,%eax
  81dd68:	83 e0 10             	and    $0x10,%eax
  81dd6b:	85 c0                	test   %eax,%eax
  81dd6d:	74 3b                	je     81ddaa <tcp_process+0xcea>
  81dd6f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81dd73:	8b 50 60             	mov    0x60(%rax),%edx
  81dd76:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81dd7d:	00 00 00 
  81dd80:	8b 00                	mov    (%rax),%eax
  81dd82:	39 c2                	cmp    %eax,%edx
  81dd84:	75 24                	jne    81ddaa <tcp_process+0xcea>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  81dd86:	48 b8 84 75 b5 00 00 	movabs $0xb57584,%rax
  81dd8d:	00 00 00 
  81dd90:	c6 00 10             	movb   $0x10,(%rax)
    }
    break;
  81dd93:	eb 15                	jmp    81ddaa <tcp_process+0xcea>
  default:
    break;
  81dd95:	90                   	nop
  81dd96:	eb 13                	jmp    81ddab <tcp_process+0xceb>
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    break;
  81dd98:	90                   	nop
  81dd99:	eb 10                	jmp    81ddab <tcp_process+0xceb>
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
      }
    }
    break;
  81dd9b:	90                   	nop
  81dd9c:	eb 0d                	jmp    81ddab <tcp_process+0xceb>
    accepted_inseq = tcp_receive(pcb);
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
      tcp_ack_now(pcb);
      pcb->state = CLOSE_WAIT;
    }
    break;
  81dd9e:	90                   	nop
  81dd9f:	eb 0a                	jmp    81ddab <tcp_process+0xceb>
        pcb->state = CLOSING;
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      pcb->state = FIN_WAIT_2;
    }
    break;
  81dda1:	90                   	nop
  81dda2:	eb 07                	jmp    81ddab <tcp_process+0xceb>
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
  81dda4:	90                   	nop
  81dda5:	eb 04                	jmp    81ddab <tcp_process+0xceb>
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
  81dda7:	90                   	nop
  81dda8:	eb 01                	jmp    81ddab <tcp_process+0xceb>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
    }
    break;
  81ddaa:	90                   	nop
  default:
    break;
  }
  return ERR_OK;
  81ddab:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81ddb0:	c9                   	leaveq 
  81ddb1:	c3                   	retq   

000000000081ddb2 <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  81ddb2:	55                   	push   %rbp
  81ddb3:	48 89 e5             	mov    %rsp,%rbp
  81ddb6:	41 55                	push   %r13
  81ddb8:	41 54                	push   %r12
  81ddba:	53                   	push   %rbx
  81ddbb:	48 83 ec 58          	sub    $0x58,%rsp
  81ddbf:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  81ddc3:	c6 45 c1 00          	movb   $0x0,-0x3f(%rbp)

  if (flags & TCP_ACK) {
  81ddc7:	48 b8 80 75 b5 00 00 	movabs $0xb57580,%rax
  81ddce:	00 00 00 
  81ddd1:	0f b6 00             	movzbl (%rax),%eax
  81ddd4:	0f b6 c0             	movzbl %al,%eax
  81ddd7:	83 e0 10             	and    $0x10,%eax
  81ddda:	85 c0                	test   %eax,%eax
  81dddc:	0f 84 ab 09 00 00    	je     81e78d <tcp_receive+0x9db>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  81dde2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dde6:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81ddea:	0f b7 d0             	movzwl %ax,%edx
  81dded:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ddf1:	8b 40 6c             	mov    0x6c(%rax),%eax
  81ddf4:	01 d0                	add    %edx,%eax
  81ddf6:	89 45 bc             	mov    %eax,-0x44(%rbp)

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  81ddf9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ddfd:	8b 50 6c             	mov    0x6c(%rax),%edx
  81de00:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81de07:	00 00 00 
  81de0a:	8b 00                	mov    (%rax),%eax
  81de0c:	89 d1                	mov    %edx,%ecx
  81de0e:	29 c1                	sub    %eax,%ecx
  81de10:	89 c8                	mov    %ecx,%eax
  81de12:	85 c0                	test   %eax,%eax
  81de14:	78 6d                	js     81de83 <tcp_receive+0xd1>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81de16:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de1a:	8b 50 6c             	mov    0x6c(%rax),%edx
  81de1d:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81de24:	00 00 00 
  81de27:	8b 00                	mov    (%rax),%eax

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  81de29:	39 c2                	cmp    %eax,%edx
  81de2b:	75 1d                	jne    81de4a <tcp_receive+0x98>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81de2d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de31:	8b 50 70             	mov    0x70(%rax),%edx
  81de34:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81de3b:	00 00 00 
  81de3e:	8b 00                	mov    (%rax),%eax
  81de40:	89 d3                	mov    %edx,%ebx
  81de42:	29 c3                	sub    %eax,%ebx
  81de44:	89 d8                	mov    %ebx,%eax
  81de46:	85 c0                	test   %eax,%eax
  81de48:	78 39                	js     81de83 <tcp_receive+0xd1>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  81de4a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de4e:	8b 50 70             	mov    0x70(%rax),%edx
  81de51:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81de58:	00 00 00 
  81de5b:	8b 00                	mov    (%rax),%eax
  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  81de5d:	39 c2                	cmp    %eax,%edx
  81de5f:	0f 85 84 00 00 00    	jne    81dee9 <tcp_receive+0x137>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  81de65:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81de6c:	00 00 00 
  81de6f:	48 8b 00             	mov    (%rax),%rax
  81de72:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81de76:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de7a:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81de7e:	66 39 c2             	cmp    %ax,%dx
  81de81:	76 66                	jbe    81dee9 <tcp_receive+0x137>
      pcb->snd_wnd = tcphdr->wnd;
  81de83:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81de8a:	00 00 00 
  81de8d:	48 8b 00             	mov    (%rax),%rax
  81de90:	0f b7 50 0e          	movzwl 0xe(%rax),%edx
  81de94:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81de98:	66 89 50 68          	mov    %dx,0x68(%rax)
      pcb->snd_wl1 = seqno;
  81de9c:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81dea3:	00 00 00 
  81dea6:	8b 10                	mov    (%rax),%edx
  81dea8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81deac:	89 50 6c             	mov    %edx,0x6c(%rax)
      pcb->snd_wl2 = ackno;
  81deaf:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81deb6:	00 00 00 
  81deb9:	8b 10                	mov    (%rax),%edx
  81debb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81debf:	89 50 70             	mov    %edx,0x70(%rax)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  81dec2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dec6:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81deca:	66 85 c0             	test   %ax,%ax
  81decd:	74 1a                	je     81dee9 <tcp_receive+0x137>
  81decf:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ded3:	0f b6 80 d8 00 00 00 	movzbl 0xd8(%rax),%eax
  81deda:	84 c0                	test   %al,%al
  81dedc:	74 0b                	je     81dee9 <tcp_receive+0x137>
          pcb->persist_backoff = 0;
  81dede:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dee2:	c6 80 d8 00 00 00 00 	movb   $0x0,0xd8(%rax)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  81dee9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81deed:	8b 50 54             	mov    0x54(%rax),%edx
  81def0:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81def7:	00 00 00 
  81defa:	8b 00                	mov    (%rax),%eax
  81defc:	39 c2                	cmp    %eax,%edx
  81defe:	0f 85 72 01 00 00    	jne    81e076 <tcp_receive+0x2c4>
      pcb->acked = 0;
  81df04:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df08:	66 c7 40 78 00 00    	movw   $0x0,0x78(%rax)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  81df0e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df12:	8b 50 6c             	mov    0x6c(%rax),%edx
  81df15:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df19:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81df1d:	0f b7 c0             	movzwl %ax,%eax
  81df20:	01 d0                	add    %edx,%eax
  81df22:	3b 45 bc             	cmp    -0x44(%rbp),%eax
  81df25:	0f 85 7a 06 00 00    	jne    81e5a5 <tcp_receive+0x7f3>
        ++pcb->dupacks;
  81df2b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df2f:	0f b6 40 58          	movzbl 0x58(%rax),%eax
  81df33:	8d 50 01             	lea    0x1(%rax),%edx
  81df36:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df3a:	88 50 58             	mov    %dl,0x58(%rax)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  81df3d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df41:	0f b6 40 58          	movzbl 0x58(%rax),%eax
  81df45:	3c 02                	cmp    $0x2,%al
  81df47:	0f 86 58 06 00 00    	jbe    81e5a5 <tcp_receive+0x7f3>
  81df4d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df51:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81df58:	48 85 c0             	test   %rax,%rax
  81df5b:	0f 84 44 06 00 00    	je     81e5a5 <tcp_receive+0x7f3>
          if (!(pcb->flags & TF_INFR)) {
  81df61:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df65:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81df69:	0f b6 c0             	movzbl %al,%eax
  81df6c:	83 e0 04             	and    $0x4,%eax
  81df6f:	85 c0                	test   %eax,%eax
  81df71:	0f 85 bd 00 00 00    	jne    81e034 <tcp_receive+0x282>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  81df77:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df7b:	48 89 c7             	mov    %rax,%rdi
  81df7e:	48 b8 c0 44 81 00 00 	movabs $0x8144c0,%rax
  81df85:	00 00 00 
  81df88:	ff d0                	callq  *%rax
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  81df8a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df8e:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81df92:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81df96:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81df9a:	66 39 c2             	cmp    %ax,%dx
  81df9d:	76 17                	jbe    81dfb6 <tcp_receive+0x204>
              pcb->ssthresh = pcb->snd_wnd / 2;
  81df9f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dfa3:	0f b7 40 68          	movzwl 0x68(%rax),%eax
  81dfa7:	89 c2                	mov    %eax,%edx
  81dfa9:	66 d1 ea             	shr    %dx
  81dfac:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dfb0:	66 89 50 5c          	mov    %dx,0x5c(%rax)
  81dfb4:	eb 15                	jmp    81dfcb <tcp_receive+0x219>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  81dfb6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dfba:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81dfbe:	89 c2                	mov    %eax,%edx
  81dfc0:	66 d1 ea             	shr    %dx
  81dfc3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dfc7:	66 89 50 5c          	mov    %dx,0x5c(%rax)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  81dfcb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dfcf:	0f b7 40 5c          	movzwl 0x5c(%rax),%eax
  81dfd3:	0f b7 d0             	movzwl %ax,%edx
  81dfd6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dfda:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81dfde:	0f b7 c0             	movzwl %ax,%eax
  81dfe1:	01 c0                	add    %eax,%eax
  81dfe3:	39 c2                	cmp    %eax,%edx
  81dfe5:	7d 13                	jge    81dffa <tcp_receive+0x248>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  81dfe7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dfeb:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81dfef:	8d 14 00             	lea    (%rax,%rax,1),%edx
  81dff2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dff6:	66 89 50 5c          	mov    %dx,0x5c(%rax)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  81dffa:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81dffe:	0f b7 48 5c          	movzwl 0x5c(%rax),%ecx
  81e002:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e006:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  81e00a:	89 d0                	mov    %edx,%eax
  81e00c:	01 c0                	add    %eax,%eax
  81e00e:	01 d0                	add    %edx,%eax
  81e010:	8d 14 01             	lea    (%rcx,%rax,1),%edx
  81e013:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e017:	66 89 50 5a          	mov    %dx,0x5a(%rax)
            pcb->flags |= TF_INFR;
  81e01b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e01f:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e023:	89 c2                	mov    %eax,%edx
  81e025:	83 ca 04             	or     $0x4,%edx
  81e028:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e02c:	88 50 2c             	mov    %dl,0x2c(%rax)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81e02f:	e9 71 05 00 00       	jmpq   81e5a5 <tcp_receive+0x7f3>
            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
            pcb->flags |= TF_INFR;
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  81e034:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e038:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e03c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e040:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e044:	01 c2                	add    %eax,%edx
  81e046:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e04a:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e04e:	66 39 c2             	cmp    %ax,%dx
  81e051:	0f 86 4e 05 00 00    	jbe    81e5a5 <tcp_receive+0x7f3>
              pcb->cwnd += pcb->mss;
  81e057:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e05b:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e05f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e063:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e067:	01 c2                	add    %eax,%edx
  81e069:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e06d:	66 89 50 5a          	mov    %dx,0x5a(%rax)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81e071:	e9 2f 05 00 00       	jmpq   81e5a5 <tcp_receive+0x7f3>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  81e076:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e07a:	8b 40 54             	mov    0x54(%rax),%eax
  81e07d:	89 c2                	mov    %eax,%edx
  81e07f:	f7 d2                	not    %edx
  81e081:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81e088:	00 00 00 
  81e08b:	8b 00                	mov    (%rax),%eax
  81e08d:	01 d0                	add    %edx,%eax
  81e08f:	85 c0                	test   %eax,%eax
  81e091:	0f 88 b4 03 00 00    	js     81e44b <tcp_receive+0x699>
  81e097:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81e09e:	00 00 00 
  81e0a1:	8b 10                	mov    (%rax),%edx
  81e0a3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e0a7:	8b 40 64             	mov    0x64(%rax),%eax
  81e0aa:	89 d1                	mov    %edx,%ecx
  81e0ac:	29 c1                	sub    %eax,%ecx
  81e0ae:	89 c8                	mov    %ecx,%eax
  81e0b0:	85 c0                	test   %eax,%eax
  81e0b2:	0f 8f 93 03 00 00    	jg     81e44b <tcp_receive+0x699>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  81e0b8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e0bc:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e0c0:	0f b6 c0             	movzbl %al,%eax
  81e0c3:	83 e0 04             	and    $0x4,%eax
  81e0c6:	85 c0                	test   %eax,%eax
  81e0c8:	74 24                	je     81e0ee <tcp_receive+0x33c>
        pcb->flags &= ~TF_INFR;
  81e0ca:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e0ce:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81e0d2:	89 c2                	mov    %eax,%edx
  81e0d4:	83 e2 fb             	and    $0xfffffffb,%edx
  81e0d7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e0db:	88 50 2c             	mov    %dl,0x2c(%rax)
        pcb->cwnd = pcb->ssthresh;
  81e0de:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e0e2:	0f b7 50 5c          	movzwl 0x5c(%rax),%edx
  81e0e6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e0ea:	66 89 50 5a          	mov    %dx,0x5a(%rax)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  81e0ee:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e0f2:	c6 40 52 00          	movb   $0x0,0x52(%rax)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  81e0f6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e0fa:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81e0fe:	66 c1 f8 03          	sar    $0x3,%ax
  81e102:	89 c2                	mov    %eax,%edx
  81e104:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e108:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81e10c:	01 d0                	add    %edx,%eax
  81e10e:	89 c2                	mov    %eax,%edx
  81e110:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e114:	66 89 50 50          	mov    %dx,0x50(%rax)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  81e118:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81e11f:	00 00 00 
  81e122:	8b 00                	mov    (%rax),%eax
  81e124:	89 c2                	mov    %eax,%edx
  81e126:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e12a:	8b 40 54             	mov    0x54(%rax),%eax
  81e12d:	66 29 c2             	sub    %ax,%dx
  81e130:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e134:	66 89 50 78          	mov    %dx,0x78(%rax)

      pcb->snd_buf += pcb->acked;
  81e138:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e13c:	0f b7 50 7a          	movzwl 0x7a(%rax),%edx
  81e140:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e144:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  81e148:	01 c2                	add    %eax,%edx
  81e14a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e14e:	66 89 50 7a          	mov    %dx,0x7a(%rax)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  81e152:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e156:	c6 40 58 00          	movb   $0x0,0x58(%rax)
      pcb->lastack = ackno;
  81e15a:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81e161:	00 00 00 
  81e164:	8b 10                	mov    (%rax),%edx
  81e166:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e16a:	89 50 54             	mov    %edx,0x54(%rax)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  81e16d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e171:	8b 40 18             	mov    0x18(%rax),%eax
  81e174:	83 f8 03             	cmp    $0x3,%eax
  81e177:	0f 86 c9 01 00 00    	jbe    81e346 <tcp_receive+0x594>
        if (pcb->cwnd < pcb->ssthresh) {
  81e17d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e181:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e185:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e189:	0f b7 40 5c          	movzwl 0x5c(%rax),%eax
  81e18d:	66 39 c2             	cmp    %ax,%dx
  81e190:	73 42                	jae    81e1d4 <tcp_receive+0x422>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  81e192:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e196:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e19a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e19e:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e1a2:	01 c2                	add    %eax,%edx
  81e1a4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1a8:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e1ac:	66 39 c2             	cmp    %ax,%dx
  81e1af:	0f 86 91 01 00 00    	jbe    81e346 <tcp_receive+0x594>
            pcb->cwnd += pcb->mss;
  81e1b5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1b9:	0f b7 50 5a          	movzwl 0x5a(%rax),%edx
  81e1bd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1c1:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e1c5:	01 c2                	add    %eax,%edx
  81e1c7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1cb:	66 89 50 5a          	mov    %dx,0x5a(%rax)
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81e1cf:	e9 72 01 00 00       	jmpq   81e346 <tcp_receive+0x594>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
            pcb->cwnd += pcb->mss;
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  81e1d4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1d8:	0f b7 48 5a          	movzwl 0x5a(%rax),%ecx
  81e1dc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1e0:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e1e4:	0f b7 d0             	movzwl %ax,%edx
  81e1e7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e1eb:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  81e1ef:	0f b7 c0             	movzwl %ax,%eax
  81e1f2:	0f af c2             	imul   %edx,%eax
  81e1f5:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81e1f9:	0f b7 52 5a          	movzwl 0x5a(%rdx),%edx
  81e1fd:	0f b7 d2             	movzwl %dx,%edx
  81e200:	89 55 94             	mov    %edx,-0x6c(%rbp)
  81e203:	89 c2                	mov    %eax,%edx
  81e205:	c1 fa 1f             	sar    $0x1f,%edx
  81e208:	f7 7d 94             	idivl  -0x6c(%rbp)
  81e20b:	01 c8                	add    %ecx,%eax
  81e20d:	66 89 45 ba          	mov    %ax,-0x46(%rbp)
          if (new_cwnd > pcb->cwnd) {
  81e211:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e215:	0f b7 40 5a          	movzwl 0x5a(%rax),%eax
  81e219:	66 3b 45 ba          	cmp    -0x46(%rbp),%ax
  81e21d:	0f 83 23 01 00 00    	jae    81e346 <tcp_receive+0x594>
            pcb->cwnd = new_cwnd;
  81e223:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e227:	0f b7 55 ba          	movzwl -0x46(%rbp),%edx
  81e22b:	66 89 50 5a          	mov    %dx,0x5a(%rax)
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81e22f:	e9 12 01 00 00       	jmpq   81e346 <tcp_receive+0x594>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  81e234:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e238:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e23f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        pcb->unacked = pcb->unacked->next;
  81e243:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e247:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e24e:	48 8b 10             	mov    (%rax),%rdx
  81e251:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e255:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  81e25c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e260:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81e264:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e268:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e26c:	48 89 c7             	mov    %rax,%rdi
  81e26f:	48 b8 e1 da 80 00 00 	movabs $0x80dae1,%rax
  81e276:	00 00 00 
  81e279:	ff d0                	callq  *%rax
  81e27b:	0f b6 c0             	movzbl %al,%eax
  81e27e:	66 39 c3             	cmp    %ax,%bx
  81e281:	73 2a                	jae    81e2ad <tcp_receive+0x4fb>
  81e283:	48 ba 88 38 82 00 00 	movabs $0x823888,%rdx
  81e28a:	00 00 00 
  81e28d:	be 55 03 00 00       	mov    $0x355,%esi
  81e292:	48 bf e7 36 82 00 00 	movabs $0x8236e7,%rdi
  81e299:	00 00 00 
  81e29c:	b8 00 00 00 00       	mov    $0x0,%eax
  81e2a1:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81e2a8:	00 00 00 
  81e2ab:	ff d1                	callq  *%rcx
        pcb->snd_queuelen -= pbuf_clen(next->p);
  81e2ad:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2b1:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81e2b5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e2b9:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e2bd:	48 89 c7             	mov    %rax,%rdi
  81e2c0:	48 b8 e1 da 80 00 00 	movabs $0x80dae1,%rax
  81e2c7:	00 00 00 
  81e2ca:	ff d0                	callq  *%rax
  81e2cc:	0f b6 c0             	movzbl %al,%eax
  81e2cf:	89 da                	mov    %ebx,%edx
  81e2d1:	66 29 c2             	sub    %ax,%dx
  81e2d4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2d8:	66 89 50 7c          	mov    %dx,0x7c(%rax)
        tcp_seg_free(next);
  81e2dc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e2e0:	48 89 c7             	mov    %rax,%rdi
  81e2e3:	48 b8 b3 00 81 00 00 	movabs $0x8100b3,%rax
  81e2ea:	00 00 00 
  81e2ed:	ff d0                	callq  *%rax

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  81e2ef:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e2f3:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81e2f7:	66 85 c0             	test   %ax,%ax
  81e2fa:	74 4b                	je     81e347 <tcp_receive+0x595>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  81e2fc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e300:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e307:	48 85 c0             	test   %rax,%rax
  81e30a:	75 3b                	jne    81e347 <tcp_receive+0x595>
  81e30c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e310:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e317:	48 85 c0             	test   %rax,%rax
  81e31a:	75 2b                	jne    81e347 <tcp_receive+0x595>
  81e31c:	48 ba b0 38 82 00 00 	movabs $0x8238b0,%rdx
  81e323:	00 00 00 
  81e326:	be 5c 03 00 00       	mov    $0x35c,%esi
  81e32b:	48 bf e7 36 82 00 00 	movabs $0x8236e7,%rdi
  81e332:	00 00 00 
  81e335:	b8 00 00 00 00       	mov    $0x0,%eax
  81e33a:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81e341:	00 00 00 
  81e344:	ff d1                	callq  *%rcx
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81e346:	90                   	nop
  81e347:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e34b:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e352:	48 85 c0             	test   %rax,%rax
  81e355:	0f 84 bd 00 00 00    	je     81e418 <tcp_receive+0x666>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  81e35b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e35f:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e366:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e36a:	8b 40 04             	mov    0x4(%rax),%eax
  81e36d:	89 c7                	mov    %eax,%edi
  81e36f:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81e376:	00 00 00 
  81e379:	ff d0                	callq  *%rax
  81e37b:	89 c3                	mov    %eax,%ebx
  81e37d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e381:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e388:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81e38c:	44 0f b7 e0          	movzwl %ax,%r12d
  81e390:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e394:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e39b:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e39f:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e3a3:	0f b7 c0             	movzwl %ax,%eax
  81e3a6:	89 c7                	mov    %eax,%edi
  81e3a8:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81e3af:	00 00 00 
  81e3b2:	ff d0                	callq  *%rax
  81e3b4:	0f b7 c0             	movzwl %ax,%eax
  81e3b7:	83 e0 01             	and    $0x1,%eax
  81e3ba:	84 c0                	test   %al,%al
  81e3bc:	75 2e                	jne    81e3ec <tcp_receive+0x63a>
  81e3be:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e3c2:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e3c9:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e3cd:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e3d1:	0f b7 c0             	movzwl %ax,%eax
  81e3d4:	89 c7                	mov    %eax,%edi
  81e3d6:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81e3dd:	00 00 00 
  81e3e0:	ff d0                	callq  *%rax
  81e3e2:	0f b7 c0             	movzwl %ax,%eax
  81e3e5:	83 e0 02             	and    $0x2,%eax
  81e3e8:	85 c0                	test   %eax,%eax
  81e3ea:	74 07                	je     81e3f3 <tcp_receive+0x641>
  81e3ec:	b8 01 00 00 00       	mov    $0x1,%eax
  81e3f1:	eb 05                	jmp    81e3f8 <tcp_receive+0x646>
  81e3f3:	b8 00 00 00 00       	mov    $0x0,%eax
  81e3f8:	44 01 e0             	add    %r12d,%eax
  81e3fb:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81e3fe:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81e405:	00 00 00 
  81e408:	8b 00                	mov    (%rax),%eax
  81e40a:	89 d1                	mov    %edx,%ecx
  81e40c:	29 c1                	sub    %eax,%ecx
  81e40e:	89 c8                	mov    %ecx,%eax
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  81e410:	85 c0                	test   %eax,%eax
  81e412:	0f 8e 1c fe ff ff    	jle    81e234 <tcp_receive+0x482>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  81e418:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e41c:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e423:	48 85 c0             	test   %rax,%rax
  81e426:	75 0c                	jne    81e434 <tcp_receive+0x682>
        pcb->rtime = -1;
  81e428:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e42c:	66 c7 40 3e ff ff    	movw   $0xffff,0x3e(%rax)
  81e432:	eb 0a                	jmp    81e43e <tcp_receive+0x68c>
      else
        pcb->rtime = 0;
  81e434:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e438:	66 c7 40 3e 00 00    	movw   $0x0,0x3e(%rax)

      pcb->polltmr = 0;
  81e43e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e442:	c6 40 3c 00          	movb   $0x0,0x3c(%rax)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81e446:	e9 5a 01 00 00       	jmpq   81e5a5 <tcp_receive+0x7f3>
        pcb->rtime = 0;

      pcb->polltmr = 0;
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  81e44b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e44f:	66 c7 40 78 00 00    	movw   $0x0,0x78(%rax)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81e455:	e9 4b 01 00 00       	jmpq   81e5a5 <tcp_receive+0x7f3>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  81e45a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e45e:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e465:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      pcb->unsent = pcb->unsent->next;
  81e469:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e46d:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e474:	48 8b 10             	mov    (%rax),%rdx
  81e477:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e47b:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  81e482:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e486:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81e48a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e48e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e492:	48 89 c7             	mov    %rax,%rdi
  81e495:	48 b8 e1 da 80 00 00 	movabs $0x80dae1,%rax
  81e49c:	00 00 00 
  81e49f:	ff d0                	callq  *%rax
  81e4a1:	0f b6 c0             	movzbl %al,%eax
  81e4a4:	66 39 c3             	cmp    %ax,%bx
  81e4a7:	73 2a                	jae    81e4d3 <tcp_receive+0x721>
  81e4a9:	48 ba 88 38 82 00 00 	movabs $0x823888,%rdx
  81e4b0:	00 00 00 
  81e4b3:	be 7f 03 00 00       	mov    $0x37f,%esi
  81e4b8:	48 bf e7 36 82 00 00 	movabs $0x8236e7,%rdi
  81e4bf:	00 00 00 
  81e4c2:	b8 00 00 00 00       	mov    $0x0,%eax
  81e4c7:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81e4ce:	00 00 00 
  81e4d1:	ff d1                	callq  *%rcx
      pcb->snd_queuelen -= pbuf_clen(next->p);
  81e4d3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4d7:	0f b7 58 7c          	movzwl 0x7c(%rax),%ebx
  81e4db:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e4df:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e4e3:	48 89 c7             	mov    %rax,%rdi
  81e4e6:	48 b8 e1 da 80 00 00 	movabs $0x80dae1,%rax
  81e4ed:	00 00 00 
  81e4f0:	ff d0                	callq  *%rax
  81e4f2:	0f b6 c0             	movzbl %al,%eax
  81e4f5:	89 da                	mov    %ebx,%edx
  81e4f7:	66 29 c2             	sub    %ax,%dx
  81e4fa:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e4fe:	66 89 50 7c          	mov    %dx,0x7c(%rax)
      tcp_seg_free(next);
  81e502:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81e506:	48 89 c7             	mov    %rax,%rdi
  81e509:	48 b8 b3 00 81 00 00 	movabs $0x8100b3,%rax
  81e510:	00 00 00 
  81e513:	ff d0                	callq  *%rax
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  81e515:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e519:	0f b7 40 7c          	movzwl 0x7c(%rax),%eax
  81e51d:	66 85 c0             	test   %ax,%ax
  81e520:	74 4a                	je     81e56c <tcp_receive+0x7ba>
        LWIP_ASSERT("tcp_receive: valid queue length",
  81e522:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e526:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  81e52d:	48 85 c0             	test   %rax,%rax
  81e530:	75 3a                	jne    81e56c <tcp_receive+0x7ba>
  81e532:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e536:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e53d:	48 85 c0             	test   %rax,%rax
  81e540:	75 2a                	jne    81e56c <tcp_receive+0x7ba>
  81e542:	48 ba b0 38 82 00 00 	movabs $0x8238b0,%rdx
  81e549:	00 00 00 
  81e54c:	be 85 03 00 00       	mov    $0x385,%esi
  81e551:	48 bf e7 36 82 00 00 	movabs $0x8236e7,%rdi
  81e558:	00 00 00 
  81e55b:	b8 00 00 00 00       	mov    $0x0,%eax
  81e560:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81e567:	00 00 00 
  81e56a:	ff d1                	callq  *%rcx
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  81e56c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e570:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e577:	48 85 c0             	test   %rax,%rax
  81e57a:	74 2a                	je     81e5a6 <tcp_receive+0x7f4>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  81e57c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e580:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e587:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e58b:	8b 40 04             	mov    0x4(%rax),%eax
  81e58e:	89 c7                	mov    %eax,%edi
  81e590:	48 b8 c9 2c 81 00 00 	movabs $0x812cc9,%rax
  81e597:	00 00 00 
  81e59a:	ff d0                	callq  *%rax
  81e59c:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81e5a0:	89 42 60             	mov    %eax,0x60(%rdx)
  81e5a3:	eb 01                	jmp    81e5a6 <tcp_receive+0x7f4>
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81e5a5:	90                   	nop
  81e5a6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5aa:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e5b1:	48 85 c0             	test   %rax,%rax
  81e5b4:	0f 84 db 00 00 00    	je     81e695 <tcp_receive+0x8e3>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  81e5ba:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81e5c1:	00 00 00 
  81e5c4:	44 8b 20             	mov    (%rax),%r12d
  81e5c7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5cb:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e5d2:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e5d6:	8b 40 04             	mov    0x4(%rax),%eax
  81e5d9:	89 c7                	mov    %eax,%edi
  81e5db:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81e5e2:	00 00 00 
  81e5e5:	ff d0                	callq  *%rax
  81e5e7:	89 c3                	mov    %eax,%ebx
  81e5e9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e5ed:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e5f4:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81e5f8:	44 0f b7 e8          	movzwl %ax,%r13d
  81e5fc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e600:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e607:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e60b:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e60f:	0f b7 c0             	movzwl %ax,%eax
  81e612:	89 c7                	mov    %eax,%edi
  81e614:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81e61b:	00 00 00 
  81e61e:	ff d0                	callq  *%rax
  81e620:	0f b7 c0             	movzwl %ax,%eax
  81e623:	83 e0 01             	and    $0x1,%eax
  81e626:	84 c0                	test   %al,%al
  81e628:	75 2e                	jne    81e658 <tcp_receive+0x8a6>
  81e62a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e62e:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  81e635:	48 8b 40 20          	mov    0x20(%rax),%rax
  81e639:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81e63d:	0f b7 c0             	movzwl %ax,%eax
  81e640:	89 c7                	mov    %eax,%edi
  81e642:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81e649:	00 00 00 
  81e64c:	ff d0                	callq  *%rax
  81e64e:	0f b7 c0             	movzwl %ax,%eax
  81e651:	83 e0 02             	and    $0x2,%eax
  81e654:	85 c0                	test   %eax,%eax
  81e656:	74 07                	je     81e65f <tcp_receive+0x8ad>
  81e658:	b8 01 00 00 00       	mov    $0x1,%eax
  81e65d:	eb 05                	jmp    81e664 <tcp_receive+0x8b2>
  81e65f:	b8 00 00 00 00       	mov    $0x0,%eax
  81e664:	44 01 e8             	add    %r13d,%eax
  81e667:	01 d8                	add    %ebx,%eax
  81e669:	44 89 e3             	mov    %r12d,%ebx
  81e66c:	29 c3                	sub    %eax,%ebx
  81e66e:	89 d8                	mov    %ebx,%eax
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81e670:	85 c0                	test   %eax,%eax
  81e672:	78 21                	js     81e695 <tcp_receive+0x8e3>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  81e674:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81e67b:	00 00 00 
  81e67e:	8b 10                	mov    (%rax),%edx
  81e680:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e684:	8b 40 64             	mov    0x64(%rax),%eax
  81e687:	89 d1                	mov    %edx,%ecx
  81e689:	29 c1                	sub    %eax,%ecx
  81e68b:	89 c8                	mov    %ecx,%eax
  81e68d:	85 c0                	test   %eax,%eax
  81e68f:	0f 8e c5 fd ff ff    	jle    81e45a <tcp_receive+0x6a8>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  81e695:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e699:	8b 40 44             	mov    0x44(%rax),%eax
  81e69c:	85 c0                	test   %eax,%eax
  81e69e:	0f 84 e9 00 00 00    	je     81e78d <tcp_receive+0x9db>
  81e6a4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6a8:	8b 50 48             	mov    0x48(%rax),%edx
  81e6ab:	48 b8 7c 75 b5 00 00 	movabs $0xb5757c,%rax
  81e6b2:	00 00 00 
  81e6b5:	8b 00                	mov    (%rax),%eax
  81e6b7:	89 d3                	mov    %edx,%ebx
  81e6b9:	29 c3                	sub    %eax,%ebx
  81e6bb:	89 d8                	mov    %ebx,%eax
  81e6bd:	85 c0                	test   %eax,%eax
  81e6bf:	0f 89 c8 00 00 00    	jns    81e78d <tcp_receive+0x9db>
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
  81e6c5:	48 b8 20 b0 b5 00 00 	movabs $0xb5b020,%rax
  81e6cc:	00 00 00 
  81e6cf:	8b 00                	mov    (%rax),%eax
  81e6d1:	89 c2                	mov    %eax,%edx
  81e6d3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6d7:	8b 40 44             	mov    0x44(%rax),%eax
  81e6da:	89 d1                	mov    %edx,%ecx
  81e6dc:	66 29 c1             	sub    %ax,%cx
  81e6df:	89 c8                	mov    %ecx,%eax
  81e6e1:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  81e6e5:	0f b7 55 c2          	movzwl -0x3e(%rbp),%edx
  81e6e9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e6ed:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81e6f1:	66 c1 f8 03          	sar    $0x3,%ax
  81e6f5:	89 d3                	mov    %edx,%ebx
  81e6f7:	66 29 c3             	sub    %ax,%bx
  81e6fa:	89 d8                	mov    %ebx,%eax
  81e6fc:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      pcb->sa += m;
  81e700:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e704:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81e708:	89 c2                	mov    %eax,%edx
  81e70a:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81e70e:	01 d0                	add    %edx,%eax
  81e710:	89 c2                	mov    %eax,%edx
  81e712:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e716:	66 89 50 4c          	mov    %dx,0x4c(%rax)
      if (m < 0) {
  81e71a:	66 83 7d c2 00       	cmpw   $0x0,-0x3e(%rbp)
  81e71f:	79 0a                	jns    81e72b <tcp_receive+0x979>
        m = -m;
  81e721:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81e725:	f7 d8                	neg    %eax
  81e727:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      }
      m = m - (pcb->sv >> 2);
  81e72b:	0f b7 55 c2          	movzwl -0x3e(%rbp),%edx
  81e72f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e733:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81e737:	66 c1 f8 02          	sar    $0x2,%ax
  81e73b:	89 d1                	mov    %edx,%ecx
  81e73d:	66 29 c1             	sub    %ax,%cx
  81e740:	89 c8                	mov    %ecx,%eax
  81e742:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
      pcb->sv += m;
  81e746:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e74a:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81e74e:	89 c2                	mov    %eax,%edx
  81e750:	0f b7 45 c2          	movzwl -0x3e(%rbp),%eax
  81e754:	01 d0                	add    %edx,%eax
  81e756:	89 c2                	mov    %eax,%edx
  81e758:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e75c:	66 89 50 4e          	mov    %dx,0x4e(%rax)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  81e760:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e764:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  81e768:	66 c1 f8 03          	sar    $0x3,%ax
  81e76c:	89 c2                	mov    %eax,%edx
  81e76e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e772:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  81e776:	01 d0                	add    %edx,%eax
  81e778:	89 c2                	mov    %eax,%edx
  81e77a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e77e:	66 89 50 50          	mov    %dx,0x50(%rax)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  81e782:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e786:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%rax)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  81e78d:	48 b8 82 75 b5 00 00 	movabs $0xb57582,%rax
  81e794:	00 00 00 
  81e797:	0f b7 00             	movzwl (%rax),%eax
  81e79a:	66 85 c0             	test   %ax,%ax
  81e79d:	0f 84 5e 10 00 00    	je     81f801 <tcp_receive+0x1a4f>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  81e7a3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7a7:	8b 50 30             	mov    0x30(%rax),%edx
  81e7aa:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81e7b1:	00 00 00 
  81e7b4:	8b 00                	mov    (%rax),%eax
  81e7b6:	f7 d0                	not    %eax
  81e7b8:	01 d0                	add    %edx,%eax
  81e7ba:	85 c0                	test   %eax,%eax
  81e7bc:	0f 88 b9 02 00 00    	js     81ea7b <tcp_receive+0xcc9>
  81e7c2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7c6:	8b 50 30             	mov    0x30(%rax),%edx
  81e7c9:	48 b8 82 75 b5 00 00 	movabs $0xb57582,%rax
  81e7d0:	00 00 00 
  81e7d3:	0f b7 00             	movzwl (%rax),%eax
  81e7d6:	0f b7 c8             	movzwl %ax,%ecx
  81e7d9:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81e7e0:	00 00 00 
  81e7e3:	8b 00                	mov    (%rax),%eax
  81e7e5:	01 c8                	add    %ecx,%eax
  81e7e7:	89 d3                	mov    %edx,%ebx
  81e7e9:	29 c3                	sub    %eax,%ebx
  81e7eb:	89 d8                	mov    %ebx,%eax
  81e7ed:	83 c0 01             	add    $0x1,%eax
  81e7f0:	85 c0                	test   %eax,%eax
  81e7f2:	0f 8f 83 02 00 00    	jg     81ea7b <tcp_receive+0xcc9>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  81e7f8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81e7fc:	8b 50 30             	mov    0x30(%rax),%edx
  81e7ff:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81e806:	00 00 00 
  81e809:	8b 00                	mov    (%rax),%eax
  81e80b:	89 d1                	mov    %edx,%ecx
  81e80d:	29 c1                	sub    %eax,%ecx
  81e80f:	89 c8                	mov    %ecx,%eax
  81e811:	89 45 c4             	mov    %eax,-0x3c(%rbp)
      p = inseg.p;
  81e814:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81e81b:	00 00 00 
  81e81e:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e822:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  81e826:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81e82d:	00 00 00 
  81e830:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e834:	48 85 c0             	test   %rax,%rax
  81e837:	75 2a                	jne    81e863 <tcp_receive+0xab1>
  81e839:	48 ba d0 38 82 00 00 	movabs $0x8238d0,%rdx
  81e840:	00 00 00 
  81e843:	be e5 03 00 00       	mov    $0x3e5,%esi
  81e848:	48 bf e7 36 82 00 00 	movabs $0x8236e7,%rdi
  81e84f:	00 00 00 
  81e852:	b8 00 00 00 00       	mov    $0x0,%eax
  81e857:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81e85e:	00 00 00 
  81e861:	ff d1                	callq  *%rcx
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  81e863:	81 7d c4 fe 7f 00 00 	cmpl   $0x7ffe,-0x3c(%rbp)
  81e86a:	7e 2a                	jle    81e896 <tcp_receive+0xae4>
  81e86c:	48 ba e0 38 82 00 00 	movabs $0x8238e0,%rdx
  81e873:	00 00 00 
  81e876:	be e6 03 00 00       	mov    $0x3e6,%esi
  81e87b:	48 bf e7 36 82 00 00 	movabs $0x8236e7,%rdi
  81e882:	00 00 00 
  81e885:	b8 00 00 00 00       	mov    $0x0,%eax
  81e88a:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81e891:	00 00 00 
  81e894:	ff d1                	callq  *%rcx
      if (inseg.p->len < off) {
  81e896:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81e89d:	00 00 00 
  81e8a0:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e8a4:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81e8a8:	0f b7 c0             	movzwl %ax,%eax
  81e8ab:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81e8ae:	0f 8d f0 00 00 00    	jge    81e9a4 <tcp_receive+0xbf2>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  81e8b4:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81e8bb:	00 00 00 
  81e8be:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e8c2:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81e8c6:	0f b7 c0             	movzwl %ax,%eax
  81e8c9:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81e8cc:	7d 2a                	jge    81e8f8 <tcp_receive+0xb46>
  81e8ce:	48 ba ef 38 82 00 00 	movabs $0x8238ef,%rdx
  81e8d5:	00 00 00 
  81e8d8:	be e8 03 00 00       	mov    $0x3e8,%esi
  81e8dd:	48 bf e7 36 82 00 00 	movabs $0x8236e7,%rdi
  81e8e4:	00 00 00 
  81e8e7:	b8 00 00 00 00       	mov    $0x0,%eax
  81e8ec:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81e8f3:	00 00 00 
  81e8f6:	ff d1                	callq  *%rcx
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  81e8f8:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81e8ff:	00 00 00 
  81e902:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e906:	0f b7 50 10          	movzwl 0x10(%rax),%edx
  81e90a:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  81e90d:	89 d3                	mov    %edx,%ebx
  81e90f:	66 29 c3             	sub    %ax,%bx
  81e912:	89 d8                	mov    %ebx,%eax
  81e914:	66 89 45 b8          	mov    %ax,-0x48(%rbp)
        while (p->len < off) {
  81e918:	eb 2f                	jmp    81e949 <tcp_receive+0xb97>
          off -= p->len;
  81e91a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e91e:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81e922:	0f b7 c0             	movzwl %ax,%eax
  81e925:	29 45 c4             	sub    %eax,-0x3c(%rbp)
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  81e928:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e92c:	0f b7 55 b8          	movzwl -0x48(%rbp),%edx
  81e930:	66 89 50 10          	mov    %dx,0x10(%rax)
          p->len = 0;
  81e934:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e938:	66 c7 40 12 00 00    	movw   $0x0,0x12(%rax)
          p = p->next;
  81e93e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e942:	48 8b 00             	mov    (%rax),%rax
  81e945:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  81e949:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e94d:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  81e951:	0f b7 c0             	movzwl %ax,%eax
  81e954:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  81e957:	7c c1                	jl     81e91a <tcp_receive+0xb68>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  81e959:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  81e95c:	f7 d8                	neg    %eax
  81e95e:	0f bf d0             	movswl %ax,%edx
  81e961:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e965:	89 d6                	mov    %edx,%esi
  81e967:	48 89 c7             	mov    %rax,%rdi
  81e96a:	48 b8 6f d7 80 00 00 	movabs $0x80d76f,%rax
  81e971:	00 00 00 
  81e974:	ff d0                	callq  *%rax
  81e976:	84 c0                	test   %al,%al
  81e978:	74 7f                	je     81e9f9 <tcp_receive+0xc47>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  81e97a:	48 ba ff 38 82 00 00 	movabs $0x8238ff,%rdx
  81e981:	00 00 00 
  81e984:	be f5 03 00 00       	mov    $0x3f5,%esi
  81e989:	48 bf e7 36 82 00 00 	movabs $0x8236e7,%rdi
  81e990:	00 00 00 
  81e993:	b8 00 00 00 00       	mov    $0x0,%eax
  81e998:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81e99f:	00 00 00 
  81e9a2:	ff d1                	callq  *%rcx
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  81e9a4:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  81e9a7:	f7 d8                	neg    %eax
  81e9a9:	0f bf d0             	movswl %ax,%edx
  81e9ac:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81e9b3:	00 00 00 
  81e9b6:	48 8b 40 08          	mov    0x8(%rax),%rax
  81e9ba:	89 d6                	mov    %edx,%esi
  81e9bc:	48 89 c7             	mov    %rax,%rdi
  81e9bf:	48 b8 6f d7 80 00 00 	movabs $0x80d76f,%rax
  81e9c6:	00 00 00 
  81e9c9:	ff d0                	callq  *%rax
  81e9cb:	84 c0                	test   %al,%al
  81e9cd:	74 2a                	je     81e9f9 <tcp_receive+0xc47>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  81e9cf:	48 ba ff 38 82 00 00 	movabs $0x8238ff,%rdx
  81e9d6:	00 00 00 
  81e9d9:	be fa 03 00 00       	mov    $0x3fa,%esi
  81e9de:	48 bf e7 36 82 00 00 	movabs $0x8236e7,%rdi
  81e9e5:	00 00 00 
  81e9e8:	b8 00 00 00 00       	mov    $0x0,%eax
  81e9ed:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81e9f4:	00 00 00 
  81e9f7:	ff d1                	callq  *%rcx
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  81e9f9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81e9fd:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81ea01:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81ea08:	00 00 00 
  81ea0b:	48 89 50 10          	mov    %rdx,0x10(%rax)
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  81ea0f:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81ea16:	00 00 00 
  81ea19:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  81ea1d:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81ea24:	00 00 00 
  81ea27:	8b 00                	mov    (%rax),%eax
  81ea29:	89 c1                	mov    %eax,%ecx
  81ea2b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea2f:	8b 40 30             	mov    0x30(%rax),%eax
  81ea32:	89 cb                	mov    %ecx,%ebx
  81ea34:	66 29 c3             	sub    %ax,%bx
  81ea37:	89 d8                	mov    %ebx,%eax
  81ea39:	01 c2                	add    %eax,%edx
  81ea3b:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81ea42:	00 00 00 
  81ea45:	66 89 50 18          	mov    %dx,0x18(%rax)
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  81ea49:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81ea50:	00 00 00 
  81ea53:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ea57:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81ea5b:	8b 4a 30             	mov    0x30(%rdx),%ecx
  81ea5e:	48 ba 78 75 b5 00 00 	movabs $0xb57578,%rdx
  81ea65:	00 00 00 
  81ea68:	89 0a                	mov    %ecx,(%rdx)
  81ea6a:	48 ba 78 75 b5 00 00 	movabs $0xb57578,%rdx
  81ea71:	00 00 00 
  81ea74:	8b 12                	mov    (%rdx),%edx
  81ea76:	89 50 04             	mov    %edx,0x4(%rax)
  81ea79:	eb 44                	jmp    81eabf <tcp_receive+0xd0d>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  81ea7b:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81ea82:	00 00 00 
  81ea85:	8b 10                	mov    (%rax),%edx
  81ea87:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea8b:	8b 40 30             	mov    0x30(%rax),%eax
  81ea8e:	89 d1                	mov    %edx,%ecx
  81ea90:	29 c1                	sub    %eax,%ecx
  81ea92:	89 c8                	mov    %ecx,%eax
  81ea94:	85 c0                	test   %eax,%eax
  81ea96:	79 27                	jns    81eabf <tcp_receive+0xd0d>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  81ea98:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ea9c:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81eaa0:	89 c2                	mov    %eax,%edx
  81eaa2:	83 ca 02             	or     $0x2,%edx
  81eaa5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eaa9:	88 50 2c             	mov    %dl,0x2c(%rax)
  81eaac:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eab0:	48 89 c7             	mov    %rax,%rdi
  81eab3:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  81eaba:	00 00 00 
  81eabd:	ff d0                	callq  *%rax
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  81eabf:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81eac6:	00 00 00 
  81eac9:	8b 10                	mov    (%rax),%edx
  81eacb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eacf:	8b 40 30             	mov    0x30(%rax),%eax
  81ead2:	89 d3                	mov    %edx,%ebx
  81ead4:	29 c3                	sub    %eax,%ebx
  81ead6:	89 d8                	mov    %ebx,%eax
  81ead8:	85 c0                	test   %eax,%eax
  81eada:	0f 88 f8 0c 00 00    	js     81f7d8 <tcp_receive+0x1a26>
  81eae0:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81eae7:	00 00 00 
  81eaea:	8b 10                	mov    (%rax),%edx
  81eaec:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eaf0:	8b 48 30             	mov    0x30(%rax),%ecx
  81eaf3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eaf7:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81eafb:	0f b7 c0             	movzwl %ax,%eax
  81eafe:	01 c8                	add    %ecx,%eax
  81eb00:	89 d1                	mov    %edx,%ecx
  81eb02:	29 c1                	sub    %eax,%ecx
  81eb04:	89 c8                	mov    %ecx,%eax
  81eb06:	83 c0 01             	add    $0x1,%eax
  81eb09:	85 c0                	test   %eax,%eax
  81eb0b:	0f 8f c7 0c 00 00    	jg     81f7d8 <tcp_receive+0x1a26>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81eb11:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb15:	8b 50 30             	mov    0x30(%rax),%edx
  81eb18:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81eb1f:	00 00 00 
  81eb22:	8b 00                	mov    (%rax),%eax
  81eb24:	39 c2                	cmp    %eax,%edx
  81eb26:	0f 85 4b 07 00 00    	jne    81f277 <tcp_receive+0x14c5>
        accepted_inseq = 1; 
  81eb2c:	c6 45 c1 01          	movb   $0x1,-0x3f(%rbp)
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  81eb30:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb34:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81eb3b:	48 85 c0             	test   %rax,%rax
  81eb3e:	0f 84 4f 01 00 00    	je     81ec93 <tcp_receive+0xee1>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  81eb44:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb48:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81eb4f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81eb53:	8b 50 04             	mov    0x4(%rax),%edx
  81eb56:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81eb5d:	00 00 00 
  81eb60:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81eb64:	0f b7 c8             	movzwl %ax,%ecx
  81eb67:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81eb6e:	00 00 00 
  81eb71:	8b 00                	mov    (%rax),%eax
  81eb73:	01 c8                	add    %ecx,%eax
  81eb75:	89 d3                	mov    %edx,%ebx
  81eb77:	29 c3                	sub    %eax,%ebx
  81eb79:	89 d8                	mov    %ebx,%eax
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  81eb7b:	85 c0                	test   %eax,%eax
  81eb7d:	0f 8f 10 01 00 00    	jg     81ec93 <tcp_receive+0xee1>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  81eb83:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb87:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81eb8e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81eb92:	66 85 c0             	test   %ax,%ax
  81eb95:	74 66                	je     81ebfd <tcp_receive+0xe4b>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  81eb97:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eb9b:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81eba2:	48 8b 40 20          	mov    0x20(%rax),%rax
  81eba6:	8b 40 04             	mov    0x4(%rax),%eax
  81eba9:	89 c2                	mov    %eax,%edx
  81ebab:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81ebb2:	00 00 00 
  81ebb5:	8b 00                	mov    (%rax),%eax
  81ebb7:	66 29 c2             	sub    %ax,%dx
  81ebba:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81ebc1:	00 00 00 
  81ebc4:	66 89 50 18          	mov    %dx,0x18(%rax)
            pbuf_realloc(inseg.p, inseg.len);
  81ebc8:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81ebcf:	00 00 00 
  81ebd2:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ebd6:	0f b7 d0             	movzwl %ax,%edx
  81ebd9:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81ebe0:	00 00 00 
  81ebe3:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ebe7:	89 d6                	mov    %edx,%esi
  81ebe9:	48 89 c7             	mov    %rax,%rdi
  81ebec:	48 b8 1f d5 80 00 00 	movabs $0x80d51f,%rax
  81ebf3:	00 00 00 
  81ebf6:	ff d0                	callq  *%rax
  81ebf8:	e9 96 00 00 00       	jmpq   81ec93 <tcp_receive+0xee1>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  81ebfd:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81ec04:	00 00 00 
  81ec07:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ec0b:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ec0f:	0f b7 c0             	movzwl %ax,%eax
  81ec12:	89 c7                	mov    %eax,%edi
  81ec14:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81ec1b:	00 00 00 
  81ec1e:	ff d0                	callq  *%rax
  81ec20:	0f b7 d8             	movzwl %ax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  81ec23:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec27:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81ec2e:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ec32:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ec36:	0f b7 c0             	movzwl %ax,%eax
  81ec39:	89 c7                	mov    %eax,%edi
  81ec3b:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81ec42:	00 00 00 
  81ec45:	ff d0                	callq  *%rax
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
            pbuf_realloc(inseg.p, inseg.len);
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  81ec47:	0f b7 c0             	movzwl %ax,%eax
  81ec4a:	31 d8                	xor    %ebx,%eax
  81ec4c:	83 e0 03             	and    $0x3,%eax
  81ec4f:	85 c0                	test   %eax,%eax
  81ec51:	75 40                	jne    81ec93 <tcp_receive+0xee1>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  81ec53:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec57:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81ec5e:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
              pcb->ooseq = pcb->ooseq->next;
  81ec62:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec66:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81ec6d:	48 8b 10             	mov    (%rax),%rdx
  81ec70:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ec74:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  81ec7b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  81ec7f:	48 89 c6             	mov    %rax,%rsi
  81ec82:	bf 04 00 00 00       	mov    $0x4,%edi
  81ec87:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  81ec8e:	00 00 00 
  81ec91:	ff d0                	callq  *%rax
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  81ec93:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81ec9a:	00 00 00 
  81ec9d:	0f b7 58 18          	movzwl 0x18(%rax),%ebx
  81eca1:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81eca8:	00 00 00 
  81ecab:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ecaf:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ecb3:	0f b7 c0             	movzwl %ax,%eax
  81ecb6:	89 c7                	mov    %eax,%edi
  81ecb8:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81ecbf:	00 00 00 
  81ecc2:	ff d0                	callq  *%rax
  81ecc4:	0f b7 c0             	movzwl %ax,%eax
  81ecc7:	83 e0 01             	and    $0x1,%eax
  81ecca:	84 c0                	test   %al,%al
  81eccc:	75 2d                	jne    81ecfb <tcp_receive+0xf49>
  81ecce:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81ecd5:	00 00 00 
  81ecd8:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ecdc:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ece0:	0f b7 c0             	movzwl %ax,%eax
  81ece3:	89 c7                	mov    %eax,%edi
  81ece5:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81ecec:	00 00 00 
  81ecef:	ff d0                	callq  *%rax
  81ecf1:	0f b7 c0             	movzwl %ax,%eax
  81ecf4:	83 e0 02             	and    $0x2,%eax
  81ecf7:	85 c0                	test   %eax,%eax
  81ecf9:	74 07                	je     81ed02 <tcp_receive+0xf50>
  81ecfb:	b8 01 00 00 00       	mov    $0x1,%eax
  81ed00:	eb 05                	jmp    81ed07 <tcp_receive+0xf55>
  81ed02:	b8 00 00 00 00       	mov    $0x0,%eax
  81ed07:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81ed0a:	48 b8 82 75 b5 00 00 	movabs $0xb57582,%rax
  81ed11:	00 00 00 
  81ed14:	66 89 10             	mov    %dx,(%rax)

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  81ed17:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed1b:	8b 40 18             	mov    0x18(%rax),%eax
  81ed1e:	83 f8 07             	cmp    $0x7,%eax
  81ed21:	74 20                	je     81ed43 <tcp_receive+0xf91>
          pcb->rcv_nxt += tcplen;
  81ed23:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed27:	8b 50 30             	mov    0x30(%rax),%edx
  81ed2a:	48 b8 82 75 b5 00 00 	movabs $0xb57582,%rax
  81ed31:	00 00 00 
  81ed34:	0f b7 00             	movzwl (%rax),%eax
  81ed37:	0f b7 c0             	movzwl %ax,%eax
  81ed3a:	01 c2                	add    %eax,%edx
  81ed3c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed40:	89 50 30             	mov    %edx,0x30(%rax)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  81ed43:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed47:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  81ed4b:	48 b8 82 75 b5 00 00 	movabs $0xb57582,%rax
  81ed52:	00 00 00 
  81ed55:	0f b7 00             	movzwl (%rax),%eax
  81ed58:	66 39 c2             	cmp    %ax,%dx
  81ed5b:	73 0c                	jae    81ed69 <tcp_receive+0xfb7>
          pcb->rcv_wnd = 0;
  81ed5d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed61:	66 c7 40 34 00 00    	movw   $0x0,0x34(%rax)
  81ed67:	eb 20                	jmp    81ed89 <tcp_receive+0xfd7>
        } else {
          pcb->rcv_wnd -= tcplen;
  81ed69:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed6d:	0f b7 50 34          	movzwl 0x34(%rax),%edx
  81ed71:	48 b8 82 75 b5 00 00 	movabs $0xb57582,%rax
  81ed78:	00 00 00 
  81ed7b:	0f b7 00             	movzwl (%rax),%eax
  81ed7e:	66 29 c2             	sub    %ax,%dx
  81ed81:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed85:	66 89 50 34          	mov    %dx,0x34(%rax)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  81ed89:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ed8d:	0f b7 50 36          	movzwl 0x36(%rax),%edx
  81ed91:	48 b8 82 75 b5 00 00 	movabs $0xb57582,%rax
  81ed98:	00 00 00 
  81ed9b:	0f b7 00             	movzwl (%rax),%eax
  81ed9e:	66 39 c2             	cmp    %ax,%dx
  81eda1:	73 0c                	jae    81edaf <tcp_receive+0xffd>
          pcb->rcv_ann_wnd = 0;
  81eda3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eda7:	66 c7 40 36 00 00    	movw   $0x0,0x36(%rax)
  81edad:	eb 20                	jmp    81edcf <tcp_receive+0x101d>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  81edaf:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81edb3:	0f b7 50 36          	movzwl 0x36(%rax),%edx
  81edb7:	48 b8 82 75 b5 00 00 	movabs $0xb57582,%rax
  81edbe:	00 00 00 
  81edc1:	0f b7 00             	movzwl (%rax),%eax
  81edc4:	66 29 c2             	sub    %ax,%dx
  81edc7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81edcb:	66 89 50 36          	mov    %dx,0x36(%rax)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  81edcf:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81edd6:	00 00 00 
  81edd9:	48 8b 40 08          	mov    0x8(%rax),%rax
  81eddd:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81ede1:	66 85 c0             	test   %ax,%ax
  81ede4:	74 2d                	je     81ee13 <tcp_receive+0x1061>
          recv_data = inseg.p;
  81ede6:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81eded:	00 00 00 
  81edf0:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81edf4:	48 b8 88 75 b5 00 00 	movabs $0xb57588,%rax
  81edfb:	00 00 00 
  81edfe:	48 89 10             	mov    %rdx,(%rax)
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  81ee01:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81ee08:	00 00 00 
  81ee0b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81ee12:	00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  81ee13:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81ee1a:	00 00 00 
  81ee1d:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ee21:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ee25:	0f b7 c0             	movzwl %ax,%eax
  81ee28:	89 c7                	mov    %eax,%edi
  81ee2a:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81ee31:	00 00 00 
  81ee34:	ff d0                	callq  *%rax
  81ee36:	0f b7 c0             	movzwl %ax,%eax
  81ee39:	83 e0 01             	and    $0x1,%eax
  81ee3c:	84 c0                	test   %al,%al
  81ee3e:	0f 84 96 03 00 00    	je     81f1da <tcp_receive+0x1428>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  81ee44:	48 b8 84 75 b5 00 00 	movabs $0xb57584,%rax
  81ee4b:	00 00 00 
  81ee4e:	c6 00 20             	movb   $0x20,(%rax)
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81ee51:	e9 84 03 00 00       	jmpq   81f1da <tcp_receive+0x1428>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
  81ee56:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ee5a:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81ee61:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
          seqno = pcb->ooseq->tcphdr->seqno;
  81ee65:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ee69:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81ee70:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ee74:	8b 50 04             	mov    0x4(%rax),%edx
  81ee77:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81ee7e:	00 00 00 
  81ee81:	89 10                	mov    %edx,(%rax)

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  81ee83:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ee87:	8b 58 30             	mov    0x30(%rax),%ebx
  81ee8a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ee8e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ee92:	44 0f b7 e0          	movzwl %ax,%r12d
  81ee96:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ee9a:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ee9e:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81eea2:	0f b7 c0             	movzwl %ax,%eax
  81eea5:	89 c7                	mov    %eax,%edi
  81eea7:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81eeae:	00 00 00 
  81eeb1:	ff d0                	callq  *%rax
  81eeb3:	0f b7 c0             	movzwl %ax,%eax
  81eeb6:	83 e0 01             	and    $0x1,%eax
  81eeb9:	84 c0                	test   %al,%al
  81eebb:	75 27                	jne    81eee4 <tcp_receive+0x1132>
  81eebd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81eec1:	48 8b 40 20          	mov    0x20(%rax),%rax
  81eec5:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81eec9:	0f b7 c0             	movzwl %ax,%eax
  81eecc:	89 c7                	mov    %eax,%edi
  81eece:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81eed5:	00 00 00 
  81eed8:	ff d0                	callq  *%rax
  81eeda:	0f b7 c0             	movzwl %ax,%eax
  81eedd:	83 e0 02             	and    $0x2,%eax
  81eee0:	85 c0                	test   %eax,%eax
  81eee2:	74 07                	je     81eeeb <tcp_receive+0x1139>
  81eee4:	b8 01 00 00 00       	mov    $0x1,%eax
  81eee9:	eb 05                	jmp    81eef0 <tcp_receive+0x113e>
  81eeeb:	b8 00 00 00 00       	mov    $0x0,%eax
  81eef0:	44 01 e0             	add    %r12d,%eax
  81eef3:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  81eef6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eefa:	89 50 30             	mov    %edx,0x30(%rax)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  81eefd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ef01:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81ef05:	0f b7 d8             	movzwl %ax,%ebx
  81ef08:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ef0c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81ef10:	44 0f b7 e0          	movzwl %ax,%r12d
  81ef14:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ef18:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ef1c:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ef20:	0f b7 c0             	movzwl %ax,%eax
  81ef23:	89 c7                	mov    %eax,%edi
  81ef25:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81ef2c:	00 00 00 
  81ef2f:	ff d0                	callq  *%rax
  81ef31:	0f b7 c0             	movzwl %ax,%eax
  81ef34:	83 e0 01             	and    $0x1,%eax
  81ef37:	84 c0                	test   %al,%al
  81ef39:	75 27                	jne    81ef62 <tcp_receive+0x11b0>
  81ef3b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ef3f:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ef43:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ef47:	0f b7 c0             	movzwl %ax,%eax
  81ef4a:	89 c7                	mov    %eax,%edi
  81ef4c:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81ef53:	00 00 00 
  81ef56:	ff d0                	callq  *%rax
  81ef58:	0f b7 c0             	movzwl %ax,%eax
  81ef5b:	83 e0 02             	and    $0x2,%eax
  81ef5e:	85 c0                	test   %eax,%eax
  81ef60:	74 07                	je     81ef69 <tcp_receive+0x11b7>
  81ef62:	b8 01 00 00 00       	mov    $0x1,%eax
  81ef67:	eb 05                	jmp    81ef6e <tcp_receive+0x11bc>
  81ef69:	b8 00 00 00 00       	mov    $0x0,%eax
  81ef6e:	44 01 e0             	add    %r12d,%eax
  81ef71:	39 c3                	cmp    %eax,%ebx
  81ef73:	7d 0c                	jge    81ef81 <tcp_receive+0x11cf>
            pcb->rcv_wnd = 0;
  81ef75:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ef79:	66 c7 40 34 00 00    	movw   $0x0,0x34(%rax)
  81ef7f:	eb 7b                	jmp    81effc <tcp_receive+0x124a>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  81ef81:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81ef85:	0f b7 58 34          	movzwl 0x34(%rax),%ebx
  81ef89:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ef8d:	44 0f b7 60 18       	movzwl 0x18(%rax),%r12d
  81ef92:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81ef96:	48 8b 40 20          	mov    0x20(%rax),%rax
  81ef9a:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81ef9e:	0f b7 c0             	movzwl %ax,%eax
  81efa1:	89 c7                	mov    %eax,%edi
  81efa3:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81efaa:	00 00 00 
  81efad:	ff d0                	callq  *%rax
  81efaf:	0f b7 c0             	movzwl %ax,%eax
  81efb2:	83 e0 01             	and    $0x1,%eax
  81efb5:	84 c0                	test   %al,%al
  81efb7:	75 27                	jne    81efe0 <tcp_receive+0x122e>
  81efb9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81efbd:	48 8b 40 20          	mov    0x20(%rax),%rax
  81efc1:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81efc5:	0f b7 c0             	movzwl %ax,%eax
  81efc8:	89 c7                	mov    %eax,%edi
  81efca:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81efd1:	00 00 00 
  81efd4:	ff d0                	callq  *%rax
  81efd6:	0f b7 c0             	movzwl %ax,%eax
  81efd9:	83 e0 02             	and    $0x2,%eax
  81efdc:	85 c0                	test   %eax,%eax
  81efde:	74 07                	je     81efe7 <tcp_receive+0x1235>
  81efe0:	b8 01 00 00 00       	mov    $0x1,%eax
  81efe5:	eb 05                	jmp    81efec <tcp_receive+0x123a>
  81efe7:	b8 00 00 00 00       	mov    $0x0,%eax
  81efec:	44 01 e0             	add    %r12d,%eax
  81efef:	89 da                	mov    %ebx,%edx
  81eff1:	66 29 c2             	sub    %ax,%dx
  81eff4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81eff8:	66 89 50 34          	mov    %dx,0x34(%rax)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  81effc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f000:	0f b7 40 36          	movzwl 0x36(%rax),%eax
  81f004:	0f b7 d8             	movzwl %ax,%ebx
  81f007:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f00b:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f00f:	44 0f b7 e0          	movzwl %ax,%r12d
  81f013:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f017:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f01b:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f01f:	0f b7 c0             	movzwl %ax,%eax
  81f022:	89 c7                	mov    %eax,%edi
  81f024:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81f02b:	00 00 00 
  81f02e:	ff d0                	callq  *%rax
  81f030:	0f b7 c0             	movzwl %ax,%eax
  81f033:	83 e0 01             	and    $0x1,%eax
  81f036:	84 c0                	test   %al,%al
  81f038:	75 27                	jne    81f061 <tcp_receive+0x12af>
  81f03a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f03e:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f042:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f046:	0f b7 c0             	movzwl %ax,%eax
  81f049:	89 c7                	mov    %eax,%edi
  81f04b:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81f052:	00 00 00 
  81f055:	ff d0                	callq  *%rax
  81f057:	0f b7 c0             	movzwl %ax,%eax
  81f05a:	83 e0 02             	and    $0x2,%eax
  81f05d:	85 c0                	test   %eax,%eax
  81f05f:	74 07                	je     81f068 <tcp_receive+0x12b6>
  81f061:	b8 01 00 00 00       	mov    $0x1,%eax
  81f066:	eb 05                	jmp    81f06d <tcp_receive+0x12bb>
  81f068:	b8 00 00 00 00       	mov    $0x0,%eax
  81f06d:	44 01 e0             	add    %r12d,%eax
  81f070:	39 c3                	cmp    %eax,%ebx
  81f072:	7d 0c                	jge    81f080 <tcp_receive+0x12ce>
            pcb->rcv_ann_wnd = 0;
  81f074:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f078:	66 c7 40 36 00 00    	movw   $0x0,0x36(%rax)
  81f07e:	eb 7b                	jmp    81f0fb <tcp_receive+0x1349>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  81f080:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f084:	0f b7 58 36          	movzwl 0x36(%rax),%ebx
  81f088:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f08c:	44 0f b7 60 18       	movzwl 0x18(%rax),%r12d
  81f091:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f095:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f099:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f09d:	0f b7 c0             	movzwl %ax,%eax
  81f0a0:	89 c7                	mov    %eax,%edi
  81f0a2:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81f0a9:	00 00 00 
  81f0ac:	ff d0                	callq  *%rax
  81f0ae:	0f b7 c0             	movzwl %ax,%eax
  81f0b1:	83 e0 01             	and    $0x1,%eax
  81f0b4:	84 c0                	test   %al,%al
  81f0b6:	75 27                	jne    81f0df <tcp_receive+0x132d>
  81f0b8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f0bc:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f0c0:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f0c4:	0f b7 c0             	movzwl %ax,%eax
  81f0c7:	89 c7                	mov    %eax,%edi
  81f0c9:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81f0d0:	00 00 00 
  81f0d3:	ff d0                	callq  *%rax
  81f0d5:	0f b7 c0             	movzwl %ax,%eax
  81f0d8:	83 e0 02             	and    $0x2,%eax
  81f0db:	85 c0                	test   %eax,%eax
  81f0dd:	74 07                	je     81f0e6 <tcp_receive+0x1334>
  81f0df:	b8 01 00 00 00       	mov    $0x1,%eax
  81f0e4:	eb 05                	jmp    81f0eb <tcp_receive+0x1339>
  81f0e6:	b8 00 00 00 00       	mov    $0x0,%eax
  81f0eb:	44 01 e0             	add    %r12d,%eax
  81f0ee:	89 da                	mov    %ebx,%edx
  81f0f0:	66 29 c2             	sub    %ax,%dx
  81f0f3:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f0f7:	66 89 50 36          	mov    %dx,0x36(%rax)
          }

          if (cseg->p->tot_len > 0) {
  81f0fb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f0ff:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f103:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81f107:	66 85 c0             	test   %ax,%ax
  81f10a:	74 5c                	je     81f168 <tcp_receive+0x13b6>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  81f10c:	48 b8 88 75 b5 00 00 	movabs $0xb57588,%rax
  81f113:	00 00 00 
  81f116:	48 8b 00             	mov    (%rax),%rax
  81f119:	48 85 c0             	test   %rax,%rax
  81f11c:	74 29                	je     81f147 <tcp_receive+0x1395>
              pbuf_cat(recv_data, cseg->p);
  81f11e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f122:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81f126:	48 b8 88 75 b5 00 00 	movabs $0xb57588,%rax
  81f12d:	00 00 00 
  81f130:	48 8b 00             	mov    (%rax),%rax
  81f133:	48 89 d6             	mov    %rdx,%rsi
  81f136:	48 89 c7             	mov    %rax,%rdi
  81f139:	48 b8 37 db 80 00 00 	movabs $0x80db37,%rax
  81f140:	00 00 00 
  81f143:	ff d0                	callq  *%rax
  81f145:	eb 15                	jmp    81f15c <tcp_receive+0x13aa>
            } else {
              recv_data = cseg->p;
  81f147:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f14b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  81f14f:	48 b8 88 75 b5 00 00 	movabs $0xb57588,%rax
  81f156:	00 00 00 
  81f159:	48 89 10             	mov    %rdx,(%rax)
            }
            cseg->p = NULL;
  81f15c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f160:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  81f167:	00 
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  81f168:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f16c:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f170:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f174:	0f b7 c0             	movzwl %ax,%eax
  81f177:	89 c7                	mov    %eax,%edi
  81f179:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81f180:	00 00 00 
  81f183:	ff d0                	callq  *%rax
  81f185:	0f b7 c0             	movzwl %ax,%eax
  81f188:	83 e0 01             	and    $0x1,%eax
  81f18b:	84 c0                	test   %al,%al
  81f18d:	74 24                	je     81f1b3 <tcp_receive+0x1401>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  81f18f:	48 b8 84 75 b5 00 00 	movabs $0xb57584,%rax
  81f196:	00 00 00 
  81f199:	c6 00 20             	movb   $0x20,(%rax)
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  81f19c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f1a0:	8b 40 18             	mov    0x18(%rax),%eax
  81f1a3:	83 f8 04             	cmp    $0x4,%eax
  81f1a6:	75 0b                	jne    81f1b3 <tcp_receive+0x1401>
              pcb->state = CLOSE_WAIT;
  81f1a8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f1ac:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%rax)
            } 
          }


          pcb->ooseq = cseg->next;
  81f1b3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f1b7:	48 8b 10             	mov    (%rax),%rdx
  81f1ba:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f1be:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
          tcp_seg_free(cseg);
  81f1c5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f1c9:	48 89 c7             	mov    %rax,%rdi
  81f1cc:	48 b8 b3 00 81 00 00 	movabs $0x8100b3,%rax
  81f1d3:	00 00 00 
  81f1d6:	ff d0                	callq  *%rax
  81f1d8:	eb 01                	jmp    81f1db <tcp_receive+0x1429>
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81f1da:	90                   	nop
  81f1db:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f1df:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f1e6:	48 85 c0             	test   %rax,%rax
  81f1e9:	74 21                	je     81f20c <tcp_receive+0x145a>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  81f1eb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f1ef:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f1f6:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f1fa:	8b 50 04             	mov    0x4(%rax),%edx
  81f1fd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f201:	8b 40 30             	mov    0x30(%rax),%eax
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81f204:	39 c2                	cmp    %eax,%edx
  81f206:	0f 84 4a fc ff ff    	je     81ee56 <tcp_receive+0x10a4>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  81f20c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f210:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f214:	0f b6 c0             	movzbl %al,%eax
  81f217:	83 e0 01             	and    $0x1,%eax
  81f21a:	84 c0                	test   %al,%al
  81f21c:	74 40                	je     81f25e <tcp_receive+0x14ac>
  81f21e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f222:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f226:	89 c2                	mov    %eax,%edx
  81f228:	83 e2 fe             	and    $0xfffffffe,%edx
  81f22b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f22f:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f232:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f236:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f23a:	89 c2                	mov    %eax,%edx
  81f23c:	83 ca 02             	or     $0x2,%edx
  81f23f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f243:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f246:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f24a:	48 89 c7             	mov    %rax,%rdi
  81f24d:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  81f254:	00 00 00 
  81f257:	ff d0                	callq  *%rax
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81f259:	e9 14 06 00 00       	jmpq   81f872 <tcp_receive+0x1ac0>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  81f25e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f262:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f266:	89 c2                	mov    %eax,%edx
  81f268:	83 ca 01             	or     $0x1,%edx
  81f26b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f26f:	88 50 2c             	mov    %dl,0x2c(%rax)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81f272:	e9 fb 05 00 00       	jmpq   81f872 <tcp_receive+0x1ac0>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  81f277:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f27b:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f27f:	89 c2                	mov    %eax,%edx
  81f281:	83 ca 02             	or     $0x2,%edx
  81f284:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f288:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f28b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f28f:	48 89 c7             	mov    %rax,%rdi
  81f292:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  81f299:	00 00 00 
  81f29c:	ff d0                	callq  *%rax
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  81f29e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f2a2:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f2a9:	48 85 c0             	test   %rax,%rax
  81f2ac:	75 26                	jne    81f2d4 <tcp_receive+0x1522>
          pcb->ooseq = tcp_seg_copy(&inseg);
  81f2ae:	48 bf 40 75 b5 00 00 	movabs $0xb57540,%rdi
  81f2b5:	00 00 00 
  81f2b8:	48 b8 2d 01 81 00 00 	movabs $0x81012d,%rax
  81f2bf:	00 00 00 
  81f2c2:	ff d0                	callq  *%rax
  81f2c4:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  81f2c8:	48 89 82 90 00 00 00 	mov    %rax,0x90(%rdx)
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81f2cf:	e9 9e 05 00 00       	jmpq   81f872 <tcp_receive+0x1ac0>

             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
  81f2d4:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  81f2db:	00 
          for(next = pcb->ooseq; next != NULL; next = next->next) {
  81f2dc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f2e0:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  81f2e7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81f2eb:	e9 c5 04 00 00       	jmpq   81f7b5 <tcp_receive+0x1a03>
            if (seqno == next->tcphdr->seqno) {
  81f2f0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f2f4:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f2f8:	8b 50 04             	mov    0x4(%rax),%edx
  81f2fb:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81f302:	00 00 00 
  81f305:	8b 00                	mov    (%rax),%eax
  81f307:	39 c2                	cmp    %eax,%edx
  81f309:	0f 85 22 01 00 00    	jne    81f431 <tcp_receive+0x167f>
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  81f30f:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81f316:	00 00 00 
  81f319:	0f b7 50 18          	movzwl 0x18(%rax),%edx
  81f31d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f321:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f325:	66 39 c2             	cmp    %ax,%dx
  81f328:	0f 86 97 04 00 00    	jbe    81f7c5 <tcp_receive+0x1a13>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  81f32e:	48 bf 40 75 b5 00 00 	movabs $0xb57540,%rdi
  81f335:	00 00 00 
  81f338:	48 b8 2d 01 81 00 00 	movabs $0x81012d,%rax
  81f33f:	00 00 00 
  81f342:	ff d0                	callq  *%rax
  81f344:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                if (cseg != NULL) {
  81f348:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81f34d:	0f 84 75 04 00 00    	je     81f7c8 <tcp_receive+0x1a16>
                  cseg->next = next->next;
  81f353:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f357:	48 8b 10             	mov    (%rax),%rdx
  81f35a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f35e:	48 89 10             	mov    %rdx,(%rax)
                  if (prev != NULL) {
  81f361:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81f366:	74 0d                	je     81f375 <tcp_receive+0x15c3>
                    prev->next = cseg;
  81f368:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f36c:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f370:	48 89 10             	mov    %rdx,(%rax)
  81f373:	eb 0f                	jmp    81f384 <tcp_receive+0x15d2>
                  } else {
                    pcb->ooseq = cseg;
  81f375:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f379:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f37d:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
                  }
                  tcp_seg_free(next);
  81f384:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f388:	48 89 c7             	mov    %rax,%rdi
  81f38b:	48 b8 b3 00 81 00 00 	movabs $0x8100b3,%rax
  81f392:	00 00 00 
  81f395:	ff d0                	callq  *%rax
                  if (cseg->next != NULL) {
  81f397:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f39b:	48 8b 00             	mov    (%rax),%rax
  81f39e:	48 85 c0             	test   %rax,%rax
  81f3a1:	0f 84 21 04 00 00    	je     81f7c8 <tcp_receive+0x1a16>
                    next = cseg->next;
  81f3a7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f3ab:	48 8b 00             	mov    (%rax),%rax
  81f3ae:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  81f3b2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f3b6:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f3ba:	0f b7 d0             	movzwl %ax,%edx
  81f3bd:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81f3c4:	00 00 00 
  81f3c7:	8b 00                	mov    (%rax),%eax
  81f3c9:	01 c2                	add    %eax,%edx
  81f3cb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f3cf:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f3d3:	8b 40 04             	mov    0x4(%rax),%eax
  81f3d6:	89 d1                	mov    %edx,%ecx
  81f3d8:	29 c1                	sub    %eax,%ecx
  81f3da:	89 c8                	mov    %ecx,%eax
  81f3dc:	85 c0                	test   %eax,%eax
  81f3de:	0f 8e e4 03 00 00    	jle    81f7c8 <tcp_receive+0x1a16>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  81f3e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f3e8:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f3ec:	8b 40 04             	mov    0x4(%rax),%eax
  81f3ef:	89 c2                	mov    %eax,%edx
  81f3f1:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81f3f8:	00 00 00 
  81f3fb:	8b 00                	mov    (%rax),%eax
  81f3fd:	66 29 c2             	sub    %ax,%dx
  81f400:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f404:	66 89 50 18          	mov    %dx,0x18(%rax)
                      pbuf_realloc(cseg->p, cseg->len);
  81f408:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f40c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f410:	0f b7 d0             	movzwl %ax,%edx
  81f413:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f417:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f41b:	89 d6                	mov    %edx,%esi
  81f41d:	48 89 c7             	mov    %rax,%rdi
  81f420:	48 b8 1f d5 80 00 00 	movabs $0x80d51f,%rax
  81f427:	00 00 00 
  81f42a:	ff d0                	callq  *%rax
                    }
                  }
                }
                break;
  81f42c:	e9 97 03 00 00       	jmpq   81f7c8 <tcp_receive+0x1a16>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  81f431:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  81f436:	0f 85 f7 00 00 00    	jne    81f533 <tcp_receive+0x1781>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  81f43c:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81f443:	00 00 00 
  81f446:	8b 10                	mov    (%rax),%edx
  81f448:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f44c:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f450:	8b 40 04             	mov    0x4(%rax),%eax
  81f453:	89 d3                	mov    %edx,%ebx
  81f455:	29 c3                	sub    %eax,%ebx
  81f457:	89 d8                	mov    %ebx,%eax
  81f459:	85 c0                	test   %eax,%eax
  81f45b:	0f 89 67 02 00 00    	jns    81f6c8 <tcp_receive+0x1916>
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  81f461:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81f468:	00 00 00 
  81f46b:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f46f:	0f b7 d0             	movzwl %ax,%edx
  81f472:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81f479:	00 00 00 
  81f47c:	8b 00                	mov    (%rax),%eax
  81f47e:	01 c2                	add    %eax,%edx
  81f480:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f484:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f488:	8b 40 04             	mov    0x4(%rax),%eax
  81f48b:	89 d1                	mov    %edx,%ecx
  81f48d:	29 c1                	sub    %eax,%ecx
  81f48f:	89 c8                	mov    %ecx,%eax
  81f491:	85 c0                	test   %eax,%eax
  81f493:	7e 5a                	jle    81f4ef <tcp_receive+0x173d>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  81f495:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f499:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f49d:	8b 40 04             	mov    0x4(%rax),%eax
  81f4a0:	89 c2                	mov    %eax,%edx
  81f4a2:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81f4a9:	00 00 00 
  81f4ac:	8b 00                	mov    (%rax),%eax
  81f4ae:	66 29 c2             	sub    %ax,%dx
  81f4b1:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81f4b8:	00 00 00 
  81f4bb:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(inseg.p, inseg.len);
  81f4bf:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81f4c6:	00 00 00 
  81f4c9:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f4cd:	0f b7 d0             	movzwl %ax,%edx
  81f4d0:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81f4d7:	00 00 00 
  81f4da:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f4de:	89 d6                	mov    %edx,%esi
  81f4e0:	48 89 c7             	mov    %rax,%rdi
  81f4e3:	48 b8 1f d5 80 00 00 	movabs $0x80d51f,%rax
  81f4ea:	00 00 00 
  81f4ed:	ff d0                	callq  *%rax
                  }
                  cseg = tcp_seg_copy(&inseg);
  81f4ef:	48 bf 40 75 b5 00 00 	movabs $0xb57540,%rdi
  81f4f6:	00 00 00 
  81f4f9:	48 b8 2d 01 81 00 00 	movabs $0x81012d,%rax
  81f500:	00 00 00 
  81f503:	ff d0                	callq  *%rax
  81f505:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                  if (cseg != NULL) {
  81f509:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81f50e:	0f 84 b7 02 00 00    	je     81f7cb <tcp_receive+0x1a19>
                    cseg->next = next;
  81f514:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f518:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81f51c:	48 89 10             	mov    %rdx,(%rax)
                    pcb->ooseq = cseg;
  81f51f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f523:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f527:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
                  }
                  break;
  81f52e:	e9 98 02 00 00       	jmpq   81f7cb <tcp_receive+0x1a19>
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  81f533:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f537:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f53b:	8b 40 04             	mov    0x4(%rax),%eax
  81f53e:	89 c2                	mov    %eax,%edx
  81f540:	f7 d2                	not    %edx
  81f542:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81f549:	00 00 00 
  81f54c:	8b 00                	mov    (%rax),%eax
  81f54e:	01 d0                	add    %edx,%eax
  81f550:	85 c0                	test   %eax,%eax
  81f552:	0f 88 70 01 00 00    	js     81f6c8 <tcp_receive+0x1916>
  81f558:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81f55f:	00 00 00 
  81f562:	8b 10                	mov    (%rax),%edx
  81f564:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f568:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f56c:	8b 40 04             	mov    0x4(%rax),%eax
  81f56f:	89 d3                	mov    %edx,%ebx
  81f571:	29 c3                	sub    %eax,%ebx
  81f573:	89 d8                	mov    %ebx,%eax
  81f575:	83 c0 01             	add    $0x1,%eax
  81f578:	85 c0                	test   %eax,%eax
  81f57a:	0f 8f 48 01 00 00    	jg     81f6c8 <tcp_receive+0x1916>
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  81f580:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81f587:	00 00 00 
  81f58a:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f58e:	0f b7 d0             	movzwl %ax,%edx
  81f591:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81f598:	00 00 00 
  81f59b:	8b 00                	mov    (%rax),%eax
  81f59d:	01 c2                	add    %eax,%edx
  81f59f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f5a3:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f5a7:	8b 40 04             	mov    0x4(%rax),%eax
  81f5aa:	89 d1                	mov    %edx,%ecx
  81f5ac:	29 c1                	sub    %eax,%ecx
  81f5ae:	89 c8                	mov    %ecx,%eax
  81f5b0:	85 c0                	test   %eax,%eax
  81f5b2:	7e 5a                	jle    81f60e <tcp_receive+0x185c>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  81f5b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f5b8:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f5bc:	8b 40 04             	mov    0x4(%rax),%eax
  81f5bf:	89 c2                	mov    %eax,%edx
  81f5c1:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81f5c8:	00 00 00 
  81f5cb:	8b 00                	mov    (%rax),%eax
  81f5cd:	66 29 c2             	sub    %ax,%dx
  81f5d0:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81f5d7:	00 00 00 
  81f5da:	66 89 50 18          	mov    %dx,0x18(%rax)
                  pbuf_realloc(inseg.p, inseg.len);
  81f5de:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81f5e5:	00 00 00 
  81f5e8:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f5ec:	0f b7 d0             	movzwl %ax,%edx
  81f5ef:	48 b8 40 75 b5 00 00 	movabs $0xb57540,%rax
  81f5f6:	00 00 00 
  81f5f9:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f5fd:	89 d6                	mov    %edx,%esi
  81f5ff:	48 89 c7             	mov    %rax,%rdi
  81f602:	48 b8 1f d5 80 00 00 	movabs $0x80d51f,%rax
  81f609:	00 00 00 
  81f60c:	ff d0                	callq  *%rax
                }

                cseg = tcp_seg_copy(&inseg);
  81f60e:	48 bf 40 75 b5 00 00 	movabs $0xb57540,%rdi
  81f615:	00 00 00 
  81f618:	48 b8 2d 01 81 00 00 	movabs $0x81012d,%rax
  81f61f:	00 00 00 
  81f622:	ff d0                	callq  *%rax
  81f624:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                if (cseg != NULL) {
  81f628:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  81f62d:	0f 84 9b 01 00 00    	je     81f7ce <tcp_receive+0x1a1c>
                  cseg->next = next;
  81f633:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  81f637:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81f63b:	48 89 10             	mov    %rdx,(%rax)
                  prev->next = cseg;
  81f63e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f642:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  81f646:	48 89 10             	mov    %rdx,(%rax)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  81f649:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f64d:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f651:	8b 50 04             	mov    0x4(%rax),%edx
  81f654:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f658:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f65c:	0f b7 c0             	movzwl %ax,%eax
  81f65f:	01 c2                	add    %eax,%edx
  81f661:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81f668:	00 00 00 
  81f66b:	8b 00                	mov    (%rax),%eax
  81f66d:	89 d3                	mov    %edx,%ebx
  81f66f:	29 c3                	sub    %eax,%ebx
  81f671:	89 d8                	mov    %ebx,%eax
  81f673:	85 c0                	test   %eax,%eax
  81f675:	0f 8e 53 01 00 00    	jle    81f7ce <tcp_receive+0x1a1c>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  81f67b:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81f682:	00 00 00 
  81f685:	8b 00                	mov    (%rax),%eax
  81f687:	89 c2                	mov    %eax,%edx
  81f689:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f68d:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f691:	8b 40 04             	mov    0x4(%rax),%eax
  81f694:	66 29 c2             	sub    %ax,%dx
  81f697:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f69b:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(prev->p, prev->len);
  81f69f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f6a3:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f6a7:	0f b7 d0             	movzwl %ax,%edx
  81f6aa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81f6ae:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f6b2:	89 d6                	mov    %edx,%esi
  81f6b4:	48 89 c7             	mov    %rax,%rdi
  81f6b7:	48 b8 1f d5 80 00 00 	movabs $0x80d51f,%rax
  81f6be:	00 00 00 
  81f6c1:	ff d0                	callq  *%rax
                  }
                }
                break;
  81f6c3:	e9 06 01 00 00       	jmpq   81f7ce <tcp_receive+0x1a1c>
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  81f6c8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f6cc:	48 8b 00             	mov    (%rax),%rax
  81f6cf:	48 85 c0             	test   %rax,%rax
  81f6d2:	0f 85 ca 00 00 00    	jne    81f7a2 <tcp_receive+0x19f0>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  81f6d8:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81f6df:	00 00 00 
  81f6e2:	8b 10                	mov    (%rax),%edx
  81f6e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f6e8:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f6ec:	8b 40 04             	mov    0x4(%rax),%eax
  81f6ef:	89 d1                	mov    %edx,%ecx
  81f6f1:	29 c1                	sub    %eax,%ecx
  81f6f3:	89 c8                	mov    %ecx,%eax
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  81f6f5:	85 c0                	test   %eax,%eax
  81f6f7:	0f 8e a5 00 00 00    	jle    81f7a2 <tcp_receive+0x19f0>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  81f6fd:	48 bf 40 75 b5 00 00 	movabs $0xb57540,%rdi
  81f704:	00 00 00 
  81f707:	48 b8 2d 01 81 00 00 	movabs $0x81012d,%rax
  81f70e:	00 00 00 
  81f711:	ff d0                	callq  *%rax
  81f713:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  81f717:	48 89 02             	mov    %rax,(%rdx)
                if (next->next != NULL) {
  81f71a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f71e:	48 8b 00             	mov    (%rax),%rax
  81f721:	48 85 c0             	test   %rax,%rax
  81f724:	0f 84 a7 00 00 00    	je     81f7d1 <tcp_receive+0x1a1f>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  81f72a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f72e:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f732:	8b 50 04             	mov    0x4(%rax),%edx
  81f735:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f739:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f73d:	0f b7 c0             	movzwl %ax,%eax
  81f740:	01 c2                	add    %eax,%edx
  81f742:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81f749:	00 00 00 
  81f74c:	8b 00                	mov    (%rax),%eax
  81f74e:	89 d3                	mov    %edx,%ebx
  81f750:	29 c3                	sub    %eax,%ebx
  81f752:	89 d8                	mov    %ebx,%eax
  81f754:	85 c0                	test   %eax,%eax
  81f756:	7e 79                	jle    81f7d1 <tcp_receive+0x1a1f>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  81f758:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81f75f:	00 00 00 
  81f762:	8b 00                	mov    (%rax),%eax
  81f764:	89 c2                	mov    %eax,%edx
  81f766:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f76a:	48 8b 40 20          	mov    0x20(%rax),%rax
  81f76e:	8b 40 04             	mov    0x4(%rax),%eax
  81f771:	66 29 c2             	sub    %ax,%dx
  81f774:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f778:	66 89 50 18          	mov    %dx,0x18(%rax)
                    pbuf_realloc(next->p, next->len);
  81f77c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f780:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  81f784:	0f b7 d0             	movzwl %ax,%edx
  81f787:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f78b:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f78f:	89 d6                	mov    %edx,%esi
  81f791:	48 89 c7             	mov    %rax,%rdi
  81f794:	48 b8 1f d5 80 00 00 	movabs $0x80d51f,%rax
  81f79b:	00 00 00 
  81f79e:	ff d0                	callq  *%rax
                  }
                }
                break;
  81f7a0:	eb 2f                	jmp    81f7d1 <tcp_receive+0x1a1f>
              }
            }
            prev = next;
  81f7a2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f7a6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
             If the incoming segment has the same sequence number as a
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
  81f7aa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81f7ae:	48 8b 00             	mov    (%rax),%rax
  81f7b1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  81f7b5:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  81f7ba:	0f 85 30 fb ff ff    	jne    81f2f0 <tcp_receive+0x153e>
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81f7c0:	e9 ad 00 00 00       	jmpq   81f872 <tcp_receive+0x1ac0>
                break;
              } else {
                /* Either the lenghts are the same or the incoming
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
  81f7c5:	90                   	nop
  81f7c6:	eb 0a                	jmp    81f7d2 <tcp_receive+0x1a20>
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
                      pbuf_realloc(cseg->p, cseg->len);
                    }
                  }
                }
                break;
  81f7c8:	90                   	nop
  81f7c9:	eb 07                	jmp    81f7d2 <tcp_receive+0x1a20>
                  cseg = tcp_seg_copy(&inseg);
                  if (cseg != NULL) {
                    cseg->next = next;
                    pcb->ooseq = cseg;
                  }
                  break;
  81f7cb:	90                   	nop
  81f7cc:	eb 04                	jmp    81f7d2 <tcp_receive+0x1a20>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
                    pbuf_realloc(prev->p, prev->len);
                  }
                }
                break;
  81f7ce:	90                   	nop
  81f7cf:	eb 01                	jmp    81f7d2 <tcp_receive+0x1a20>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
                    pbuf_realloc(next->p, next->len);
                  }
                }
                break;
  81f7d1:	90                   	nop
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  81f7d2:	90                   	nop
  81f7d3:	e9 9a 00 00 00       	jmpq   81f872 <tcp_receive+0x1ac0>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  81f7d8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f7dc:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f7e0:	89 c2                	mov    %eax,%edx
  81f7e2:	83 ca 02             	or     $0x2,%edx
  81f7e5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f7e9:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f7ec:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f7f0:	48 89 c7             	mov    %rax,%rdi
  81f7f3:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  81f7fa:	00 00 00 
  81f7fd:	ff d0                	callq  *%rax
  81f7ff:	eb 71                	jmp    81f872 <tcp_receive+0x1ac0>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  81f801:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81f808:	00 00 00 
  81f80b:	8b 10                	mov    (%rax),%edx
  81f80d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f811:	8b 40 30             	mov    0x30(%rax),%eax
  81f814:	89 d1                	mov    %edx,%ecx
  81f816:	29 c1                	sub    %eax,%ecx
  81f818:	89 c8                	mov    %ecx,%eax
  81f81a:	85 c0                	test   %eax,%eax
  81f81c:	78 2d                	js     81f84b <tcp_receive+0x1a99>
  81f81e:	48 b8 78 75 b5 00 00 	movabs $0xb57578,%rax
  81f825:	00 00 00 
  81f828:	8b 10                	mov    (%rax),%edx
  81f82a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f82e:	8b 48 30             	mov    0x30(%rax),%ecx
  81f831:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f835:	0f b7 40 34          	movzwl 0x34(%rax),%eax
  81f839:	0f b7 c0             	movzwl %ax,%eax
  81f83c:	01 c8                	add    %ecx,%eax
  81f83e:	89 d3                	mov    %edx,%ebx
  81f840:	29 c3                	sub    %eax,%ebx
  81f842:	89 d8                	mov    %ebx,%eax
  81f844:	83 c0 01             	add    $0x1,%eax
  81f847:	85 c0                	test   %eax,%eax
  81f849:	7e 27                	jle    81f872 <tcp_receive+0x1ac0>
      tcp_ack_now(pcb);
  81f84b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f84f:	0f b6 40 2c          	movzbl 0x2c(%rax),%eax
  81f853:	89 c2                	mov    %eax,%edx
  81f855:	83 ca 02             	or     $0x2,%edx
  81f858:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f85c:	88 50 2c             	mov    %dl,0x2c(%rax)
  81f85f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  81f863:	48 89 c7             	mov    %rax,%rdi
  81f866:	48 b8 c2 38 81 00 00 	movabs $0x8138c2,%rax
  81f86d:	00 00 00 
  81f870:	ff d0                	callq  *%rax
    }
  }
  return accepted_inseq;
  81f872:	0f b6 45 c1          	movzbl -0x3f(%rbp),%eax
}
  81f876:	48 83 c4 58          	add    $0x58,%rsp
  81f87a:	5b                   	pop    %rbx
  81f87b:	41 5c                	pop    %r12
  81f87d:	41 5d                	pop    %r13
  81f87f:	5d                   	pop    %rbp
  81f880:	c3                   	retq   

000000000081f881 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  81f881:	55                   	push   %rbp
  81f882:	48 89 e5             	mov    %rsp,%rbp
  81f885:	53                   	push   %rbx
  81f886:	48 83 ec 38          	sub    $0x38,%rsp
  81f88a:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  81f88e:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81f895:	00 00 00 
  81f898:	48 8b 00             	mov    (%rax),%rax
  81f89b:	48 83 c0 14          	add    $0x14,%rax
  81f89f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  81f8a3:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81f8aa:	00 00 00 
  81f8ad:	48 8b 00             	mov    (%rax),%rax
  81f8b0:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f8b4:	0f b7 c0             	movzwl %ax,%eax
  81f8b7:	89 c7                	mov    %eax,%edi
  81f8b9:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81f8c0:	00 00 00 
  81f8c3:	ff d0                	callq  *%rax
  81f8c5:	66 c1 e8 0c          	shr    $0xc,%ax
  81f8c9:	66 83 f8 05          	cmp    $0x5,%ax
  81f8cd:	0f 86 02 01 00 00    	jbe    81f9d5 <tcp_parseopt+0x154>
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  81f8d3:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  81f8d7:	e9 b8 00 00 00       	jmpq   81f994 <tcp_parseopt+0x113>
      opt = opts[c];
  81f8dc:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81f8e0:	48 03 45 e0          	add    -0x20(%rbp),%rax
  81f8e4:	0f b6 00             	movzbl (%rax),%eax
  81f8e7:	88 45 df             	mov    %al,-0x21(%rbp)
      if (opt == 0x00) {
  81f8ea:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  81f8ee:	0f 84 dd 00 00 00    	je     81f9d1 <tcp_parseopt+0x150>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
  81f8f4:	80 7d df 01          	cmpb   $0x1,-0x21(%rbp)
  81f8f8:	75 09                	jne    81f903 <tcp_parseopt+0x82>
        ++c;
  81f8fa:	80 45 ef 01          	addb   $0x1,-0x11(%rbp)
  81f8fe:	e9 91 00 00 00       	jmpq   81f994 <tcp_parseopt+0x113>
        /* NOP option. */
      } else if (opt == 0x02 &&
  81f903:	80 7d df 02          	cmpb   $0x2,-0x21(%rbp)
  81f907:	75 66                	jne    81f96f <tcp_parseopt+0xee>
        opts[c + 1] == 0x04) {
  81f909:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81f90d:	48 83 c0 01          	add    $0x1,%rax
  81f911:	48 03 45 e0          	add    -0x20(%rbp),%rax
  81f915:	0f b6 00             	movzbl (%rax),%eax
        /* End of options. */
        break;
      } else if (opt == 0x01) {
        ++c;
        /* NOP option. */
      } else if (opt == 0x02 &&
  81f918:	3c 04                	cmp    $0x4,%al
  81f91a:	75 53                	jne    81f96f <tcp_parseopt+0xee>
        opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  81f91c:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81f920:	48 83 c0 02          	add    $0x2,%rax
  81f924:	48 03 45 e0          	add    -0x20(%rbp),%rax
  81f928:	0f b6 00             	movzbl (%rax),%eax
  81f92b:	0f b6 c0             	movzbl %al,%eax
  81f92e:	c1 e0 08             	shl    $0x8,%eax
  81f931:	89 c2                	mov    %eax,%edx
  81f933:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81f937:	48 83 c0 03          	add    $0x3,%rax
  81f93b:	48 03 45 e0          	add    -0x20(%rbp),%rax
  81f93f:	0f b6 00             	movzbl (%rax),%eax
  81f942:	0f b6 c0             	movzbl %al,%eax
  81f945:	09 d0                	or     %edx,%eax
  81f947:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  81f94b:	66 81 7d dc b4 05    	cmpw   $0x5b4,-0x24(%rbp)
  81f951:	77 0d                	ja     81f960 <tcp_parseopt+0xdf>
  81f953:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
  81f958:	74 06                	je     81f960 <tcp_parseopt+0xdf>
  81f95a:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  81f95e:	eb 05                	jmp    81f965 <tcp_parseopt+0xe4>
  81f960:	b8 b4 05 00 00       	mov    $0x5b4,%eax
  81f965:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81f969:	66 89 42 40          	mov    %ax,0x40(%rdx)

        /* And we are done processing options. */
        break;
  81f96d:	eb 66                	jmp    81f9d5 <tcp_parseopt+0x154>
      } else {
        if (opts[c + 1] == 0) {
  81f96f:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81f973:	48 83 c0 01          	add    $0x1,%rax
  81f977:	48 03 45 e0          	add    -0x20(%rbp),%rax
  81f97b:	0f b6 00             	movzbl (%rax),%eax
  81f97e:	84 c0                	test   %al,%al
  81f980:	74 52                	je     81f9d4 <tcp_parseopt+0x153>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  81f982:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  81f986:	48 83 c0 01          	add    $0x1,%rax
  81f98a:	48 03 45 e0          	add    -0x20(%rbp),%rax
  81f98e:	0f b6 00             	movzbl (%rax),%eax
  81f991:	00 45 ef             	add    %al,-0x11(%rbp)

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  81f994:	0f b6 5d ef          	movzbl -0x11(%rbp),%ebx
  81f998:	48 b8 68 75 b5 00 00 	movabs $0xb57568,%rax
  81f99f:	00 00 00 
  81f9a2:	48 8b 00             	mov    (%rax),%rax
  81f9a5:	0f b7 40 0c          	movzwl 0xc(%rax),%eax
  81f9a9:	0f b7 c0             	movzwl %ax,%eax
  81f9ac:	89 c7                	mov    %eax,%edi
  81f9ae:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81f9b5:	00 00 00 
  81f9b8:	ff d0                	callq  *%rax
  81f9ba:	66 c1 e8 0c          	shr    $0xc,%ax
  81f9be:	0f b7 c0             	movzwl %ax,%eax
  81f9c1:	83 e8 05             	sub    $0x5,%eax
  81f9c4:	c1 e0 02             	shl    $0x2,%eax
  81f9c7:	39 c3                	cmp    %eax,%ebx
  81f9c9:	0f 8c 0d ff ff ff    	jl     81f8dc <tcp_parseopt+0x5b>
  81f9cf:	eb 04                	jmp    81f9d5 <tcp_parseopt+0x154>
      opt = opts[c];
      if (opt == 0x00) {
        /* End of options. */
        break;
  81f9d1:	90                   	nop
  81f9d2:	eb 01                	jmp    81f9d5 <tcp_parseopt+0x154>
        break;
      } else {
        if (opts[c + 1] == 0) {
          /* If the length field is zero, the options are malformed
             and we don't process them further. */
          break;
  81f9d4:	90                   	nop
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  81f9d5:	48 83 c4 38          	add    $0x38,%rsp
  81f9d9:	5b                   	pop    %rbx
  81f9da:	5d                   	pop    %rbp
  81f9db:	c3                   	retq   

000000000081f9dc <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  81f9dc:	55                   	push   %rbp
  81f9dd:	48 89 e5             	mov    %rsp,%rbp
  81f9e0:	48 83 ec 40          	sub    $0x40,%rsp
  81f9e4:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  81f9e8:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
  81f9ec:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  81f9f0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81f9f4:	48 8b 40 08          	mov    0x8(%rax),%rax
  81f9f8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  proto = IPH_PROTO(iphdr);
  81f9fc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fa00:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  81fa04:	0f b7 c0             	movzwl %ax,%eax
  81fa07:	89 c7                	mov    %eax,%edi
  81fa09:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81fa10:	00 00 00 
  81fa13:	ff d0                	callq  *%rax
  81fa15:	66 25 ff 00          	and    $0xff,%ax
  81fa19:	66 89 45 de          	mov    %ax,-0x22(%rbp)

  prev = NULL;
  81fa1d:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  81fa24:	00 
  pcb = raw_pcbs;
  81fa25:	48 b8 90 75 b5 00 00 	movabs $0xb57590,%rax
  81fa2c:	00 00 00 
  81fa2f:	48 8b 00             	mov    (%rax),%rax
  81fa32:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  81fa36:	e9 ab 00 00 00       	jmpq   81fae6 <raw_input+0x10a>
    if (pcb->protocol == proto) {
  81fa3b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fa3f:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81fa43:	0f b6 d0             	movzbl %al,%edx
  81fa46:	0f bf 45 de          	movswl -0x22(%rbp),%eax
  81fa4a:	39 c2                	cmp    %eax,%edx
  81fa4c:	0f 85 80 00 00 00    	jne    81fad2 <raw_input+0xf6>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  81fa52:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fa56:	48 8b 40 20          	mov    0x20(%rax),%rax
  81fa5a:	48 85 c0             	test   %rax,%rax
  81fa5d:	74 73                	je     81fad2 <raw_input+0xf6>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  81fa5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fa63:	4c 8b 40 20          	mov    0x20(%rax),%r8
  81fa67:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  81fa6b:	48 8d 48 0c          	lea    0xc(%rax),%rcx
  81fa6f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fa73:	48 8b 40 28          	mov    0x28(%rax),%rax
  81fa77:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81fa7b:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  81fa7f:	48 89 c7             	mov    %rax,%rdi
  81fa82:	41 ff d0             	callq  *%r8
  81fa85:	84 c0                	test   %al,%al
  81fa87:	74 49                	je     81fad2 <raw_input+0xf6>
        {
          /* receive function ate the packet */
          p = NULL;
  81fa89:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  81fa90:	00 
          eaten = 1;
  81fa91:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
          if (prev != NULL) {
  81fa95:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81fa9a:	74 36                	je     81fad2 <raw_input+0xf6>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  81fa9c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81faa0:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81faa4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81faa8:	48 89 50 10          	mov    %rdx,0x10(%rax)
            pcb->next = raw_pcbs;
  81faac:	48 b8 90 75 b5 00 00 	movabs $0xb57590,%rax
  81fab3:	00 00 00 
  81fab6:	48 8b 10             	mov    (%rax),%rdx
  81fab9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fabd:	48 89 50 10          	mov    %rdx,0x10(%rax)
            raw_pcbs = pcb;
  81fac1:	48 b8 90 75 b5 00 00 	movabs $0xb57590,%rax
  81fac8:	00 00 00 
  81facb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81facf:	48 89 10             	mov    %rdx,(%rax)
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  81fad2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fad6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    pcb = pcb->next;
  81fada:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fade:	48 8b 40 10          	mov    0x10(%rax),%rax
  81fae2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  81fae6:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  81faea:	75 0b                	jne    81faf7 <raw_input+0x11b>
  81faec:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81faf1:	0f 85 44 ff ff ff    	jne    81fa3b <raw_input+0x5f>
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
  81faf7:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
}
  81fafb:	c9                   	leaveq 
  81fafc:	c3                   	retq   

000000000081fafd <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  81fafd:	55                   	push   %rbp
  81fafe:	48 89 e5             	mov    %rsp,%rbp
  81fb01:	48 83 ec 10          	sub    $0x10,%rsp
  81fb05:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81fb09:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&pcb->local_ip, ipaddr);
  81fb0d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81fb12:	74 08                	je     81fb1c <raw_bind+0x1f>
  81fb14:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fb18:	8b 00                	mov    (%rax),%eax
  81fb1a:	eb 05                	jmp    81fb21 <raw_bind+0x24>
  81fb1c:	b8 00 00 00 00       	mov    $0x0,%eax
  81fb21:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81fb25:	89 02                	mov    %eax,(%rdx)
  return ERR_OK;
  81fb27:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81fb2c:	c9                   	leaveq 
  81fb2d:	c3                   	retq   

000000000081fb2e <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  81fb2e:	55                   	push   %rbp
  81fb2f:	48 89 e5             	mov    %rsp,%rbp
  81fb32:	48 83 ec 10          	sub    $0x10,%rsp
  81fb36:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81fb3a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  ip_addr_set(&pcb->remote_ip, ipaddr);
  81fb3e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81fb43:	74 08                	je     81fb4d <raw_connect+0x1f>
  81fb45:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fb49:	8b 00                	mov    (%rax),%eax
  81fb4b:	eb 05                	jmp    81fb52 <raw_connect+0x24>
  81fb4d:	b8 00 00 00 00       	mov    $0x0,%eax
  81fb52:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81fb56:	89 42 04             	mov    %eax,0x4(%rdx)
  return ERR_OK;
  81fb59:	b8 00 00 00 00       	mov    $0x0,%eax
}
  81fb5e:	c9                   	leaveq 
  81fb5f:	c3                   	retq   

000000000081fb60 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  81fb60:	55                   	push   %rbp
  81fb61:	48 89 e5             	mov    %rsp,%rbp
  81fb64:	48 83 ec 18          	sub    $0x18,%rsp
  81fb68:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81fb6c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  81fb70:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  /* remember recv() callback and user data */
  pcb->recv = recv;
  81fb74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fb78:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  81fb7c:	48 89 50 20          	mov    %rdx,0x20(%rax)
  pcb->recv_arg = recv_arg;
  81fb80:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fb84:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  81fb88:	48 89 50 28          	mov    %rdx,0x28(%rax)
}
  81fb8c:	c9                   	leaveq 
  81fb8d:	c3                   	retq   

000000000081fb8e <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  81fb8e:	55                   	push   %rbp
  81fb8f:	48 89 e5             	mov    %rsp,%rbp
  81fb92:	48 83 ec 50          	sub    $0x50,%rsp
  81fb96:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  81fb9a:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  81fb9e:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  81fba2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fba6:	be 14 00 00 00       	mov    $0x14,%esi
  81fbab:	48 89 c7             	mov    %rax,%rdi
  81fbae:	48 b8 6f d7 80 00 00 	movabs $0x80d76f,%rax
  81fbb5:	00 00 00 
  81fbb8:	ff d0                	callq  *%rax
  81fbba:	84 c0                	test   %al,%al
  81fbbc:	74 4c                	je     81fc0a <raw_sendto+0x7c>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  81fbbe:	ba 00 00 00 00       	mov    $0x0,%edx
  81fbc3:	be 00 00 00 00       	mov    $0x0,%esi
  81fbc8:	bf 01 00 00 00       	mov    $0x1,%edi
  81fbcd:	48 b8 4c d0 80 00 00 	movabs $0x80d04c,%rax
  81fbd4:	00 00 00 
  81fbd7:	ff d0                	callq  *%rax
  81fbd9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  81fbdd:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  81fbe2:	75 0a                	jne    81fbee <raw_sendto+0x60>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
  81fbe4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  81fbe9:	e9 42 01 00 00       	jmpq   81fd30 <raw_sendto+0x1a2>
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  81fbee:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  81fbf2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fbf6:	48 89 d6             	mov    %rdx,%rsi
  81fbf9:	48 89 c7             	mov    %rax,%rdi
  81fbfc:	48 b8 56 dc 80 00 00 	movabs $0x80dc56,%rax
  81fc03:	00 00 00 
  81fc06:	ff d0                	callq  *%rax
  81fc08:	eb 4e                	jmp    81fc58 <raw_sendto+0xca>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
  81fc0a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  81fc0e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    if(pbuf_header(q, -IP_HLEN)) {
  81fc12:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fc16:	be ec ff ff ff       	mov    $0xffffffec,%esi
  81fc1b:	48 89 c7             	mov    %rax,%rdi
  81fc1e:	48 b8 6f d7 80 00 00 	movabs $0x80d76f,%rax
  81fc25:	00 00 00 
  81fc28:	ff d0                	callq  *%rax
  81fc2a:	84 c0                	test   %al,%al
  81fc2c:	74 2a                	je     81fc58 <raw_sendto+0xca>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  81fc2e:	48 ba 18 39 82 00 00 	movabs $0x823918,%rdx
  81fc35:	00 00 00 
  81fc38:	be e3 00 00 00       	mov    $0xe3,%esi
  81fc3d:	48 bf 3e 39 82 00 00 	movabs $0x82393e,%rdi
  81fc44:	00 00 00 
  81fc47:	b8 00 00 00 00       	mov    $0x0,%eax
  81fc4c:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  81fc53:	00 00 00 
  81fc56:	ff d1                	callq  *%rcx
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  81fc58:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  81fc5c:	48 89 c7             	mov    %rax,%rdi
  81fc5f:	48 b8 20 0a 81 00 00 	movabs $0x810a20,%rax
  81fc66:	00 00 00 
  81fc69:	ff d0                	callq  *%rax
  81fc6b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  81fc6f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  81fc74:	75 27                	jne    81fc9d <raw_sendto+0x10f>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  81fc76:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fc7a:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  81fc7e:	74 13                	je     81fc93 <raw_sendto+0x105>
      pbuf_free(q);
  81fc80:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fc84:	48 89 c7             	mov    %rax,%rdi
  81fc87:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81fc8e:	00 00 00 
  81fc91:	ff d0                	callq  *%rax
    }
    return ERR_RTE;
  81fc93:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  81fc98:	e9 93 00 00 00       	jmpq   81fd30 <raw_sendto+0x1a2>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  81fc9d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fca1:	48 85 c0             	test   %rax,%rax
  81fca4:	74 0a                	je     81fcb0 <raw_sendto+0x122>
  81fca6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fcaa:	8b 00                	mov    (%rax),%eax
  81fcac:	85 c0                	test   %eax,%eax
  81fcae:	75 0e                	jne    81fcbe <raw_sendto+0x130>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  81fcb0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fcb4:	48 83 c0 08          	add    $0x8,%rax
  81fcb8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81fcbc:	eb 08                	jmp    81fcc6 <raw_sendto+0x138>
  } else {
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  81fcbe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fcc2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  81fcc6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fcca:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  81fcce:	44 0f b6 c8          	movzbl %al,%r9d
  81fcd2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fcd6:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  81fcda:	44 0f b6 c0          	movzbl %al,%r8d
  81fcde:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  81fce2:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  81fce6:	0f b6 c8             	movzbl %al,%ecx
  81fce9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  81fced:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  81fcf1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fcf5:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  81fcf9:	48 89 3c 24          	mov    %rdi,(%rsp)
  81fcfd:	48 89 c7             	mov    %rax,%rdi
  81fd00:	48 b8 57 0f 81 00 00 	movabs $0x810f57,%rax
  81fd07:	00 00 00 
  81fd0a:	ff d0                	callq  *%rax
  81fd0c:	88 45 e7             	mov    %al,-0x19(%rbp)
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  81fd0f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fd13:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  81fd17:	74 13                	je     81fd2c <raw_sendto+0x19e>
    /* free the header */
    pbuf_free(q);
  81fd19:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  81fd1d:	48 89 c7             	mov    %rax,%rdi
  81fd20:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81fd27:	00 00 00 
  81fd2a:	ff d0                	callq  *%rax
  }
  return err;
  81fd2c:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
}
  81fd30:	c9                   	leaveq 
  81fd31:	c3                   	retq   

000000000081fd32 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  81fd32:	55                   	push   %rbp
  81fd33:	48 89 e5             	mov    %rsp,%rbp
  81fd36:	48 83 ec 10          	sub    $0x10,%rsp
  81fd3a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  81fd3e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  return raw_sendto(pcb, p, &pcb->remote_ip);
  81fd42:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fd46:	48 8d 50 04          	lea    0x4(%rax),%rdx
  81fd4a:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  81fd4e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fd52:	48 89 ce             	mov    %rcx,%rsi
  81fd55:	48 89 c7             	mov    %rax,%rdi
  81fd58:	48 b8 8e fb 81 00 00 	movabs $0x81fb8e,%rax
  81fd5f:	00 00 00 
  81fd62:	ff d0                	callq  *%rax
}
  81fd64:	c9                   	leaveq 
  81fd65:	c3                   	retq   

000000000081fd66 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  81fd66:	55                   	push   %rbp
  81fd67:	48 89 e5             	mov    %rsp,%rbp
  81fd6a:	48 83 ec 20          	sub    $0x20,%rsp
  81fd6e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  81fd72:	48 b8 90 75 b5 00 00 	movabs $0xb57590,%rax
  81fd79:	00 00 00 
  81fd7c:	48 8b 00             	mov    (%rax),%rax
  81fd7f:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81fd83:	75 20                	jne    81fda5 <raw_remove+0x3f>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  81fd85:	48 b8 90 75 b5 00 00 	movabs $0xb57590,%rax
  81fd8c:	00 00 00 
  81fd8f:	48 8b 00             	mov    (%rax),%rax
  81fd92:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81fd96:	48 b8 90 75 b5 00 00 	movabs $0xb57590,%rax
  81fd9d:	00 00 00 
  81fda0:	48 89 10             	mov    %rdx,(%rax)
  81fda3:	eb 51                	jmp    81fdf6 <raw_remove+0x90>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  81fda5:	48 b8 90 75 b5 00 00 	movabs $0xb57590,%rax
  81fdac:	00 00 00 
  81fdaf:	48 8b 00             	mov    (%rax),%rax
  81fdb2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81fdb6:	eb 37                	jmp    81fdef <raw_remove+0x89>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  81fdb8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fdbc:	48 8b 40 10          	mov    0x10(%rax),%rax
  81fdc0:	48 85 c0             	test   %rax,%rax
  81fdc3:	74 1e                	je     81fde3 <raw_remove+0x7d>
  81fdc5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fdc9:	48 8b 40 10          	mov    0x10(%rax),%rax
  81fdcd:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  81fdd1:	75 10                	jne    81fde3 <raw_remove+0x7d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  81fdd3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fdd7:	48 8b 50 10          	mov    0x10(%rax),%rdx
  81fddb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fddf:	48 89 50 10          	mov    %rdx,0x10(%rax)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  81fde3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fde7:	48 8b 40 10          	mov    0x10(%rax),%rax
  81fdeb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  81fdef:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81fdf4:	75 c2                	jne    81fdb8 <raw_remove+0x52>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  81fdf6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81fdfa:	48 89 c6             	mov    %rax,%rsi
  81fdfd:	bf 00 00 00 00       	mov    $0x0,%edi
  81fe02:	48 b8 ec ca 80 00 00 	movabs $0x80caec,%rax
  81fe09:	00 00 00 
  81fe0c:	ff d0                	callq  *%rax
}
  81fe0e:	c9                   	leaveq 
  81fe0f:	c3                   	retq   

000000000081fe10 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  81fe10:	55                   	push   %rbp
  81fe11:	48 89 e5             	mov    %rsp,%rbp
  81fe14:	48 83 ec 20          	sub    $0x20,%rsp
  81fe18:	89 f8                	mov    %edi,%eax
  81fe1a:	88 45 ec             	mov    %al,-0x14(%rbp)
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  81fe1d:	bf 00 00 00 00       	mov    $0x0,%edi
  81fe22:	48 b8 41 ca 80 00 00 	movabs $0x80ca41,%rax
  81fe29:	00 00 00 
  81fe2c:	ff d0                	callq  *%rax
  81fe2e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  81fe32:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  81fe37:	74 56                	je     81fe8f <raw_new+0x7f>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  81fe39:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fe3d:	ba 30 00 00 00       	mov    $0x30,%edx
  81fe42:	be 00 00 00 00       	mov    $0x0,%esi
  81fe47:	48 89 c7             	mov    %rax,%rdi
  81fe4a:	48 b8 5b 21 80 00 00 	movabs $0x80215b,%rax
  81fe51:	00 00 00 
  81fe54:	ff d0                	callq  *%rax
    pcb->protocol = proto;
  81fe56:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fe5a:	0f b6 55 ec          	movzbl -0x14(%rbp),%edx
  81fe5e:	88 50 18             	mov    %dl,0x18(%rax)
    pcb->ttl = RAW_TTL;
  81fe61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fe65:	c6 40 0b ff          	movb   $0xff,0xb(%rax)
    pcb->next = raw_pcbs;
  81fe69:	48 b8 90 75 b5 00 00 	movabs $0xb57590,%rax
  81fe70:	00 00 00 
  81fe73:	48 8b 10             	mov    (%rax),%rdx
  81fe76:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  81fe7a:	48 89 50 10          	mov    %rdx,0x10(%rax)
    raw_pcbs = pcb;
  81fe7e:	48 b8 90 75 b5 00 00 	movabs $0xb57590,%rax
  81fe85:	00 00 00 
  81fe88:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  81fe8c:	48 89 10             	mov    %rdx,(%rax)
  }
  return pcb;
  81fe8f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  81fe93:	c9                   	leaveq 
  81fe94:	c3                   	retq   
  81fe95:	00 00                	add    %al,(%rax)
	...

000000000081fe98 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  81fe98:	55                   	push   %rbp
  81fe99:	48 89 e5             	mov    %rsp,%rbp
  81fe9c:	53                   	push   %rbx
  81fe9d:	48 83 ec 58          	sub    $0x58,%rsp
  81fea1:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  81fea5:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  81fea9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81fead:	48 8b 40 08          	mov    0x8(%rax),%rax
  81feb1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  hlen = IPH_HL(iphdr) * 4;
  81feb5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81feb9:	0f b7 00             	movzwl (%rax),%eax
  81febc:	0f b7 c0             	movzwl %ax,%eax
  81febf:	89 c7                	mov    %eax,%edi
  81fec1:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  81fec8:	00 00 00 
  81fecb:	ff d0                	callq  *%rax
  81fecd:	66 c1 e8 08          	shr    $0x8,%ax
  81fed1:	83 e0 0f             	and    $0xf,%eax
  81fed4:	c1 e0 02             	shl    $0x2,%eax
  81fed7:	66 89 45 e6          	mov    %ax,-0x1a(%rbp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  81fedb:	0f b7 45 e6          	movzwl -0x1a(%rbp),%eax
  81fedf:	f7 d8                	neg    %eax
  81fee1:	0f bf d0             	movswl %ax,%edx
  81fee4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81fee8:	89 d6                	mov    %edx,%esi
  81feea:	48 89 c7             	mov    %rax,%rdi
  81feed:	48 b8 6f d7 80 00 00 	movabs $0x80d76f,%rax
  81fef4:	00 00 00 
  81fef7:	ff d0                	callq  *%rax
  81fef9:	84 c0                	test   %al,%al
  81fefb:	0f 85 8c 04 00 00    	jne    82038d <icmp_input+0x4f5>
  81ff01:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81ff05:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81ff09:	66 83 f8 03          	cmp    $0x3,%ax
  81ff0d:	0f 86 7a 04 00 00    	jbe    82038d <icmp_input+0x4f5>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  81ff13:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81ff17:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ff1b:	0f b6 00             	movzbl (%rax),%eax
  81ff1e:	88 45 e5             	mov    %al,-0x1b(%rbp)
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
  81ff21:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81ff25:	48 8b 40 08          	mov    0x8(%rax),%rax
  81ff29:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  81ff2d:	88 45 e4             	mov    %al,-0x1c(%rbp)
#endif /* LWIP_DEBUG */
  switch (type) {
  81ff30:	0f b6 45 e5          	movzbl -0x1b(%rbp),%eax
  81ff34:	83 f8 08             	cmp    $0x8,%eax
  81ff37:	0f 85 3b 04 00 00    	jne    820378 <icmp_input+0x4e0>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  81ff3d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ff41:	48 8d 50 10          	lea    0x10(%rax),%rdx
  81ff45:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  81ff49:	48 89 c6             	mov    %rax,%rsi
  81ff4c:	48 89 d7             	mov    %rdx,%rdi
  81ff4f:	48 b8 80 09 81 00 00 	movabs $0x810980,%rax
  81ff56:	00 00 00 
  81ff59:	ff d0                	callq  *%rax
  81ff5b:	84 c0                	test   %al,%al
  81ff5d:	75 2f                	jne    81ff8e <icmp_input+0xf6>
  81ff5f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  81ff63:	8b 58 10             	mov    0x10(%rax),%ebx
  81ff66:	bf 00 00 00 f0       	mov    $0xf0000000,%edi
  81ff6b:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81ff72:	00 00 00 
  81ff75:	ff d0                	callq  *%rax
  81ff77:	21 c3                	and    %eax,%ebx
  81ff79:	bf 00 00 00 e0       	mov    $0xe0000000,%edi
  81ff7e:	48 b8 01 2d 81 00 00 	movabs $0x812d01,%rax
  81ff85:	00 00 00 
  81ff88:	ff d0                	callq  *%rax
  81ff8a:	39 c3                	cmp    %eax,%ebx
  81ff8c:	75 18                	jne    81ffa6 <icmp_input+0x10e>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  81ff8e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81ff92:	48 89 c7             	mov    %rax,%rdi
  81ff95:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81ff9c:	00 00 00 
  81ff9f:	ff d0                	callq  *%rax
      return;
  81ffa1:	e9 15 04 00 00       	jmpq   8203bb <icmp_input+0x523>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  81ffa6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81ffaa:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  81ffae:	66 83 f8 07          	cmp    $0x7,%ax
  81ffb2:	0f 86 d8 03 00 00    	jbe    820390 <icmp_input+0x4f8>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  81ffb8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81ffbc:	48 89 c7             	mov    %rax,%rdi
  81ffbf:	48 b8 a5 27 81 00 00 	movabs $0x8127a5,%rax
  81ffc6:	00 00 00 
  81ffc9:	ff d0                	callq  *%rax
  81ffcb:	66 85 c0             	test   %ax,%ax
  81ffce:	74 18                	je     81ffe8 <icmp_input+0x150>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  81ffd0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81ffd4:	48 89 c7             	mov    %rax,%rdi
  81ffd7:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  81ffde:	00 00 00 
  81ffe1:	ff d0                	callq  *%rax
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  81ffe3:	e9 d3 03 00 00       	jmpq   8203bb <icmp_input+0x523>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  81ffe8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  81ffec:	be 22 00 00 00       	mov    $0x22,%esi
  81fff1:	48 89 c7             	mov    %rax,%rdi
  81fff4:	48 b8 6f d7 80 00 00 	movabs $0x80d76f,%rax
  81fffb:	00 00 00 
  81fffe:	ff d0                	callq  *%rax
  820000:	84 c0                	test   %al,%al
  820002:	0f 84 79 01 00 00    	je     820181 <icmp_input+0x2e9>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  820008:	0f bf 55 e6          	movswl -0x1a(%rbp),%edx
  82000c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820010:	89 d6                	mov    %edx,%esi
  820012:	48 89 c7             	mov    %rax,%rdi
  820015:	48 b8 6f d7 80 00 00 	movabs $0x80d76f,%rax
  82001c:	00 00 00 
  82001f:	ff d0                	callq  *%rax
  820021:	84 c0                	test   %al,%al
  820023:	74 2a                	je     82004f <icmp_input+0x1b7>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  820025:	48 ba 58 39 82 00 00 	movabs $0x823958,%rdx
  82002c:	00 00 00 
  82002f:	be 7b 00 00 00       	mov    $0x7b,%esi
  820034:	48 bf 8b 39 82 00 00 	movabs $0x82398b,%rdi
  82003b:	00 00 00 
  82003e:	b8 00 00 00 00       	mov    $0x0,%eax
  820043:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  82004a:	00 00 00 
  82004d:	ff d1                	callq  *%rcx
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  82004f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820053:	0f b7 40 10          	movzwl 0x10(%rax),%eax
  820057:	0f b7 c0             	movzwl %ax,%eax
  82005a:	ba 00 00 00 00       	mov    $0x0,%edx
  82005f:	89 c6                	mov    %eax,%esi
  820061:	bf 02 00 00 00       	mov    $0x2,%edi
  820066:	48 b8 4c d0 80 00 00 	movabs $0x80d04c,%rax
  82006d:	00 00 00 
  820070:	ff d0                	callq  *%rax
  820072:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      if (r == NULL) {
  820076:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  82007b:	0f 84 25 03 00 00    	je     8203a6 <icmp_input+0x50e>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  820081:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820085:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  820089:	0f b7 c0             	movzwl %ax,%eax
  82008c:	48 0f bf 55 e6       	movswq -0x1a(%rbp),%rdx
  820091:	48 83 c2 08          	add    $0x8,%rdx
  820095:	48 39 d0             	cmp    %rdx,%rax
  820098:	73 2a                	jae    8200c4 <icmp_input+0x22c>
  82009a:	48 ba a8 39 82 00 00 	movabs $0x8239a8,%rdx
  8200a1:	00 00 00 
  8200a4:	be 85 00 00 00       	mov    $0x85,%esi
  8200a9:	48 bf 8b 39 82 00 00 	movabs $0x82398b,%rdi
  8200b0:	00 00 00 
  8200b3:	b8 00 00 00 00       	mov    $0x0,%eax
  8200b8:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8200bf:	00 00 00 
  8200c2:	ff d1                	callq  *%rcx
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  8200c4:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8200c8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8200cc:	48 89 d6             	mov    %rdx,%rsi
  8200cf:	48 89 c7             	mov    %rax,%rdi
  8200d2:	48 b8 b4 dd 80 00 00 	movabs $0x80ddb4,%rax
  8200d9:	00 00 00 
  8200dc:	ff d0                	callq  *%rax
  8200de:	84 c0                	test   %al,%al
  8200e0:	74 2a                	je     82010c <icmp_input+0x274>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  8200e2:	48 ba e0 39 82 00 00 	movabs $0x8239e0,%rdx
  8200e9:	00 00 00 
  8200ec:	be 88 00 00 00       	mov    $0x88,%esi
  8200f1:	48 bf 8b 39 82 00 00 	movabs $0x82398b,%rdi
  8200f8:	00 00 00 
  8200fb:	b8 00 00 00 00       	mov    $0x0,%eax
  820100:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  820107:	00 00 00 
  82010a:	ff d1                	callq  *%rcx
        goto memerr;
      }
      iphdr = r->payload;
  82010c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820110:	48 8b 40 08          	mov    0x8(%rax),%rax
  820114:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  820118:	0f b7 45 e6          	movzwl -0x1a(%rbp),%eax
  82011c:	f7 d8                	neg    %eax
  82011e:	0f bf d0             	movswl %ax,%edx
  820121:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820125:	89 d6                	mov    %edx,%esi
  820127:	48 89 c7             	mov    %rax,%rdi
  82012a:	48 b8 6f d7 80 00 00 	movabs $0x80d76f,%rax
  820131:	00 00 00 
  820134:	ff d0                	callq  *%rax
  820136:	84 c0                	test   %al,%al
  820138:	74 2a                	je     820164 <icmp_input+0x2cc>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  82013a:	48 ba 08 3a 82 00 00 	movabs $0x823a08,%rdx
  820141:	00 00 00 
  820144:	be 8e 00 00 00       	mov    $0x8e,%esi
  820149:	48 bf 8b 39 82 00 00 	movabs $0x82398b,%rdi
  820150:	00 00 00 
  820153:	b8 00 00 00 00       	mov    $0x0,%eax
  820158:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  82015f:	00 00 00 
  820162:	ff d1                	callq  *%rcx
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  820164:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820168:	48 89 c7             	mov    %rax,%rdi
  82016b:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  820172:	00 00 00 
  820175:	ff d0                	callq  *%rax
      /* we now have an identical copy of p that has room for link headers */
      p = r;
  820177:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  82017b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  82017f:	eb 46                	jmp    8201c7 <icmp_input+0x32f>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  820181:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820185:	be de ff ff ff       	mov    $0xffffffde,%esi
  82018a:	48 89 c7             	mov    %rax,%rdi
  82018d:	48 b8 6f d7 80 00 00 	movabs $0x80d76f,%rax
  820194:	00 00 00 
  820197:	ff d0                	callq  *%rax
  820199:	84 c0                	test   %al,%al
  82019b:	74 2a                	je     8201c7 <icmp_input+0x32f>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  82019d:	48 ba 08 3a 82 00 00 	movabs $0x823a08,%rdx
  8201a4:	00 00 00 
  8201a7:	be 98 00 00 00       	mov    $0x98,%esi
  8201ac:	48 bf 8b 39 82 00 00 	movabs $0x82398b,%rdi
  8201b3:	00 00 00 
  8201b6:	b8 00 00 00 00       	mov    $0x0,%eax
  8201bb:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8201c2:	00 00 00 
  8201c5:	ff d1                	callq  *%rcx
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  8201c7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8201cb:	48 8b 40 08          	mov    0x8(%rax),%rax
  8201cf:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    tmpaddr.addr = iphdr->src.addr;
  8201d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8201d7:	8b 40 0c             	mov    0xc(%rax),%eax
  8201da:	89 45 c0             	mov    %eax,-0x40(%rbp)
    iphdr->src.addr = iphdr->dest.addr;
  8201dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8201e1:	8b 50 10             	mov    0x10(%rax),%edx
  8201e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8201e8:	89 50 0c             	mov    %edx,0xc(%rax)
    iphdr->dest.addr = tmpaddr.addr;
  8201eb:	8b 55 c0             	mov    -0x40(%rbp),%edx
  8201ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8201f2:	89 50 10             	mov    %edx,0x10(%rax)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  8201f5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8201f9:	0f b7 00             	movzwl (%rax),%eax
  8201fc:	0f b7 c0             	movzwl %ax,%eax
  8201ff:	89 c7                	mov    %eax,%edi
  820201:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  820208:	00 00 00 
  82020b:	ff d0                	callq  *%rax
  82020d:	0f b7 c0             	movzwl %ax,%eax
  820210:	25 ff 00 00 00       	and    $0xff,%eax
  820215:	89 c7                	mov    %eax,%edi
  820217:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  82021e:	00 00 00 
  820221:	ff d0                	callq  *%rax
  820223:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  820227:	66 89 02             	mov    %ax,(%rdx)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  82022a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  82022e:	0f b7 58 02          	movzwl 0x2(%rax),%ebx
  820232:	bf ff f7 00 00       	mov    $0xf7ff,%edi
  820237:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  82023e:	00 00 00 
  820241:	ff d0                	callq  *%rax
  820243:	66 39 c3             	cmp    %ax,%bx
  820246:	72 28                	jb     820270 <icmp_input+0x3d8>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  820248:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  82024c:	0f b7 58 02          	movzwl 0x2(%rax),%ebx
  820250:	bf 00 08 00 00       	mov    $0x800,%edi
  820255:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  82025c:	00 00 00 
  82025f:	ff d0                	callq  *%rax
  820261:	01 d8                	add    %ebx,%eax
  820263:	8d 50 01             	lea    0x1(%rax),%edx
  820266:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  82026a:	66 89 50 02          	mov    %dx,0x2(%rax)
  82026e:	eb 24                	jmp    820294 <icmp_input+0x3fc>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  820270:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  820274:	0f b7 58 02          	movzwl 0x2(%rax),%ebx
  820278:	bf 00 08 00 00       	mov    $0x800,%edi
  82027d:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  820284:	00 00 00 
  820287:	ff d0                	callq  *%rax
  820289:	8d 14 03             	lea    (%rbx,%rax,1),%edx
  82028c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  820290:	66 89 50 02          	mov    %dx,0x2(%rax)
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  820294:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820298:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  82029c:	0f b7 c0             	movzwl %ax,%eax
  82029f:	89 c7                	mov    %eax,%edi
  8202a1:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  8202a8:	00 00 00 
  8202ab:	ff d0                	callq  *%rax
  8202ad:	66 0d 00 ff          	or     $0xff00,%ax
  8202b1:	0f b7 c0             	movzwl %ax,%eax
  8202b4:	89 c7                	mov    %eax,%edi
  8202b6:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  8202bd:	00 00 00 
  8202c0:	ff d0                	callq  *%rax
  8202c2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8202c6:	66 89 42 08          	mov    %ax,0x8(%rdx)
    IPH_CHKSUM_SET(iphdr, 0);
  8202ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8202ce:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8202d4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8202d8:	be 14 00 00 00       	mov    $0x14,%esi
  8202dd:	48 89 c7             	mov    %rax,%rdi
  8202e0:	48 b8 76 27 81 00 00 	movabs $0x812776,%rax
  8202e7:	00 00 00 
  8202ea:	ff d0                	callq  *%rax
  8202ec:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8202f0:	66 89 42 0a          	mov    %ax,0xa(%rdx)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  8202f4:	0f bf 55 e6          	movswl -0x1a(%rbp),%edx
  8202f8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8202fc:	89 d6                	mov    %edx,%esi
  8202fe:	48 89 c7             	mov    %rax,%rdi
  820301:	48 b8 6f d7 80 00 00 	movabs $0x80d76f,%rax
  820308:	00 00 00 
  82030b:	ff d0                	callq  *%rax
  82030d:	84 c0                	test   %al,%al
  82030f:	74 2a                	je     82033b <icmp_input+0x4a3>
      LWIP_ASSERT("Can't move over header in packet", 0);
  820311:	48 ba 40 3a 82 00 00 	movabs $0x823a40,%rdx
  820318:	00 00 00 
  82031b:	be b9 00 00 00       	mov    $0xb9,%esi
  820320:	48 bf 8b 39 82 00 00 	movabs $0x82398b,%rdi
  820327:	00 00 00 
  82032a:	b8 00 00 00 00       	mov    $0x0,%eax
  82032f:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  820336:	00 00 00 
  820339:	ff d1                	callq  *%rcx
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  82033b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82033f:	48 8d 70 0c          	lea    0xc(%rax),%rsi
  820343:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820347:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  82034b:	48 89 14 24          	mov    %rdx,(%rsp)
  82034f:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  820355:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  82035b:	b9 ff 00 00 00       	mov    $0xff,%ecx
  820360:	ba 00 00 00 00       	mov    $0x0,%edx
  820365:	48 89 c7             	mov    %rax,%rdi
  820368:	48 b8 57 0f 81 00 00 	movabs $0x810f57,%rax
  82036f:	00 00 00 
  820372:	ff d0                	callq  *%rax
  820374:	88 45 cf             	mov    %al,-0x31(%rbp)
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
      if (ret != ERR_OK) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %c.\n", ret));
      }
    }
    break;
  820377:	90                   	nop
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  820378:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  82037c:	48 89 c7             	mov    %rax,%rdi
  82037f:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  820386:	00 00 00 
  820389:	ff d0                	callq  *%rax
  return;
  82038b:	eb 2e                	jmp    8203bb <icmp_input+0x523>

  iphdr = p->payload;
  hlen = IPH_HL(iphdr) * 4;
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  82038d:	90                   	nop
  82038e:	eb 01                	jmp    820391 <icmp_input+0x4f9>
      return;
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
  820390:	90                   	nop
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  return;
lenerr:
  pbuf_free(p);
  820391:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  820395:	48 89 c7             	mov    %rax,%rdi
  820398:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  82039f:	00 00 00 
  8203a2:	ff d0                	callq  *%rax
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  8203a4:	eb 15                	jmp    8203bb <icmp_input+0x523>
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
      if (r == NULL) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
  8203a6:	90                   	nop
  pbuf_free(p);
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
memerr:
  pbuf_free(p);
  8203a7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8203ab:	48 89 c7             	mov    %rax,%rdi
  8203ae:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  8203b5:	00 00 00 
  8203b8:	ff d0                	callq  *%rax
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
  8203ba:	90                   	nop
}
  8203bb:	48 83 c4 58          	add    $0x58,%rsp
  8203bf:	5b                   	pop    %rbx
  8203c0:	5d                   	pop    %rbp
  8203c1:	c3                   	retq   

00000000008203c2 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  8203c2:	55                   	push   %rbp
  8203c3:	48 89 e5             	mov    %rsp,%rbp
  8203c6:	48 83 ec 30          	sub    $0x30,%rsp
  8203ca:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8203ce:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  8203d1:	ba 00 00 00 00       	mov    $0x0,%edx
  8203d6:	be 24 00 00 00       	mov    $0x24,%esi
  8203db:	bf 01 00 00 00       	mov    $0x1,%edi
  8203e0:	48 b8 4c d0 80 00 00 	movabs $0x80d04c,%rax
  8203e7:	00 00 00 
  8203ea:	ff d0                	callq  *%rax
  8203ec:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 PBUF_RAM);
  if (q == NULL) {
  8203f0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8203f5:	0f 84 63 01 00 00    	je     82055e <icmp_dest_unreach+0x19c>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  8203fb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8203ff:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  820403:	66 83 f8 23          	cmp    $0x23,%ax
  820407:	77 2a                	ja     820433 <icmp_dest_unreach+0x71>
  820409:	48 ba 68 3a 82 00 00 	movabs $0x823a68,%rdx
  820410:	00 00 00 
  820413:	be ef 00 00 00       	mov    $0xef,%esi
  820418:	48 bf 8b 39 82 00 00 	movabs $0x82398b,%rdi
  82041f:	00 00 00 
  820422:	b8 00 00 00 00       	mov    $0x0,%eax
  820427:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  82042e:	00 00 00 
  820431:	ff d1                	callq  *%rcx
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  820433:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  820437:	48 8b 40 08          	mov    0x8(%rax),%rax
  82043b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  idur = q->payload;
  82043f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820443:	48 8b 40 08          	mov    0x8(%rax),%rax
  820447:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  82044b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82044f:	0f b7 00             	movzwl (%rax),%eax
  820452:	0f b7 c0             	movzwl %ax,%eax
  820455:	89 c7                	mov    %eax,%edi
  820457:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  82045e:	00 00 00 
  820461:	ff d0                	callq  *%rax
  820463:	66 25 ff 00          	and    $0xff,%ax
  820467:	80 cc 03             	or     $0x3,%ah
  82046a:	0f b7 c0             	movzwl %ax,%eax
  82046d:	89 c7                	mov    %eax,%edi
  82046f:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  820476:	00 00 00 
  820479:	ff d0                	callq  *%rax
  82047b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  82047f:	66 89 02             	mov    %ax,(%rdx)
  ICMPH_CODE_SET(idur, t);
  820482:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820486:	0f b7 00             	movzwl (%rax),%eax
  820489:	0f b7 c0             	movzwl %ax,%eax
  82048c:	89 c7                	mov    %eax,%edi
  82048e:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  820495:	00 00 00 
  820498:	ff d0                	callq  *%rax
  82049a:	89 c2                	mov    %eax,%edx
  82049c:	b2 00                	mov    $0x0,%dl
  82049e:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8204a1:	09 d0                	or     %edx,%eax
  8204a3:	0f b7 c0             	movzwl %ax,%eax
  8204a6:	89 c7                	mov    %eax,%edi
  8204a8:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  8204af:	00 00 00 
  8204b2:	ff d0                	callq  *%rax
  8204b4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8204b8:	66 89 02             	mov    %ax,(%rdx)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  8204bb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8204bf:	48 8b 40 08          	mov    0x8(%rax),%rax
  8204c3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8204c7:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8204cb:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  8204cf:	ba 1c 00 00 00       	mov    $0x1c,%edx
  8204d4:	48 89 c6             	mov    %rax,%rsi
  8204d7:	48 89 cf             	mov    %rcx,%rdi
  8204da:	48 b8 fd 22 80 00 00 	movabs $0x8022fd,%rax
  8204e1:	00 00 00 
  8204e4:	ff d0                	callq  *%rax
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  8204e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8204ea:	66 c7 40 02 00 00    	movw   $0x0,0x2(%rax)
  idur->chksum = inet_chksum(idur, q->len);
  8204f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8204f4:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8204f8:	0f b7 d0             	movzwl %ax,%edx
  8204fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8204ff:	89 d6                	mov    %edx,%esi
  820501:	48 89 c7             	mov    %rax,%rdi
  820504:	48 b8 76 27 81 00 00 	movabs $0x812776,%rax
  82050b:	00 00 00 
  82050e:	ff d0                	callq  *%rax
  820510:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  820514:	66 89 42 02          	mov    %ax,0x2(%rdx)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  820518:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  82051c:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  820520:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820524:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  82052a:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  820530:	b9 ff 00 00 00       	mov    $0xff,%ecx
  820535:	be 00 00 00 00       	mov    $0x0,%esi
  82053a:	48 89 c7             	mov    %rax,%rdi
  82053d:	48 b8 0d 12 81 00 00 	movabs $0x81120d,%rax
  820544:	00 00 00 
  820547:	ff d0                	callq  *%rax
  pbuf_free(q);
  820549:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  82054d:	48 89 c7             	mov    %rax,%rdi
  820550:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  820557:	00 00 00 
  82055a:	ff d0                	callq  *%rax
  82055c:	eb 01                	jmp    82055f <icmp_dest_unreach+0x19d>
  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
                 PBUF_RAM);
  if (q == NULL) {
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  82055e:	90                   	nop
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  pbuf_free(q);
}
  82055f:	c9                   	leaveq 
  820560:	c3                   	retq   

0000000000820561 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  820561:	55                   	push   %rbp
  820562:	48 89 e5             	mov    %rsp,%rbp
  820565:	48 83 ec 30          	sub    $0x30,%rsp
  820569:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  82056d:	89 75 d4             	mov    %esi,-0x2c(%rbp)
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  820570:	ba 00 00 00 00       	mov    $0x0,%edx
  820575:	be 24 00 00 00       	mov    $0x24,%esi
  82057a:	bf 01 00 00 00       	mov    $0x1,%edi
  82057f:	48 b8 4c d0 80 00 00 	movabs $0x80d04c,%rax
  820586:	00 00 00 
  820589:	ff d0                	callq  *%rax
  82058b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                 PBUF_RAM);
  if (q == NULL) {
  82058f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  820594:	0f 84 63 01 00 00    	je     8206fd <icmp_time_exceeded+0x19c>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  82059a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  82059e:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  8205a2:	66 83 f8 23          	cmp    $0x23,%ax
  8205a6:	77 2a                	ja     8205d2 <icmp_time_exceeded+0x71>
  8205a8:	48 ba 68 3a 82 00 00 	movabs $0x823a68,%rdx
  8205af:	00 00 00 
  8205b2:	be 1e 01 00 00       	mov    $0x11e,%esi
  8205b7:	48 bf 8b 39 82 00 00 	movabs $0x82398b,%rdi
  8205be:	00 00 00 
  8205c1:	b8 00 00 00 00       	mov    $0x0,%eax
  8205c6:	48 b9 cc 10 80 00 00 	movabs $0x8010cc,%rcx
  8205cd:	00 00 00 
  8205d0:	ff d1                	callq  *%rcx
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  8205d2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8205d6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8205da:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  8205de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8205e2:	48 8b 40 08          	mov    0x8(%rax),%rax
  8205e6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  8205ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8205ee:	0f b7 00             	movzwl (%rax),%eax
  8205f1:	0f b7 c0             	movzwl %ax,%eax
  8205f4:	89 c7                	mov    %eax,%edi
  8205f6:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  8205fd:	00 00 00 
  820600:	ff d0                	callq  *%rax
  820602:	66 25 ff 00          	and    $0xff,%ax
  820606:	80 cc 0b             	or     $0xb,%ah
  820609:	0f b7 c0             	movzwl %ax,%eax
  82060c:	89 c7                	mov    %eax,%edi
  82060e:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  820615:	00 00 00 
  820618:	ff d0                	callq  *%rax
  82061a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  82061e:	66 89 02             	mov    %ax,(%rdx)
  ICMPH_CODE_SET(tehdr, t);
  820621:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820625:	0f b7 00             	movzwl (%rax),%eax
  820628:	0f b7 c0             	movzwl %ax,%eax
  82062b:	89 c7                	mov    %eax,%edi
  82062d:	48 b8 a7 2c 81 00 00 	movabs $0x812ca7,%rax
  820634:	00 00 00 
  820637:	ff d0                	callq  *%rax
  820639:	89 c2                	mov    %eax,%edx
  82063b:	b2 00                	mov    $0x0,%dl
  82063d:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  820640:	09 d0                	or     %edx,%eax
  820642:	0f b7 c0             	movzwl %ax,%eax
  820645:	89 c7                	mov    %eax,%edi
  820647:	48 b8 84 2c 81 00 00 	movabs $0x812c84,%rax
  82064e:	00 00 00 
  820651:	ff d0                	callq  *%rax
  820653:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  820657:	66 89 02             	mov    %ax,(%rdx)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  82065a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  82065e:	48 8b 40 08          	mov    0x8(%rax),%rax
  820662:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  820666:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  82066a:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  82066e:	ba 1c 00 00 00       	mov    $0x1c,%edx
  820673:	48 89 c6             	mov    %rax,%rsi
  820676:	48 89 cf             	mov    %rcx,%rdi
  820679:	48 b8 fd 22 80 00 00 	movabs $0x8022fd,%rax
  820680:	00 00 00 
  820683:	ff d0                	callq  *%rax
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  820685:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  820689:	66 c7 40 02 00 00    	movw   $0x0,0x2(%rax)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  82068f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  820693:	0f b7 40 12          	movzwl 0x12(%rax),%eax
  820697:	0f b7 d0             	movzwl %ax,%edx
  82069a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  82069e:	89 d6                	mov    %edx,%esi
  8206a0:	48 89 c7             	mov    %rax,%rdi
  8206a3:	48 b8 76 27 81 00 00 	movabs $0x812776,%rax
  8206aa:	00 00 00 
  8206ad:	ff d0                	callq  *%rax
  8206af:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8206b3:	66 89 42 02          	mov    %ax,0x2(%rdx)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  8206b7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8206bb:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8206bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8206c3:	41 b9 01 00 00 00    	mov    $0x1,%r9d
  8206c9:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8206cf:	b9 ff 00 00 00       	mov    $0xff,%ecx
  8206d4:	be 00 00 00 00       	mov    $0x0,%esi
  8206d9:	48 89 c7             	mov    %rax,%rdi
  8206dc:	48 b8 0d 12 81 00 00 	movabs $0x81120d,%rax
  8206e3:	00 00 00 
  8206e6:	ff d0                	callq  *%rax
  pbuf_free(q);
  8206e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8206ec:	48 89 c7             	mov    %rax,%rdi
  8206ef:	48 b8 32 d9 80 00 00 	movabs $0x80d932,%rax
  8206f6:	00 00 00 
  8206f9:	ff d0                	callq  *%rax
  8206fb:	eb 01                	jmp    8206fe <icmp_time_exceeded+0x19d>
  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
                 PBUF_RAM);
  if (q == NULL) {
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  8206fd:	90                   	nop
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  pbuf_free(q);
}
  8206fe:	c9                   	leaveq 
  8206ff:	c3                   	retq   
