
obj/kern/kernel:     file format elf64-x86-64


Disassembly of section .bootstrap:

0000000000100000 <_head64>:
.text
.globl _head64
_head64:

# Save multiboot_info addr passed by bootloader
    movl $multiboot_info, %eax
  100000:	b8 00 70 10 00       	mov    $0x107000,%eax
    movl %ebx, (%eax)
  100005:	89 18                	mov    %ebx,(%rax)

	movw $0x1234,0x472			# warm boot
  100007:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472(%rip)        # 100482 <verify_cpu_no_longmode+0x36f>
  10000e:	34 12 
# Reset the stack pointer in case we didn't come from the loader
    movl $0x7c00,%esp
  100010:	bc 00 7c 00 00       	mov    $0x7c00,%esp

    call verify_cpu   #check if CPU supports long mode
  100015:	e8 cc 00 00 00       	callq  1000e6 <verify_cpu>
    movl $CR4_PAE,%eax
  10001a:	b8 20 00 00 00       	mov    $0x20,%eax
    movl %eax,%cr4
  10001f:	0f 22 e0             	mov    %rax,%cr4

# build an early boot pml4 at physical address pml4phys 

    #initializing the page tables
    movl $pml4,%edi
  100022:	bf 00 20 10 00       	mov    $0x102000,%edi
    xorl %eax,%eax
  100027:	31 c0                	xor    %eax,%eax
    movl $((4096/4)*5),%ecx  # moving these many words to the 6 pages with 4 second level pages + 1 3rd level + 1 4th level pages 
  100029:	b9 00 14 00 00       	mov    $0x1400,%ecx
    rep stosl
  10002e:	f3 ab                	rep stos %eax,%es:(%rdi)
    # creating a 4G boot page table
    # setting the 4th level page table only the second entry needed (PML4)
    movl $pml4,%eax
  100030:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl $pdpt1, %ebx
  100035:	bb 00 30 10 00       	mov    $0x103000,%ebx
    orl $PTE_P,%ebx
  10003a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10003d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%eax)
  100040:	89 18                	mov    %ebx,(%rax)

    movl $pdpt2, %ebx
  100042:	bb 00 40 10 00       	mov    $0x104000,%ebx
    orl $PTE_P,%ebx
  100047:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10004a:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,0x8(%eax)
  10004d:	89 58 08             	mov    %ebx,0x8(%rax)

    # setting the 3rd level page table (PDPE)
    # 4 entries (counter in ecx), point to the next four physical pages (pgdirs)
    # pgdirs in 0xa0000--0xd000
    movl $pdpt1,%edi
  100050:	bf 00 30 10 00       	mov    $0x103000,%edi
    movl $pde1,%ebx
  100055:	bb 00 50 10 00       	mov    $0x105000,%ebx
    orl $PTE_P,%ebx
  10005a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10005d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100060:	89 1f                	mov    %ebx,(%rdi)

    movl $pdpt2,%edi
  100062:	bf 00 40 10 00       	mov    $0x104000,%edi
    movl $pde2,%ebx
  100067:	bb 00 60 10 00       	mov    $0x106000,%ebx
    orl $PTE_P,%ebx
  10006c:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10006f:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100072:	89 1f                	mov    %ebx,(%rdi)
    
    # setting the pgdir so that the LA=PA
    # mapping first 1G of mem at KERNBASE
    movl $128,%ecx
  100074:	b9 80 00 00 00       	mov    $0x80,%ecx
    # Start at the end and work backwards
    #leal (pml4 + 5*0x1000 - 0x8),%edi
    movl $pde1,%edi
  100079:	bf 00 50 10 00       	mov    $0x105000,%edi
    movl $pde2,%ebx
  10007e:	bb 00 60 10 00       	mov    $0x106000,%ebx
    #64th entry - 0x8004000000
    addl $256,%ebx 
  100083:	81 c3 00 01 00 00    	add    $0x100,%ebx
    # PTE_P|PTE_W|PTE_MBZ
    movl $0x00000183,%eax
  100089:	b8 83 01 00 00       	mov    $0x183,%eax
  1:
     movl %eax,(%edi)
  10008e:	89 07                	mov    %eax,(%rdi)
     movl %eax,(%ebx)
  100090:	89 03                	mov    %eax,(%rbx)
     addl $0x8,%edi
  100092:	83 c7 08             	add    $0x8,%edi
     addl $0x8,%ebx
  100095:	83 c3 08             	add    $0x8,%ebx
     addl $0x00200000,%eax
  100098:	05 00 00 20 00       	add    $0x200000,%eax
     subl $1,%ecx
  10009d:	83 e9 01             	sub    $0x1,%ecx
     cmp $0x0,%ecx
  1000a0:	83 f9 00             	cmp    $0x0,%ecx
     jne 1b
  1000a3:	75 e9                	jne    10008e <_head64+0x8e>
 /*    subl $1,%ecx */
 /*    cmp $0x0,%ecx */
 /*    jne 1b */

    # set the cr3 register
    movl $pml4,%eax
  1000a5:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl %eax, %cr3
  1000aa:	0f 22 d8             	mov    %rax,%cr3

	
    # enable the long mode in MSR
    movl $EFER_MSR,%ecx
  1000ad:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
    rdmsr
  1000b2:	0f 32                	rdmsr  
    btsl $EFER_LME,%eax
  1000b4:	0f ba e8 08          	bts    $0x8,%eax
    wrmsr
  1000b8:	0f 30                	wrmsr  
    
    # enable paging 
    movl %cr0,%eax
  1000ba:	0f 20 c0             	mov    %cr0,%rax
    orl $CR0_PE,%eax
  1000bd:	83 c8 01             	or     $0x1,%eax
    orl $CR0_PG,%eax
  1000c0:	0d 00 00 00 80       	or     $0x80000000,%eax
    orl $CR0_AM,%eax
  1000c5:	0d 00 00 04 00       	or     $0x40000,%eax
    orl $CR0_WP,%eax
  1000ca:	0d 00 00 01 00       	or     $0x10000,%eax
    orl $CR0_MP,%eax
  1000cf:	83 c8 02             	or     $0x2,%eax
    movl %eax,%cr0
  1000d2:	0f 22 c0             	mov    %rax,%cr0
    #jump to long mode with CS=0 and

    movl $gdtdesc_64,%eax
  1000d5:	b8 18 10 10 00       	mov    $0x101018,%eax
    lgdt (%eax)
  1000da:	0f 01 10             	lgdt   (%rax)
    pushl $0x8
  1000dd:	6a 08                	pushq  $0x8
    movl $_start,%eax
  1000df:	b8 0c 00 20 00       	mov    $0x20000c,%eax
    pushl %eax
  1000e4:	50                   	push   %rax

00000000001000e5 <jumpto_longmode>:
    
    .globl jumpto_longmode
    .type jumpto_longmode,@function
jumpto_longmode:
    lret
  1000e5:	cb                   	lret   

00000000001000e6 <verify_cpu>:
/*     movabs $_back_from_head64, %rax */
/*     pushq %rax */
/*     lretq */

verify_cpu:
    pushfl                   # get eflags in eax -- standardard way to check for cpuid
  1000e6:	9c                   	pushfq 
    popl %eax
  1000e7:	58                   	pop    %rax
    movl %eax,%ecx
  1000e8:	89 c1                	mov    %eax,%ecx
    xorl $0x200000, %eax
  1000ea:	35 00 00 20 00       	xor    $0x200000,%eax
    pushl %eax
  1000ef:	50                   	push   %rax
    popfl
  1000f0:	9d                   	popfq  
    pushfl
  1000f1:	9c                   	pushfq 
    popl %eax
  1000f2:	58                   	pop    %rax
    cmpl %eax,%ebx
  1000f3:	39 c3                	cmp    %eax,%ebx
    jz verify_cpu_no_longmode   # no cpuid -- no long mode
  1000f5:	74 1c                	je     100113 <verify_cpu_no_longmode>

    movl $0x0,%eax              # see if cpuid 1 is implemented
  1000f7:	b8 00 00 00 00       	mov    $0x0,%eax
    cpuid
  1000fc:	0f a2                	cpuid  
    cmpl $0x1,%eax
  1000fe:	83 f8 01             	cmp    $0x1,%eax
    jb verify_cpu_no_longmode    # cpuid 1 is not implemented
  100101:	72 10                	jb     100113 <verify_cpu_no_longmode>


    mov $0x80000001, %eax
  100103:	b8 01 00 00 80       	mov    $0x80000001,%eax
    cpuid                 
  100108:	0f a2                	cpuid  
    test $(1 << 29),%edx                 #Test if the LM-bit, is set or not.
  10010a:	f7 c2 00 00 00 20    	test   $0x20000000,%edx
    jz verify_cpu_no_longmode
  100110:	74 01                	je     100113 <verify_cpu_no_longmode>

    ret
  100112:	c3                   	retq   

0000000000100113 <verify_cpu_no_longmode>:

verify_cpu_no_longmode:
    jmp verify_cpu_no_longmode
  100113:	eb fe                	jmp    100113 <verify_cpu_no_longmode>
	...

0000000000101000 <gdt_64>:
	...
  101008:	ff                   	(bad)  
  101009:	ff 00                	incl   (%rax)
  10100b:	00 00                	add    %al,(%rax)
  10100d:	9a                   	(bad)  
  10100e:	af                   	scas   %es:(%rdi),%eax
  10100f:	00 ff                	add    %bh,%bh
  101011:	ff 00                	incl   (%rax)
  101013:	00 00                	add    %al,(%rax)
  101015:	92                   	xchg   %eax,%edx
  101016:	cf                   	iret   
	...

0000000000101018 <gdtdesc_64>:
  101018:	17                   	(bad)  
  101019:	00 00                	add    %al,(%rax)
  10101b:	10 10                	adc    %dl,(%rax)
	...

0000000000102000 <pml4phys>:
	...

0000000000103000 <pdpt1>:
	...

0000000000104000 <pdpt2>:
	...

0000000000105000 <pde1>:
	...

0000000000106000 <pde2>:
	...

0000000000107000 <multiboot_info>:
  107000:	00 00                	add    %al,(%rax)
	...

Disassembly of section .text:

0000008004200000 <_start+0x8003fffff4>:
  8004200000:	02 b0 ad 1b 00 00    	add    0x1bad(%rax),%dh
  8004200006:	00 00                	add    %al,(%rax)
  8004200008:	fe 4f 52             	decb   0x52(%rdi)
  800420000b:	e4 48                	in     $0x48,%al

000000800420000c <entry>:
entry:

/* .globl _back_from_head64 */
/* _back_from_head64: */

    movabs   $gdtdesc_64,%rax
  800420000c:	48 b8 38 a0 22 04 80 	movabs $0x800422a038,%rax
  8004200013:	00 00 00 
    lgdt     (%rax)
  8004200016:	0f 01 10             	lgdt   (%rax)
    movw    $DATA_SEL,%ax
  8004200019:	66 b8 10 00          	mov    $0x10,%ax
    movw    %ax,%ds
  800420001d:	8e d8                	mov    %eax,%ds
    movw    %ax,%ss
  800420001f:	8e d0                	mov    %eax,%ss
    movw    %ax,%fs
  8004200021:	8e e0                	mov    %eax,%fs
    movw    %ax,%gs
  8004200023:	8e e8                	mov    %eax,%gs
    movw    %ax,%es
  8004200025:	8e c0                	mov    %eax,%es
    pushq   $CODE_SEL
  8004200027:	6a 08                	pushq  $0x8
    movabs  $relocated,%rax
  8004200029:	48 b8 36 00 20 04 80 	movabs $0x8004200036,%rax
  8004200030:	00 00 00 
    pushq   %rax
  8004200033:	50                   	push   %rax
    lretq
  8004200034:	48 cb                	lretq  

0000008004200036 <relocated>:
relocated:

	# Clear the frame pointer register (RBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movq	$0x0,%rbp			# nuke frame pointer
  8004200036:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Set the stack pointer
	movabs	$(bootstacktop),%rax
  800420003d:	48 b8 00 a0 22 04 80 	movabs $0x800422a000,%rax
  8004200044:	00 00 00 
	movq  %rax,%rsp
  8004200047:	48 89 c4             	mov    %rax,%rsp

	# now to C code
    movabs $i386_init, %rax
  800420004a:	48 b8 a5 00 20 04 80 	movabs $0x80042000a5,%rax
  8004200051:	00 00 00 
	call *%rax
  8004200054:	ff d0                	callq  *%rax

0000008004200056 <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
  8004200056:	eb fe                	jmp    8004200056 <spin>

0000008004200058 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004200058:	55                   	push   %rbp
  8004200059:	48 89 e5             	mov    %rsp,%rbp
  800420005c:	53                   	push   %rbx
  800420005d:	48 83 ec 20          	sub    $0x20,%rsp
  8004200061:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
  8004200065:	89 75 dc             	mov    %esi,-0x24(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
	"+m" (*addr), "=a" (result):
  8004200068:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800420006c:	8b 45 dc             	mov    -0x24(%rbp),%eax
	"+m" (*addr), "=a" (result):
  800420006f:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004200073:	89 c3                	mov    %eax,%ebx
  8004200075:	89 d8                	mov    %ebx,%eax
  8004200077:	f0 87 02             	lock xchg %eax,(%rdx)
  800420007a:	89 c3                	mov    %eax,%ebx
  800420007c:	89 5d f4             	mov    %ebx,-0xc(%rbp)
	"+m" (*addr), "=a" (result):
	"1"(newval):
	"cc");
	return result;
  800420007f:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  8004200082:	48 83 c4 20          	add    $0x20,%rsp
  8004200086:	5b                   	pop    %rbx
  8004200087:	5d                   	pop    %rbp
  8004200088:	c3                   	retq   

0000008004200089 <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  8004200089:	55                   	push   %rbp
  800420008a:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  800420008d:	48 bf 80 a7 22 04 80 	movabs $0x800422a780,%rdi
  8004200094:	00 00 00 
  8004200097:	48 b8 61 59 21 04 80 	movabs $0x8004215961,%rax
  800420009e:	00 00 00 
  80042000a1:	ff d0                	callq  *%rax
}
  80042000a3:	5d                   	pop    %rbp
  80042000a4:	c3                   	retq   

00000080042000a5 <i386_init>:
static void boot_aps(void);


void
i386_init(void)
{
  80042000a5:	55                   	push   %rbp
  80042000a6:	48 89 e5             	mov    %rsp,%rbp
	extern char edata[], end[];

	// Before doing anything else, complete the ELF loading process.
	// Clear the uninitialized global data (BSS) section of our program.
	// This ensures that all static/global variables start out zero.
	memset(edata, 0, end - edata);
  80042000a9:	48 ba 18 f0 6f 04 80 	movabs $0x80046ff018,%rdx
  80042000b0:	00 00 00 
  80042000b3:	48 b8 07 a6 63 04 80 	movabs $0x800463a607,%rax
  80042000ba:	00 00 00 
  80042000bd:	48 89 d1             	mov    %rdx,%rcx
  80042000c0:	48 29 c1             	sub    %rax,%rcx
  80042000c3:	48 89 c8             	mov    %rcx,%rax
  80042000c6:	48 89 c2             	mov    %rax,%rdx
  80042000c9:	be 00 00 00 00       	mov    $0x0,%esi
  80042000ce:	48 bf 07 a6 63 04 80 	movabs $0x800463a607,%rdi
  80042000d5:	00 00 00 
  80042000d8:	48 b8 53 e6 20 04 80 	movabs $0x800420e653,%rax
  80042000df:	00 00 00 
  80042000e2:	ff d0                	callq  *%rax

	// Initialize the console.
	// Can't call cprintf until after we do this!
	cons_init();
  80042000e4:	48 b8 51 12 20 04 80 	movabs $0x8004201251,%rax
  80042000eb:	00 00 00 
  80042000ee:	ff d0                	callq  *%rax

	cprintf("6828 decimal is %o octal!\n", 6828);
  80042000f0:	be ac 1a 00 00       	mov    $0x1aac,%esi
  80042000f5:	48 bf a0 6f 21 04 80 	movabs $0x8004216fa0,%rdi
  80042000fc:	00 00 00 
  80042000ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200104:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420010b:	00 00 00 
  800420010e:	ff d2                	callq  *%rdx

    extern char end[];
    end_debug = read_section_headers((0x10000+KERNBASE), (uintptr_t)end); 
  8004200110:	48 b8 18 f0 6f 04 80 	movabs $0x80046ff018,%rax
  8004200117:	00 00 00 
  800420011a:	48 89 c6             	mov    %rax,%rsi
  800420011d:	48 bf 00 00 01 04 80 	movabs $0x8004010000,%rdi
  8004200124:	00 00 00 
  8004200127:	48 b8 17 41 21 04 80 	movabs $0x8004214117,%rax
  800420012e:	00 00 00 
  8004200131:	ff d0                	callq  *%rax
  8004200133:	48 ba b8 c7 63 04 80 	movabs $0x800463c7b8,%rdx
  800420013a:	00 00 00 
  800420013d:	48 89 02             	mov    %rax,(%rdx)

	// Lab 2 memory management initialization functions
	x64_vm_init();
  8004200140:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200145:	48 ba 86 24 20 04 80 	movabs $0x8004202486,%rdx
  800420014c:	00 00 00 
  800420014f:	ff d2                	callq  *%rdx

	// Lab 3 user environment initialization functions
	env_init();
  8004200151:	48 b8 3f 77 20 04 80 	movabs $0x800420773f,%rax
  8004200158:	00 00 00 
  800420015b:	ff d0                	callq  *%rax
	trap_init();
  800420015d:	48 b8 78 8b 20 04 80 	movabs $0x8004208b78,%rax
  8004200164:	00 00 00 
  8004200167:	ff d0                	callq  *%rax

	// Lab 4 multiprocessor initialization functions
	mp_init();
  8004200169:	48 b8 8f 50 21 04 80 	movabs $0x800421508f,%rax
  8004200170:	00 00 00 
  8004200173:	ff d0                	callq  *%rax
	lapic_init();
  8004200175:	48 b8 da 53 21 04 80 	movabs $0x80042153da,%rax
  800420017c:	00 00 00 
  800420017f:	ff d0                	callq  *%rax

	// Lab 4 multitasking initialization functions
	pic_init();
  8004200181:	48 b8 ec 86 20 04 80 	movabs $0x80042086ec,%rax
  8004200188:	00 00 00 
  800420018b:	ff d0                	callq  *%rax

	// Lab 6 hardware initialization functions
	time_init();
  800420018d:	48 b8 f8 6e 21 04 80 	movabs $0x8004216ef8,%rax
  8004200194:	00 00 00 
  8004200197:	ff d0                	callq  *%rax
	pci_init();
  8004200199:	48 b8 ba 6e 21 04 80 	movabs $0x8004216eba,%rax
  80042001a0:	00 00 00 
  80042001a3:	ff d0                	callq  *%rax

	// Acquire the big kernel lock before waking up APs
	// Your code here:
	lock_kernel();
  80042001a5:	48 b8 89 00 20 04 80 	movabs $0x8004200089,%rax
  80042001ac:	00 00 00 
  80042001af:	ff d0                	callq  *%rax
	// Starting non-boot CPUs
	boot_aps();
  80042001b1:	48 b8 26 02 20 04 80 	movabs $0x8004200226,%rax
  80042001b8:	00 00 00 
  80042001bb:	ff d0                	callq  *%rax

	// Start fs.
	ENV_CREATE(fs_fs, ENV_TYPE_FS);
  80042001bd:	be 01 00 00 00       	mov    $0x1,%esi
  80042001c2:	48 bf e7 46 46 04 80 	movabs $0x80044646e7,%rdi
  80042001c9:	00 00 00 
  80042001cc:	48 b8 07 7e 20 04 80 	movabs $0x8004207e07,%rax
  80042001d3:	00 00 00 
  80042001d6:	ff d0                	callq  *%rax

#if !defined(TEST_NO_NS)
	// Start ns.
	ENV_CREATE(net_ns, ENV_TYPE_NS);
  80042001d8:	be 02 00 00 00       	mov    $0x2,%esi
  80042001dd:	48 bf 42 90 51 04 80 	movabs $0x8004519042,%rdi
  80042001e4:	00 00 00 
  80042001e7:	48 b8 07 7e 20 04 80 	movabs $0x8004207e07,%rax
  80042001ee:	00 00 00 
  80042001f1:	ff d0                	callq  *%rax
#endif

#if defined(TEST)
	// Don't touch -- used by grading script!
	ENV_CREATE(TEST, ENV_TYPE_USER);
  80042001f3:	be 00 00 00 00       	mov    $0x0,%esi
  80042001f8:	48 bf af 25 4a 04 80 	movabs $0x80044a25af,%rdi
  80042001ff:	00 00 00 
  8004200202:	48 b8 07 7e 20 04 80 	movabs $0x8004207e07,%rax
  8004200209:	00 00 00 
  800420020c:	ff d0                	callq  *%rax
//<<<<<<< HEAD
	//ENV_CREATE(user_spawnhello, ENV_TYPE_USER);
#endif // TEST*

	// Should not be necessary - drains keyboard because interrupt has given up.
	kbd_intr();
  800420020e:	48 b8 81 10 20 04 80 	movabs $0x8004201081,%rax
  8004200215:	00 00 00 
  8004200218:	ff d0                	callq  *%rax
	//ENV_CREATE(user_yield, ENV_TYPE_USER);

//#endif // TEST*
//>>>>>>> lab4
	// Schedule and run the first user environment!
	sched_yield();
  800420021a:	48 b8 db bc 20 04 80 	movabs $0x800420bcdb,%rax
  8004200221:	00 00 00 
  8004200224:	ff d0                	callq  *%rax

0000008004200226 <boot_aps>:
void *mpentry_kstack;

// Start the non-boot (AP) processors.
static void
boot_aps(void)
{
  8004200226:	55                   	push   %rbp
  8004200227:	48 89 e5             	mov    %rsp,%rbp
  800420022a:	48 83 ec 30          	sub    $0x30,%rsp
	extern unsigned char mpentry_start[], mpentry_end[];
	void *code;
	struct CpuInfo *c;

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
  800420022e:	48 c7 45 f0 00 70 00 	movq   $0x7000,-0x10(%rbp)
  8004200235:	00 
  8004200236:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420023a:	48 c1 e8 0c          	shr    $0xc,%rax
  800420023e:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004200241:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200244:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  800420024b:	00 00 00 
  800420024e:	48 8b 00             	mov    (%rax),%rax
  8004200251:	48 39 c2             	cmp    %rax,%rdx
  8004200254:	72 32                	jb     8004200288 <boot_aps+0x62>
  8004200256:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420025a:	48 89 c1             	mov    %rax,%rcx
  800420025d:	48 ba c0 6f 21 04 80 	movabs $0x8004216fc0,%rdx
  8004200264:	00 00 00 
  8004200267:	be 7a 00 00 00       	mov    $0x7a,%esi
  800420026c:	48 bf e3 6f 21 04 80 	movabs $0x8004216fe3,%rdi
  8004200273:	00 00 00 
  8004200276:	b8 00 00 00 00       	mov    $0x0,%eax
  800420027b:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004200282:	00 00 00 
  8004200285:	41 ff d0             	callq  *%r8
  8004200288:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  800420028f:	00 00 00 
  8004200292:	48 03 45 f0          	add    -0x10(%rbp),%rax
  8004200296:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
  800420029a:	48 ba ce 4b 21 04 80 	movabs $0x8004214bce,%rdx
  80042002a1:	00 00 00 
  80042002a4:	48 b8 e8 4a 21 04 80 	movabs $0x8004214ae8,%rax
  80042002ab:	00 00 00 
  80042002ae:	48 89 d1             	mov    %rdx,%rcx
  80042002b1:	48 29 c1             	sub    %rax,%rcx
  80042002b4:	48 89 c8             	mov    %rcx,%rax
  80042002b7:	48 89 c2             	mov    %rax,%rdx
  80042002ba:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042002be:	48 be e8 4a 21 04 80 	movabs $0x8004214ae8,%rsi
  80042002c5:	00 00 00 
  80042002c8:	48 89 c7             	mov    %rax,%rdi
  80042002cb:	48 b8 de e6 20 04 80 	movabs $0x800420e6de,%rax
  80042002d2:	00 00 00 
  80042002d5:	ff d0                	callq  *%rax
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  80042002d7:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  80042002de:	00 00 00 
  80042002e1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042002e5:	e9 0d 01 00 00       	jmpq   80042003f7 <boot_aps+0x1d1>
		if (c == cpus + cpunum())  // We've started already.
  80042002ea:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  80042002f1:	00 00 00 
  80042002f4:	ff d0                	callq  *%rax
  80042002f6:	48 98                	cltq   
  80042002f8:	48 c1 e0 03          	shl    $0x3,%rax
  80042002fc:	48 89 c2             	mov    %rax,%rdx
  80042002ff:	48 c1 e2 04          	shl    $0x4,%rdx
  8004200303:	48 29 c2             	sub    %rax,%rdx
  8004200306:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420030d:	00 00 00 
  8004200310:	48 01 d0             	add    %rdx,%rax
  8004200313:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004200317:	0f 84 d4 00 00 00    	je     80042003f1 <boot_aps+0x1cb>
			continue;

		// Tell mpentry.S what stack to use 
		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
  800420031d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200321:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  8004200328:	00 00 00 
  800420032b:	48 89 d1             	mov    %rdx,%rcx
  800420032e:	48 29 c1             	sub    %rax,%rcx
  8004200331:	48 89 c8             	mov    %rcx,%rax
  8004200334:	48 89 c2             	mov    %rax,%rdx
  8004200337:	48 c1 fa 03          	sar    $0x3,%rdx
  800420033b:	48 b8 ef ee ee ee ee 	movabs $0xeeeeeeeeeeeeeeef,%rax
  8004200342:	ee ee ee 
  8004200345:	48 0f af c2          	imul   %rdx,%rax
  8004200349:	48 83 c0 01          	add    $0x1,%rax
  800420034d:	48 89 c2             	mov    %rax,%rdx
  8004200350:	48 c1 e2 10          	shl    $0x10,%rdx
  8004200354:	48 b8 00 f0 67 04 80 	movabs $0x800467f000,%rax
  800420035b:	00 00 00 
  800420035e:	48 01 c2             	add    %rax,%rdx
  8004200361:	48 b8 c8 c7 63 04 80 	movabs $0x800463c7c8,%rax
  8004200368:	00 00 00 
  800420036b:	48 89 10             	mov    %rdx,(%rax)
		// Start the CPU at mpentry_start
		lapic_startap(c->cpu_id, PADDR(code));
  800420036e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004200372:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004200376:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420037d:	00 00 00 
  8004200380:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  8004200384:	77 32                	ja     80042003b8 <boot_aps+0x192>
  8004200386:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420038a:	48 89 c1             	mov    %rax,%rcx
  800420038d:	48 ba f0 6f 21 04 80 	movabs $0x8004216ff0,%rdx
  8004200394:	00 00 00 
  8004200397:	be 84 00 00 00       	mov    $0x84,%esi
  800420039c:	48 bf e3 6f 21 04 80 	movabs $0x8004216fe3,%rdi
  80042003a3:	00 00 00 
  80042003a6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042003ab:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042003b2:	00 00 00 
  80042003b5:	41 ff d0             	callq  *%r8
  80042003b8:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  80042003bf:	ff ff ff 
  80042003c2:	48 03 45 d8          	add    -0x28(%rbp),%rax
  80042003c6:	89 c2                	mov    %eax,%edx
  80042003c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042003cc:	0f b6 00             	movzbl (%rax),%eax
  80042003cf:	0f b6 c0             	movzbl %al,%eax
  80042003d2:	89 d6                	mov    %edx,%esi
  80042003d4:	89 c7                	mov    %eax,%edi
  80042003d6:	48 b8 45 56 21 04 80 	movabs $0x8004215645,%rax
  80042003dd:	00 00 00 
  80042003e0:	ff d0                	callq  *%rax
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
  80042003e2:	90                   	nop
  80042003e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042003e7:	8b 40 04             	mov    0x4(%rax),%eax
  80042003ea:	83 f8 01             	cmp    $0x1,%eax
  80042003ed:	75 f4                	jne    80042003e3 <boot_aps+0x1bd>
  80042003ef:	eb 01                	jmp    80042003f2 <boot_aps+0x1cc>
	code = KADDR(MPENTRY_PADDR);
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
		if (c == cpus + cpunum())  // We've started already.
			continue;
  80042003f1:	90                   	nop

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  80042003f2:	48 83 45 f8 78       	addq   $0x78,-0x8(%rbp)
  80042003f7:	48 b8 e8 e3 67 04 80 	movabs $0x800467e3e8,%rax
  80042003fe:	00 00 00 
  8004200401:	8b 00                	mov    (%rax),%eax
  8004200403:	48 98                	cltq   
  8004200405:	48 c1 e0 03          	shl    $0x3,%rax
  8004200409:	48 89 c2             	mov    %rax,%rdx
  800420040c:	48 c1 e2 04          	shl    $0x4,%rdx
  8004200410:	48 29 c2             	sub    %rax,%rdx
  8004200413:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420041a:	00 00 00 
  800420041d:	48 01 d0             	add    %rdx,%rax
  8004200420:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004200424:	0f 87 c0 fe ff ff    	ja     80042002ea <boot_aps+0xc4>
		lapic_startap(c->cpu_id, PADDR(code));
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
			;
	}
}
  800420042a:	c9                   	leaveq 
  800420042b:	c3                   	retq   

000000800420042c <mp_main>:

// Setup code for APs
void
mp_main(void)
{
  800420042c:	55                   	push   %rbp
  800420042d:	48 89 e5             	mov    %rsp,%rbp
  8004200430:	48 83 ec 10          	sub    $0x10,%rsp
	// We are in high EIP now, safe to switch to kern_pgdir 
	lcr3(boot_cr3);
  8004200434:	48 b8 d0 c7 63 04 80 	movabs $0x800463c7d0,%rax
  800420043b:	00 00 00 
  800420043e:	48 8b 00             	mov    (%rax),%rax
  8004200441:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004200445:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200449:	0f 22 d8             	mov    %rax,%cr3
	cprintf("SMP: CPU %d starting\n", cpunum());
  800420044c:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  8004200453:	00 00 00 
  8004200456:	ff d0                	callq  *%rax
  8004200458:	89 c6                	mov    %eax,%esi
  800420045a:	48 bf 14 70 21 04 80 	movabs $0x8004217014,%rdi
  8004200461:	00 00 00 
  8004200464:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200469:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  8004200470:	00 00 00 
  8004200473:	ff d2                	callq  *%rdx


	lapic_init();
  8004200475:	48 b8 da 53 21 04 80 	movabs $0x80042153da,%rax
  800420047c:	00 00 00 
  800420047f:	ff d0                	callq  *%rax
	env_init_percpu();
  8004200481:	48 b8 51 78 20 04 80 	movabs $0x8004207851,%rax
  8004200488:	00 00 00 
  800420048b:	ff d0                	callq  *%rax
	trap_init_percpu();
  800420048d:	48 b8 9c a6 20 04 80 	movabs $0x800420a69c,%rax
  8004200494:	00 00 00 
  8004200497:	ff d0                	callq  *%rax
	xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
  8004200499:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  80042004a0:	00 00 00 
  80042004a3:	ff d0                	callq  *%rax
  80042004a5:	48 98                	cltq   
  80042004a7:	48 c1 e0 03          	shl    $0x3,%rax
  80042004ab:	48 89 c2             	mov    %rax,%rdx
  80042004ae:	48 c1 e2 04          	shl    $0x4,%rdx
  80042004b2:	48 29 c2             	sub    %rax,%rdx
  80042004b5:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  80042004bc:	00 00 00 
  80042004bf:	48 01 d0             	add    %rdx,%rax
  80042004c2:	48 83 c0 04          	add    $0x4,%rax
  80042004c6:	be 01 00 00 00       	mov    $0x1,%esi
  80042004cb:	48 89 c7             	mov    %rax,%rdi
  80042004ce:	48 b8 58 00 20 04 80 	movabs $0x8004200058,%rax
  80042004d5:	00 00 00 
  80042004d8:	ff d0                	callq  *%rax
	// Now that we have finished some basic setup, call sched_yield()
	// to start running processes on this CPU.  But make sure that
	// only one CPU can enter the scheduler at a time!
	//
	// Your code here:
	lock_kernel();
  80042004da:	48 b8 89 00 20 04 80 	movabs $0x8004200089,%rax
  80042004e1:	00 00 00 
  80042004e4:	ff d0                	callq  *%rax
	sched_yield();
  80042004e6:	48 b8 db bc 20 04 80 	movabs $0x800420bcdb,%rax
  80042004ed:	00 00 00 
  80042004f0:	ff d0                	callq  *%rax

00000080042004f2 <_panic>:
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", and then enters the kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
{
  80042004f2:	55                   	push   %rbp
  80042004f3:	48 89 e5             	mov    %rsp,%rbp
  80042004f6:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  80042004fd:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  8004200504:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  800420050a:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004200511:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004200518:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420051f:	84 c0                	test   %al,%al
  8004200521:	74 20                	je     8004200543 <_panic+0x51>
  8004200523:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004200527:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420052b:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420052f:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004200533:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004200537:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420053b:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420053f:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004200543:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	if (panicstr)
  800420054a:	48 b8 c0 c7 63 04 80 	movabs $0x800463c7c0,%rax
  8004200551:	00 00 00 
  8004200554:	48 8b 00             	mov    (%rax),%rax
  8004200557:	48 85 c0             	test   %rax,%rax
  800420055a:	0f 85 b7 00 00 00    	jne    8004200617 <_panic+0x125>
		goto dead;
	panicstr = fmt;
  8004200560:	48 b8 c0 c7 63 04 80 	movabs $0x800463c7c0,%rax
  8004200567:	00 00 00 
  800420056a:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  8004200571:	48 89 10             	mov    %rdx,(%rax)

	// Be extra sure that the machine is in as reasonable state
	__asm __volatile("cli; cld");
  8004200574:	fa                   	cli    
  8004200575:	fc                   	cld    

	va_start(ap, fmt);
  8004200576:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420057d:	00 00 00 
  8004200580:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  8004200587:	00 00 00 
  800420058a:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420058e:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004200595:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420059c:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel panic on CPU %d at %s:%d: ", cpunum(), file, line);
  80042005a3:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  80042005aa:	00 00 00 
  80042005ad:	ff d0                	callq  *%rax
  80042005af:	8b 8d 24 ff ff ff    	mov    -0xdc(%rbp),%ecx
  80042005b5:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  80042005bc:	89 c6                	mov    %eax,%esi
  80042005be:	48 bf 30 70 21 04 80 	movabs $0x8004217030,%rdi
  80042005c5:	00 00 00 
  80042005c8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042005cd:	49 b8 f2 89 20 04 80 	movabs $0x80042089f2,%r8
  80042005d4:	00 00 00 
  80042005d7:	41 ff d0             	callq  *%r8
	vcprintf(fmt, ap);
  80042005da:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  80042005e1:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042005e8:	48 89 d6             	mov    %rdx,%rsi
  80042005eb:	48 89 c7             	mov    %rax,%rdi
  80042005ee:	48 b8 93 89 20 04 80 	movabs $0x8004208993,%rax
  80042005f5:	00 00 00 
  80042005f8:	ff d0                	callq  *%rax
	cprintf("\n");
  80042005fa:	48 bf 52 70 21 04 80 	movabs $0x8004217052,%rdi
  8004200601:	00 00 00 
  8004200604:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200609:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  8004200610:	00 00 00 
  8004200613:	ff d2                	callq  *%rdx
  8004200615:	eb 01                	jmp    8004200618 <_panic+0x126>
_panic(const char *file, int line, const char *fmt,...)
{
	va_list ap;

	if (panicstr)
		goto dead;
  8004200617:	90                   	nop
	va_end(ap);

dead:
	/* break into the kernel monitor */
	while (1)
		monitor(NULL);
  8004200618:	bf 00 00 00 00       	mov    $0x0,%edi
  800420061d:	48 b8 c9 18 20 04 80 	movabs $0x80042018c9,%rax
  8004200624:	00 00 00 
  8004200627:	ff d0                	callq  *%rax
  8004200629:	eb ed                	jmp    8004200618 <_panic+0x126>

000000800420062b <_warn>:
}

/* like panic, but don't */
void
_warn(const char *file, int line, const char *fmt,...)
{
  800420062b:	55                   	push   %rbp
  800420062c:	48 89 e5             	mov    %rsp,%rbp
  800420062f:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  8004200636:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420063d:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  8004200643:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420064a:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004200651:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004200658:	84 c0                	test   %al,%al
  800420065a:	74 20                	je     800420067c <_warn+0x51>
  800420065c:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004200660:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004200664:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004200668:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420066c:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004200670:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004200674:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004200678:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420067c:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  8004200683:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420068a:	00 00 00 
  800420068d:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  8004200694:	00 00 00 
  8004200697:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420069b:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  80042006a2:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042006a9:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel warning at %s:%d: ", file, line);
  80042006b0:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  80042006b6:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042006bd:	48 89 c6             	mov    %rax,%rsi
  80042006c0:	48 bf 54 70 21 04 80 	movabs $0x8004217054,%rdi
  80042006c7:	00 00 00 
  80042006ca:	b8 00 00 00 00       	mov    $0x0,%eax
  80042006cf:	48 b9 f2 89 20 04 80 	movabs $0x80042089f2,%rcx
  80042006d6:	00 00 00 
  80042006d9:	ff d1                	callq  *%rcx
	vcprintf(fmt, ap);
  80042006db:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  80042006e2:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042006e9:	48 89 d6             	mov    %rdx,%rsi
  80042006ec:	48 89 c7             	mov    %rax,%rdi
  80042006ef:	48 b8 93 89 20 04 80 	movabs $0x8004208993,%rax
  80042006f6:	00 00 00 
  80042006f9:	ff d0                	callq  *%rax
	cprintf("\n");
  80042006fb:	48 bf 52 70 21 04 80 	movabs $0x8004217052,%rdi
  8004200702:	00 00 00 
  8004200705:	b8 00 00 00 00       	mov    $0x0,%eax
  800420070a:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  8004200711:	00 00 00 
  8004200714:	ff d2                	callq  *%rdx
	va_end(ap);
}
  8004200716:	c9                   	leaveq 
  8004200717:	c3                   	retq   

0000008004200718 <delay>:
static void cons_putc(int c);

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
  8004200718:	55                   	push   %rbp
  8004200719:	48 89 e5             	mov    %rsp,%rbp
  800420071c:	53                   	push   %rbx
  800420071d:	48 83 ec 28          	sub    $0x28,%rsp
  8004200721:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200728:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420072b:	89 55 d4             	mov    %edx,-0x2c(%rbp)
  800420072e:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004200731:	ec                   	in     (%dx),%al
  8004200732:	89 c3                	mov    %eax,%ebx
  8004200734:	88 5d f3             	mov    %bl,-0xd(%rbp)
	return data;
  8004200737:	c7 45 ec 84 00 00 00 	movl   $0x84,-0x14(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420073e:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200741:	89 55 d4             	mov    %edx,-0x2c(%rbp)
  8004200744:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004200747:	ec                   	in     (%dx),%al
  8004200748:	89 c3                	mov    %eax,%ebx
  800420074a:	88 5d eb             	mov    %bl,-0x15(%rbp)
	return data;
  800420074d:	c7 45 e4 84 00 00 00 	movl   $0x84,-0x1c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200754:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200757:	89 55 d4             	mov    %edx,-0x2c(%rbp)
  800420075a:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800420075d:	ec                   	in     (%dx),%al
  800420075e:	89 c3                	mov    %eax,%ebx
  8004200760:	88 5d e3             	mov    %bl,-0x1d(%rbp)
	return data;
  8004200763:	c7 45 dc 84 00 00 00 	movl   $0x84,-0x24(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420076a:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800420076d:	89 55 d4             	mov    %edx,-0x2c(%rbp)
  8004200770:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004200773:	ec                   	in     (%dx),%al
  8004200774:	89 c3                	mov    %eax,%ebx
  8004200776:	88 5d db             	mov    %bl,-0x25(%rbp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
  8004200779:	48 83 c4 28          	add    $0x28,%rsp
  800420077d:	5b                   	pop    %rbx
  800420077e:	5d                   	pop    %rbp
  800420077f:	c3                   	retq   

0000008004200780 <serial_proc_data>:

static bool serial_exists;

static int
serial_proc_data(void)
{
  8004200780:	55                   	push   %rbp
  8004200781:	48 89 e5             	mov    %rsp,%rbp
  8004200784:	53                   	push   %rbx
  8004200785:	48 83 ec 18          	sub    $0x18,%rsp
  8004200789:	c7 45 f4 fd 03 00 00 	movl   $0x3fd,-0xc(%rbp)
  8004200790:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004200793:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  8004200796:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200799:	ec                   	in     (%dx),%al
  800420079a:	89 c3                	mov    %eax,%ebx
  800420079c:	88 5d f3             	mov    %bl,-0xd(%rbp)
	return data;
  800420079f:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
  80042007a3:	0f b6 c0             	movzbl %al,%eax
  80042007a6:	83 e0 01             	and    $0x1,%eax
  80042007a9:	85 c0                	test   %eax,%eax
  80042007ab:	75 07                	jne    80042007b4 <serial_proc_data+0x34>
		return -1;
  80042007ad:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042007b2:	eb 1d                	jmp    80042007d1 <serial_proc_data+0x51>
  80042007b4:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042007bb:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042007be:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  80042007c1:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042007c4:	ec                   	in     (%dx),%al
  80042007c5:	89 c3                	mov    %eax,%ebx
  80042007c7:	88 5d eb             	mov    %bl,-0x15(%rbp)
	return data;
  80042007ca:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
	return inb(COM1+COM_RX);
  80042007ce:	0f b6 c0             	movzbl %al,%eax
}
  80042007d1:	48 83 c4 18          	add    $0x18,%rsp
  80042007d5:	5b                   	pop    %rbx
  80042007d6:	5d                   	pop    %rbp
  80042007d7:	c3                   	retq   

00000080042007d8 <serial_intr>:

void
serial_intr(void)
{
  80042007d8:	55                   	push   %rbp
  80042007d9:	48 89 e5             	mov    %rsp,%rbp
	if (serial_exists)
  80042007dc:	48 b8 00 b0 63 04 80 	movabs $0x800463b000,%rax
  80042007e3:	00 00 00 
  80042007e6:	0f b6 00             	movzbl (%rax),%eax
  80042007e9:	84 c0                	test   %al,%al
  80042007eb:	74 16                	je     8004200803 <serial_intr+0x2b>
		cons_intr(serial_proc_data);
  80042007ed:	48 bf 80 07 20 04 80 	movabs $0x8004200780,%rdi
  80042007f4:	00 00 00 
  80042007f7:	48 b8 d2 10 20 04 80 	movabs $0x80042010d2,%rax
  80042007fe:	00 00 00 
  8004200801:	ff d0                	callq  *%rax
}
  8004200803:	5d                   	pop    %rbp
  8004200804:	c3                   	retq   

0000008004200805 <serial_putc>:

static void
serial_putc(int c)
{
  8004200805:	55                   	push   %rbp
  8004200806:	48 89 e5             	mov    %rsp,%rbp
  8004200809:	53                   	push   %rbx
  800420080a:	48 83 ec 28          	sub    $0x28,%rsp
  800420080e:	89 7d d4             	mov    %edi,-0x2c(%rbp)
	int i;

	for (i = 0;
  8004200811:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004200818:	eb 10                	jmp    800420082a <serial_putc+0x25>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
		delay();
  800420081a:	48 b8 18 07 20 04 80 	movabs $0x8004200718,%rax
  8004200821:	00 00 00 
  8004200824:	ff d0                	callq  *%rax
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
  8004200826:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800420082a:	c7 45 f0 fd 03 00 00 	movl   $0x3fd,-0x10(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200831:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200834:	89 55 d0             	mov    %edx,-0x30(%rbp)
  8004200837:	8b 55 d0             	mov    -0x30(%rbp),%edx
  800420083a:	ec                   	in     (%dx),%al
  800420083b:	89 c3                	mov    %eax,%ebx
  800420083d:	88 5d ef             	mov    %bl,-0x11(%rbp)
	return data;
  8004200840:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
serial_putc(int c)
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  8004200844:	0f b6 c0             	movzbl %al,%eax
  8004200847:	83 e0 20             	and    $0x20,%eax
static void
serial_putc(int c)
{
	int i;

	for (i = 0;
  800420084a:	85 c0                	test   %eax,%eax
  800420084c:	75 09                	jne    8004200857 <serial_putc+0x52>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  800420084e:	81 7d f4 ff 31 00 00 	cmpl   $0x31ff,-0xc(%rbp)
  8004200855:	7e c3                	jle    800420081a <serial_putc+0x15>
	     i++)
		delay();

	outb(COM1 + COM_TX, c);
  8004200857:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800420085a:	0f b6 c0             	movzbl %al,%eax
  800420085d:	c7 45 e8 f8 03 00 00 	movl   $0x3f8,-0x18(%rbp)
  8004200864:	88 45 e7             	mov    %al,-0x19(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200867:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420086b:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420086e:	ee                   	out    %al,(%dx)
}
  800420086f:	48 83 c4 28          	add    $0x28,%rsp
  8004200873:	5b                   	pop    %rbx
  8004200874:	5d                   	pop    %rbp
  8004200875:	c3                   	retq   

0000008004200876 <serial_init>:

static void
serial_init(void)
{
  8004200876:	55                   	push   %rbp
  8004200877:	48 89 e5             	mov    %rsp,%rbp
  800420087a:	53                   	push   %rbx
  800420087b:	48 83 ec 68          	sub    $0x68,%rsp
  800420087f:	c7 45 ec fa 03 00 00 	movl   $0x3fa,-0x14(%rbp)
  8004200886:	c6 45 eb 00          	movb   $0x0,-0x15(%rbp)
  800420088a:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  800420088e:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200891:	ee                   	out    %al,(%dx)
  8004200892:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%rbp)
  8004200899:	c6 45 e3 80          	movb   $0x80,-0x1d(%rbp)
  800420089d:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  80042008a1:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042008a4:	ee                   	out    %al,(%dx)
  80042008a5:	c7 45 dc f8 03 00 00 	movl   $0x3f8,-0x24(%rbp)
  80042008ac:	c6 45 db 0c          	movb   $0xc,-0x25(%rbp)
  80042008b0:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  80042008b4:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042008b7:	ee                   	out    %al,(%dx)
  80042008b8:	c7 45 d4 f9 03 00 00 	movl   $0x3f9,-0x2c(%rbp)
  80042008bf:	c6 45 d3 00          	movb   $0x0,-0x2d(%rbp)
  80042008c3:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  80042008c7:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042008ca:	ee                   	out    %al,(%dx)
  80042008cb:	c7 45 cc fb 03 00 00 	movl   $0x3fb,-0x34(%rbp)
  80042008d2:	c6 45 cb 03          	movb   $0x3,-0x35(%rbp)
  80042008d6:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  80042008da:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042008dd:	ee                   	out    %al,(%dx)
  80042008de:	c7 45 c4 fc 03 00 00 	movl   $0x3fc,-0x3c(%rbp)
  80042008e5:	c6 45 c3 00          	movb   $0x0,-0x3d(%rbp)
  80042008e9:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
  80042008ed:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042008f0:	ee                   	out    %al,(%dx)
  80042008f1:	c7 45 bc f9 03 00 00 	movl   $0x3f9,-0x44(%rbp)
  80042008f8:	c6 45 bb 01          	movb   $0x1,-0x45(%rbp)
  80042008fc:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  8004200900:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004200903:	ee                   	out    %al,(%dx)
  8004200904:	c7 45 b4 fd 03 00 00 	movl   $0x3fd,-0x4c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420090b:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  800420090e:	89 55 9c             	mov    %edx,-0x64(%rbp)
  8004200911:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004200914:	ec                   	in     (%dx),%al
  8004200915:	89 c3                	mov    %eax,%ebx
  8004200917:	88 5d b3             	mov    %bl,-0x4d(%rbp)
	return data;
  800420091a:	0f b6 45 b3          	movzbl -0x4d(%rbp),%eax
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
  800420091e:	3c ff                	cmp    $0xff,%al
  8004200920:	0f 95 c2             	setne  %dl
  8004200923:	48 b8 00 b0 63 04 80 	movabs $0x800463b000,%rax
  800420092a:	00 00 00 
  800420092d:	88 10                	mov    %dl,(%rax)
  800420092f:	c7 45 ac fa 03 00 00 	movl   $0x3fa,-0x54(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200936:	8b 55 ac             	mov    -0x54(%rbp),%edx
  8004200939:	89 55 9c             	mov    %edx,-0x64(%rbp)
  800420093c:	8b 55 9c             	mov    -0x64(%rbp),%edx
  800420093f:	ec                   	in     (%dx),%al
  8004200940:	89 c3                	mov    %eax,%ebx
  8004200942:	88 5d ab             	mov    %bl,-0x55(%rbp)
	return data;
  8004200945:	c7 45 a4 f8 03 00 00 	movl   $0x3f8,-0x5c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420094c:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  800420094f:	89 55 9c             	mov    %edx,-0x64(%rbp)
  8004200952:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004200955:	ec                   	in     (%dx),%al
  8004200956:	89 c3                	mov    %eax,%ebx
  8004200958:	88 5d a3             	mov    %bl,-0x5d(%rbp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	// Enable serial interrupts
	if (serial_exists)
  800420095b:	48 b8 00 b0 63 04 80 	movabs $0x800463b000,%rax
  8004200962:	00 00 00 
  8004200965:	0f b6 00             	movzbl (%rax),%eax
  8004200968:	84 c0                	test   %al,%al
  800420096a:	74 23                	je     800420098f <serial_init+0x119>
		irq_setmask_8259A(irq_mask_8259A & ~(1<<4));
  800420096c:	48 b8 94 a6 22 04 80 	movabs $0x800422a694,%rax
  8004200973:	00 00 00 
  8004200976:	0f b7 00             	movzwl (%rax),%eax
  8004200979:	0f b7 c0             	movzwl %ax,%eax
  800420097c:	25 ef ff 00 00       	and    $0xffef,%eax
  8004200981:	89 c7                	mov    %eax,%edi
  8004200983:	48 b8 3e 88 20 04 80 	movabs $0x800420883e,%rax
  800420098a:	00 00 00 
  800420098d:	ff d0                	callq  *%rax
}
  800420098f:	48 83 c4 68          	add    $0x68,%rsp
  8004200993:	5b                   	pop    %rbx
  8004200994:	5d                   	pop    %rbp
  8004200995:	c3                   	retq   

0000008004200996 <lpt_putc>:
// For information on PC parallel port programming, see the class References
// page.

static void
lpt_putc(int c)
{
  8004200996:	55                   	push   %rbp
  8004200997:	48 89 e5             	mov    %rsp,%rbp
  800420099a:	53                   	push   %rbx
  800420099b:	48 83 ec 38          	sub    $0x38,%rsp
  800420099f:	89 7d c4             	mov    %edi,-0x3c(%rbp)
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  80042009a2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042009a9:	eb 10                	jmp    80042009bb <lpt_putc+0x25>
		delay();
  80042009ab:	48 b8 18 07 20 04 80 	movabs $0x8004200718,%rax
  80042009b2:	00 00 00 
  80042009b5:	ff d0                	callq  *%rax
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  80042009b7:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042009bb:	c7 45 f0 79 03 00 00 	movl   $0x379,-0x10(%rbp)
  80042009c2:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042009c5:	89 55 c0             	mov    %edx,-0x40(%rbp)
  80042009c8:	8b 55 c0             	mov    -0x40(%rbp),%edx
  80042009cb:	ec                   	in     (%dx),%al
  80042009cc:	89 c3                	mov    %eax,%ebx
  80042009ce:	88 5d ef             	mov    %bl,-0x11(%rbp)
	return data;
  80042009d1:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  80042009d5:	84 c0                	test   %al,%al
  80042009d7:	78 09                	js     80042009e2 <lpt_putc+0x4c>
  80042009d9:	81 7d f4 ff 31 00 00 	cmpl   $0x31ff,-0xc(%rbp)
  80042009e0:	7e c9                	jle    80042009ab <lpt_putc+0x15>
		delay();
	outb(0x378+0, c);
  80042009e2:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042009e5:	0f b6 c0             	movzbl %al,%eax
  80042009e8:	c7 45 e8 78 03 00 00 	movl   $0x378,-0x18(%rbp)
  80042009ef:	88 45 e7             	mov    %al,-0x19(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042009f2:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  80042009f6:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80042009f9:	ee                   	out    %al,(%dx)
  80042009fa:	c7 45 e0 7a 03 00 00 	movl   $0x37a,-0x20(%rbp)
  8004200a01:	c6 45 df 0d          	movb   $0xd,-0x21(%rbp)
  8004200a05:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200a09:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004200a0c:	ee                   	out    %al,(%dx)
  8004200a0d:	c7 45 d8 7a 03 00 00 	movl   $0x37a,-0x28(%rbp)
  8004200a14:	c6 45 d7 08          	movb   $0x8,-0x29(%rbp)
  8004200a18:	0f b6 45 d7          	movzbl -0x29(%rbp),%eax
  8004200a1c:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8004200a1f:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
  8004200a20:	48 83 c4 38          	add    $0x38,%rsp
  8004200a24:	5b                   	pop    %rbx
  8004200a25:	5d                   	pop    %rbp
  8004200a26:	c3                   	retq   

0000008004200a27 <cga_init>:
static uint16_t *crt_buf;
static uint16_t crt_pos;

static void
cga_init(void)
{
  8004200a27:	55                   	push   %rbp
  8004200a28:	48 89 e5             	mov    %rsp,%rbp
  8004200a2b:	53                   	push   %rbx
  8004200a2c:	48 83 ec 38          	sub    $0x38,%rsp
	volatile uint16_t *cp;
	uint16_t was;
	unsigned pos;

	cp = (uint16_t*) (KERNBASE + CGA_BUF);
  8004200a30:	c7 45 f0 00 80 0b 04 	movl   $0x40b8000,-0x10(%rbp)
  8004200a37:	c7 45 f4 80 00 00 00 	movl   $0x80,-0xc(%rbp)
	was = *cp;
  8004200a3e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200a42:	0f b7 00             	movzwl (%rax),%eax
  8004200a45:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
	*cp = (uint16_t) 0xA55A;
  8004200a49:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200a4d:	66 c7 00 5a a5       	movw   $0xa55a,(%rax)
	if (*cp != 0xA55A) {
  8004200a52:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200a56:	0f b7 00             	movzwl (%rax),%eax
  8004200a59:	66 3d 5a a5          	cmp    $0xa55a,%ax
  8004200a5d:	74 20                	je     8004200a7f <cga_init+0x58>
		cp = (uint16_t*) (KERNBASE + MONO_BUF);
  8004200a5f:	c7 45 f0 00 00 0b 04 	movl   $0x40b0000,-0x10(%rbp)
  8004200a66:	c7 45 f4 80 00 00 00 	movl   $0x80,-0xc(%rbp)
		addr_6845 = MONO_BASE;
  8004200a6d:	48 b8 04 b0 63 04 80 	movabs $0x800463b004,%rax
  8004200a74:	00 00 00 
  8004200a77:	c7 00 b4 03 00 00    	movl   $0x3b4,(%rax)
  8004200a7d:	eb 1b                	jmp    8004200a9a <cga_init+0x73>
	} else {
		*cp = was;
  8004200a7f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200a83:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
  8004200a87:	66 89 10             	mov    %dx,(%rax)
		addr_6845 = CGA_BASE;
  8004200a8a:	48 b8 04 b0 63 04 80 	movabs $0x800463b004,%rax
  8004200a91:	00 00 00 
  8004200a94:	c7 00 d4 03 00 00    	movl   $0x3d4,(%rax)
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
  8004200a9a:	48 b8 04 b0 63 04 80 	movabs $0x800463b004,%rax
  8004200aa1:	00 00 00 
  8004200aa4:	8b 00                	mov    (%rax),%eax
  8004200aa6:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004200aa9:	c6 45 e3 0e          	movb   $0xe,-0x1d(%rbp)
  8004200aad:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200ab1:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200ab4:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
  8004200ab5:	48 b8 04 b0 63 04 80 	movabs $0x800463b004,%rax
  8004200abc:	00 00 00 
  8004200abf:	8b 00                	mov    (%rax),%eax
  8004200ac1:	83 c0 01             	add    $0x1,%eax
  8004200ac4:	89 45 dc             	mov    %eax,-0x24(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200ac7:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200aca:	89 55 c4             	mov    %edx,-0x3c(%rbp)
  8004200acd:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004200ad0:	ec                   	in     (%dx),%al
  8004200ad1:	89 c3                	mov    %eax,%ebx
  8004200ad3:	88 5d db             	mov    %bl,-0x25(%rbp)
	return data;
  8004200ad6:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004200ada:	0f b6 c0             	movzbl %al,%eax
  8004200add:	c1 e0 08             	shl    $0x8,%eax
  8004200ae0:	89 45 e8             	mov    %eax,-0x18(%rbp)
	outb(addr_6845, 15);
  8004200ae3:	48 b8 04 b0 63 04 80 	movabs $0x800463b004,%rax
  8004200aea:	00 00 00 
  8004200aed:	8b 00                	mov    (%rax),%eax
  8004200aef:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  8004200af2:	c6 45 d3 0f          	movb   $0xf,-0x2d(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200af6:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004200afa:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004200afd:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
  8004200afe:	48 b8 04 b0 63 04 80 	movabs $0x800463b004,%rax
  8004200b05:	00 00 00 
  8004200b08:	8b 00                	mov    (%rax),%eax
  8004200b0a:	83 c0 01             	add    $0x1,%eax
  8004200b0d:	89 45 cc             	mov    %eax,-0x34(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200b10:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004200b13:	89 55 c4             	mov    %edx,-0x3c(%rbp)
  8004200b16:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004200b19:	ec                   	in     (%dx),%al
  8004200b1a:	89 c3                	mov    %eax,%ebx
  8004200b1c:	88 5d cb             	mov    %bl,-0x35(%rbp)
	return data;
  8004200b1f:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004200b23:	0f b6 c0             	movzbl %al,%eax
  8004200b26:	09 45 e8             	or     %eax,-0x18(%rbp)

	crt_buf = (uint16_t*) cp;
  8004200b29:	48 b8 08 b0 63 04 80 	movabs $0x800463b008,%rax
  8004200b30:	00 00 00 
  8004200b33:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004200b37:	48 89 10             	mov    %rdx,(%rax)
	crt_pos = pos;
  8004200b3a:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004200b3d:	89 c2                	mov    %eax,%edx
  8004200b3f:	48 b8 10 b0 63 04 80 	movabs $0x800463b010,%rax
  8004200b46:	00 00 00 
  8004200b49:	66 89 10             	mov    %dx,(%rax)
}
  8004200b4c:	48 83 c4 38          	add    $0x38,%rsp
  8004200b50:	5b                   	pop    %rbx
  8004200b51:	5d                   	pop    %rbp
  8004200b52:	c3                   	retq   

0000008004200b53 <cga_putc>:



static void
cga_putc(int c)
{
  8004200b53:	55                   	push   %rbp
  8004200b54:	48 89 e5             	mov    %rsp,%rbp
  8004200b57:	48 83 ec 40          	sub    $0x40,%rsp
  8004200b5b:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
  8004200b5e:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200b61:	b0 00                	mov    $0x0,%al
  8004200b63:	85 c0                	test   %eax,%eax
  8004200b65:	75 07                	jne    8004200b6e <cga_putc+0x1b>
		c |= 0x0700;
  8004200b67:	81 4d cc 00 07 00 00 	orl    $0x700,-0x34(%rbp)

	switch (c & 0xff) {
  8004200b6e:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200b71:	25 ff 00 00 00       	and    $0xff,%eax
  8004200b76:	83 f8 09             	cmp    $0x9,%eax
  8004200b79:	0f 84 f9 00 00 00    	je     8004200c78 <cga_putc+0x125>
  8004200b7f:	83 f8 09             	cmp    $0x9,%eax
  8004200b82:	7f 0a                	jg     8004200b8e <cga_putc+0x3b>
  8004200b84:	83 f8 08             	cmp    $0x8,%eax
  8004200b87:	74 18                	je     8004200ba1 <cga_putc+0x4e>
  8004200b89:	e9 41 01 00 00       	jmpq   8004200ccf <cga_putc+0x17c>
  8004200b8e:	83 f8 0a             	cmp    $0xa,%eax
  8004200b91:	74 74                	je     8004200c07 <cga_putc+0xb4>
  8004200b93:	83 f8 0d             	cmp    $0xd,%eax
  8004200b96:	0f 84 88 00 00 00    	je     8004200c24 <cga_putc+0xd1>
  8004200b9c:	e9 2e 01 00 00       	jmpq   8004200ccf <cga_putc+0x17c>
	case '\b':
		if (crt_pos > 0) {
  8004200ba1:	48 b8 10 b0 63 04 80 	movabs $0x800463b010,%rax
  8004200ba8:	00 00 00 
  8004200bab:	0f b7 00             	movzwl (%rax),%eax
  8004200bae:	66 85 c0             	test   %ax,%ax
  8004200bb1:	0f 84 53 01 00 00    	je     8004200d0a <cga_putc+0x1b7>
			crt_pos--;
  8004200bb7:	48 b8 10 b0 63 04 80 	movabs $0x800463b010,%rax
  8004200bbe:	00 00 00 
  8004200bc1:	0f b7 00             	movzwl (%rax),%eax
  8004200bc4:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004200bc7:	48 b8 10 b0 63 04 80 	movabs $0x800463b010,%rax
  8004200bce:	00 00 00 
  8004200bd1:	66 89 10             	mov    %dx,(%rax)
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
  8004200bd4:	48 b8 08 b0 63 04 80 	movabs $0x800463b008,%rax
  8004200bdb:	00 00 00 
  8004200bde:	48 8b 10             	mov    (%rax),%rdx
  8004200be1:	48 b8 10 b0 63 04 80 	movabs $0x800463b010,%rax
  8004200be8:	00 00 00 
  8004200beb:	0f b7 00             	movzwl (%rax),%eax
  8004200bee:	0f b7 c0             	movzwl %ax,%eax
  8004200bf1:	48 01 c0             	add    %rax,%rax
  8004200bf4:	48 01 c2             	add    %rax,%rdx
  8004200bf7:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200bfa:	b0 00                	mov    $0x0,%al
  8004200bfc:	83 c8 20             	or     $0x20,%eax
  8004200bff:	66 89 02             	mov    %ax,(%rdx)
		}
		break;
  8004200c02:	e9 03 01 00 00       	jmpq   8004200d0a <cga_putc+0x1b7>
	case '\n':
		crt_pos += CRT_COLS;
  8004200c07:	48 b8 10 b0 63 04 80 	movabs $0x800463b010,%rax
  8004200c0e:	00 00 00 
  8004200c11:	0f b7 00             	movzwl (%rax),%eax
  8004200c14:	8d 50 50             	lea    0x50(%rax),%edx
  8004200c17:	48 b8 10 b0 63 04 80 	movabs $0x800463b010,%rax
  8004200c1e:	00 00 00 
  8004200c21:	66 89 10             	mov    %dx,(%rax)
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
  8004200c24:	48 b8 10 b0 63 04 80 	movabs $0x800463b010,%rax
  8004200c2b:	00 00 00 
  8004200c2e:	0f b7 30             	movzwl (%rax),%esi
  8004200c31:	48 b8 10 b0 63 04 80 	movabs $0x800463b010,%rax
  8004200c38:	00 00 00 
  8004200c3b:	0f b7 08             	movzwl (%rax),%ecx
  8004200c3e:	0f b7 c1             	movzwl %cx,%eax
  8004200c41:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
  8004200c47:	c1 e8 10             	shr    $0x10,%eax
  8004200c4a:	89 c2                	mov    %eax,%edx
  8004200c4c:	66 c1 ea 06          	shr    $0x6,%dx
  8004200c50:	89 d0                	mov    %edx,%eax
  8004200c52:	c1 e0 02             	shl    $0x2,%eax
  8004200c55:	01 d0                	add    %edx,%eax
  8004200c57:	c1 e0 04             	shl    $0x4,%eax
  8004200c5a:	89 ca                	mov    %ecx,%edx
  8004200c5c:	66 29 c2             	sub    %ax,%dx
  8004200c5f:	89 f0                	mov    %esi,%eax
  8004200c61:	66 29 d0             	sub    %dx,%ax
  8004200c64:	89 c2                	mov    %eax,%edx
  8004200c66:	48 b8 10 b0 63 04 80 	movabs $0x800463b010,%rax
  8004200c6d:	00 00 00 
  8004200c70:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200c73:	e9 93 00 00 00       	jmpq   8004200d0b <cga_putc+0x1b8>
	case '\t':
		cons_putc(' ');
  8004200c78:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c7d:	48 b8 11 12 20 04 80 	movabs $0x8004201211,%rax
  8004200c84:	00 00 00 
  8004200c87:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c89:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c8e:	48 b8 11 12 20 04 80 	movabs $0x8004201211,%rax
  8004200c95:	00 00 00 
  8004200c98:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c9a:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c9f:	48 b8 11 12 20 04 80 	movabs $0x8004201211,%rax
  8004200ca6:	00 00 00 
  8004200ca9:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200cab:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200cb0:	48 b8 11 12 20 04 80 	movabs $0x8004201211,%rax
  8004200cb7:	00 00 00 
  8004200cba:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200cbc:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200cc1:	48 b8 11 12 20 04 80 	movabs $0x8004201211,%rax
  8004200cc8:	00 00 00 
  8004200ccb:	ff d0                	callq  *%rax
		break;
  8004200ccd:	eb 3c                	jmp    8004200d0b <cga_putc+0x1b8>
	default:
		crt_buf[crt_pos++] = c;		/* write the character */
  8004200ccf:	48 b8 08 b0 63 04 80 	movabs $0x800463b008,%rax
  8004200cd6:	00 00 00 
  8004200cd9:	48 8b 10             	mov    (%rax),%rdx
  8004200cdc:	48 b8 10 b0 63 04 80 	movabs $0x800463b010,%rax
  8004200ce3:	00 00 00 
  8004200ce6:	0f b7 00             	movzwl (%rax),%eax
  8004200ce9:	0f b7 c8             	movzwl %ax,%ecx
  8004200cec:	48 01 c9             	add    %rcx,%rcx
  8004200cef:	48 01 d1             	add    %rdx,%rcx
  8004200cf2:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004200cf5:	66 89 11             	mov    %dx,(%rcx)
  8004200cf8:	8d 50 01             	lea    0x1(%rax),%edx
  8004200cfb:	48 b8 10 b0 63 04 80 	movabs $0x800463b010,%rax
  8004200d02:	00 00 00 
  8004200d05:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200d08:	eb 01                	jmp    8004200d0b <cga_putc+0x1b8>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
  8004200d0a:	90                   	nop
		crt_buf[crt_pos++] = c;		/* write the character */
		break;
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
  8004200d0b:	48 b8 10 b0 63 04 80 	movabs $0x800463b010,%rax
  8004200d12:	00 00 00 
  8004200d15:	0f b7 00             	movzwl (%rax),%eax
  8004200d18:	66 3d cf 07          	cmp    $0x7cf,%ax
  8004200d1c:	0f 86 89 00 00 00    	jbe    8004200dab <cga_putc+0x258>
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
  8004200d22:	48 b8 08 b0 63 04 80 	movabs $0x800463b008,%rax
  8004200d29:	00 00 00 
  8004200d2c:	48 8b 00             	mov    (%rax),%rax
  8004200d2f:	48 8d 88 a0 00 00 00 	lea    0xa0(%rax),%rcx
  8004200d36:	48 b8 08 b0 63 04 80 	movabs $0x800463b008,%rax
  8004200d3d:	00 00 00 
  8004200d40:	48 8b 00             	mov    (%rax),%rax
  8004200d43:	ba 00 0f 00 00       	mov    $0xf00,%edx
  8004200d48:	48 89 ce             	mov    %rcx,%rsi
  8004200d4b:	48 89 c7             	mov    %rax,%rdi
  8004200d4e:	48 b8 de e6 20 04 80 	movabs $0x800420e6de,%rax
  8004200d55:	00 00 00 
  8004200d58:	ff d0                	callq  *%rax
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200d5a:	c7 45 fc 80 07 00 00 	movl   $0x780,-0x4(%rbp)
  8004200d61:	eb 22                	jmp    8004200d85 <cga_putc+0x232>
			crt_buf[i] = 0x0700 | ' ';
  8004200d63:	48 b8 08 b0 63 04 80 	movabs $0x800463b008,%rax
  8004200d6a:	00 00 00 
  8004200d6d:	48 8b 00             	mov    (%rax),%rax
  8004200d70:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200d73:	48 63 d2             	movslq %edx,%rdx
  8004200d76:	48 01 d2             	add    %rdx,%rdx
  8004200d79:	48 01 d0             	add    %rdx,%rax
  8004200d7c:	66 c7 00 20 07       	movw   $0x720,(%rax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200d81:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200d85:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%rbp)
  8004200d8c:	7e d5                	jle    8004200d63 <cga_putc+0x210>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
  8004200d8e:	48 b8 10 b0 63 04 80 	movabs $0x800463b010,%rax
  8004200d95:	00 00 00 
  8004200d98:	0f b7 00             	movzwl (%rax),%eax
  8004200d9b:	8d 50 b0             	lea    -0x50(%rax),%edx
  8004200d9e:	48 b8 10 b0 63 04 80 	movabs $0x800463b010,%rax
  8004200da5:	00 00 00 
  8004200da8:	66 89 10             	mov    %dx,(%rax)
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
  8004200dab:	48 b8 04 b0 63 04 80 	movabs $0x800463b004,%rax
  8004200db2:	00 00 00 
  8004200db5:	8b 00                	mov    (%rax),%eax
  8004200db7:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004200dba:	c6 45 f7 0e          	movb   $0xe,-0x9(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200dbe:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200dc2:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004200dc5:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
  8004200dc6:	48 b8 10 b0 63 04 80 	movabs $0x800463b010,%rax
  8004200dcd:	00 00 00 
  8004200dd0:	0f b7 00             	movzwl (%rax),%eax
  8004200dd3:	66 c1 e8 08          	shr    $0x8,%ax
  8004200dd7:	0f b6 c0             	movzbl %al,%eax
  8004200dda:	48 ba 04 b0 63 04 80 	movabs $0x800463b004,%rdx
  8004200de1:	00 00 00 
  8004200de4:	8b 12                	mov    (%rdx),%edx
  8004200de6:	83 c2 01             	add    $0x1,%edx
  8004200de9:	89 55 f0             	mov    %edx,-0x10(%rbp)
  8004200dec:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004200def:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200df3:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200df6:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
  8004200df7:	48 b8 04 b0 63 04 80 	movabs $0x800463b004,%rax
  8004200dfe:	00 00 00 
  8004200e01:	8b 00                	mov    (%rax),%eax
  8004200e03:	89 45 e8             	mov    %eax,-0x18(%rbp)
  8004200e06:	c6 45 e7 0f          	movb   $0xf,-0x19(%rbp)
  8004200e0a:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004200e0e:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004200e11:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
  8004200e12:	48 b8 10 b0 63 04 80 	movabs $0x800463b010,%rax
  8004200e19:	00 00 00 
  8004200e1c:	0f b7 00             	movzwl (%rax),%eax
  8004200e1f:	0f b6 c0             	movzbl %al,%eax
  8004200e22:	48 ba 04 b0 63 04 80 	movabs $0x800463b004,%rdx
  8004200e29:	00 00 00 
  8004200e2c:	8b 12                	mov    (%rdx),%edx
  8004200e2e:	83 c2 01             	add    $0x1,%edx
  8004200e31:	89 55 e0             	mov    %edx,-0x20(%rbp)
  8004200e34:	88 45 df             	mov    %al,-0x21(%rbp)
  8004200e37:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200e3b:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004200e3e:	ee                   	out    %al,(%dx)
}
  8004200e3f:	c9                   	leaveq 
  8004200e40:	c3                   	retq   

0000008004200e41 <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
  8004200e41:	55                   	push   %rbp
  8004200e42:	48 89 e5             	mov    %rsp,%rbp
  8004200e45:	53                   	push   %rbx
  8004200e46:	48 83 ec 38          	sub    $0x38,%rsp
  8004200e4a:	c7 45 e4 64 00 00 00 	movl   $0x64,-0x1c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200e51:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004200e54:	89 55 cc             	mov    %edx,-0x34(%rbp)
  8004200e57:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004200e5a:	ec                   	in     (%dx),%al
  8004200e5b:	89 c3                	mov    %eax,%ebx
  8004200e5d:	88 5d e3             	mov    %bl,-0x1d(%rbp)
	return data;
  8004200e60:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
	int c;
	uint8_t data;
	static uint32_t shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
  8004200e64:	0f b6 c0             	movzbl %al,%eax
  8004200e67:	83 e0 01             	and    $0x1,%eax
  8004200e6a:	85 c0                	test   %eax,%eax
  8004200e6c:	75 0a                	jne    8004200e78 <kbd_proc_data+0x37>
		return -1;
  8004200e6e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200e73:	e9 02 02 00 00       	jmpq   800420107a <kbd_proc_data+0x239>
  8004200e78:	c7 45 dc 60 00 00 00 	movl   $0x60,-0x24(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200e7f:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200e82:	89 55 cc             	mov    %edx,-0x34(%rbp)
  8004200e85:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004200e88:	ec                   	in     (%dx),%al
  8004200e89:	89 c3                	mov    %eax,%ebx
  8004200e8b:	88 5d db             	mov    %bl,-0x25(%rbp)
	return data;
  8004200e8e:	0f b6 45 db          	movzbl -0x25(%rbp),%eax

	data = inb(KBDATAP);
  8004200e92:	88 45 eb             	mov    %al,-0x15(%rbp)

	if (data == 0xE0) {
  8004200e95:	80 7d eb e0          	cmpb   $0xe0,-0x15(%rbp)
  8004200e99:	75 27                	jne    8004200ec2 <kbd_proc_data+0x81>
		// E0 escape character
		shift |= E0ESC;
  8004200e9b:	48 b8 28 b2 63 04 80 	movabs $0x800463b228,%rax
  8004200ea2:	00 00 00 
  8004200ea5:	8b 00                	mov    (%rax),%eax
  8004200ea7:	89 c2                	mov    %eax,%edx
  8004200ea9:	83 ca 40             	or     $0x40,%edx
  8004200eac:	48 b8 28 b2 63 04 80 	movabs $0x800463b228,%rax
  8004200eb3:	00 00 00 
  8004200eb6:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200eb8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200ebd:	e9 b8 01 00 00       	jmpq   800420107a <kbd_proc_data+0x239>
	} else if (data & 0x80) {
  8004200ec2:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200ec6:	84 c0                	test   %al,%al
  8004200ec8:	79 65                	jns    8004200f2f <kbd_proc_data+0xee>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
  8004200eca:	48 b8 28 b2 63 04 80 	movabs $0x800463b228,%rax
  8004200ed1:	00 00 00 
  8004200ed4:	8b 00                	mov    (%rax),%eax
  8004200ed6:	83 e0 40             	and    $0x40,%eax
  8004200ed9:	85 c0                	test   %eax,%eax
  8004200edb:	75 09                	jne    8004200ee6 <kbd_proc_data+0xa5>
  8004200edd:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200ee1:	83 e0 7f             	and    $0x7f,%eax
  8004200ee4:	eb 04                	jmp    8004200eea <kbd_proc_data+0xa9>
  8004200ee6:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200eea:	88 45 eb             	mov    %al,-0x15(%rbp)
		shift &= ~(shiftcode[data] | E0ESC);
  8004200eed:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200ef1:	48 ba 60 a0 22 04 80 	movabs $0x800422a060,%rdx
  8004200ef8:	00 00 00 
  8004200efb:	48 98                	cltq   
  8004200efd:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200f01:	83 c8 40             	or     $0x40,%eax
  8004200f04:	0f b6 c0             	movzbl %al,%eax
  8004200f07:	f7 d0                	not    %eax
  8004200f09:	89 c2                	mov    %eax,%edx
  8004200f0b:	48 b8 28 b2 63 04 80 	movabs $0x800463b228,%rax
  8004200f12:	00 00 00 
  8004200f15:	8b 00                	mov    (%rax),%eax
  8004200f17:	21 c2                	and    %eax,%edx
  8004200f19:	48 b8 28 b2 63 04 80 	movabs $0x800463b228,%rax
  8004200f20:	00 00 00 
  8004200f23:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200f25:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200f2a:	e9 4b 01 00 00       	jmpq   800420107a <kbd_proc_data+0x239>
	} else if (shift & E0ESC) {
  8004200f2f:	48 b8 28 b2 63 04 80 	movabs $0x800463b228,%rax
  8004200f36:	00 00 00 
  8004200f39:	8b 00                	mov    (%rax),%eax
  8004200f3b:	83 e0 40             	and    $0x40,%eax
  8004200f3e:	85 c0                	test   %eax,%eax
  8004200f40:	74 21                	je     8004200f63 <kbd_proc_data+0x122>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
  8004200f42:	80 4d eb 80          	orb    $0x80,-0x15(%rbp)
		shift &= ~E0ESC;
  8004200f46:	48 b8 28 b2 63 04 80 	movabs $0x800463b228,%rax
  8004200f4d:	00 00 00 
  8004200f50:	8b 00                	mov    (%rax),%eax
  8004200f52:	89 c2                	mov    %eax,%edx
  8004200f54:	83 e2 bf             	and    $0xffffffbf,%edx
  8004200f57:	48 b8 28 b2 63 04 80 	movabs $0x800463b228,%rax
  8004200f5e:	00 00 00 
  8004200f61:	89 10                	mov    %edx,(%rax)
	}

	shift |= shiftcode[data];
  8004200f63:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200f67:	48 ba 60 a0 22 04 80 	movabs $0x800422a060,%rdx
  8004200f6e:	00 00 00 
  8004200f71:	48 98                	cltq   
  8004200f73:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200f77:	0f b6 d0             	movzbl %al,%edx
  8004200f7a:	48 b8 28 b2 63 04 80 	movabs $0x800463b228,%rax
  8004200f81:	00 00 00 
  8004200f84:	8b 00                	mov    (%rax),%eax
  8004200f86:	09 c2                	or     %eax,%edx
  8004200f88:	48 b8 28 b2 63 04 80 	movabs $0x800463b228,%rax
  8004200f8f:	00 00 00 
  8004200f92:	89 10                	mov    %edx,(%rax)
	shift ^= togglecode[data];
  8004200f94:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200f98:	48 ba 60 a1 22 04 80 	movabs $0x800422a160,%rdx
  8004200f9f:	00 00 00 
  8004200fa2:	48 98                	cltq   
  8004200fa4:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200fa8:	0f b6 d0             	movzbl %al,%edx
  8004200fab:	48 b8 28 b2 63 04 80 	movabs $0x800463b228,%rax
  8004200fb2:	00 00 00 
  8004200fb5:	8b 00                	mov    (%rax),%eax
  8004200fb7:	31 c2                	xor    %eax,%edx
  8004200fb9:	48 b8 28 b2 63 04 80 	movabs $0x800463b228,%rax
  8004200fc0:	00 00 00 
  8004200fc3:	89 10                	mov    %edx,(%rax)

	c = charcode[shift & (CTL | SHIFT)][data];
  8004200fc5:	48 b8 28 b2 63 04 80 	movabs $0x800463b228,%rax
  8004200fcc:	00 00 00 
  8004200fcf:	8b 00                	mov    (%rax),%eax
  8004200fd1:	89 c2                	mov    %eax,%edx
  8004200fd3:	83 e2 03             	and    $0x3,%edx
  8004200fd6:	48 b8 60 a5 22 04 80 	movabs $0x800422a560,%rax
  8004200fdd:	00 00 00 
  8004200fe0:	89 d2                	mov    %edx,%edx
  8004200fe2:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8004200fe6:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200fea:	48 01 d0             	add    %rdx,%rax
  8004200fed:	0f b6 00             	movzbl (%rax),%eax
  8004200ff0:	0f b6 c0             	movzbl %al,%eax
  8004200ff3:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if (shift & CAPSLOCK) {
  8004200ff6:	48 b8 28 b2 63 04 80 	movabs $0x800463b228,%rax
  8004200ffd:	00 00 00 
  8004201000:	8b 00                	mov    (%rax),%eax
  8004201002:	83 e0 08             	and    $0x8,%eax
  8004201005:	85 c0                	test   %eax,%eax
  8004201007:	74 22                	je     800420102b <kbd_proc_data+0x1ea>
		if ('a' <= c && c <= 'z')
  8004201009:	83 7d ec 60          	cmpl   $0x60,-0x14(%rbp)
  800420100d:	7e 0c                	jle    800420101b <kbd_proc_data+0x1da>
  800420100f:	83 7d ec 7a          	cmpl   $0x7a,-0x14(%rbp)
  8004201013:	7f 06                	jg     800420101b <kbd_proc_data+0x1da>
			c += 'A' - 'a';
  8004201015:	83 6d ec 20          	subl   $0x20,-0x14(%rbp)
  8004201019:	eb 10                	jmp    800420102b <kbd_proc_data+0x1ea>
		else if ('A' <= c && c <= 'Z')
  800420101b:	83 7d ec 40          	cmpl   $0x40,-0x14(%rbp)
  800420101f:	7e 0a                	jle    800420102b <kbd_proc_data+0x1ea>
  8004201021:	83 7d ec 5a          	cmpl   $0x5a,-0x14(%rbp)
  8004201025:	7f 04                	jg     800420102b <kbd_proc_data+0x1ea>
			c += 'a' - 'A';
  8004201027:	83 45 ec 20          	addl   $0x20,-0x14(%rbp)
	}

	// Process special keys
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  800420102b:	48 b8 28 b2 63 04 80 	movabs $0x800463b228,%rax
  8004201032:	00 00 00 
  8004201035:	8b 00                	mov    (%rax),%eax
  8004201037:	f7 d0                	not    %eax
  8004201039:	83 e0 06             	and    $0x6,%eax
  800420103c:	85 c0                	test   %eax,%eax
  800420103e:	75 37                	jne    8004201077 <kbd_proc_data+0x236>
  8004201040:	81 7d ec e9 00 00 00 	cmpl   $0xe9,-0x14(%rbp)
  8004201047:	75 2e                	jne    8004201077 <kbd_proc_data+0x236>
		cprintf("Rebooting!\n");
  8004201049:	48 bf 6e 70 21 04 80 	movabs $0x800421706e,%rdi
  8004201050:	00 00 00 
  8004201053:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201058:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420105f:	00 00 00 
  8004201062:	ff d2                	callq  *%rdx
  8004201064:	c7 45 d4 92 00 00 00 	movl   $0x92,-0x2c(%rbp)
  800420106b:	c6 45 d3 03          	movb   $0x3,-0x2d(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  800420106f:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004201073:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004201076:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
  8004201077:	8b 45 ec             	mov    -0x14(%rbp),%eax
}
  800420107a:	48 83 c4 38          	add    $0x38,%rsp
  800420107e:	5b                   	pop    %rbx
  800420107f:	5d                   	pop    %rbp
  8004201080:	c3                   	retq   

0000008004201081 <kbd_intr>:

void
kbd_intr(void)
{
  8004201081:	55                   	push   %rbp
  8004201082:	48 89 e5             	mov    %rsp,%rbp
	cons_intr(kbd_proc_data);
  8004201085:	48 bf 41 0e 20 04 80 	movabs $0x8004200e41,%rdi
  800420108c:	00 00 00 
  800420108f:	48 b8 d2 10 20 04 80 	movabs $0x80042010d2,%rax
  8004201096:	00 00 00 
  8004201099:	ff d0                	callq  *%rax
}
  800420109b:	5d                   	pop    %rbp
  800420109c:	c3                   	retq   

000000800420109d <kbd_init>:

static void
kbd_init(void)
{
  800420109d:	55                   	push   %rbp
  800420109e:	48 89 e5             	mov    %rsp,%rbp
	// Drain the kbd buffer so that Bochs generates interrupts.
	kbd_intr();
  80042010a1:	48 b8 81 10 20 04 80 	movabs $0x8004201081,%rax
  80042010a8:	00 00 00 
  80042010ab:	ff d0                	callq  *%rax
	irq_setmask_8259A(irq_mask_8259A & ~(1<<1));
  80042010ad:	48 b8 94 a6 22 04 80 	movabs $0x800422a694,%rax
  80042010b4:	00 00 00 
  80042010b7:	0f b7 00             	movzwl (%rax),%eax
  80042010ba:	0f b7 c0             	movzwl %ax,%eax
  80042010bd:	25 fd ff 00 00       	and    $0xfffd,%eax
  80042010c2:	89 c7                	mov    %eax,%edi
  80042010c4:	48 b8 3e 88 20 04 80 	movabs $0x800420883e,%rax
  80042010cb:	00 00 00 
  80042010ce:	ff d0                	callq  *%rax
}
  80042010d0:	5d                   	pop    %rbp
  80042010d1:	c3                   	retq   

00000080042010d2 <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
static void
cons_intr(int (*proc)(void))
{
  80042010d2:	55                   	push   %rbp
  80042010d3:	48 89 e5             	mov    %rsp,%rbp
  80042010d6:	48 83 ec 20          	sub    $0x20,%rsp
  80042010da:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int c;

	while ((c = (*proc)()) != -1) {
  80042010de:	eb 6c                	jmp    800420114c <cons_intr+0x7a>
		if (c == 0)
  80042010e0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042010e4:	74 65                	je     800420114b <cons_intr+0x79>
			continue;
		cons.buf[cons.wpos++] = c;
  80042010e6:	48 b8 20 b0 63 04 80 	movabs $0x800463b020,%rax
  80042010ed:	00 00 00 
  80042010f0:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  80042010f6:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042010f9:	89 d6                	mov    %edx,%esi
  80042010fb:	48 b9 20 b0 63 04 80 	movabs $0x800463b020,%rcx
  8004201102:	00 00 00 
  8004201105:	89 c2                	mov    %eax,%edx
  8004201107:	40 88 34 11          	mov    %sil,(%rcx,%rdx,1)
  800420110b:	8d 50 01             	lea    0x1(%rax),%edx
  800420110e:	48 b8 20 b0 63 04 80 	movabs $0x800463b020,%rax
  8004201115:	00 00 00 
  8004201118:	89 90 04 02 00 00    	mov    %edx,0x204(%rax)
		if (cons.wpos == CONSBUFSIZE)
  800420111e:	48 b8 20 b0 63 04 80 	movabs $0x800463b020,%rax
  8004201125:	00 00 00 
  8004201128:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  800420112e:	3d 00 02 00 00       	cmp    $0x200,%eax
  8004201133:	75 17                	jne    800420114c <cons_intr+0x7a>
			cons.wpos = 0;
  8004201135:	48 b8 20 b0 63 04 80 	movabs $0x800463b020,%rax
  800420113c:	00 00 00 
  800420113f:	c7 80 04 02 00 00 00 	movl   $0x0,0x204(%rax)
  8004201146:	00 00 00 
  8004201149:	eb 01                	jmp    800420114c <cons_intr+0x7a>
{
	int c;

	while ((c = (*proc)()) != -1) {
		if (c == 0)
			continue;
  800420114b:	90                   	nop
static void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
  800420114c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201150:	ff d0                	callq  *%rax
  8004201152:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004201155:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  8004201159:	75 85                	jne    80042010e0 <cons_intr+0xe>
			continue;
		cons.buf[cons.wpos++] = c;
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;
	}
}
  800420115b:	c9                   	leaveq 
  800420115c:	c3                   	retq   

000000800420115d <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
  800420115d:	55                   	push   %rbp
  800420115e:	48 89 e5             	mov    %rsp,%rbp
  8004201161:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
  8004201165:	48 b8 d8 07 20 04 80 	movabs $0x80042007d8,%rax
  800420116c:	00 00 00 
  800420116f:	ff d0                	callq  *%rax
	kbd_intr();
  8004201171:	48 b8 81 10 20 04 80 	movabs $0x8004201081,%rax
  8004201178:	00 00 00 
  800420117b:	ff d0                	callq  *%rax

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
  800420117d:	48 b8 20 b0 63 04 80 	movabs $0x800463b020,%rax
  8004201184:	00 00 00 
  8004201187:	8b 90 00 02 00 00    	mov    0x200(%rax),%edx
  800420118d:	48 b8 20 b0 63 04 80 	movabs $0x800463b020,%rax
  8004201194:	00 00 00 
  8004201197:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  800420119d:	39 c2                	cmp    %eax,%edx
  800420119f:	74 69                	je     800420120a <cons_getc+0xad>
		c = cons.buf[cons.rpos++];
  80042011a1:	48 b8 20 b0 63 04 80 	movabs $0x800463b020,%rax
  80042011a8:	00 00 00 
  80042011ab:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  80042011b1:	48 b9 20 b0 63 04 80 	movabs $0x800463b020,%rcx
  80042011b8:	00 00 00 
  80042011bb:	89 c2                	mov    %eax,%edx
  80042011bd:	0f b6 14 11          	movzbl (%rcx,%rdx,1),%edx
  80042011c1:	0f b6 d2             	movzbl %dl,%edx
  80042011c4:	89 55 fc             	mov    %edx,-0x4(%rbp)
  80042011c7:	8d 50 01             	lea    0x1(%rax),%edx
  80042011ca:	48 b8 20 b0 63 04 80 	movabs $0x800463b020,%rax
  80042011d1:	00 00 00 
  80042011d4:	89 90 00 02 00 00    	mov    %edx,0x200(%rax)
		if (cons.rpos == CONSBUFSIZE)
  80042011da:	48 b8 20 b0 63 04 80 	movabs $0x800463b020,%rax
  80042011e1:	00 00 00 
  80042011e4:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  80042011ea:	3d 00 02 00 00       	cmp    $0x200,%eax
  80042011ef:	75 14                	jne    8004201205 <cons_getc+0xa8>
			cons.rpos = 0;
  80042011f1:	48 b8 20 b0 63 04 80 	movabs $0x800463b020,%rax
  80042011f8:	00 00 00 
  80042011fb:	c7 80 00 02 00 00 00 	movl   $0x0,0x200(%rax)
  8004201202:	00 00 00 
		return c;
  8004201205:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201208:	eb 05                	jmp    800420120f <cons_getc+0xb2>
	}
	return 0;
  800420120a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420120f:	c9                   	leaveq 
  8004201210:	c3                   	retq   

0000008004201211 <cons_putc>:

// output a character to the console
static void
cons_putc(int c)
{
  8004201211:	55                   	push   %rbp
  8004201212:	48 89 e5             	mov    %rsp,%rbp
  8004201215:	48 83 ec 10          	sub    $0x10,%rsp
  8004201219:	89 7d fc             	mov    %edi,-0x4(%rbp)
	serial_putc(c);
  800420121c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420121f:	89 c7                	mov    %eax,%edi
  8004201221:	48 b8 05 08 20 04 80 	movabs $0x8004200805,%rax
  8004201228:	00 00 00 
  800420122b:	ff d0                	callq  *%rax
	lpt_putc(c);
  800420122d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201230:	89 c7                	mov    %eax,%edi
  8004201232:	48 b8 96 09 20 04 80 	movabs $0x8004200996,%rax
  8004201239:	00 00 00 
  800420123c:	ff d0                	callq  *%rax
	cga_putc(c);
  800420123e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201241:	89 c7                	mov    %eax,%edi
  8004201243:	48 b8 53 0b 20 04 80 	movabs $0x8004200b53,%rax
  800420124a:	00 00 00 
  800420124d:	ff d0                	callq  *%rax
}
  800420124f:	c9                   	leaveq 
  8004201250:	c3                   	retq   

0000008004201251 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
  8004201251:	55                   	push   %rbp
  8004201252:	48 89 e5             	mov    %rsp,%rbp
	cga_init();
  8004201255:	48 b8 27 0a 20 04 80 	movabs $0x8004200a27,%rax
  800420125c:	00 00 00 
  800420125f:	ff d0                	callq  *%rax
	kbd_init();
  8004201261:	48 b8 9d 10 20 04 80 	movabs $0x800420109d,%rax
  8004201268:	00 00 00 
  800420126b:	ff d0                	callq  *%rax
	serial_init();
  800420126d:	48 b8 76 08 20 04 80 	movabs $0x8004200876,%rax
  8004201274:	00 00 00 
  8004201277:	ff d0                	callq  *%rax

	if (!serial_exists)
  8004201279:	48 b8 00 b0 63 04 80 	movabs $0x800463b000,%rax
  8004201280:	00 00 00 
  8004201283:	0f b6 00             	movzbl (%rax),%eax
  8004201286:	83 f0 01             	xor    $0x1,%eax
  8004201289:	84 c0                	test   %al,%al
  800420128b:	74 1b                	je     80042012a8 <cons_init+0x57>
		cprintf("Serial port does not exist!\n");
  800420128d:	48 bf 7a 70 21 04 80 	movabs $0x800421707a,%rdi
  8004201294:	00 00 00 
  8004201297:	b8 00 00 00 00       	mov    $0x0,%eax
  800420129c:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  80042012a3:	00 00 00 
  80042012a6:	ff d2                	callq  *%rdx
}
  80042012a8:	5d                   	pop    %rbp
  80042012a9:	c3                   	retq   

00000080042012aa <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf.

void
cputchar(int c)
{
  80042012aa:	55                   	push   %rbp
  80042012ab:	48 89 e5             	mov    %rsp,%rbp
  80042012ae:	48 83 ec 10          	sub    $0x10,%rsp
  80042012b2:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cons_putc(c);
  80042012b5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012b8:	89 c7                	mov    %eax,%edi
  80042012ba:	48 b8 11 12 20 04 80 	movabs $0x8004201211,%rax
  80042012c1:	00 00 00 
  80042012c4:	ff d0                	callq  *%rax
}
  80042012c6:	c9                   	leaveq 
  80042012c7:	c3                   	retq   

00000080042012c8 <getchar>:

int
getchar(void)
{
  80042012c8:	55                   	push   %rbp
  80042012c9:	48 89 e5             	mov    %rsp,%rbp
  80042012cc:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	while ((c = cons_getc()) == 0)
  80042012d0:	48 b8 5d 11 20 04 80 	movabs $0x800420115d,%rax
  80042012d7:	00 00 00 
  80042012da:	ff d0                	callq  *%rax
  80042012dc:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80042012df:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042012e3:	74 eb                	je     80042012d0 <getchar+0x8>
		/* do nothing */;
	return c;
  80042012e5:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042012e8:	c9                   	leaveq 
  80042012e9:	c3                   	retq   

00000080042012ea <iscons>:

int
iscons(int fdnum)
{
  80042012ea:	55                   	push   %rbp
  80042012eb:	48 89 e5             	mov    %rsp,%rbp
  80042012ee:	48 83 ec 08          	sub    $0x8,%rsp
  80042012f2:	89 7d fc             	mov    %edi,-0x4(%rbp)
	// used by readline
	return 1;
  80042012f5:	b8 01 00 00 00       	mov    $0x1,%eax
}
  80042012fa:	c9                   	leaveq 
  80042012fb:	c3                   	retq   

00000080042012fc <mon_help>:

/***** Implementations of basic kernel monitor commands *****/

int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
  80042012fc:	55                   	push   %rbp
  80042012fd:	48 89 e5             	mov    %rsp,%rbp
  8004201300:	48 83 ec 30          	sub    $0x30,%rsp
  8004201304:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004201307:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420130b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  800420130f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004201316:	eb 6c                	jmp    8004201384 <mon_help+0x88>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
  8004201318:	48 b9 80 a5 22 04 80 	movabs $0x800422a580,%rcx
  800420131f:	00 00 00 
  8004201322:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201325:	48 63 d0             	movslq %eax,%rdx
  8004201328:	48 89 d0             	mov    %rdx,%rax
  800420132b:	48 01 c0             	add    %rax,%rax
  800420132e:	48 01 d0             	add    %rdx,%rax
  8004201331:	48 c1 e0 03          	shl    $0x3,%rax
  8004201335:	48 01 c8             	add    %rcx,%rax
  8004201338:	48 8b 48 08          	mov    0x8(%rax),%rcx
  800420133c:	48 be 80 a5 22 04 80 	movabs $0x800422a580,%rsi
  8004201343:	00 00 00 
  8004201346:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201349:	48 63 d0             	movslq %eax,%rdx
  800420134c:	48 89 d0             	mov    %rdx,%rax
  800420134f:	48 01 c0             	add    %rax,%rax
  8004201352:	48 01 d0             	add    %rdx,%rax
  8004201355:	48 c1 e0 03          	shl    $0x3,%rax
  8004201359:	48 01 f0             	add    %rsi,%rax
  800420135c:	48 8b 00             	mov    (%rax),%rax
  800420135f:	48 89 ca             	mov    %rcx,%rdx
  8004201362:	48 89 c6             	mov    %rax,%rsi
  8004201365:	48 bf 28 71 21 04 80 	movabs $0x8004217128,%rdi
  800420136c:	00 00 00 
  800420136f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201374:	48 b9 f2 89 20 04 80 	movabs $0x80042089f2,%rcx
  800420137b:	00 00 00 
  800420137e:	ff d1                	callq  *%rcx
int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  8004201380:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004201384:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201387:	83 f8 02             	cmp    $0x2,%eax
  800420138a:	76 8c                	jbe    8004201318 <mon_help+0x1c>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
	return 0;
  800420138c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201391:	c9                   	leaveq 
  8004201392:	c3                   	retq   

0000008004201393 <mon_kerninfo>:

int
mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
{
  8004201393:	55                   	push   %rbp
  8004201394:	48 89 e5             	mov    %rsp,%rbp
  8004201397:	48 83 ec 30          	sub    $0x30,%rsp
  800420139b:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420139e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042013a2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	extern char _start[], entry[], etext[], edata[], end[];

	cprintf("Special kernel symbols:\n");
  80042013a6:	48 bf 31 71 21 04 80 	movabs $0x8004217131,%rdi
  80042013ad:	00 00 00 
  80042013b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013b5:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  80042013bc:	00 00 00 
  80042013bf:	ff d2                	callq  *%rdx
	cprintf("  _start                  %08x (phys)\n", _start);
  80042013c1:	48 be 0c 00 20 00 00 	movabs $0x20000c,%rsi
  80042013c8:	00 00 00 
  80042013cb:	48 bf 50 71 21 04 80 	movabs $0x8004217150,%rdi
  80042013d2:	00 00 00 
  80042013d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013da:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  80042013e1:	00 00 00 
  80042013e4:	ff d2                	callq  *%rdx
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
  80042013e6:	48 ba 0c 00 20 00 00 	movabs $0x20000c,%rdx
  80042013ed:	00 00 00 
  80042013f0:	48 be 0c 00 20 04 80 	movabs $0x800420000c,%rsi
  80042013f7:	00 00 00 
  80042013fa:	48 bf 78 71 21 04 80 	movabs $0x8004217178,%rdi
  8004201401:	00 00 00 
  8004201404:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201409:	48 b9 f2 89 20 04 80 	movabs $0x80042089f2,%rcx
  8004201410:	00 00 00 
  8004201413:	ff d1                	callq  *%rcx
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
  8004201415:	48 ba 9b 6f 21 00 00 	movabs $0x216f9b,%rdx
  800420141c:	00 00 00 
  800420141f:	48 be 9b 6f 21 04 80 	movabs $0x8004216f9b,%rsi
  8004201426:	00 00 00 
  8004201429:	48 bf a0 71 21 04 80 	movabs $0x80042171a0,%rdi
  8004201430:	00 00 00 
  8004201433:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201438:	48 b9 f2 89 20 04 80 	movabs $0x80042089f2,%rcx
  800420143f:	00 00 00 
  8004201442:	ff d1                	callq  *%rcx
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
  8004201444:	48 ba 07 a6 63 00 00 	movabs $0x63a607,%rdx
  800420144b:	00 00 00 
  800420144e:	48 be 07 a6 63 04 80 	movabs $0x800463a607,%rsi
  8004201455:	00 00 00 
  8004201458:	48 bf c8 71 21 04 80 	movabs $0x80042171c8,%rdi
  800420145f:	00 00 00 
  8004201462:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201467:	48 b9 f2 89 20 04 80 	movabs $0x80042089f2,%rcx
  800420146e:	00 00 00 
  8004201471:	ff d1                	callq  *%rcx
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
  8004201473:	48 ba 18 f0 6f 00 00 	movabs $0x6ff018,%rdx
  800420147a:	00 00 00 
  800420147d:	48 be 18 f0 6f 04 80 	movabs $0x80046ff018,%rsi
  8004201484:	00 00 00 
  8004201487:	48 bf f0 71 21 04 80 	movabs $0x80042171f0,%rdi
  800420148e:	00 00 00 
  8004201491:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201496:	48 b9 f2 89 20 04 80 	movabs $0x80042089f2,%rcx
  800420149d:	00 00 00 
  80042014a0:	ff d1                	callq  *%rcx
	cprintf("Kernel executable memory footprint: %dKB\n",
		ROUNDUP(end - entry, 1024) / 1024);
  80042014a2:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  80042014a9:	00 
  80042014aa:	48 b8 0c 00 20 04 80 	movabs $0x800420000c,%rax
  80042014b1:	00 00 00 
  80042014b4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042014b8:	48 29 c2             	sub    %rax,%rdx
  80042014bb:	48 b8 18 f0 6f 04 80 	movabs $0x80046ff018,%rax
  80042014c2:	00 00 00 
  80042014c5:	48 83 e8 01          	sub    $0x1,%rax
  80042014c9:	48 01 d0             	add    %rdx,%rax
  80042014cc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042014d0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042014d4:	ba 00 00 00 00       	mov    $0x0,%edx
  80042014d9:	48 f7 75 f8          	divq   -0x8(%rbp)
  80042014dd:	48 89 d0             	mov    %rdx,%rax
  80042014e0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042014e4:	48 89 d1             	mov    %rdx,%rcx
  80042014e7:	48 29 c1             	sub    %rax,%rcx
  80042014ea:	48 89 c8             	mov    %rcx,%rax
	cprintf("  _start                  %08x (phys)\n", _start);
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
	cprintf("Kernel executable memory footprint: %dKB\n",
  80042014ed:	48 8d 90 ff 03 00 00 	lea    0x3ff(%rax),%rdx
  80042014f4:	48 85 c0             	test   %rax,%rax
  80042014f7:	48 0f 48 c2          	cmovs  %rdx,%rax
  80042014fb:	48 c1 f8 0a          	sar    $0xa,%rax
  80042014ff:	48 89 c6             	mov    %rax,%rsi
  8004201502:	48 bf 18 72 21 04 80 	movabs $0x8004217218,%rdi
  8004201509:	00 00 00 
  800420150c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201511:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  8004201518:	00 00 00 
  800420151b:	ff d2                	callq  *%rdx
		ROUNDUP(end - entry, 1024) / 1024);
	return 0;
  800420151d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201522:	c9                   	leaveq 
  8004201523:	c3                   	retq   

0000008004201524 <mon_backtrace>:

int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
  8004201524:	55                   	push   %rbp
  8004201525:	48 89 e5             	mov    %rsp,%rbp
  8004201528:	53                   	push   %rbx
  8004201529:	48 81 ec d8 04 00 00 	sub    $0x4d8,%rsp
  8004201530:	89 bd 3c fb ff ff    	mov    %edi,-0x4c4(%rbp)
  8004201536:	48 89 b5 30 fb ff ff 	mov    %rsi,-0x4d0(%rbp)
  800420153d:	48 89 95 28 fb ff ff 	mov    %rdx,-0x4d8(%rbp)

static __inline uint64_t
read_rbp(void)
{
        uint64_t rbp;
        __asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  8004201544:	48 89 eb             	mov    %rbp,%rbx
  8004201547:	48 89 5d c0          	mov    %rbx,-0x40(%rbp)
        return rbp;
  800420154b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
	// Your code here.
	uint64_t *ptr,num,var,*rip,rbp;
        int i;
	rbp=read_rbp();
  800420154f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
        ptr=(uint64_t*)rbp;
  8004201553:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201557:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        struct Ripdebuginfo dbginfo;
        read_rip(var);
  800420155b:	48 8d 1d 00 00 00 00 	lea    0x0(%rip),%rbx        # 8004201562 <mon_backtrace+0x3e>
  8004201562:	48 89 5d e0          	mov    %rbx,-0x20(%rbp)
        cprintf("Stack backtrace:\n");
  8004201566:	48 bf 42 72 21 04 80 	movabs $0x8004217242,%rdi
  800420156d:	00 00 00 
  8004201570:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201575:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420157c:	00 00 00 
  800420157f:	ff d2                	callq  *%rdx
        do
         {
                 debuginfo_rip(var,&dbginfo);
  8004201581:	48 8d 95 40 fb ff ff 	lea    -0x4c0(%rbp),%rdx
  8004201588:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420158c:	48 89 d6             	mov    %rdx,%rsi
  800420158f:	48 89 c7             	mov    %rax,%rdi
  8004201592:	48 b8 8f d3 20 04 80 	movabs $0x800420d38f,%rax
  8004201599:	00 00 00 
  800420159c:	ff d0                	callq  *%rax
                 cprintf("  rbp %016llx  rip %016llx\n",ptr,var);
  800420159e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042015a2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042015a6:	48 89 c6             	mov    %rax,%rsi
  80042015a9:	48 bf 54 72 21 04 80 	movabs $0x8004217254,%rdi
  80042015b0:	00 00 00 
  80042015b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015b8:	48 b9 f2 89 20 04 80 	movabs $0x80042089f2,%rcx
  80042015bf:	00 00 00 
  80042015c2:	ff d1                	callq  *%rcx
                 cprintf("       %s:%d: %s+%016llx  args:%d  ",dbginfo.rip_file,dbginfo.rip_line,dbginfo.rip_fn_name,var-dbginfo.rip_fn_addr,dbginfo.rip_fn_narg);
  80042015c4:	8b b5 68 fb ff ff    	mov    -0x498(%rbp),%esi
  80042015ca:	48 8b 85 60 fb ff ff 	mov    -0x4a0(%rbp),%rax
  80042015d1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042015d5:	48 89 d7             	mov    %rdx,%rdi
  80042015d8:	48 29 c7             	sub    %rax,%rdi
  80042015db:	48 8b 8d 50 fb ff ff 	mov    -0x4b0(%rbp),%rcx
  80042015e2:	8b 95 48 fb ff ff    	mov    -0x4b8(%rbp),%edx
  80042015e8:	48 8b 85 40 fb ff ff 	mov    -0x4c0(%rbp),%rax
  80042015ef:	41 89 f1             	mov    %esi,%r9d
  80042015f2:	49 89 f8             	mov    %rdi,%r8
  80042015f5:	48 89 c6             	mov    %rax,%rsi
  80042015f8:	48 bf 70 72 21 04 80 	movabs $0x8004217270,%rdi
  80042015ff:	00 00 00 
  8004201602:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201607:	49 ba f2 89 20 04 80 	movabs $0x80042089f2,%r10
  800420160e:	00 00 00 
  8004201611:	41 ff d2             	callq  *%r10
                 for(i=1;i<dbginfo.rip_fn_narg+1;i++)
  8004201614:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%rbp)
  800420161b:	eb 39                	jmp    8004201656 <mon_backtrace+0x132>
                        cprintf("%016llx ",(*(ptr-i))>>32);
  800420161d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004201620:	48 98                	cltq   
  8004201622:	48 c1 e0 03          	shl    $0x3,%rax
  8004201626:	48 f7 d8             	neg    %rax
  8004201629:	48 03 45 e8          	add    -0x18(%rbp),%rax
  800420162d:	48 8b 00             	mov    (%rax),%rax
  8004201630:	48 c1 e8 20          	shr    $0x20,%rax
  8004201634:	48 89 c6             	mov    %rax,%rsi
  8004201637:	48 bf 94 72 21 04 80 	movabs $0x8004217294,%rdi
  800420163e:	00 00 00 
  8004201641:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201646:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420164d:	00 00 00 
  8004201650:	ff d2                	callq  *%rdx
        do
         {
                 debuginfo_rip(var,&dbginfo);
                 cprintf("  rbp %016llx  rip %016llx\n",ptr,var);
                 cprintf("       %s:%d: %s+%016llx  args:%d  ",dbginfo.rip_file,dbginfo.rip_line,dbginfo.rip_fn_name,var-dbginfo.rip_fn_addr,dbginfo.rip_fn_narg);
                 for(i=1;i<dbginfo.rip_fn_narg+1;i++)
  8004201652:	83 45 dc 01          	addl   $0x1,-0x24(%rbp)
  8004201656:	8b 85 68 fb ff ff    	mov    -0x498(%rbp),%eax
  800420165c:	83 c0 01             	add    $0x1,%eax
  800420165f:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  8004201662:	7f b9                	jg     800420161d <mon_backtrace+0xf9>
                        cprintf("%016llx ",(*(ptr-i))>>32);
                 cprintf("\n");
  8004201664:	48 bf 9d 72 21 04 80 	movabs $0x800421729d,%rdi
  800420166b:	00 00 00 
  800420166e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201673:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420167a:	00 00 00 
  800420167d:	ff d2                	callq  *%rdx
		 var=*(ptr+1);
  800420167f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201683:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004201687:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
                 num=*ptr;
  800420168b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420168f:	48 8b 00             	mov    (%rax),%rax
  8004201692:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                 ptr=(uint64_t*) num;
  8004201696:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420169a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
         }while(ptr!=0);
  800420169e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042016a3:	0f 85 d8 fe ff ff    	jne    8004201581 <mon_backtrace+0x5d>
return 0;
  80042016a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042016ae:	48 81 c4 d8 04 00 00 	add    $0x4d8,%rsp
  80042016b5:	5b                   	pop    %rbx
  80042016b6:	5d                   	pop    %rbp
  80042016b7:	c3                   	retq   

00000080042016b8 <runcmd>:
#define WHITESPACE "\t\r\n "
#define MAXARGS 16

static int
runcmd(char *buf, struct Trapframe *tf)
{
  80042016b8:	55                   	push   %rbp
  80042016b9:	48 89 e5             	mov    %rsp,%rbp
  80042016bc:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  80042016c3:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  80042016ca:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
	int argc;
	char *argv[MAXARGS];
	int i;

	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
  80042016d1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	argv[argc] = 0;
  80042016d8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042016db:	48 98                	cltq   
  80042016dd:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  80042016e4:	ff 00 00 00 00 
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  80042016e9:	eb 15                	jmp    8004201700 <runcmd+0x48>
			return 0;
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
			buf++;
	}
  80042016eb:	90                   	nop
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  80042016ec:	eb 12                	jmp    8004201700 <runcmd+0x48>
			*buf++ = 0;
  80042016ee:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042016f5:	c6 00 00             	movb   $0x0,(%rax)
  80042016f8:	48 83 85 68 ff ff ff 	addq   $0x1,-0x98(%rbp)
  80042016ff:	01 
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201700:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201707:	0f b6 00             	movzbl (%rax),%eax
  800420170a:	84 c0                	test   %al,%al
  800420170c:	74 2a                	je     8004201738 <runcmd+0x80>
  800420170e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201715:	0f b6 00             	movzbl (%rax),%eax
  8004201718:	0f be c0             	movsbl %al,%eax
  800420171b:	89 c6                	mov    %eax,%esi
  800420171d:	48 bf 9f 72 21 04 80 	movabs $0x800421729f,%rdi
  8004201724:	00 00 00 
  8004201727:	48 b8 df e5 20 04 80 	movabs $0x800420e5df,%rax
  800420172e:	00 00 00 
  8004201731:	ff d0                	callq  *%rax
  8004201733:	48 85 c0             	test   %rax,%rax
  8004201736:	75 b6                	jne    80042016ee <runcmd+0x36>
			*buf++ = 0;
		if (*buf == 0)
  8004201738:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420173f:	0f b6 00             	movzbl (%rax),%eax
  8004201742:	84 c0                	test   %al,%al
  8004201744:	0f 84 93 00 00 00    	je     80042017dd <runcmd+0x125>
			break;

		// save and scan past next arg
		if (argc == MAXARGS-1) {
  800420174a:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  800420174e:	75 2a                	jne    800420177a <runcmd+0xc2>
			cprintf("Too many arguments (max %d)\n", MAXARGS);
  8004201750:	be 10 00 00 00       	mov    $0x10,%esi
  8004201755:	48 bf a4 72 21 04 80 	movabs $0x80042172a4,%rdi
  800420175c:	00 00 00 
  800420175f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201764:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420176b:	00 00 00 
  800420176e:	ff d2                	callq  *%rdx
			return 0;
  8004201770:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201775:	e9 4d 01 00 00       	jmpq   80042018c7 <runcmd+0x20f>
		}
		argv[argc++] = buf;
  800420177a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420177d:	48 98                	cltq   
  800420177f:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  8004201786:	48 89 94 c5 70 ff ff 	mov    %rdx,-0x90(%rbp,%rax,8)
  800420178d:	ff 
  800420178e:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
		while (*buf && !strchr(WHITESPACE, *buf))
  8004201792:	eb 08                	jmp    800420179c <runcmd+0xe4>
			buf++;
  8004201794:	48 83 85 68 ff ff ff 	addq   $0x1,-0x98(%rbp)
  800420179b:	01 
		if (argc == MAXARGS-1) {
			cprintf("Too many arguments (max %d)\n", MAXARGS);
			return 0;
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
  800420179c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042017a3:	0f b6 00             	movzbl (%rax),%eax
  80042017a6:	84 c0                	test   %al,%al
  80042017a8:	0f 84 3d ff ff ff    	je     80042016eb <runcmd+0x33>
  80042017ae:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042017b5:	0f b6 00             	movzbl (%rax),%eax
  80042017b8:	0f be c0             	movsbl %al,%eax
  80042017bb:	89 c6                	mov    %eax,%esi
  80042017bd:	48 bf 9f 72 21 04 80 	movabs $0x800421729f,%rdi
  80042017c4:	00 00 00 
  80042017c7:	48 b8 df e5 20 04 80 	movabs $0x800420e5df,%rax
  80042017ce:	00 00 00 
  80042017d1:	ff d0                	callq  *%rax
  80042017d3:	48 85 c0             	test   %rax,%rax
  80042017d6:	74 bc                	je     8004201794 <runcmd+0xdc>
			buf++;
	}
  80042017d8:	e9 0e ff ff ff       	jmpq   80042016eb <runcmd+0x33>
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
			*buf++ = 0;
		if (*buf == 0)
			break;
  80042017dd:	90                   	nop
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
			buf++;
	}
	argv[argc] = 0;
  80042017de:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042017e1:	48 98                	cltq   
  80042017e3:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  80042017ea:	ff 00 00 00 00 

	// Lookup and invoke the command
	if (argc == 0)
  80042017ef:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042017f3:	75 0a                	jne    80042017ff <runcmd+0x147>
		return 0;
  80042017f5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042017fa:	e9 c8 00 00 00       	jmpq   80042018c7 <runcmd+0x20f>
	for (i = 0; i < NCOMMANDS; i++) {
  80042017ff:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  8004201806:	e9 86 00 00 00       	jmpq   8004201891 <runcmd+0x1d9>
		if (strcmp(argv[0], commands[i].name) == 0)
  800420180b:	48 b9 80 a5 22 04 80 	movabs $0x800422a580,%rcx
  8004201812:	00 00 00 
  8004201815:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201818:	48 63 d0             	movslq %eax,%rdx
  800420181b:	48 89 d0             	mov    %rdx,%rax
  800420181e:	48 01 c0             	add    %rax,%rax
  8004201821:	48 01 d0             	add    %rdx,%rax
  8004201824:	48 c1 e0 03          	shl    $0x3,%rax
  8004201828:	48 01 c8             	add    %rcx,%rax
  800420182b:	48 8b 10             	mov    (%rax),%rdx
  800420182e:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201835:	48 89 d6             	mov    %rdx,%rsi
  8004201838:	48 89 c7             	mov    %rax,%rdi
  800420183b:	48 b8 17 e5 20 04 80 	movabs $0x800420e517,%rax
  8004201842:	00 00 00 
  8004201845:	ff d0                	callq  *%rax
  8004201847:	85 c0                	test   %eax,%eax
  8004201849:	75 42                	jne    800420188d <runcmd+0x1d5>
			return commands[i].func(argc, argv, tf);
  800420184b:	48 b9 80 a5 22 04 80 	movabs $0x800422a580,%rcx
  8004201852:	00 00 00 
  8004201855:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201858:	48 63 d0             	movslq %eax,%rdx
  800420185b:	48 89 d0             	mov    %rdx,%rax
  800420185e:	48 01 c0             	add    %rax,%rax
  8004201861:	48 01 d0             	add    %rdx,%rax
  8004201864:	48 c1 e0 03          	shl    $0x3,%rax
  8004201868:	48 01 c8             	add    %rcx,%rax
  800420186b:	48 83 c0 10          	add    $0x10,%rax
  800420186f:	4c 8b 00             	mov    (%rax),%r8
  8004201872:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004201879:	48 8d 8d 70 ff ff ff 	lea    -0x90(%rbp),%rcx
  8004201880:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201883:	48 89 ce             	mov    %rcx,%rsi
  8004201886:	89 c7                	mov    %eax,%edi
  8004201888:	41 ff d0             	callq  *%r8
  800420188b:	eb 3a                	jmp    80042018c7 <runcmd+0x20f>
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
	for (i = 0; i < NCOMMANDS; i++) {
  800420188d:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004201891:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201894:	83 f8 02             	cmp    $0x2,%eax
  8004201897:	0f 86 6e ff ff ff    	jbe    800420180b <runcmd+0x153>
		if (strcmp(argv[0], commands[i].name) == 0)
			return commands[i].func(argc, argv, tf);
	}
	cprintf("Unknown command '%s'\n", argv[0]);
  800420189d:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042018a4:	48 89 c6             	mov    %rax,%rsi
  80042018a7:	48 bf c1 72 21 04 80 	movabs $0x80042172c1,%rdi
  80042018ae:	00 00 00 
  80042018b1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042018b6:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  80042018bd:	00 00 00 
  80042018c0:	ff d2                	callq  *%rdx
	return 0;
  80042018c2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042018c7:	c9                   	leaveq 
  80042018c8:	c3                   	retq   

00000080042018c9 <monitor>:

void
monitor(struct Trapframe *tf)
{
  80042018c9:	55                   	push   %rbp
  80042018ca:	48 89 e5             	mov    %rsp,%rbp
  80042018cd:	48 83 ec 20          	sub    $0x20,%rsp
  80042018d1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	char *buf;

	cprintf("Welcome to the JOS kernel monitor!\n");
  80042018d5:	48 bf d8 72 21 04 80 	movabs $0x80042172d8,%rdi
  80042018dc:	00 00 00 
  80042018df:	b8 00 00 00 00       	mov    $0x0,%eax
  80042018e4:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  80042018eb:	00 00 00 
  80042018ee:	ff d2                	callq  *%rdx
	cprintf("Type 'help' for a list of commands.\n");
  80042018f0:	48 bf 00 73 21 04 80 	movabs $0x8004217300,%rdi
  80042018f7:	00 00 00 
  80042018fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042018ff:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  8004201906:	00 00 00 
  8004201909:	ff d2                	callq  *%rdx

	if (tf != NULL)
  800420190b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004201910:	74 16                	je     8004201928 <monitor+0x5f>
		print_trapframe(tf);
  8004201912:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201916:	48 89 c7             	mov    %rax,%rdi
  8004201919:	48 b8 f8 ac 20 04 80 	movabs $0x800420acf8,%rax
  8004201920:	00 00 00 
  8004201923:	ff d0                	callq  *%rax
  8004201925:	eb 01                	jmp    8004201928 <monitor+0x5f>
	while (1) {
		buf = readline("K> ");
		if (buf != NULL)
			if (runcmd(buf, tf) < 0)
				break;
	}
  8004201927:	90                   	nop

	if (tf != NULL)
		print_trapframe(tf);

	while (1) {
		buf = readline("K> ");
  8004201928:	48 bf 25 73 21 04 80 	movabs $0x8004217325,%rdi
  800420192f:	00 00 00 
  8004201932:	48 b8 f4 e1 20 04 80 	movabs $0x800420e1f4,%rax
  8004201939:	00 00 00 
  800420193c:	ff d0                	callq  *%rax
  800420193e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (buf != NULL)
  8004201942:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004201947:	74 de                	je     8004201927 <monitor+0x5e>
			if (runcmd(buf, tf) < 0)
  8004201949:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420194d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201951:	48 89 d6             	mov    %rdx,%rsi
  8004201954:	48 89 c7             	mov    %rax,%rdi
  8004201957:	48 b8 b8 16 20 04 80 	movabs $0x80042016b8,%rax
  800420195e:	00 00 00 
  8004201961:	ff d0                	callq  *%rax
  8004201963:	85 c0                	test   %eax,%eax
  8004201965:	79 c0                	jns    8004201927 <monitor+0x5e>
				break;
  8004201967:	90                   	nop
	}
}
  8004201968:	c9                   	leaveq 
  8004201969:	c3                   	retq   
	...

000000800420196c <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  800420196c:	55                   	push   %rbp
  800420196d:	48 89 e5             	mov    %rsp,%rbp
  8004201970:	48 83 ec 08          	sub    $0x8,%rsp
  8004201974:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004201978:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420197c:	48 b8 e8 c7 63 04 80 	movabs $0x800463c7e8,%rax
  8004201983:	00 00 00 
  8004201986:	48 8b 00             	mov    (%rax),%rax
  8004201989:	48 89 d1             	mov    %rdx,%rcx
  800420198c:	48 29 c1             	sub    %rax,%rcx
  800420198f:	48 89 c8             	mov    %rcx,%rax
  8004201992:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004201996:	c9                   	leaveq 
  8004201997:	c3                   	retq   

0000008004201998 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004201998:	55                   	push   %rbp
  8004201999:	48 89 e5             	mov    %rsp,%rbp
  800420199c:	48 83 ec 08          	sub    $0x8,%rsp
  80042019a0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  80042019a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042019a8:	48 89 c7             	mov    %rax,%rdi
  80042019ab:	48 b8 6c 19 20 04 80 	movabs $0x800420196c,%rax
  80042019b2:	00 00 00 
  80042019b5:	ff d0                	callq  *%rax
  80042019b7:	48 c1 e0 0c          	shl    $0xc,%rax
}
  80042019bb:	c9                   	leaveq 
  80042019bc:	c3                   	retq   

00000080042019bd <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  80042019bd:	55                   	push   %rbp
  80042019be:	48 89 e5             	mov    %rsp,%rbp
  80042019c1:	48 83 ec 10          	sub    $0x10,%rsp
  80042019c5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  80042019c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042019cd:	48 89 c2             	mov    %rax,%rdx
  80042019d0:	48 c1 ea 0c          	shr    $0xc,%rdx
  80042019d4:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  80042019db:	00 00 00 
  80042019de:	48 8b 00             	mov    (%rax),%rax
  80042019e1:	48 39 c2             	cmp    %rax,%rdx
  80042019e4:	72 2a                	jb     8004201a10 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  80042019e6:	48 ba 30 73 21 04 80 	movabs $0x8004217330,%rdx
  80042019ed:	00 00 00 
  80042019f0:	be 59 00 00 00       	mov    $0x59,%esi
  80042019f5:	48 bf 4f 73 21 04 80 	movabs $0x800421734f,%rdi
  80042019fc:	00 00 00 
  80042019ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a04:	48 b9 f2 04 20 04 80 	movabs $0x80042004f2,%rcx
  8004201a0b:	00 00 00 
  8004201a0e:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004201a10:	48 b8 e8 c7 63 04 80 	movabs $0x800463c7e8,%rax
  8004201a17:	00 00 00 
  8004201a1a:	48 8b 00             	mov    (%rax),%rax
  8004201a1d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201a21:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004201a25:	48 c1 e2 04          	shl    $0x4,%rdx
  8004201a29:	48 01 d0             	add    %rdx,%rax
}
  8004201a2c:	c9                   	leaveq 
  8004201a2d:	c3                   	retq   

0000008004201a2e <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004201a2e:	55                   	push   %rbp
  8004201a2f:	48 89 e5             	mov    %rsp,%rbp
  8004201a32:	48 83 ec 20          	sub    $0x20,%rsp
  8004201a36:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004201a3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201a3e:	48 89 c7             	mov    %rax,%rdi
  8004201a41:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  8004201a48:	00 00 00 
  8004201a4b:	ff d0                	callq  *%rax
  8004201a4d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004201a51:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201a55:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201a59:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004201a5c:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004201a5f:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004201a66:	00 00 00 
  8004201a69:	48 8b 00             	mov    (%rax),%rax
  8004201a6c:	48 39 c2             	cmp    %rax,%rdx
  8004201a6f:	72 32                	jb     8004201aa3 <page2kva+0x75>
  8004201a71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201a75:	48 89 c1             	mov    %rax,%rcx
  8004201a78:	48 ba 60 73 21 04 80 	movabs $0x8004217360,%rdx
  8004201a7f:	00 00 00 
  8004201a82:	be 60 00 00 00       	mov    $0x60,%esi
  8004201a87:	48 bf 4f 73 21 04 80 	movabs $0x800421734f,%rdi
  8004201a8e:	00 00 00 
  8004201a91:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a96:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004201a9d:	00 00 00 
  8004201aa0:	41 ff d0             	callq  *%r8
  8004201aa3:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004201aaa:	00 00 00 
  8004201aad:	48 03 45 f8          	add    -0x8(%rbp),%rax
}
  8004201ab1:	c9                   	leaveq 
  8004201ab2:	c3                   	retq   

0000008004201ab3 <restrictive_type>:
   uint32_t length_low;
   uint32_t length_high;
   uint32_t type;
 } memory_map_t;

uint32_t restrictive_type(uint32_t t1, uint32_t t2) {
  8004201ab3:	55                   	push   %rbp
  8004201ab4:	48 89 e5             	mov    %rsp,%rbp
  8004201ab7:	48 83 ec 08          	sub    $0x8,%rsp
  8004201abb:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004201abe:	89 75 f8             	mov    %esi,-0x8(%rbp)
  if(t1==MB_TYPE_BAD || t2==MB_TYPE_BAD)
  8004201ac1:	83 7d fc 05          	cmpl   $0x5,-0x4(%rbp)
  8004201ac5:	74 06                	je     8004201acd <restrictive_type+0x1a>
  8004201ac7:	83 7d f8 05          	cmpl   $0x5,-0x8(%rbp)
  8004201acb:	75 07                	jne    8004201ad4 <restrictive_type+0x21>
    return MB_TYPE_BAD;
  8004201acd:	b8 05 00 00 00       	mov    $0x5,%eax
  8004201ad2:	eb 3e                	jmp    8004201b12 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_NVS || t2==MB_TYPE_ACPI_NVS)
  8004201ad4:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004201ad8:	74 06                	je     8004201ae0 <restrictive_type+0x2d>
  8004201ada:	83 7d f8 04          	cmpl   $0x4,-0x8(%rbp)
  8004201ade:	75 07                	jne    8004201ae7 <restrictive_type+0x34>
    return MB_TYPE_ACPI_NVS;
  8004201ae0:	b8 04 00 00 00       	mov    $0x4,%eax
  8004201ae5:	eb 2b                	jmp    8004201b12 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_RESERVED || t2==MB_TYPE_RESERVED)
  8004201ae7:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
  8004201aeb:	74 06                	je     8004201af3 <restrictive_type+0x40>
  8004201aed:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  8004201af1:	75 07                	jne    8004201afa <restrictive_type+0x47>
    return MB_TYPE_RESERVED;
  8004201af3:	b8 02 00 00 00       	mov    $0x2,%eax
  8004201af8:	eb 18                	jmp    8004201b12 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_RECLM || t2==MB_TYPE_ACPI_RECLM)
  8004201afa:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  8004201afe:	74 06                	je     8004201b06 <restrictive_type+0x53>
  8004201b00:	83 7d f8 03          	cmpl   $0x3,-0x8(%rbp)
  8004201b04:	75 07                	jne    8004201b0d <restrictive_type+0x5a>
    return MB_TYPE_ACPI_RECLM;
  8004201b06:	b8 03 00 00 00       	mov    $0x3,%eax
  8004201b0b:	eb 05                	jmp    8004201b12 <restrictive_type+0x5f>

  return MB_TYPE_USABLE;
  8004201b0d:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004201b12:	c9                   	leaveq 
  8004201b13:	c3                   	retq   

0000008004201b14 <nvram_read>:
// Detect machine's physical memory setup.
// --------------------------------------------------------------

static int
nvram_read(int r)
{
  8004201b14:	55                   	push   %rbp
  8004201b15:	48 89 e5             	mov    %rsp,%rbp
  8004201b18:	53                   	push   %rbx
  8004201b19:	48 83 ec 18          	sub    $0x18,%rsp
  8004201b1d:	89 7d ec             	mov    %edi,-0x14(%rbp)
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
  8004201b20:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201b23:	89 c7                	mov    %eax,%edi
  8004201b25:	48 b8 64 86 20 04 80 	movabs $0x8004208664,%rax
  8004201b2c:	00 00 00 
  8004201b2f:	ff d0                	callq  *%rax
  8004201b31:	89 c3                	mov    %eax,%ebx
  8004201b33:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201b36:	83 c0 01             	add    $0x1,%eax
  8004201b39:	89 c7                	mov    %eax,%edi
  8004201b3b:	48 b8 64 86 20 04 80 	movabs $0x8004208664,%rax
  8004201b42:	00 00 00 
  8004201b45:	ff d0                	callq  *%rax
  8004201b47:	c1 e0 08             	shl    $0x8,%eax
  8004201b4a:	09 d8                	or     %ebx,%eax
}
  8004201b4c:	48 83 c4 18          	add    $0x18,%rsp
  8004201b50:	5b                   	pop    %rbx
  8004201b51:	5d                   	pop    %rbp
  8004201b52:	c3                   	retq   

0000008004201b53 <multiboot_read>:

static void
multiboot_read(multiboot_info_t* mbinfo, size_t* basemem, size_t* extmem) {
  8004201b53:	55                   	push   %rbp
  8004201b54:	48 89 e5             	mov    %rsp,%rbp
  8004201b57:	53                   	push   %rbx
  8004201b58:	48 81 ec c8 00 00 00 	sub    $0xc8,%rsp
  8004201b5f:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
  8004201b66:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
  8004201b6d:	48 89 95 48 ff ff ff 	mov    %rdx,-0xb8(%rbp)
  8004201b74:	48 89 e0             	mov    %rsp,%rax
  8004201b77:	48 89 c3             	mov    %rax,%rbx
	int i;

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
  8004201b7a:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201b81:	8b 40 30             	mov    0x30(%rax),%eax
  8004201b84:	89 c0                	mov    %eax,%eax
  8004201b86:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];
  8004201b8a:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201b91:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201b94:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
  8004201b9a:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201b9f:	8b 85 44 ff ff ff    	mov    -0xbc(%rbp),%eax
  8004201ba5:	f7 e2                	mul    %edx
  8004201ba7:	89 d0                	mov    %edx,%eax
  8004201ba9:	c1 e8 04             	shr    $0x4,%eax
  8004201bac:	89 c0                	mov    %eax,%eax
  8004201bae:	48 89 c2             	mov    %rax,%rdx
  8004201bb1:	48 83 ea 01          	sub    $0x1,%rdx
  8004201bb5:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004201bb9:	48 c1 e0 03          	shl    $0x3,%rax
  8004201bbd:	48 8d 50 0f          	lea    0xf(%rax),%rdx
  8004201bc1:	b8 10 00 00 00       	mov    $0x10,%eax
  8004201bc6:	48 83 e8 01          	sub    $0x1,%rax
  8004201bca:	48 01 d0             	add    %rdx,%rax
  8004201bcd:	48 c7 85 38 ff ff ff 	movq   $0x10,-0xc8(%rbp)
  8004201bd4:	10 00 00 00 
  8004201bd8:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201bdd:	48 f7 b5 38 ff ff ff 	divq   -0xc8(%rbp)
  8004201be4:	48 6b c0 10          	imul   $0x10,%rax,%rax
  8004201be8:	48 29 c4             	sub    %rax,%rsp
  8004201beb:	48 89 e0             	mov    %rsp,%rax
  8004201bee:	48 83 c0 0f          	add    $0xf,%rax
  8004201bf2:	48 c1 e8 04          	shr    $0x4,%rax
  8004201bf6:	48 c1 e0 04          	shl    $0x4,%rax
  8004201bfa:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

    cprintf("\ne820 MEMORY MAP\n");
  8004201bfe:	48 bf 83 73 21 04 80 	movabs $0x8004217383,%rdi
  8004201c05:	00 00 00 
  8004201c08:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201c0d:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  8004201c14:	00 00 00 
  8004201c17:	ff d2                	callq  *%rdx
    for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201c19:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004201c20:	e9 66 01 00 00       	jmpq   8004201d8b <multiboot_read+0x238>
    	memory_map_t* mmap = &mmap_base[i];
  8004201c25:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201c28:	48 63 d0             	movslq %eax,%rdx
  8004201c2b:	48 89 d0             	mov    %rdx,%rax
  8004201c2e:	48 01 c0             	add    %rax,%rax
  8004201c31:	48 01 d0             	add    %rdx,%rax
  8004201c34:	48 c1 e0 03          	shl    $0x3,%rax
  8004201c38:	48 03 45 d8          	add    -0x28(%rbp),%rax
  8004201c3c:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

    	uint64_t addr = APPEND_HILO(mmap->base_addr_high, mmap->base_addr_low);
  8004201c40:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201c44:	8b 40 08             	mov    0x8(%rax),%eax
  8004201c47:	89 c0                	mov    %eax,%eax
  8004201c49:	48 89 c2             	mov    %rax,%rdx
  8004201c4c:	48 c1 e2 20          	shl    $0x20,%rdx
  8004201c50:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201c54:	8b 40 04             	mov    0x4(%rax),%eax
  8004201c57:	89 c0                	mov    %eax,%eax
  8004201c59:	48 01 d0             	add    %rdx,%rax
  8004201c5c:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    	uint64_t len = APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201c60:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201c64:	8b 40 10             	mov    0x10(%rax),%eax
  8004201c67:	89 c0                	mov    %eax,%eax
  8004201c69:	48 89 c2             	mov    %rax,%rdx
  8004201c6c:	48 c1 e2 20          	shl    $0x20,%rdx
  8004201c70:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201c74:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201c77:	89 c0                	mov    %eax,%eax
  8004201c79:	48 01 d0             	add    %rdx,%rax
  8004201c7c:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        
        cprintf("size: %d, address: 0x%016x, length: 0x%016x, type: %x\n", mmap->size, 
                addr, len, mmap->type);
  8004201c80:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    	memory_map_t* mmap = &mmap_base[i];

    	uint64_t addr = APPEND_HILO(mmap->base_addr_high, mmap->base_addr_low);
    	uint64_t len = APPEND_HILO(mmap->length_high, mmap->length_low);
        
        cprintf("size: %d, address: 0x%016x, length: 0x%016x, type: %x\n", mmap->size, 
  8004201c84:	8b 70 14             	mov    0x14(%rax),%esi
  8004201c87:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201c8b:	8b 00                	mov    (%rax),%eax
  8004201c8d:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004201c91:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004201c95:	41 89 f0             	mov    %esi,%r8d
  8004201c98:	89 c6                	mov    %eax,%esi
  8004201c9a:	48 bf 98 73 21 04 80 	movabs $0x8004217398,%rdi
  8004201ca1:	00 00 00 
  8004201ca4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201ca9:	49 b9 f2 89 20 04 80 	movabs $0x80042089f2,%r9
  8004201cb0:	00 00 00 
  8004201cb3:	41 ff d1             	callq  *%r9
                addr, len, mmap->type);

        if(mmap->type > 5 || mmap->type < 1)
  8004201cb6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201cba:	8b 40 14             	mov    0x14(%rax),%eax
  8004201cbd:	83 f8 05             	cmp    $0x5,%eax
  8004201cc0:	77 0b                	ja     8004201ccd <multiboot_read+0x17a>
  8004201cc2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201cc6:	8b 40 14             	mov    0x14(%rax),%eax
  8004201cc9:	85 c0                	test   %eax,%eax
  8004201ccb:	75 0b                	jne    8004201cd8 <multiboot_read+0x185>
        	mmap->type = MB_TYPE_RESERVED;
  8004201ccd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201cd1:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%rax)
       
        //Insert into the sorted list
        int j = 0;
  8004201cd8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
        for(;j<i;j++) {
  8004201cdf:	e9 85 00 00 00       	jmpq   8004201d69 <multiboot_read+0x216>
        	memory_map_t* this = mmap_list[j];
  8004201ce4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201ce8:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201ceb:	48 63 d2             	movslq %edx,%rdx
  8004201cee:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201cf2:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
        	uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004201cf6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201cfa:	8b 40 08             	mov    0x8(%rax),%eax
  8004201cfd:	89 c0                	mov    %eax,%eax
  8004201cff:	48 89 c2             	mov    %rax,%rdx
  8004201d02:	48 c1 e2 20          	shl    $0x20,%rdx
  8004201d06:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201d0a:	8b 40 04             	mov    0x4(%rax),%eax
  8004201d0d:	89 c0                	mov    %eax,%eax
  8004201d0f:	48 01 d0             	add    %rdx,%rax
  8004201d12:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        	if(this_addr > addr) {
  8004201d16:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004201d1a:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004201d1e:	76 45                	jbe    8004201d65 <multiboot_read+0x212>
        		int last = i+1;
  8004201d20:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201d23:	83 c0 01             	add    $0x1,%eax
  8004201d26:	89 45 e4             	mov    %eax,-0x1c(%rbp)
        		while(last != j) {
  8004201d29:	eb 30                	jmp    8004201d5b <multiboot_read+0x208>
        			*(mmap_list + last) = *(mmap_list + last - 1);
  8004201d2b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201d2f:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004201d32:	48 63 d2             	movslq %edx,%rdx
  8004201d35:	48 c1 e2 03          	shl    $0x3,%rdx
  8004201d39:	48 01 c2             	add    %rax,%rdx
  8004201d3c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201d40:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004201d43:	48 63 c9             	movslq %ecx,%rcx
  8004201d46:	48 83 e9 01          	sub    $0x1,%rcx
  8004201d4a:	48 c1 e1 03          	shl    $0x3,%rcx
  8004201d4e:	48 01 c8             	add    %rcx,%rax
  8004201d51:	48 8b 00             	mov    (%rax),%rax
  8004201d54:	48 89 02             	mov    %rax,(%rdx)
        			last--;
  8004201d57:	83 6d e4 01          	subl   $0x1,-0x1c(%rbp)
        for(;j<i;j++) {
        	memory_map_t* this = mmap_list[j];
        	uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
        	if(this_addr > addr) {
        		int last = i+1;
        		while(last != j) {
  8004201d5b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004201d5e:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8004201d61:	75 c8                	jne    8004201d2b <multiboot_read+0x1d8>
        			*(mmap_list + last) = *(mmap_list + last - 1);
        			last--;
        		}
        		break; 
  8004201d63:	eb 10                	jmp    8004201d75 <multiboot_read+0x222>
        if(mmap->type > 5 || mmap->type < 1)
        	mmap->type = MB_TYPE_RESERVED;
       
        //Insert into the sorted list
        int j = 0;
        for(;j<i;j++) {
  8004201d65:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  8004201d69:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004201d6c:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004201d6f:	0f 8c 6f ff ff ff    	jl     8004201ce4 <multiboot_read+0x191>
        			last--;
        		}
        		break; 
        	}
        }
        mmap_list[j] = mmap;  
  8004201d75:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201d79:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201d7c:	48 63 d2             	movslq %edx,%rdx
  8004201d7f:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004201d83:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];

    cprintf("\ne820 MEMORY MAP\n");
    for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201d87:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004201d8b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201d8e:	48 63 c8             	movslq %eax,%rcx
  8004201d91:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201d98:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201d9b:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
  8004201da1:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201da6:	8b 85 44 ff ff ff    	mov    -0xbc(%rbp),%eax
  8004201dac:	f7 e2                	mul    %edx
  8004201dae:	89 d0                	mov    %edx,%eax
  8004201db0:	c1 e8 04             	shr    $0x4,%eax
  8004201db3:	89 c0                	mov    %eax,%eax
  8004201db5:	48 39 c1             	cmp    %rax,%rcx
  8004201db8:	0f 82 67 fe ff ff    	jb     8004201c25 <multiboot_read+0xd2>
        		break; 
        	}
        }
        mmap_list[j] = mmap;  
    }
    cprintf("\n");
  8004201dbe:	48 bf cf 73 21 04 80 	movabs $0x80042173cf,%rdi
  8004201dc5:	00 00 00 
  8004201dc8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201dcd:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  8004201dd4:	00 00 00 
  8004201dd7:	ff d2                	callq  *%rdx
    
    // Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201dd9:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
  8004201de0:	e9 93 01 00 00       	jmpq   8004201f78 <multiboot_read+0x425>
		memory_map_t* prev = mmap_list[i-1];
  8004201de5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201de8:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004201deb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201def:	48 63 d2             	movslq %edx,%rdx
  8004201df2:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201df6:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		memory_map_t* this = mmap_list[i];
  8004201dfa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201dfe:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004201e01:	48 63 d2             	movslq %edx,%rdx
  8004201e04:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201e08:	48 89 45 90          	mov    %rax,-0x70(%rbp)

		uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004201e0c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201e10:	8b 40 08             	mov    0x8(%rax),%eax
  8004201e13:	89 c0                	mov    %eax,%eax
  8004201e15:	48 89 c2             	mov    %rax,%rdx
  8004201e18:	48 c1 e2 20          	shl    $0x20,%rdx
  8004201e1c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201e20:	8b 40 04             	mov    0x4(%rax),%eax
  8004201e23:	89 c0                	mov    %eax,%eax
  8004201e25:	48 01 d0             	add    %rdx,%rax
  8004201e28:	48 89 45 88          	mov    %rax,-0x78(%rbp)
        uint64_t prev_addr = APPEND_HILO(prev->base_addr_high, prev->base_addr_low);
  8004201e2c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201e30:	8b 40 08             	mov    0x8(%rax),%eax
  8004201e33:	89 c0                	mov    %eax,%eax
  8004201e35:	48 89 c2             	mov    %rax,%rdx
  8004201e38:	48 c1 e2 20          	shl    $0x20,%rdx
  8004201e3c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201e40:	8b 40 04             	mov    0x4(%rax),%eax
  8004201e43:	89 c0                	mov    %eax,%eax
  8004201e45:	48 01 d0             	add    %rdx,%rax
  8004201e48:	48 89 45 80          	mov    %rax,-0x80(%rbp)
        uint64_t prev_length = APPEND_HILO(prev->length_high, prev->length_low);
  8004201e4c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201e50:	8b 40 10             	mov    0x10(%rax),%eax
  8004201e53:	89 c0                	mov    %eax,%eax
  8004201e55:	48 89 c2             	mov    %rax,%rdx
  8004201e58:	48 c1 e2 20          	shl    $0x20,%rdx
  8004201e5c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201e60:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201e63:	89 c0                	mov    %eax,%eax
  8004201e65:	48 01 d0             	add    %rdx,%rax
  8004201e68:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
		uint64_t this_length = APPEND_HILO(this->length_high, this->length_low);
  8004201e6f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201e73:	8b 40 10             	mov    0x10(%rax),%eax
  8004201e76:	89 c0                	mov    %eax,%eax
  8004201e78:	48 89 c2             	mov    %rax,%rdx
  8004201e7b:	48 c1 e2 20          	shl    $0x20,%rdx
  8004201e7f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201e83:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201e86:	89 c0                	mov    %eax,%eax
  8004201e88:	48 01 d0             	add    %rdx,%rax
  8004201e8b:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)

		// Merge adjacent regions with same type
		if(prev_addr + prev_length == this_addr && prev->type == this->type) {
  8004201e92:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004201e99:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004201e9d:	48 01 d0             	add    %rdx,%rax
  8004201ea0:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  8004201ea4:	75 7c                	jne    8004201f22 <multiboot_read+0x3cf>
  8004201ea6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201eaa:	8b 50 14             	mov    0x14(%rax),%edx
  8004201ead:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201eb1:	8b 40 14             	mov    0x14(%rax),%eax
  8004201eb4:	39 c2                	cmp    %eax,%edx
  8004201eb6:	75 6a                	jne    8004201f22 <multiboot_read+0x3cf>
			this->length_low = (uint32_t)prev_length + this_length;
  8004201eb8:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004201ebf:	89 c2                	mov    %eax,%edx
  8004201ec1:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201ec8:	01 c2                	add    %eax,%edx
  8004201eca:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201ece:	89 50 0c             	mov    %edx,0xc(%rax)
			this->length_high = (uint32_t)((prev_length + this_length)>>32);
  8004201ed1:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201ed8:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004201edf:	48 01 d0             	add    %rdx,%rax
  8004201ee2:	48 c1 e8 20          	shr    $0x20,%rax
  8004201ee6:	89 c2                	mov    %eax,%edx
  8004201ee8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201eec:	89 50 10             	mov    %edx,0x10(%rax)
			this->base_addr_low = prev->base_addr_low;
  8004201eef:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201ef3:	8b 50 04             	mov    0x4(%rax),%edx
  8004201ef6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201efa:	89 50 04             	mov    %edx,0x4(%rax)
			this->base_addr_high = prev->base_addr_high;
  8004201efd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201f01:	8b 50 08             	mov    0x8(%rax),%edx
  8004201f04:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201f08:	89 50 08             	mov    %edx,0x8(%rax)
			mmap_list[i-1] = NULL;
  8004201f0b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201f0e:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004201f11:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201f15:	48 63 d2             	movslq %edx,%rdx
  8004201f18:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  8004201f1f:	00 
  8004201f20:	eb 52                	jmp    8004201f74 <multiboot_read+0x421>
		} else if(prev_addr + prev_length > this_addr) {
  8004201f22:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004201f29:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004201f2d:	48 01 d0             	add    %rdx,%rax
  8004201f30:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  8004201f34:	76 3e                	jbe    8004201f74 <multiboot_read+0x421>
			//Overlapping regions
			uint32_t type = restrictive_type(prev->type, this->type);
  8004201f36:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201f3a:	8b 50 14             	mov    0x14(%rax),%edx
  8004201f3d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201f41:	8b 40 14             	mov    0x14(%rax),%eax
  8004201f44:	89 d6                	mov    %edx,%esi
  8004201f46:	89 c7                	mov    %eax,%edi
  8004201f48:	48 b8 b3 1a 20 04 80 	movabs $0x8004201ab3,%rax
  8004201f4f:	00 00 00 
  8004201f52:	ff d0                	callq  *%rax
  8004201f54:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
			prev->type = type;
  8004201f5a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004201f5e:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  8004201f64:	89 50 14             	mov    %edx,0x14(%rax)
			this->type = type;
  8004201f67:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004201f6b:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  8004201f71:	89 50 14             	mov    %edx,0x14(%rax)
        mmap_list[j] = mmap;  
    }
    cprintf("\n");
    
    // Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201f74:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004201f78:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201f7b:	48 63 c8             	movslq %eax,%rcx
  8004201f7e:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201f85:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201f88:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
  8004201f8e:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201f93:	8b 85 44 ff ff ff    	mov    -0xbc(%rbp),%eax
  8004201f99:	f7 e2                	mul    %edx
  8004201f9b:	89 d0                	mov    %edx,%eax
  8004201f9d:	c1 e8 04             	shr    $0x4,%eax
  8004201fa0:	89 c0                	mov    %eax,%eax
  8004201fa2:	48 39 c1             	cmp    %rax,%rcx
  8004201fa5:	0f 82 3a fe ff ff    	jb     8004201de5 <multiboot_read+0x292>
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201fab:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004201fb2:	e9 dc 00 00 00       	jmpq   8004202093 <multiboot_read+0x540>
		memory_map_t* mmap = mmap_list[i];
  8004201fb7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201fbb:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004201fbe:	48 63 d2             	movslq %edx,%rdx
  8004201fc1:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201fc5:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
		if(mmap) {
  8004201fcc:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  8004201fd3:	00 
  8004201fd4:	0f 84 b5 00 00 00    	je     800420208f <multiboot_read+0x53c>
			if(mmap->type == MB_TYPE_USABLE || mmap->type == MB_TYPE_ACPI_RECLM) {
  8004201fda:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201fe1:	8b 40 14             	mov    0x14(%rax),%eax
  8004201fe4:	83 f8 01             	cmp    $0x1,%eax
  8004201fe7:	74 13                	je     8004201ffc <multiboot_read+0x4a9>
  8004201fe9:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004201ff0:	8b 40 14             	mov    0x14(%rax),%eax
  8004201ff3:	83 f8 03             	cmp    $0x3,%eax
  8004201ff6:	0f 85 93 00 00 00    	jne    800420208f <multiboot_read+0x53c>
				if(mmap->base_addr_low < 0x100000 && mmap->base_addr_high == 0)
  8004201ffc:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202003:	8b 40 04             	mov    0x4(%rax),%eax
  8004202006:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  800420200b:	77 49                	ja     8004202056 <multiboot_read+0x503>
  800420200d:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202014:	8b 40 08             	mov    0x8(%rax),%eax
  8004202017:	85 c0                	test   %eax,%eax
  8004202019:	75 3b                	jne    8004202056 <multiboot_read+0x503>
					*basemem += APPEND_HILO(mmap->length_high, mmap->length_low);
  800420201b:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004202022:	48 8b 10             	mov    (%rax),%rdx
  8004202025:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420202c:	8b 40 10             	mov    0x10(%rax),%eax
  800420202f:	89 c0                	mov    %eax,%eax
  8004202031:	48 89 c1             	mov    %rax,%rcx
  8004202034:	48 c1 e1 20          	shl    $0x20,%rcx
  8004202038:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420203f:	8b 40 0c             	mov    0xc(%rax),%eax
  8004202042:	89 c0                	mov    %eax,%eax
  8004202044:	48 01 c8             	add    %rcx,%rax
  8004202047:	48 01 c2             	add    %rax,%rdx
  800420204a:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004202051:	48 89 10             	mov    %rdx,(%rax)
  8004202054:	eb 39                	jmp    800420208f <multiboot_read+0x53c>
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
  8004202056:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420205d:	48 8b 10             	mov    (%rax),%rdx
  8004202060:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202067:	8b 40 10             	mov    0x10(%rax),%eax
  800420206a:	89 c0                	mov    %eax,%eax
  800420206c:	48 89 c1             	mov    %rax,%rcx
  800420206f:	48 c1 e1 20          	shl    $0x20,%rcx
  8004202073:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420207a:	8b 40 0c             	mov    0xc(%rax),%eax
  800420207d:	89 c0                	mov    %eax,%eax
  800420207f:	48 01 c8             	add    %rcx,%rax
  8004202082:	48 01 c2             	add    %rax,%rdx
  8004202085:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420208c:	48 89 10             	mov    %rdx,(%rax)
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  800420208f:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004202093:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202096:	48 63 c8             	movslq %eax,%rcx
  8004202099:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042020a0:	8b 40 2c             	mov    0x2c(%rax),%eax
  80042020a3:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
  80042020a9:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  80042020ae:	8b 85 44 ff ff ff    	mov    -0xbc(%rbp),%eax
  80042020b4:	f7 e2                	mul    %edx
  80042020b6:	89 d0                	mov    %edx,%eax
  80042020b8:	c1 e8 04             	shr    $0x4,%eax
  80042020bb:	89 c0                	mov    %eax,%eax
  80042020bd:	48 39 c1             	cmp    %rax,%rcx
  80042020c0:	0f 82 f1 fe ff ff    	jb     8004201fb7 <multiboot_read+0x464>
  80042020c6:	48 89 dc             	mov    %rbx,%rsp
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
			}
		}
	}
}
  80042020c9:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
  80042020cd:	c9                   	leaveq 
  80042020ce:	c3                   	retq   

00000080042020cf <i386_detect_memory>:

static void
i386_detect_memory(void)
{
  80042020cf:	55                   	push   %rbp
  80042020d0:	48 89 e5             	mov    %rsp,%rbp
  80042020d3:	48 83 ec 30          	sub    $0x30,%rsp
	size_t npages_extmem;
	size_t basemem = 0;
  80042020d7:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  80042020de:	00 
	size_t extmem = 0;
  80042020df:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  80042020e6:	00 

	// Check if the bootloader passed us a multiboot structure
	extern char multiboot_info[];
	uintptr_t* mbp = (uintptr_t*)multiboot_info;
  80042020e7:	48 b8 00 70 10 00 00 	movabs $0x107000,%rax
  80042020ee:	00 00 00 
  80042020f1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	multiboot_info_t * mbinfo = (multiboot_info_t*)*mbp;
  80042020f5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042020f9:	48 8b 00             	mov    (%rax),%rax
  80042020fc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	
	if(mbinfo && (mbinfo->flags & MB_FLAG_MMAP)) {
  8004202100:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202105:	74 2d                	je     8004202134 <i386_detect_memory+0x65>
  8004202107:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420210b:	8b 00                	mov    (%rax),%eax
  800420210d:	83 e0 40             	and    $0x40,%eax
  8004202110:	85 c0                	test   %eax,%eax
  8004202112:	74 20                	je     8004202134 <i386_detect_memory+0x65>
		multiboot_read(mbinfo, &basemem, &extmem);
  8004202114:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8004202118:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800420211c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202120:	48 89 ce             	mov    %rcx,%rsi
  8004202123:	48 89 c7             	mov    %rax,%rdi
  8004202126:	48 b8 53 1b 20 04 80 	movabs $0x8004201b53,%rax
  800420212d:	00 00 00 
  8004202130:	ff d0                	callq  *%rax
  8004202132:	eb 34                	jmp    8004202168 <i386_detect_memory+0x99>
	} else {
		basemem = (nvram_read(NVRAM_BASELO) * 1024);
  8004202134:	bf 15 00 00 00       	mov    $0x15,%edi
  8004202139:	48 b8 14 1b 20 04 80 	movabs $0x8004201b14,%rax
  8004202140:	00 00 00 
  8004202143:	ff d0                	callq  *%rax
  8004202145:	c1 e0 0a             	shl    $0xa,%eax
  8004202148:	48 98                	cltq   
  800420214a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		extmem = (nvram_read(NVRAM_EXTLO) * 1024);
  800420214e:	bf 17 00 00 00       	mov    $0x17,%edi
  8004202153:	48 b8 14 1b 20 04 80 	movabs $0x8004201b14,%rax
  800420215a:	00 00 00 
  800420215d:	ff d0                	callq  *%rax
  800420215f:	c1 e0 0a             	shl    $0xa,%eax
  8004202162:	48 98                	cltq   
  8004202164:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	}
    
	assert(basemem);
  8004202168:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420216c:	48 85 c0             	test   %rax,%rax
  800420216f:	75 35                	jne    80042021a6 <i386_detect_memory+0xd7>
  8004202171:	48 b9 d1 73 21 04 80 	movabs $0x80042173d1,%rcx
  8004202178:	00 00 00 
  800420217b:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004202182:	00 00 00 
  8004202185:	be 89 00 00 00       	mov    $0x89,%esi
  800420218a:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004202191:	00 00 00 
  8004202194:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202199:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042021a0:	00 00 00 
  80042021a3:	41 ff d0             	callq  *%r8

	npages_basemem = basemem / PGSIZE;
  80042021a6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042021aa:	48 89 c2             	mov    %rax,%rdx
  80042021ad:	48 c1 ea 0c          	shr    $0xc,%rdx
  80042021b1:	48 b8 30 b2 63 04 80 	movabs $0x800463b230,%rax
  80042021b8:	00 00 00 
  80042021bb:	48 89 10             	mov    %rdx,(%rax)
	npages_extmem = extmem / PGSIZE;
  80042021be:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042021c2:	48 c1 e8 0c          	shr    $0xc,%rax
  80042021c6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	
	// Calculate the number of physical pages available in both base
	// and extended memory.
	if (npages_extmem)
  80042021ca:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042021cf:	74 1a                	je     80042021eb <i386_detect_memory+0x11c>
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
  80042021d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042021d5:	48 8d 90 00 01 00 00 	lea    0x100(%rax),%rdx
  80042021dc:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  80042021e3:	00 00 00 
  80042021e6:	48 89 10             	mov    %rdx,(%rax)
  80042021e9:	eb 1a                	jmp    8004202205 <i386_detect_memory+0x136>
	else
		npages = npages_basemem;
  80042021eb:	48 b8 30 b2 63 04 80 	movabs $0x800463b230,%rax
  80042021f2:	00 00 00 
  80042021f5:	48 8b 10             	mov    (%rax),%rdx
  80042021f8:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  80042021ff:	00 00 00 
  8004202202:	48 89 10             	mov    %rdx,(%rax)

	if(nvram_read(NVRAM_EXTLO) == 0xffff) {
  8004202205:	bf 17 00 00 00       	mov    $0x17,%edi
  800420220a:	48 b8 14 1b 20 04 80 	movabs $0x8004201b14,%rax
  8004202211:	00 00 00 
  8004202214:	ff d0                	callq  *%rax
  8004202216:	3d ff ff 00 00       	cmp    $0xffff,%eax
  800420221b:	75 2c                	jne    8004202249 <i386_detect_memory+0x17a>
		// EXTMEM > 16M in blocks of 64k
		size_t pextmem = nvram_read(NVRAM_EXTGT16LO) * (64 * 1024);
  800420221d:	bf 34 00 00 00       	mov    $0x34,%edi
  8004202222:	48 b8 14 1b 20 04 80 	movabs $0x8004201b14,%rax
  8004202229:	00 00 00 
  800420222c:	ff d0                	callq  *%rax
  800420222e:	c1 e0 10             	shl    $0x10,%eax
  8004202231:	48 98                	cltq   
  8004202233:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		npages_extmem = ((16 * 1024 * 1024) + pextmem - (1 * 1024 * 1024)) / PGSIZE;
  8004202237:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420223b:	48 05 00 00 f0 00    	add    $0xf00000,%rax
  8004202241:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202245:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}
	
	// Calculate the number of physical pages available in both base
	// and extended memory.
	if (npages_extmem)
  8004202249:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420224e:	74 1a                	je     800420226a <i386_detect_memory+0x19b>
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
  8004202250:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202254:	48 8d 90 00 01 00 00 	lea    0x100(%rax),%rdx
  800420225b:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004202262:	00 00 00 
  8004202265:	48 89 10             	mov    %rdx,(%rax)
  8004202268:	eb 1a                	jmp    8004202284 <i386_detect_memory+0x1b5>
	else
		npages = npages_basemem;
  800420226a:	48 b8 30 b2 63 04 80 	movabs $0x800463b230,%rax
  8004202271:	00 00 00 
  8004202274:	48 8b 10             	mov    (%rax),%rdx
  8004202277:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  800420227e:	00 00 00 
  8004202281:	48 89 10             	mov    %rdx,(%rax)

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202284:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  800420228b:	00 00 00 
  800420228e:	48 8b 30             	mov    (%rax),%rsi
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
		npages_extmem * PGSIZE / 1024,
  8004202291:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202295:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202299:	48 89 c1             	mov    %rax,%rcx
  800420229c:	48 c1 e9 0a          	shr    $0xa,%rcx
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
  80042022a0:	48 b8 30 b2 63 04 80 	movabs $0x800463b230,%rax
  80042022a7:	00 00 00 
  80042022aa:	48 8b 00             	mov    (%rax),%rax
  80042022ad:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042022b1:	48 89 c2             	mov    %rax,%rdx
  80042022b4:	48 c1 ea 0a          	shr    $0xa,%rdx
		npages * PGSIZE / (1024 * 1024),
  80042022b8:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  80042022bf:	00 00 00 
  80042022c2:	48 8b 00             	mov    (%rax),%rax
  80042022c5:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042022c9:	48 c1 e8 14          	shr    $0x14,%rax
  80042022cd:	49 89 f0             	mov    %rsi,%r8
  80042022d0:	48 89 c6             	mov    %rax,%rsi
  80042022d3:	48 bf 00 74 21 04 80 	movabs $0x8004217400,%rdi
  80042022da:	00 00 00 
  80042022dd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042022e2:	49 b9 f2 89 20 04 80 	movabs $0x80042089f2,%r9
  80042022e9:	00 00 00 
  80042022ec:	41 ff d1             	callq  *%r9
		npages_basemem * PGSIZE / 1024,
		npages_extmem * PGSIZE / 1024,
		npages);
	
	//JOS is hardwired to support only 256M of physical memory
	if(npages > ((255 * 1024 * 1024)/PGSIZE)) {
  80042022ef:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  80042022f6:	00 00 00 
  80042022f9:	48 8b 00             	mov    (%rax),%rax
  80042022fc:	48 3d 00 ff 00 00    	cmp    $0xff00,%rax
  8004202302:	76 44                	jbe    8004202348 <i386_detect_memory+0x279>
		npages = (255 * 1024 * 1024) / PGSIZE;
  8004202304:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  800420230b:	00 00 00 
  800420230e:	48 c7 00 00 ff 00 00 	movq   $0xff00,(%rax)
		cprintf("Using only %uK of the available memory.\n", npages * PGSIZE/1024);
  8004202315:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  800420231c:	00 00 00 
  800420231f:	48 8b 00             	mov    (%rax),%rax
  8004202322:	48 c1 e0 0c          	shl    $0xc,%rax
  8004202326:	48 c1 e8 0a          	shr    $0xa,%rax
  800420232a:	48 89 c6             	mov    %rax,%rsi
  800420232d:	48 bf 50 74 21 04 80 	movabs $0x8004217450,%rdi
  8004202334:	00 00 00 
  8004202337:	b8 00 00 00 00       	mov    $0x0,%eax
  800420233c:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  8004202343:	00 00 00 
  8004202346:	ff d2                	callq  *%rdx
	}
}
  8004202348:	c9                   	leaveq 
  8004202349:	c3                   	retq   

000000800420234a <boot_alloc>:
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void *
boot_alloc(uint32_t n)
{
  800420234a:	55                   	push   %rbp
  800420234b:	48 89 e5             	mov    %rsp,%rbp
  800420234e:	48 83 ec 40          	sub    $0x40,%rsp
  8004202352:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
  8004202355:	48 b8 48 b2 63 04 80 	movabs $0x800463b248,%rax
  800420235c:	00 00 00 
  800420235f:	48 8b 00             	mov    (%rax),%rax
  8004202362:	48 85 c0             	test   %rax,%rax
  8004202365:	75 4e                	jne    80042023b5 <boot_alloc+0x6b>
        extern uintptr_t end_debug;
		nextfree = ROUNDUP((char *) end_debug, PGSIZE);
  8004202367:	48 c7 45 f0 00 10 00 	movq   $0x1000,-0x10(%rbp)
  800420236e:	00 
  800420236f:	48 b8 b8 c7 63 04 80 	movabs $0x800463c7b8,%rax
  8004202376:	00 00 00 
  8004202379:	48 8b 00             	mov    (%rax),%rax
  800420237c:	48 03 45 f0          	add    -0x10(%rbp),%rax
  8004202380:	48 83 e8 01          	sub    $0x1,%rax
  8004202384:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004202388:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420238c:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202391:	48 f7 75 f0          	divq   -0x10(%rbp)
  8004202395:	48 89 d0             	mov    %rdx,%rax
  8004202398:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420239c:	48 89 d1             	mov    %rdx,%rcx
  800420239f:	48 29 c1             	sub    %rax,%rcx
  80042023a2:	48 89 c8             	mov    %rcx,%rax
  80042023a5:	48 89 c2             	mov    %rax,%rdx
  80042023a8:	48 b8 48 b2 63 04 80 	movabs $0x800463b248,%rax
  80042023af:	00 00 00 
  80042023b2:	48 89 10             	mov    %rdx,(%rax)
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.

	assert(nextfree!=NULL);
  80042023b5:	48 b8 48 b2 63 04 80 	movabs $0x800463b248,%rax
  80042023bc:	00 00 00 
  80042023bf:	48 8b 00             	mov    (%rax),%rax
  80042023c2:	48 85 c0             	test   %rax,%rax
  80042023c5:	75 35                	jne    80042023fc <boot_alloc+0xb2>
  80042023c7:	48 b9 79 74 21 04 80 	movabs $0x8004217479,%rcx
  80042023ce:	00 00 00 
  80042023d1:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042023d8:	00 00 00 
  80042023db:	be de 00 00 00       	mov    $0xde,%esi
  80042023e0:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042023e7:	00 00 00 
  80042023ea:	b8 00 00 00 00       	mov    $0x0,%eax
  80042023ef:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042023f6:	00 00 00 
  80042023f9:	41 ff d0             	callq  *%r8
	if(n>0)
  80042023fc:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004202400:	74 67                	je     8004202469 <boot_alloc+0x11f>
        {
                result=nextfree;
  8004202402:	48 b8 48 b2 63 04 80 	movabs $0x800463b248,%rax
  8004202409:	00 00 00 
  800420240c:	48 8b 00             	mov    (%rax),%rax
  800420240f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                nextfree=ROUNDUP((char *)(nextfree+n), PGSIZE);
  8004202413:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  800420241a:	00 
  800420241b:	48 b8 48 b2 63 04 80 	movabs $0x800463b248,%rax
  8004202422:	00 00 00 
  8004202425:	48 8b 10             	mov    (%rax),%rdx
  8004202428:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420242b:	48 01 d0             	add    %rdx,%rax
  800420242e:	48 03 45 e0          	add    -0x20(%rbp),%rax
  8004202432:	48 83 e8 01          	sub    $0x1,%rax
  8004202436:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420243a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420243e:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202443:	48 f7 75 e0          	divq   -0x20(%rbp)
  8004202447:	48 89 d0             	mov    %rdx,%rax
  800420244a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420244e:	48 89 d1             	mov    %rdx,%rcx
  8004202451:	48 29 c1             	sub    %rax,%rcx
  8004202454:	48 89 c8             	mov    %rcx,%rax
  8004202457:	48 89 c2             	mov    %rax,%rdx
  800420245a:	48 b8 48 b2 63 04 80 	movabs $0x800463b248,%rax
  8004202461:	00 00 00 
  8004202464:	48 89 10             	mov    %rdx,(%rax)
  8004202467:	eb 17                	jmp    8004202480 <boot_alloc+0x136>
        }
        else if(n==0)
  8004202469:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420246d:	75 11                	jne    8004202480 <boot_alloc+0x136>
        {
                result=nextfree;
  800420246f:	48 b8 48 b2 63 04 80 	movabs $0x800463b248,%rax
  8004202476:	00 00 00 
  8004202479:	48 8b 00             	mov    (%rax),%rax
  800420247c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        }
	return (void *)result;
  8004202480:	48 8b 45 f8          	mov    -0x8(%rbp),%rax


}
  8004202484:	c9                   	leaveq 
  8004202485:	c3                   	retq   

0000008004202486 <x64_vm_init>:
//
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
void
x64_vm_init(void)
{
  8004202486:	55                   	push   %rbp
  8004202487:	48 89 e5             	mov    %rsp,%rbp
  800420248a:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
	pml4e_t* pml4e;
	uint32_t cr0;
	uint64_t n;
	int r;
	struct Env *env;
	i386_detect_memory();
  8004202491:	48 b8 cf 20 20 04 80 	movabs $0x80042020cf,%rax
  8004202498:	00 00 00 
  800420249b:	ff d0                	callq  *%rax
	//panic("i386_vm_init: This function is not finished\n");
	//////////////////////////////////////////////////////////////////////
	// create initial page directory.
	//panic("x64_vm_init: this function is not finished\n");
	pml4e = boot_alloc(PGSIZE);
  800420249d:	bf 00 10 00 00       	mov    $0x1000,%edi
  80042024a2:	48 b8 4a 23 20 04 80 	movabs $0x800420234a,%rax
  80042024a9:	00 00 00 
  80042024ac:	ff d0                	callq  *%rax
  80042024ae:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(pml4e, 0, PGSIZE);
  80042024b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042024b6:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042024bb:	be 00 00 00 00       	mov    $0x0,%esi
  80042024c0:	48 89 c7             	mov    %rax,%rdi
  80042024c3:	48 b8 53 e6 20 04 80 	movabs $0x800420e653,%rax
  80042024ca:	00 00 00 
  80042024cd:	ff d0                	callq  *%rax
	boot_pml4e = pml4e;
  80042024cf:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  80042024d6:	00 00 00 
  80042024d9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042024dd:	48 89 10             	mov    %rdx,(%rax)
	boot_cr3 = PADDR(pml4e);
  80042024e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042024e4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042024e8:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042024ef:	00 00 00 
  80042024f2:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  80042024f6:	77 32                	ja     800420252a <x64_vm_init+0xa4>
  80042024f8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042024fc:	48 89 c1             	mov    %rax,%rcx
  80042024ff:	48 ba 88 74 21 04 80 	movabs $0x8004217488,%rdx
  8004202506:	00 00 00 
  8004202509:	be 06 01 00 00       	mov    $0x106,%esi
  800420250e:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004202515:	00 00 00 
  8004202518:	b8 00 00 00 00       	mov    $0x0,%eax
  800420251d:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004202524:	00 00 00 
  8004202527:	41 ff d0             	callq  *%r8
  800420252a:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004202531:	ff ff ff 
  8004202534:	48 89 c2             	mov    %rax,%rdx
  8004202537:	48 03 55 f0          	add    -0x10(%rbp),%rdx
  800420253b:	48 b8 d0 c7 63 04 80 	movabs $0x800463c7d0,%rax
  8004202542:	00 00 00 
  8004202545:	48 89 10             	mov    %rdx,(%rax)
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.
	// Your code goes here:
	pages=(struct PageInfo *)boot_alloc(npages*sizeof(struct PageInfo));
  8004202548:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  800420254f:	00 00 00 
  8004202552:	48 8b 00             	mov    (%rax),%rax
  8004202555:	c1 e0 04             	shl    $0x4,%eax
  8004202558:	89 c7                	mov    %eax,%edi
  800420255a:	48 b8 4a 23 20 04 80 	movabs $0x800420234a,%rax
  8004202561:	00 00 00 
  8004202564:	ff d0                	callq  *%rax
  8004202566:	48 ba e8 c7 63 04 80 	movabs $0x800463c7e8,%rdx
  800420256d:	00 00 00 
  8004202570:	48 89 02             	mov    %rax,(%rdx)

	//////////////////////////////////////////////////////////////////////
	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
	// LAB 3: Your code here.
	envs=(struct Env *)boot_alloc(NENV*sizeof(struct Env));
  8004202573:	bf 00 80 04 00       	mov    $0x48000,%edi
  8004202578:	48 b8 4a 23 20 04 80 	movabs $0x800420234a,%rax
  800420257f:	00 00 00 
  8004202582:	ff d0                	callq  *%rax
  8004202584:	48 ba 50 b2 63 04 80 	movabs $0x800463b250,%rdx
  800420258b:	00 00 00 
  800420258e:	48 89 02             	mov    %rax,(%rdx)
	memset(envs, 0, NENV * sizeof(struct Env));
  8004202591:	48 b8 50 b2 63 04 80 	movabs $0x800463b250,%rax
  8004202598:	00 00 00 
  800420259b:	48 8b 00             	mov    (%rax),%rax
  800420259e:	ba 00 80 04 00       	mov    $0x48000,%edx
  80042025a3:	be 00 00 00 00       	mov    $0x0,%esi
  80042025a8:	48 89 c7             	mov    %rax,%rdi
  80042025ab:	48 b8 53 e6 20 04 80 	movabs $0x800420e653,%rax
  80042025b2:	00 00 00 
  80042025b5:	ff d0                	callq  *%rax
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region or page_insert
	
	page_init();
  80042025b7:	48 b8 a3 2a 20 04 80 	movabs $0x8004202aa3,%rax
  80042025be:	00 00 00 
  80042025c1:	ff d0                	callq  *%rax
	// Permissions:
	//    - the new image at UPAGES -- kernel R, us/er R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:
	size_t pagessize = ROUNDUP(npages*(sizeof(struct PageInfo)),PGSIZE);	
  80042025c3:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  80042025ca:	00 
  80042025cb:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  80042025d2:	00 00 00 
  80042025d5:	48 8b 00             	mov    (%rax),%rax
  80042025d8:	48 c1 e0 04          	shl    $0x4,%rax
  80042025dc:	48 03 45 e8          	add    -0x18(%rbp),%rax
  80042025e0:	48 83 e8 01          	sub    $0x1,%rax
  80042025e4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042025e8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042025ec:	ba 00 00 00 00       	mov    $0x0,%edx
  80042025f1:	48 f7 75 e8          	divq   -0x18(%rbp)
  80042025f5:	48 89 d0             	mov    %rdx,%rax
  80042025f8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042025fc:	48 89 d1             	mov    %rdx,%rcx
  80042025ff:	48 29 c1             	sub    %rax,%rcx
  8004202602:	48 89 c8             	mov    %rcx,%rax
  8004202605:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	boot_map_region(boot_pml4e, UPAGES, pagessize, PADDR(pages),PTE_U | PTE_P);
  8004202609:	48 b8 e8 c7 63 04 80 	movabs $0x800463c7e8,%rax
  8004202610:	00 00 00 
  8004202613:	48 8b 00             	mov    (%rax),%rax
  8004202616:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420261a:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202621:	00 00 00 
  8004202624:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  8004202628:	77 32                	ja     800420265c <x64_vm_init+0x1d6>
  800420262a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420262e:	48 89 c1             	mov    %rax,%rcx
  8004202631:	48 ba 88 74 21 04 80 	movabs $0x8004217488,%rdx
  8004202638:	00 00 00 
  800420263b:	be 2f 01 00 00       	mov    $0x12f,%esi
  8004202640:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004202647:	00 00 00 
  800420264a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420264f:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004202656:	00 00 00 
  8004202659:	41 ff d0             	callq  *%r8
  800420265c:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004202663:	ff ff ff 
  8004202666:	48 89 c1             	mov    %rax,%rcx
  8004202669:	48 03 4d d0          	add    -0x30(%rbp),%rcx
  800420266d:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004202674:	00 00 00 
  8004202677:	48 8b 00             	mov    (%rax),%rax
  800420267a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420267e:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  8004202684:	48 be 00 00 a0 00 80 	movabs $0x8000a00000,%rsi
  800420268b:	00 00 00 
  800420268e:	48 89 c7             	mov    %rax,%rdi
  8004202691:	48 b8 b2 34 20 04 80 	movabs $0x80042034b2,%rax
  8004202698:	00 00 00 
  800420269b:	ff d0                	callq  *%rax
	// (ie. perm = PTE_U | PTE_P).
	// Permissions:
	//    - the new image at UENVS  -- kernel R, user R
	//    - envs itself -- kernel RW, user NONE
	// LAB 3: Your code here.
	size_t envssize = ROUNDUP(NENV*(sizeof(struct Env)),PGSIZE);
  800420269d:	48 c7 45 c8 00 10 00 	movq   $0x1000,-0x38(%rbp)
  80042026a4:	00 
  80042026a5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042026a9:	48 05 ff 7f 04 00    	add    $0x47fff,%rax
  80042026af:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80042026b3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042026b7:	ba 00 00 00 00       	mov    $0x0,%edx
  80042026bc:	48 f7 75 c8          	divq   -0x38(%rbp)
  80042026c0:	48 89 d0             	mov    %rdx,%rax
  80042026c3:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042026c7:	48 89 d1             	mov    %rdx,%rcx
  80042026ca:	48 29 c1             	sub    %rax,%rcx
  80042026cd:	48 89 c8             	mov    %rcx,%rax
  80042026d0:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	boot_map_region(boot_pml4e, UENVS, envssize, PADDR(envs), PTE_U | PTE_P);
  80042026d4:	48 b8 50 b2 63 04 80 	movabs $0x800463b250,%rax
  80042026db:	00 00 00 
  80042026de:	48 8b 00             	mov    (%rax),%rax
  80042026e1:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  80042026e5:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042026ec:	00 00 00 
  80042026ef:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
  80042026f3:	77 32                	ja     8004202727 <x64_vm_init+0x2a1>
  80042026f5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042026f9:	48 89 c1             	mov    %rax,%rcx
  80042026fc:	48 ba 88 74 21 04 80 	movabs $0x8004217488,%rdx
  8004202703:	00 00 00 
  8004202706:	be 39 01 00 00       	mov    $0x139,%esi
  800420270b:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004202712:	00 00 00 
  8004202715:	b8 00 00 00 00       	mov    $0x0,%eax
  800420271a:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004202721:	00 00 00 
  8004202724:	41 ff d0             	callq  *%r8
  8004202727:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  800420272e:	ff ff ff 
  8004202731:	48 89 c1             	mov    %rax,%rcx
  8004202734:	48 03 4d b0          	add    -0x50(%rbp),%rcx
  8004202738:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  800420273f:	00 00 00 
  8004202742:	48 8b 00             	mov    (%rax),%rax
  8004202745:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004202749:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  800420274f:	48 be 00 00 80 00 80 	movabs $0x8000800000,%rsi
  8004202756:	00 00 00 
  8004202759:	48 89 c7             	mov    %rax,%rdi
  800420275c:	48 b8 b2 34 20 04 80 	movabs $0x80042034b2,%rax
  8004202763:	00 00 00 
  8004202766:	ff d0                	callq  *%rax
	//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
	//       the kernel overflows its stack, it will fault rather than
	//       overwrite memory.  Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	// Your code goes here:
	boot_map_region(boot_pml4e, KSTACKTOP-KSTKSIZE, KSTKSIZE,PADDR(bootstack) ,PTE_P | PTE_W);
  8004202768:	48 b8 00 a0 21 04 80 	movabs $0x800421a000,%rax
  800420276f:	00 00 00 
  8004202772:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  8004202776:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420277d:	00 00 00 
  8004202780:	48 39 45 a8          	cmp    %rax,-0x58(%rbp)
  8004202784:	77 32                	ja     80042027b8 <x64_vm_init+0x332>
  8004202786:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420278a:	48 89 c1             	mov    %rax,%rcx
  800420278d:	48 ba 88 74 21 04 80 	movabs $0x8004217488,%rdx
  8004202794:	00 00 00 
  8004202797:	be 46 01 00 00       	mov    $0x146,%esi
  800420279c:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042027a3:	00 00 00 
  80042027a6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042027ab:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042027b2:	00 00 00 
  80042027b5:	41 ff d0             	callq  *%r8
  80042027b8:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  80042027bf:	ff ff ff 
  80042027c2:	48 89 c2             	mov    %rax,%rdx
  80042027c5:	48 03 55 a8          	add    -0x58(%rbp),%rdx
  80042027c9:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  80042027d0:	00 00 00 
  80042027d3:	48 8b 00             	mov    (%rax),%rax
  80042027d6:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  80042027dc:	48 89 d1             	mov    %rdx,%rcx
  80042027df:	ba 00 00 01 00       	mov    $0x10000,%edx
  80042027e4:	48 be 00 00 ff 03 80 	movabs $0x8003ff0000,%rsi
  80042027eb:	00 00 00 
  80042027ee:	48 89 c7             	mov    %rax,%rdi
  80042027f1:	48 b8 b2 34 20 04 80 	movabs $0x80042034b2,%rax
  80042027f8:	00 00 00 
  80042027fb:	ff d0                	callq  *%rax
    // of physical pages to be npages.
	// Ie.  the VA range [KERNBASE, npages*PGSIZE) should map to
	//      the PA range [0, npages*PGSIZE)
	// Permissions: kernel RW, user NONE
	// Your code goes here:
	boot_map_region(boot_pml4e, KERNBASE, npages *PGSIZE, (physaddr_t)0x0, PTE_P | PTE_W);	
  80042027fd:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004202804:	00 00 00 
  8004202807:	48 8b 00             	mov    (%rax),%rax
  800420280a:	48 89 c2             	mov    %rax,%rdx
  800420280d:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004202811:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004202818:	00 00 00 
  800420281b:	48 8b 00             	mov    (%rax),%rax
  800420281e:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202824:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004202829:	48 be 00 00 00 04 80 	movabs $0x8004000000,%rsi
  8004202830:	00 00 00 
  8004202833:	48 89 c7             	mov    %rax,%rdi
  8004202836:	48 b8 b2 34 20 04 80 	movabs $0x80042034b2,%rax
  800420283d:	00 00 00 
  8004202840:	ff d0                	callq  *%rax
	//boot_map_region(boot_pml4e,(uint64_t)recvDescRing, NUM_RX_DESC*16, PADDR(recvDescRing),PTE_P | PTE_U | PTE_W);
	
	
	// Check that the initial page directory has been set up correctly.
	// Initialize the SMP-related parts of the memory map
	mem_init_mp();
  8004202842:	48 b8 b5 29 20 04 80 	movabs $0x80042029b5,%rax
  8004202849:	00 00 00 
  800420284c:	ff d0                	callq  *%rax

	check_boot_pml4e(boot_pml4e);
  800420284e:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004202855:	00 00 00 
  8004202858:	48 8b 00             	mov    (%rax),%rax
  800420285b:	48 89 c7             	mov    %rax,%rdi
  800420285e:	48 b8 a9 4a 20 04 80 	movabs $0x8004204aa9,%rax
  8004202865:	00 00 00 
  8004202868:	ff d0                	callq  *%rax

	//////////////////////////////////////////////////////////////////////
	// Permissions: kernel RW, user NONE
         lcr3(boot_cr3);
  800420286a:	48 b8 d0 c7 63 04 80 	movabs $0x800463c7d0,%rax
  8004202871:	00 00 00 
  8004202874:	48 8b 00             	mov    (%rax),%rax
  8004202877:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420287e:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004202885:	0f 22 d8             	mov    %rax,%cr3

	pdpe_t *pdpe = KADDR(PTE_ADDR(pml4e[1]));
  8004202888:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420288c:	48 83 c0 08          	add    $0x8,%rax
  8004202890:	48 8b 00             	mov    (%rax),%rax
  8004202893:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202899:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  800420289d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042028a1:	48 c1 e8 0c          	shr    $0xc,%rax
  80042028a5:	89 45 9c             	mov    %eax,-0x64(%rbp)
  80042028a8:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042028ab:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  80042028b2:	00 00 00 
  80042028b5:	48 8b 00             	mov    (%rax),%rax
  80042028b8:	48 39 c2             	cmp    %rax,%rdx
  80042028bb:	72 32                	jb     80042028ef <x64_vm_init+0x469>
  80042028bd:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042028c1:	48 89 c1             	mov    %rax,%rcx
  80042028c4:	48 ba 60 73 21 04 80 	movabs $0x8004217360,%rdx
  80042028cb:	00 00 00 
  80042028ce:	be 5f 01 00 00       	mov    $0x15f,%esi
  80042028d3:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042028da:	00 00 00 
  80042028dd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042028e2:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042028e9:	00 00 00 
  80042028ec:	41 ff d0             	callq  *%r8
  80042028ef:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  80042028f6:	00 00 00 
  80042028f9:	48 03 45 a0          	add    -0x60(%rbp),%rax
  80042028fd:	48 89 45 90          	mov    %rax,-0x70(%rbp)
        pde_t *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004202901:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202905:	48 8b 00             	mov    (%rax),%rax
  8004202908:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420290e:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004202912:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004202916:	48 c1 e8 0c          	shr    $0xc,%rax
  800420291a:	89 45 84             	mov    %eax,-0x7c(%rbp)
  800420291d:	8b 55 84             	mov    -0x7c(%rbp),%edx
  8004202920:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004202927:	00 00 00 
  800420292a:	48 8b 00             	mov    (%rax),%rax
  800420292d:	48 39 c2             	cmp    %rax,%rdx
  8004202930:	72 32                	jb     8004202964 <x64_vm_init+0x4de>
  8004202932:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004202936:	48 89 c1             	mov    %rax,%rcx
  8004202939:	48 ba 60 73 21 04 80 	movabs $0x8004217360,%rdx
  8004202940:	00 00 00 
  8004202943:	be 60 01 00 00       	mov    $0x160,%esi
  8004202948:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420294f:	00 00 00 
  8004202952:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202957:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420295e:	00 00 00 
  8004202961:	41 ff d0             	callq  *%r8
  8004202964:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  800420296b:	00 00 00 
  800420296e:	48 03 45 88          	add    -0x78(%rbp),%rax
  8004202972:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	

	 check_page_free_list(1);
  8004202979:	bf 01 00 00 00       	mov    $0x1,%edi
  800420297e:	48 b8 8f 3b 20 04 80 	movabs $0x8004203b8f,%rax
  8004202985:	00 00 00 
  8004202988:	ff d0                	callq  *%rax
        check_page_alloc();
  800420298a:	48 b8 c1 40 20 04 80 	movabs $0x80042040c1,%rax
  8004202991:	00 00 00 
  8004202994:	ff d0                	callq  *%rax
        page_check();
  8004202996:	48 b8 46 54 20 04 80 	movabs $0x8004205446,%rax
  800420299d:	00 00 00 
  80042029a0:	ff d0                	callq  *%rax

        check_page_free_list(0);
  80042029a2:	bf 00 00 00 00       	mov    $0x0,%edi
  80042029a7:	48 b8 8f 3b 20 04 80 	movabs $0x8004203b8f,%rax
  80042029ae:	00 00 00 
  80042029b1:	ff d0                	callq  *%rax
        //check_page_alloc();
        //page_check();
	//check_page_free_list(0);


}
  80042029b3:	c9                   	leaveq 
  80042029b4:	c3                   	retq   

00000080042029b5 <mem_init_mp>:
// Modify mappings in boot_pml4e to support SMP
//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)
//
	static void
mem_init_mp(void)
{
  80042029b5:	55                   	push   %rbp
  80042029b6:	48 89 e5             	mov    %rsp,%rbp
  80042029b9:	48 83 ec 20          	sub    $0x20,%rsp
	//     Permissions: kernel RW, user NONE
	//
	// LAB 4: Your code here:
 	int i;
	uintptr_t kstacktop_i;
	for(i=0;i<NCPU;i++)
  80042029bd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042029c4:	e9 ce 00 00 00       	jmpq   8004202a97 <mem_init_mp+0xe2>
	{
		kstacktop_i= KSTACKTOP-i*(KSTKSIZE + KSTKGAP);
  80042029c9:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042029cc:	89 d0                	mov    %edx,%eax
  80042029ce:	01 c0                	add    %eax,%eax
  80042029d0:	01 d0                	add    %edx,%eax
  80042029d2:	c1 e0 0f             	shl    $0xf,%eax
  80042029d5:	48 98                	cltq   
  80042029d7:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042029de:	00 00 00 
  80042029e1:	48 89 d1             	mov    %rdx,%rcx
  80042029e4:	48 29 c1             	sub    %rax,%rcx
  80042029e7:	48 89 c8             	mov    %rcx,%rax
  80042029ea:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		boot_map_region(boot_pml4e,kstacktop_i-KSTKSIZE,KSTKSIZE,PADDR(percpu_kstacks[i]),PTE_P | PTE_W);
  80042029ee:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042029f1:	48 98                	cltq   
  80042029f3:	48 89 c2             	mov    %rax,%rdx
  80042029f6:	48 c1 e2 10          	shl    $0x10,%rdx
  80042029fa:	48 b8 00 f0 67 04 80 	movabs $0x800467f000,%rax
  8004202a01:	00 00 00 
  8004202a04:	48 01 d0             	add    %rdx,%rax
  8004202a07:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004202a0b:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202a12:	00 00 00 
  8004202a15:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004202a19:	77 32                	ja     8004202a4d <mem_init_mp+0x98>
  8004202a1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202a1f:	48 89 c1             	mov    %rax,%rcx
  8004202a22:	48 ba 88 74 21 04 80 	movabs $0x8004217488,%rdx
  8004202a29:	00 00 00 
  8004202a2c:	be 8f 01 00 00       	mov    $0x18f,%esi
  8004202a31:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004202a38:	00 00 00 
  8004202a3b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202a40:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004202a47:	00 00 00 
  8004202a4a:	41 ff d0             	callq  *%r8
  8004202a4d:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004202a54:	ff ff ff 
  8004202a57:	48 89 c2             	mov    %rax,%rdx
  8004202a5a:	48 03 55 e8          	add    -0x18(%rbp),%rdx
  8004202a5e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202a62:	48 8d b0 00 00 ff ff 	lea    -0x10000(%rax),%rsi
  8004202a69:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004202a70:	00 00 00 
  8004202a73:	48 8b 00             	mov    (%rax),%rax
  8004202a76:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202a7c:	48 89 d1             	mov    %rdx,%rcx
  8004202a7f:	ba 00 00 01 00       	mov    $0x10000,%edx
  8004202a84:	48 89 c7             	mov    %rax,%rdi
  8004202a87:	48 b8 b2 34 20 04 80 	movabs $0x80042034b2,%rax
  8004202a8e:	00 00 00 
  8004202a91:	ff d0                	callq  *%rax
	//     Permissions: kernel RW, user NONE
	//
	// LAB 4: Your code here:
 	int i;
	uintptr_t kstacktop_i;
	for(i=0;i<NCPU;i++)
  8004202a93:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004202a97:	83 7d fc 07          	cmpl   $0x7,-0x4(%rbp)
  8004202a9b:	0f 8e 28 ff ff ff    	jle    80042029c9 <mem_init_mp+0x14>
	{
		kstacktop_i= KSTACKTOP-i*(KSTKSIZE + KSTKGAP);
		boot_map_region(boot_pml4e,kstacktop_i-KSTKSIZE,KSTKSIZE,PADDR(percpu_kstacks[i]),PTE_P | PTE_W);
	}	
}
  8004202aa1:	c9                   	leaveq 
  8004202aa2:	c3                   	retq   

0000008004202aa3 <page_init>:
// After this is done, NEVER use boot_alloc again.  ONLY use the page
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void page_init(void)
{
  8004202aa3:	55                   	push   %rbp
  8004202aa4:	48 89 e5             	mov    %rsp,%rbp
  8004202aa7:	48 83 ec 30          	sub    $0x30,%rsp
    // NB: Make sure you preserve the direction in which your page_free_list 
    // is constructed
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)

	size_t i,temp;
        struct PageInfo *head = NULL,*tail=NULL;
  8004202aab:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004202ab2:	00 
  8004202ab3:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004202aba:	00 
	physaddr_t phy;
        temp=0;
  8004202abb:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004202ac2:	00 
	//cprintf("\nPA: %x",PADDR(boot_alloc(0)));
	//cprintf("IOPHYSMEM: %x\nEXTPHYSMEM: %x\nboot_alloc(0) %u",IOPHYSMEM,EXTPHYSMEM,boot_alloc(0));
	//cprintf("PA: %x",PADDR(BOOT_PAGE_TABLE_START));
	//cprintf("PA :%x        VA :%x",EXTPHYSMEM,KADDR(EXTPHYSMEM));
	//cprintf("PA :%x  VA :%x",IOPHYSMEM,KADDR(IOPHYSMEM));
        for(i=0;i<npages;i++,temp=0)
  8004202ac3:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004202aca:	00 
  8004202acb:	e9 9f 01 00 00       	jmpq   8004202c6f <page_init+0x1cc>
        {
		pages[i].pp_ref=0;
  8004202ad0:	48 b8 e8 c7 63 04 80 	movabs $0x800463c7e8,%rax
  8004202ad7:	00 00 00 
  8004202ada:	48 8b 00             	mov    (%rax),%rax
  8004202add:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202ae1:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202ae5:	48 01 d0             	add    %rdx,%rax
  8004202ae8:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
                phy=page2pa(&pages[i]);
  8004202aee:	48 b8 e8 c7 63 04 80 	movabs $0x800463c7e8,%rax
  8004202af5:	00 00 00 
  8004202af8:	48 8b 00             	mov    (%rax),%rax
  8004202afb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202aff:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202b03:	48 01 d0             	add    %rdx,%rax
  8004202b06:	48 89 c7             	mov    %rax,%rdi
  8004202b09:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  8004202b10:	00 00 00 
  8004202b13:	ff d0                	callq  *%rax
  8004202b15:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		//cprintf(" Page %d PA : %x ",i,phy);
                //cprintf("%x\t%x\n",EXTPHYSMEM,PADDR(boot_alloc(0)));
		//cprintf("%d\t%d\t%d\n",npages,npages_basemem,npages_extmem);
		if(i==0)
  8004202b19:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202b1e:	75 0d                	jne    8004202b2d <page_init+0x8a>
                        temp=1;
  8004202b20:	48 c7 45 f0 01 00 00 	movq   $0x1,-0x10(%rbp)
  8004202b27:	00 
  8004202b28:	e9 b2 00 00 00       	jmpq   8004202bdf <page_init+0x13c>
                else if(phy >= IOPHYSMEM && phy < EXTPHYSMEM )
  8004202b2d:	48 81 7d d8 ff ff 09 	cmpq   $0x9ffff,-0x28(%rbp)
  8004202b34:	00 
  8004202b35:	76 17                	jbe    8004202b4e <page_init+0xab>
  8004202b37:	48 81 7d d8 ff ff 0f 	cmpq   $0xfffff,-0x28(%rbp)
  8004202b3e:	00 
  8004202b3f:	77 0d                	ja     8004202b4e <page_init+0xab>
                        temp=1;
  8004202b41:	48 c7 45 f0 01 00 00 	movq   $0x1,-0x10(%rbp)
  8004202b48:	00 
  8004202b49:	e9 91 00 00 00       	jmpq   8004202bdf <page_init+0x13c>
		//cprintf("%x\t%x\n",EXTPHYSMEM,PADDR(boot_alloc(0)));
                else if(phy >= EXTPHYSMEM && phy < PADDR(boot_alloc(0)))
  8004202b4e:	48 81 7d d8 ff ff 0f 	cmpq   $0xfffff,-0x28(%rbp)
  8004202b55:	00 
  8004202b56:	76 75                	jbe    8004202bcd <page_init+0x12a>
  8004202b58:	bf 00 00 00 00       	mov    $0x0,%edi
  8004202b5d:	48 b8 4a 23 20 04 80 	movabs $0x800420234a,%rax
  8004202b64:	00 00 00 
  8004202b67:	ff d0                	callq  *%rax
  8004202b69:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004202b6d:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202b74:	00 00 00 
  8004202b77:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  8004202b7b:	77 32                	ja     8004202baf <page_init+0x10c>
  8004202b7d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202b81:	48 89 c1             	mov    %rax,%rcx
  8004202b84:	48 ba 88 74 21 04 80 	movabs $0x8004217488,%rdx
  8004202b8b:	00 00 00 
  8004202b8e:	be cf 01 00 00       	mov    $0x1cf,%esi
  8004202b93:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004202b9a:	00 00 00 
  8004202b9d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202ba2:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004202ba9:	00 00 00 
  8004202bac:	41 ff d0             	callq  *%r8
  8004202baf:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004202bb6:	ff ff ff 
  8004202bb9:	48 03 45 d0          	add    -0x30(%rbp),%rax
  8004202bbd:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004202bc1:	76 0a                	jbe    8004202bcd <page_init+0x12a>
                        temp=1;
  8004202bc3:	48 c7 45 f0 01 00 00 	movq   $0x1,-0x10(%rbp)
  8004202bca:	00 
  8004202bcb:	eb 12                	jmp    8004202bdf <page_init+0x13c>
		else if(phy == MPENTRY_PADDR)
  8004202bcd:	48 81 7d d8 00 70 00 	cmpq   $0x7000,-0x28(%rbp)
  8004202bd4:	00 
  8004202bd5:	75 08                	jne    8004202bdf <page_init+0x13c>
		{
		//	cprintf("\nEntered page_init:MPENTRY_PADDR invalidation area\n");
			temp=1;
  8004202bd7:	48 c7 45 f0 01 00 00 	movq   $0x1,-0x10(%rbp)
  8004202bde:	00 
		}
                //else if((phy >= PADDR(BOOT_PAGE_TABLE_START)) && (phy < PADDR(BOOT_PAGE_TABLE_END)))
                //        temp=1;
	        if(temp==0)
  8004202bdf:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004202be4:	75 7c                	jne    8004202c62 <page_init+0x1bf>
                {
                        if(head==NULL)
  8004202be6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202beb:	75 3a                	jne    8004202c27 <page_init+0x184>
                        {
                                head=&pages[i];
  8004202bed:	48 b8 e8 c7 63 04 80 	movabs $0x800463c7e8,%rax
  8004202bf4:	00 00 00 
  8004202bf7:	48 8b 00             	mov    (%rax),%rax
  8004202bfa:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202bfe:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202c02:	48 01 d0             	add    %rdx,%rax
  8004202c05:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                                tail=&pages[i];
  8004202c09:	48 b8 e8 c7 63 04 80 	movabs $0x800463c7e8,%rax
  8004202c10:	00 00 00 
  8004202c13:	48 8b 00             	mov    (%rax),%rax
  8004202c16:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202c1a:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202c1e:	48 01 d0             	add    %rdx,%rax
  8004202c21:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004202c25:	eb 3b                	jmp    8004202c62 <page_init+0x1bf>
                        }
                        else
                        {
                        tail->pp_link=&pages[i];
  8004202c27:	48 b8 e8 c7 63 04 80 	movabs $0x800463c7e8,%rax
  8004202c2e:	00 00 00 
  8004202c31:	48 8b 00             	mov    (%rax),%rax
  8004202c34:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202c38:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202c3c:	48 01 c2             	add    %rax,%rdx
  8004202c3f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202c43:	48 89 10             	mov    %rdx,(%rax)
                        tail=&pages[i];
  8004202c46:	48 b8 e8 c7 63 04 80 	movabs $0x800463c7e8,%rax
  8004202c4d:	00 00 00 
  8004202c50:	48 8b 00             	mov    (%rax),%rax
  8004202c53:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202c57:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202c5b:	48 01 d0             	add    %rdx,%rax
  8004202c5e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	//cprintf("\nPA: %x",PADDR(boot_alloc(0)));
	//cprintf("IOPHYSMEM: %x\nEXTPHYSMEM: %x\nboot_alloc(0) %u",IOPHYSMEM,EXTPHYSMEM,boot_alloc(0));
	//cprintf("PA: %x",PADDR(BOOT_PAGE_TABLE_START));
	//cprintf("PA :%x        VA :%x",EXTPHYSMEM,KADDR(EXTPHYSMEM));
	//cprintf("PA :%x  VA :%x",IOPHYSMEM,KADDR(IOPHYSMEM));
        for(i=0;i<npages;i++,temp=0)
  8004202c62:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004202c67:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004202c6e:	00 
  8004202c6f:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004202c76:	00 00 00 
  8004202c79:	48 8b 00             	mov    (%rax),%rax
  8004202c7c:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004202c80:	0f 82 4a fe ff ff    	jb     8004202ad0 <page_init+0x2d>
                        tail->pp_link=&pages[i];
                        tail=&pages[i];
                        }
               }
        }
        page_free_list=head;
  8004202c86:	48 b8 38 b2 63 04 80 	movabs $0x800463b238,%rax
  8004202c8d:	00 00 00 
  8004202c90:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202c94:	48 89 10             	mov    %rdx,(%rax)

}
  8004202c97:	c9                   	leaveq 
  8004202c98:	c3                   	retq   

0000008004202c99 <page_alloc>:
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
  8004202c99:	55                   	push   %rbp
  8004202c9a:	48 89 e5             	mov    %rsp,%rbp
  8004202c9d:	48 83 ec 20          	sub    $0x20,%rsp
  8004202ca1:	89 7d ec             	mov    %edi,-0x14(%rbp)
	

	// Fill this function in
	struct PageInfo* page=page_free_list;
  8004202ca4:	48 b8 38 b2 63 04 80 	movabs $0x800463b238,%rax
  8004202cab:	00 00 00 
  8004202cae:	48 8b 00             	mov    (%rax),%rax
  8004202cb1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if(page_free_list == NULL)
  8004202cb5:	48 b8 38 b2 63 04 80 	movabs $0x800463b238,%rax
  8004202cbc:	00 00 00 
  8004202cbf:	48 8b 00             	mov    (%rax),%rax
  8004202cc2:	48 85 c0             	test   %rax,%rax
  8004202cc5:	75 0a                	jne    8004202cd1 <page_alloc+0x38>
        {
                return NULL;
  8004202cc7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202ccc:	e9 87 00 00 00       	jmpq   8004202d58 <page_alloc+0xbf>
        }
	if(alloc_flags & ALLOC_ZERO)
  8004202cd1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202cd4:	83 e0 01             	and    $0x1,%eax
  8004202cd7:	84 c0                	test   %al,%al
  8004202cd9:	74 2e                	je     8004202d09 <page_alloc+0x70>
	  	memset(page2kva(page),'\0',PGSIZE);
  8004202cdb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202cdf:	48 89 c7             	mov    %rax,%rdi
  8004202ce2:	48 b8 2e 1a 20 04 80 	movabs $0x8004201a2e,%rax
  8004202ce9:	00 00 00 
  8004202cec:	ff d0                	callq  *%rax
  8004202cee:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202cf3:	be 00 00 00 00       	mov    $0x0,%esi
  8004202cf8:	48 89 c7             	mov    %rax,%rdi
  8004202cfb:	48 b8 53 e6 20 04 80 	movabs $0x800420e653,%rax
  8004202d02:	00 00 00 
  8004202d05:	ff d0                	callq  *%rax
  8004202d07:	eb 2c                	jmp    8004202d35 <page_alloc+0x9c>
	else
		memset(page2kva(page),alloc_flags,PGSIZE);
  8004202d09:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202d0d:	48 89 c7             	mov    %rax,%rdi
  8004202d10:	48 b8 2e 1a 20 04 80 	movabs $0x8004201a2e,%rax
  8004202d17:	00 00 00 
  8004202d1a:	ff d0                	callq  *%rax
  8004202d1c:	8b 4d ec             	mov    -0x14(%rbp),%ecx
  8004202d1f:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202d24:	89 ce                	mov    %ecx,%esi
  8004202d26:	48 89 c7             	mov    %rax,%rdi
  8004202d29:	48 b8 53 e6 20 04 80 	movabs $0x800420e653,%rax
  8004202d30:	00 00 00 
  8004202d33:	ff d0                	callq  *%rax
	page_free_list=page->pp_link;
  8004202d35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202d39:	48 8b 10             	mov    (%rax),%rdx
  8004202d3c:	48 b8 38 b2 63 04 80 	movabs $0x800463b238,%rax
  8004202d43:	00 00 00 
  8004202d46:	48 89 10             	mov    %rdx,(%rax)
	page->pp_link=NULL;
  8004202d49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202d4d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	return page;
  8004202d54:	48 8b 45 f8          	mov    -0x8(%rbp),%rax



}
  8004202d58:	c9                   	leaveq 
  8004202d59:	c3                   	retq   

0000008004202d5a <page_initpp>:
// The result has null links and 0 refcount.
// Note that the corresponding physical page is NOT initialized!
//
	static void
page_initpp(struct PageInfo *pp)
{
  8004202d5a:	55                   	push   %rbp
  8004202d5b:	48 89 e5             	mov    %rsp,%rbp
  8004202d5e:	48 83 ec 10          	sub    $0x10,%rsp
  8004202d62:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	memset(pp, 0, sizeof(*pp));
  8004202d66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202d6a:	ba 10 00 00 00       	mov    $0x10,%edx
  8004202d6f:	be 00 00 00 00       	mov    $0x0,%esi
  8004202d74:	48 89 c7             	mov    %rax,%rdi
  8004202d77:	48 b8 53 e6 20 04 80 	movabs $0x800420e653,%rax
  8004202d7e:	00 00 00 
  8004202d81:	ff d0                	callq  *%rax
}
  8004202d83:	c9                   	leaveq 
  8004202d84:	c3                   	retq   

0000008004202d85 <page_free>:
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
  8004202d85:	55                   	push   %rbp
  8004202d86:	48 89 e5             	mov    %rsp,%rbp
  8004202d89:	48 83 ec 20          	sub    $0x20,%rsp
  8004202d8d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	

	struct PageInfo *page=page_free_list;
  8004202d91:	48 b8 38 b2 63 04 80 	movabs $0x800463b238,%rax
  8004202d98:	00 00 00 
  8004202d9b:	48 8b 00             	mov    (%rax),%rax
  8004202d9e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        assert(pp->pp_ref ==0 && pp->pp_link ==NULL);
  8004202da2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202da6:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202daa:	66 85 c0             	test   %ax,%ax
  8004202dad:	75 0c                	jne    8004202dbb <page_free+0x36>
  8004202daf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202db3:	48 8b 00             	mov    (%rax),%rax
  8004202db6:	48 85 c0             	test   %rax,%rax
  8004202db9:	74 35                	je     8004202df0 <page_free+0x6b>
  8004202dbb:	48 b9 b0 74 21 04 80 	movabs $0x80042174b0,%rcx
  8004202dc2:	00 00 00 
  8004202dc5:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004202dcc:	00 00 00 
  8004202dcf:	be 24 02 00 00       	mov    $0x224,%esi
  8004202dd4:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004202ddb:	00 00 00 
  8004202dde:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202de3:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004202dea:	00 00 00 
  8004202ded:	41 ff d0             	callq  *%r8
	pp->pp_link=page;
  8004202df0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202df4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202df8:	48 89 10             	mov    %rdx,(%rax)
	page_free_list=pp;
  8004202dfb:	48 b8 38 b2 63 04 80 	movabs $0x800463b238,%rax
  8004202e02:	00 00 00 
  8004202e05:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202e09:	48 89 10             	mov    %rdx,(%rax)


}
  8004202e0c:	c9                   	leaveq 
  8004202e0d:	c3                   	retq   

0000008004202e0e <page_decref>:
// Decrement the reference count on a page,
// freeing it if there are no more refs.
//
void
page_decref(struct PageInfo* pp)
{
  8004202e0e:	55                   	push   %rbp
  8004202e0f:	48 89 e5             	mov    %rsp,%rbp
  8004202e12:	48 83 ec 10          	sub    $0x10,%rsp
  8004202e16:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (--pp->pp_ref == 0)
  8004202e1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202e1e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202e22:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004202e25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202e29:	66 89 50 08          	mov    %dx,0x8(%rax)
  8004202e2d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202e31:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202e35:	66 85 c0             	test   %ax,%ax
  8004202e38:	75 13                	jne    8004202e4d <page_decref+0x3f>
		page_free(pp);
  8004202e3a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202e3e:	48 89 c7             	mov    %rax,%rdi
  8004202e41:	48 b8 85 2d 20 04 80 	movabs $0x8004202d85,%rax
  8004202e48:	00 00 00 
  8004202e4b:	ff d0                	callq  *%rax
}
  8004202e4d:	c9                   	leaveq 
  8004202e4e:	c3                   	retq   

0000008004202e4f <pml4e_walk>:
// table, page directory,page directory pointer and pml4 entries.
//

pte_t *
pml4e_walk(pml4e_t *pml4e, const void *va, int create)
{
  8004202e4f:	55                   	push   %rbp
  8004202e50:	48 89 e5             	mov    %rsp,%rbp
  8004202e53:	48 83 ec 70          	sub    $0x70,%rsp
  8004202e57:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004202e5b:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8004202e5f:	89 55 9c             	mov    %edx,-0x64(%rbp)
        physaddr_t pdpeaddr;
        pte_t *result;
        physaddr_t temp;
        uintptr_t la=(uintptr_t) va;
  8004202e62:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202e66:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        struct PageInfo *npdpepage=NULL;
  8004202e6a:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004202e71:	00 
        pdpe_t *pdpe;
        pml4e+=PML4(la);
  8004202e72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202e76:	48 c1 e8 27          	shr    $0x27,%rax
  8004202e7a:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004202e7f:	48 c1 e0 03          	shl    $0x3,%rax
  8004202e83:	48 01 45 a8          	add    %rax,-0x58(%rbp)
        pdpe=NULL;
  8004202e87:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004202e8e:	00 
        if(*pml4e!=0)
  8004202e8f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202e93:	48 8b 00             	mov    (%rax),%rax
  8004202e96:	48 85 c0             	test   %rax,%rax
  8004202e99:	0f 84 a7 00 00 00    	je     8004202f46 <pml4e_walk+0xf7>
        {
        pdpeaddr=PTE_ADDR(*pml4e);
  8004202e9f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202ea3:	48 8b 00             	mov    (%rax),%rax
  8004202ea6:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202eac:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        pdpe=(pdpe_t *)KADDR(pdpeaddr);
  8004202eb0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202eb4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004202eb8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202ebc:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202ec0:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  8004202ec3:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004202ec6:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004202ecd:	00 00 00 
  8004202ed0:	48 8b 00             	mov    (%rax),%rax
  8004202ed3:	48 39 c2             	cmp    %rax,%rdx
  8004202ed6:	72 32                	jb     8004202f0a <pml4e_walk+0xbb>
  8004202ed8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202edc:	48 89 c1             	mov    %rax,%rcx
  8004202edf:	48 ba 60 73 21 04 80 	movabs $0x8004217360,%rdx
  8004202ee6:	00 00 00 
  8004202ee9:	be 5d 02 00 00       	mov    $0x25d,%esi
  8004202eee:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004202ef5:	00 00 00 
  8004202ef8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202efd:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004202f04:	00 00 00 
  8004202f07:	41 ff d0             	callq  *%r8
  8004202f0a:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004202f11:	00 00 00 
  8004202f14:	48 03 45 d8          	add    -0x28(%rbp),%rax
  8004202f18:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        result=pdpe_walk(pdpe,(const void*)la,create);
  8004202f1c:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004202f20:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004202f23:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202f27:	48 89 ce             	mov    %rcx,%rsi
  8004202f2a:	48 89 c7             	mov    %rax,%rdi
  8004202f2d:	48 b8 69 30 20 04 80 	movabs $0x8004203069,%rax
  8004202f34:	00 00 00 
  8004202f37:	ff d0                	callq  *%rax
  8004202f39:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        return result;
  8004202f3d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202f41:	e9 21 01 00 00       	jmpq   8004203067 <pml4e_walk+0x218>
        }
        //pdpe+=PDPE(la);
        if(pdpe==NULL && create==false)
  8004202f46:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202f4b:	75 10                	jne    8004202f5d <pml4e_walk+0x10e>
  8004202f4d:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  8004202f51:	75 0a                	jne    8004202f5d <pml4e_walk+0x10e>
                return NULL;
  8004202f53:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202f58:	e9 0a 01 00 00       	jmpq   8004203067 <pml4e_walk+0x218>
        else
        {
                        npdpepage=page_alloc(0);    // Should it be 0 or 1????
  8004202f5d:	bf 00 00 00 00       	mov    $0x0,%edi
  8004202f62:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  8004202f69:	00 00 00 
  8004202f6c:	ff d0                	callq  *%rax
  8004202f6e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
                        //assert(npdpepage!=NULL);
                        if(npdpepage==NULL)
  8004202f72:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004202f77:	75 0a                	jne    8004202f83 <pml4e_walk+0x134>
                                return NULL;
  8004202f79:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202f7e:	e9 e4 00 00 00       	jmpq   8004203067 <pml4e_walk+0x218>
                        //assert(npdpepage->pp_ref==0);
                        npdpepage->pp_ref++;
  8004202f83:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202f87:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004202f8b:	8d 50 01             	lea    0x1(%rax),%edx
  8004202f8e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202f92:	66 89 50 08          	mov    %dx,0x8(%rax)
                        pdpe=(pdpe_t *)page2kva(npdpepage);
  8004202f96:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202f9a:	48 89 c7             	mov    %rax,%rdi
  8004202f9d:	48 b8 2e 1a 20 04 80 	movabs $0x8004201a2e,%rax
  8004202fa4:	00 00 00 
  8004202fa7:	ff d0                	callq  *%rax
  8004202fa9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                        temp=PADDR(pdpe);
  8004202fad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202fb1:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004202fb5:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202fbc:	00 00 00 
  8004202fbf:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  8004202fc3:	77 32                	ja     8004202ff7 <pml4e_walk+0x1a8>
  8004202fc5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202fc9:	48 89 c1             	mov    %rax,%rcx
  8004202fcc:	48 ba 88 74 21 04 80 	movabs $0x8004217488,%rdx
  8004202fd3:	00 00 00 
  8004202fd6:	be 6d 02 00 00       	mov    $0x26d,%esi
  8004202fdb:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004202fe2:	00 00 00 
  8004202fe5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202fea:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004202ff1:	00 00 00 
  8004202ff4:	41 ff d0             	callq  *%r8
  8004202ff7:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004202ffe:	ff ff ff 
  8004203001:	48 03 45 c0          	add    -0x40(%rbp),%rax
  8004203005:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        *pml4e=(temp | PTE_P | PTE_W |PTE_U);
  8004203009:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420300d:	48 89 c2             	mov    %rax,%rdx
  8004203010:	48 83 ca 07          	or     $0x7,%rdx
  8004203014:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203018:	48 89 10             	mov    %rdx,(%rax)
        }
        result=pdpe_walk(pdpe,(const void *)la,true);
  800420301b:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800420301f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203023:	ba 01 00 00 00       	mov    $0x1,%edx
  8004203028:	48 89 ce             	mov    %rcx,%rsi
  800420302b:	48 89 c7             	mov    %rax,%rdi
  800420302e:	48 b8 69 30 20 04 80 	movabs $0x8004203069,%rax
  8004203035:	00 00 00 
  8004203038:	ff d0                	callq  *%rax
  800420303a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        if(result==NULL)
  800420303e:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004203043:	75 1e                	jne    8004203063 <pml4e_walk+0x214>
        {
                page_decref(npdpepage);
  8004203045:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203049:	48 89 c7             	mov    %rax,%rdi
  800420304c:	48 b8 0e 2e 20 04 80 	movabs $0x8004202e0e,%rax
  8004203053:	00 00 00 
  8004203056:	ff d0                	callq  *%rax
                *pml4e=0;
  8004203058:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420305c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        }
        return result;
  8004203063:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
}
  8004203067:	c9                   	leaveq 
  8004203068:	c3                   	retq   

0000008004203069 <pdpe_walk>:
// The programming logic in this function is similar to pml4e_walk.
// It calls the pgdir_walk which returns the page_table entry pointer.
// Hints are the same as in pml4e_walk
pte_t *
pdpe_walk(pdpe_t *pdpe,const void *va,int create)
{
  8004203069:	55                   	push   %rbp
  800420306a:	48 89 e5             	mov    %rsp,%rbp
  800420306d:	48 83 ec 70          	sub    $0x70,%rsp
  8004203071:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004203075:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8004203079:	89 55 9c             	mov    %edx,-0x64(%rbp)
	physaddr_t pdeaddr,temp;
        pte_t *result;
        uintptr_t la=(uintptr_t) va;
  800420307c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203080:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        struct PageInfo *npdepage=NULL;
  8004203084:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420308b:	00 
        pde_t *pde;
        pdpe+=PDPE(la);
  800420308c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203090:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004203094:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203099:	48 c1 e0 03          	shl    $0x3,%rax
  800420309d:	48 01 45 a8          	add    %rax,-0x58(%rbp)
        pde=NULL;
  80042030a1:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042030a8:	00 
        if(*pdpe!=0)
  80042030a9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042030ad:	48 8b 00             	mov    (%rax),%rax
  80042030b0:	48 85 c0             	test   %rax,%rax
  80042030b3:	0f 84 a7 00 00 00    	je     8004203160 <pdpe_walk+0xf7>
        {
                pdeaddr=PTE_ADDR(*pdpe);
  80042030b9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042030bd:	48 8b 00             	mov    (%rax),%rax
  80042030c0:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042030c6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
                pde=(pde_t*)KADDR(pdeaddr);
  80042030ca:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042030ce:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042030d2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042030d6:	48 c1 e8 0c          	shr    $0xc,%rax
  80042030da:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  80042030dd:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042030e0:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  80042030e7:	00 00 00 
  80042030ea:	48 8b 00             	mov    (%rax),%rax
  80042030ed:	48 39 c2             	cmp    %rax,%rdx
  80042030f0:	72 32                	jb     8004203124 <pdpe_walk+0xbb>
  80042030f2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042030f6:	48 89 c1             	mov    %rax,%rcx
  80042030f9:	48 ba 60 73 21 04 80 	movabs $0x8004217360,%rdx
  8004203100:	00 00 00 
  8004203103:	be 8b 02 00 00       	mov    $0x28b,%esi
  8004203108:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420310f:	00 00 00 
  8004203112:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203117:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420311e:	00 00 00 
  8004203121:	41 ff d0             	callq  *%r8
  8004203124:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  800420312b:	00 00 00 
  800420312e:	48 03 45 d8          	add    -0x28(%rbp),%rax
  8004203132:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                result=pgdir_walk(pde,(const void*)la,create);
  8004203136:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800420313a:	8b 55 9c             	mov    -0x64(%rbp),%edx
  800420313d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203141:	48 89 ce             	mov    %rcx,%rsi
  8004203144:	48 89 c7             	mov    %rax,%rdi
  8004203147:	48 b8 c5 32 20 04 80 	movabs $0x80042032c5,%rax
  800420314e:	00 00 00 
  8004203151:	ff d0                	callq  *%rax
  8004203153:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                return result;
  8004203157:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420315b:	e9 63 01 00 00       	jmpq   80042032c3 <pdpe_walk+0x25a>

        }
//      pde=(uint64_t*)*pdpe;
        //pdpe+=PDPE(la);
        if(pde==NULL && create==false)
  8004203160:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203165:	75 10                	jne    8004203177 <pdpe_walk+0x10e>
  8004203167:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  800420316b:	75 0a                	jne    8004203177 <pdpe_walk+0x10e>
                return NULL;
  800420316d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203172:	e9 4c 01 00 00       	jmpq   80042032c3 <pdpe_walk+0x25a>
        else
        {
                        npdepage=page_alloc(0);
  8004203177:	bf 00 00 00 00       	mov    $0x0,%edi
  800420317c:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  8004203183:	00 00 00 
  8004203186:	ff d0                	callq  *%rax
  8004203188:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
                        //assert(npdepage!=NULL);
                        if(npdepage==NULL)
  800420318c:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004203191:	75 0a                	jne    800420319d <pdpe_walk+0x134>
                                return NULL;
  8004203193:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203198:	e9 26 01 00 00       	jmpq   80042032c3 <pdpe_walk+0x25a>
                        assert(npdepage->pp_ref==0);
  800420319d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042031a1:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042031a5:	66 85 c0             	test   %ax,%ax
  80042031a8:	74 35                	je     80042031df <pdpe_walk+0x176>
  80042031aa:	48 b9 d5 74 21 04 80 	movabs $0x80042174d5,%rcx
  80042031b1:	00 00 00 
  80042031b4:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042031bb:	00 00 00 
  80042031be:	be 9a 02 00 00       	mov    $0x29a,%esi
  80042031c3:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042031ca:	00 00 00 
  80042031cd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042031d2:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042031d9:	00 00 00 
  80042031dc:	41 ff d0             	callq  *%r8
                        npdepage->pp_ref=npdepage->pp_ref+1;
  80042031df:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042031e3:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042031e7:	8d 50 01             	lea    0x1(%rax),%edx
  80042031ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042031ee:	66 89 50 08          	mov    %dx,0x8(%rax)
                        pde=(pde_t *)page2kva(npdepage);
  80042031f2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042031f6:	48 89 c7             	mov    %rax,%rdi
  80042031f9:	48 b8 2e 1a 20 04 80 	movabs $0x8004201a2e,%rax
  8004203200:	00 00 00 
  8004203203:	ff d0                	callq  *%rax
  8004203205:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                        temp=PADDR(pde);
  8004203209:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420320d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004203211:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004203218:	00 00 00 
  800420321b:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  800420321f:	77 32                	ja     8004203253 <pdpe_walk+0x1ea>
  8004203221:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203225:	48 89 c1             	mov    %rax,%rcx
  8004203228:	48 ba 88 74 21 04 80 	movabs $0x8004217488,%rdx
  800420322f:	00 00 00 
  8004203232:	be 9d 02 00 00       	mov    $0x29d,%esi
  8004203237:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420323e:	00 00 00 
  8004203241:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203246:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420324d:	00 00 00 
  8004203250:	41 ff d0             	callq  *%r8
  8004203253:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  800420325a:	ff ff ff 
  800420325d:	48 03 45 c0          	add    -0x40(%rbp),%rax
  8004203261:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        *pdpe=(temp | PTE_P | PTE_W | PTE_U);
  8004203265:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203269:	48 89 c2             	mov    %rax,%rdx
  800420326c:	48 83 ca 07          	or     $0x7,%rdx
  8004203270:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203274:	48 89 10             	mov    %rdx,(%rax)

                        //*pdpe=(uint64_t)pde;
        }
        result=pgdir_walk(pde,(const void*)la,true);
  8004203277:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800420327b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420327f:	ba 01 00 00 00       	mov    $0x1,%edx
  8004203284:	48 89 ce             	mov    %rcx,%rsi
  8004203287:	48 89 c7             	mov    %rax,%rdi
  800420328a:	48 b8 c5 32 20 04 80 	movabs $0x80042032c5,%rax
  8004203291:	00 00 00 
  8004203294:	ff d0                	callq  *%rax
  8004203296:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        if(result==NULL)
  800420329a:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420329f:	75 1e                	jne    80042032bf <pdpe_walk+0x256>
        {
                page_decref(npdepage);
  80042032a1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042032a5:	48 89 c7             	mov    %rax,%rdi
  80042032a8:	48 b8 0e 2e 20 04 80 	movabs $0x8004202e0e,%rax
  80042032af:	00 00 00 
  80042032b2:	ff d0                	callq  *%rax
                //page_free(npdepage);
                *pdpe=0;
  80042032b4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042032b8:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        }
        return result;
  80042032bf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
}
  80042032c3:	c9                   	leaveq 
  80042032c4:	c3                   	retq   

00000080042032c5 <pgdir_walk>:
// a pointer to the page table entry (PTE). 
// The programming logic and the hints are the same as pml4e_walk
// and pdpe_walk.

pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create)
{
  80042032c5:	55                   	push   %rbp
  80042032c6:	48 89 e5             	mov    %rsp,%rbp
  80042032c9:	48 83 ec 70          	sub    $0x70,%rsp
  80042032cd:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  80042032d1:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  80042032d5:	89 55 9c             	mov    %edx,-0x64(%rbp)

	physaddr_t pteaddr,temp,temp1;
        pte_t *resultptr;
        pte_t *result;
        pte_t *pte;
        uintptr_t la=(uintptr_t) va;
  80042032d8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042032dc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        struct PageInfo *nptepage=NULL;
  80042032e0:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042032e7:	00 
        pgdir+=PDX(la);
  80042032e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042032ec:	48 c1 e8 15          	shr    $0x15,%rax
  80042032f0:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042032f5:	48 c1 e0 03          	shl    $0x3,%rax
  80042032f9:	48 01 45 a8          	add    %rax,-0x58(%rbp)
        pte=NULL;
  80042032fd:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203304:	00 
        if(*pgdir!=0)
  8004203305:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203309:	48 8b 00             	mov    (%rax),%rax
  800420330c:	48 85 c0             	test   %rax,%rax
  800420330f:	0f 84 9f 00 00 00    	je     80042033b4 <pgdir_walk+0xef>
        {
                pteaddr=PTE_ADDR(*pgdir);
  8004203315:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203319:	48 8b 00             	mov    (%rax),%rax
  800420331c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203322:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
                pte=(pte_t *)KADDR(pteaddr);
  8004203326:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420332a:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420332e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203332:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203336:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  8004203339:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800420333c:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004203343:	00 00 00 
  8004203346:	48 8b 00             	mov    (%rax),%rax
  8004203349:	48 39 c2             	cmp    %rax,%rdx
  800420334c:	72 32                	jb     8004203380 <pgdir_walk+0xbb>
  800420334e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203352:	48 89 c1             	mov    %rax,%rcx
  8004203355:	48 ba 60 73 21 04 80 	movabs $0x8004217360,%rdx
  800420335c:	00 00 00 
  800420335f:	be be 02 00 00       	mov    $0x2be,%esi
  8004203364:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420336b:	00 00 00 
  800420336e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203373:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420337a:	00 00 00 
  800420337d:	41 ff d0             	callq  *%r8
  8004203380:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004203387:	00 00 00 
  800420338a:	48 03 45 d8          	add    -0x28(%rbp),%rax
  800420338e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                result=pte+PTX(la);
  8004203392:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203396:	48 c1 e8 0c          	shr    $0xc,%rax
  800420339a:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420339f:	48 c1 e0 03          	shl    $0x3,%rax
  80042033a3:	48 03 45 e8          	add    -0x18(%rbp),%rax
  80042033a7:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                return result;
  80042033ab:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042033af:	e9 fc 00 00 00       	jmpq   80042034b0 <pgdir_walk+0x1eb>
        //pte_t *pte=(uint64_t *)*pgdir;
        //pdpe+=PDPE(la);

        }
        if(pte==NULL && create==false)
  80042033b4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042033b9:	75 10                	jne    80042033cb <pgdir_walk+0x106>
  80042033bb:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  80042033bf:	75 0a                	jne    80042033cb <pgdir_walk+0x106>
                return NULL;
  80042033c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042033c6:	e9 e5 00 00 00       	jmpq   80042034b0 <pgdir_walk+0x1eb>
        else
        {
                        nptepage=page_alloc(0);
  80042033cb:	bf 00 00 00 00       	mov    $0x0,%edi
  80042033d0:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  80042033d7:	00 00 00 
  80042033da:	ff d0                	callq  *%rax
  80042033dc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
                       // assert(nptepage!=NULL);
                        if(nptepage==NULL)
  80042033e0:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042033e5:	75 0a                	jne    80042033f1 <pgdir_walk+0x12c>
                                return NULL;
  80042033e7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042033ec:	e9 bf 00 00 00       	jmpq   80042034b0 <pgdir_walk+0x1eb>
                        //assert(nptepage->pp_ref==0);
                        nptepage->pp_ref++;
  80042033f1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042033f5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042033f9:	8d 50 01             	lea    0x1(%rax),%edx
  80042033fc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203400:	66 89 50 08          	mov    %dx,0x8(%rax)
                        pte=(pte_t *)page2kva(nptepage);
  8004203404:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203408:	48 89 c7             	mov    %rax,%rdi
  800420340b:	48 b8 2e 1a 20 04 80 	movabs $0x8004201a2e,%rax
  8004203412:	00 00 00 
  8004203415:	ff d0                	callq  *%rax
  8004203417:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                        temp=PADDR(pte);
  800420341b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420341f:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004203423:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420342a:	00 00 00 
  800420342d:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  8004203431:	77 32                	ja     8004203465 <pgdir_walk+0x1a0>
  8004203433:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203437:	48 89 c1             	mov    %rax,%rcx
  800420343a:	48 ba 88 74 21 04 80 	movabs $0x8004217488,%rdx
  8004203441:	00 00 00 
  8004203444:	be d0 02 00 00       	mov    $0x2d0,%esi
  8004203449:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004203450:	00 00 00 
  8004203453:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203458:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420345f:	00 00 00 
  8004203462:	41 ff d0             	callq  *%r8
  8004203465:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  800420346c:	ff ff ff 
  800420346f:	48 03 45 c0          	add    -0x40(%rbp),%rax
  8004203473:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        temp1=PTE_ADDR(temp);
  8004203477:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420347b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203481:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
                        *pgdir=(temp1 | PTE_P | PTE_W | PTE_U);
  8004203485:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203489:	48 89 c2             	mov    %rax,%rdx
  800420348c:	48 83 ca 07          	or     $0x7,%rdx
  8004203490:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203494:	48 89 10             	mov    %rdx,(%rax)
                        //*pgdir=(uint64_t)pte;
        }
        pte+=PTX(la);
  8004203497:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420349b:	48 c1 e8 0c          	shr    $0xc,%rax
  800420349f:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042034a4:	48 c1 e0 03          	shl    $0x3,%rax
  80042034a8:	48 01 45 e8          	add    %rax,-0x18(%rbp)
        //result=(pte_t *)*pte;
        //assert(pte==NULL);
        return pte;
  80042034ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  80042034b0:	c9                   	leaveq 
  80042034b1:	c3                   	retq   

00000080042034b2 <boot_map_region>:
// above UTOP. As such, it should *not* change the pp_ref field on the
// mapped pages.
//
// Hint: the TA solution uses pml4e_walk
static void boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
  80042034b2:	55                   	push   %rbp
  80042034b3:	48 89 e5             	mov    %rsp,%rbp
  80042034b6:	48 83 ec 50          	sub    $0x50,%rsp
  80042034ba:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042034be:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042034c2:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  80042034c6:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  80042034ca:	44 89 45 bc          	mov    %r8d,-0x44(%rbp)

	uint64_t noe;
	pte_t *temp;
	int i;
	physaddr_t temp1;
        noe=(uint64_t)size/PGSIZE;
  80042034ce:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042034d2:	48 c1 e8 0c          	shr    $0xc,%rax
  80042034d6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        for(i=0;i<noe;i++)
  80042034da:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042034e1:	eb 5b                	jmp    800420353e <boot_map_region+0x8c>
        {
                temp=pml4e_walk(pml4e,(void*)la,1);
  80042034e3:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  80042034e7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042034eb:	ba 01 00 00 00       	mov    $0x1,%edx
  80042034f0:	48 89 ce             	mov    %rcx,%rsi
  80042034f3:	48 89 c7             	mov    %rax,%rdi
  80042034f6:	48 b8 4f 2e 20 04 80 	movabs $0x8004202e4f,%rax
  80042034fd:	00 00 00 
  8004203500:	ff d0                	callq  *%rax
  8004203502:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                temp1=(pa+(i*PGSIZE));
  8004203506:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004203509:	c1 e0 0c             	shl    $0xc,%eax
  800420350c:	48 98                	cltq   
  800420350e:	48 03 45 c0          	add    -0x40(%rbp),%rax
  8004203512:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
                //temp1=temp1<<12;
                temp1=(temp1|perm|PTE_P);
  8004203516:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8004203519:	48 98                	cltq   
  800420351b:	48 0b 45 e0          	or     -0x20(%rbp),%rax
  800420351f:	48 83 c8 01          	or     $0x1,%rax
  8004203523:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
                *temp=temp1;
  8004203527:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420352b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420352f:	48 89 10             	mov    %rdx,(%rax)
                la+=PGSIZE;
  8004203532:	48 81 45 d0 00 10 00 	addq   $0x1000,-0x30(%rbp)
  8004203539:	00 
	uint64_t noe;
	pte_t *temp;
	int i;
	physaddr_t temp1;
        noe=(uint64_t)size/PGSIZE;
        for(i=0;i<noe;i++)
  800420353a:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420353e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004203541:	48 98                	cltq   
  8004203543:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004203547:	72 9a                	jb     80042034e3 <boot_map_region+0x31>

        }



}
  8004203549:	c9                   	leaveq 
  800420354a:	c3                   	retq   

000000800420354b <page_insert>:
// Hint: The TA solution is implemented using pml4e_walk, page_remove,
// and page2pa.
//
int
page_insert(pml4e_t *pml4e, struct PageInfo *pp, void *va, int perm)
{
  800420354b:	55                   	push   %rbp
  800420354c:	48 89 e5             	mov    %rsp,%rbp
  800420354f:	48 83 ec 40          	sub    $0x40,%rsp
  8004203553:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004203557:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420355b:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  800420355f:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
	//struct PageInfo* lookup;
       // pte_t *ptestore;
        pte_t *entry;
        uint64_t pte;
	physaddr_t pg_entry,ppconv;
        entry=pml4e_walk(pml4e,va,1);
  8004203562:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004203566:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420356a:	ba 01 00 00 00       	mov    $0x1,%edx
  800420356f:	48 89 ce             	mov    %rcx,%rsi
  8004203572:	48 89 c7             	mov    %rax,%rdi
  8004203575:	48 b8 4f 2e 20 04 80 	movabs $0x8004202e4f,%rax
  800420357c:	00 00 00 
  800420357f:	ff d0                	callq  *%rax
  8004203581:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if(entry!=NULL)
  8004203585:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420358a:	0f 84 ef 00 00 00    	je     800420367f <page_insert+0x134>
        {
		pg_entry = PTE_ADDR(*entry);
  8004203590:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203594:	48 8b 00             	mov    (%rax),%rax
  8004203597:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420359d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
                ppconv = page2pa(pp);
  80042035a1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042035a5:	48 89 c7             	mov    %rax,%rdi
  80042035a8:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  80042035af:	00 00 00 
  80042035b2:	ff d0                	callq  *%rax
  80042035b4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                if (pg_entry == ppconv)
  80042035b8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042035bc:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042035c0:	75 3b                	jne    80042035fd <page_insert+0xb2>
                {
                	*entry = pg_entry|perm|PTE_P;
  80042035c2:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042035c5:	48 98                	cltq   
  80042035c7:	48 0b 45 f0          	or     -0x10(%rbp),%rax
  80042035cb:	48 89 c2             	mov    %rax,%rdx
  80042035ce:	48 83 ca 01          	or     $0x1,%rdx
  80042035d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042035d6:	48 89 10             	mov    %rdx,(%rax)
                        tlb_invalidate(pml4e, va);
  80042035d9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042035dd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042035e1:	48 89 d6             	mov    %rdx,%rsi
  80042035e4:	48 89 c7             	mov    %rax,%rdi
  80042035e7:	48 b8 79 37 20 04 80 	movabs $0x8004203779,%rax
  80042035ee:	00 00 00 
  80042035f1:	ff d0                	callq  *%rax
                        return 0;
  80042035f3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042035f8:	e9 87 00 00 00       	jmpq   8004203684 <page_insert+0x139>
                }
                if(*entry!=0)
  80042035fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203601:	48 8b 00             	mov    (%rax),%rax
  8004203604:	48 85 c0             	test   %rax,%rax
  8004203607:	74 34                	je     800420363d <page_insert+0xf2>
		{
            		page_remove(pml4e, va);
  8004203609:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420360d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203611:	48 89 d6             	mov    %rdx,%rsi
  8004203614:	48 89 c7             	mov    %rax,%rdi
  8004203617:	48 b8 03 37 20 04 80 	movabs $0x8004203703,%rax
  800420361e:	00 00 00 
  8004203621:	ff d0                	callq  *%rax
            		tlb_invalidate(pml4e, va);
  8004203623:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004203627:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420362b:	48 89 d6             	mov    %rdx,%rsi
  800420362e:	48 89 c7             	mov    %rax,%rdi
  8004203631:	48 b8 79 37 20 04 80 	movabs $0x8004203779,%rax
  8004203638:	00 00 00 
  800420363b:	ff d0                	callq  *%rax
                }
		*entry = ppconv;
  800420363d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203641:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203645:	48 89 10             	mov    %rdx,(%rax)
        	*entry= (*entry) | perm | PTE_P;
  8004203648:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420364c:	48 8b 10             	mov    (%rax),%rdx
  800420364f:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004203652:	48 98                	cltq   
  8004203654:	48 09 d0             	or     %rdx,%rax
  8004203657:	48 89 c2             	mov    %rax,%rdx
  800420365a:	48 83 ca 01          	or     $0x1,%rdx
  800420365e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203662:	48 89 10             	mov    %rdx,(%rax)
        	pp->pp_ref = pp->pp_ref + 1;
  8004203665:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203669:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420366d:	8d 50 01             	lea    0x1(%rax),%edx
  8004203670:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203674:	66 89 50 08          	mov    %dx,0x8(%rax)
    		return 0;
  8004203678:	b8 00 00 00 00       	mov    $0x0,%eax
  800420367d:	eb 05                	jmp    8004203684 <page_insert+0x139>
   	}	 
    	return -E_NO_MEM;
  800420367f:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
}
  8004203684:	c9                   	leaveq 
  8004203685:	c3                   	retq   

0000008004203686 <page_lookup>:
//
// Hint: the TA solution uses pml4e_walk and pa2page.
//
struct PageInfo *
page_lookup(pml4e_t *pml4e, void *va, pte_t **pte_store)
{
  8004203686:	55                   	push   %rbp
  8004203687:	48 89 e5             	mov    %rsp,%rbp
  800420368a:	48 83 ec 30          	sub    $0x30,%rsp
  800420368e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203692:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004203696:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// Fill this function in
	struct PageInfo *page;
        pte_t *temp;
        temp=pml4e_walk(pml4e,va,0);
  800420369a:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420369e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042036a2:	ba 00 00 00 00       	mov    $0x0,%edx
  80042036a7:	48 89 ce             	mov    %rcx,%rsi
  80042036aa:	48 89 c7             	mov    %rax,%rdi
  80042036ad:	48 b8 4f 2e 20 04 80 	movabs $0x8004202e4f,%rax
  80042036b4:	00 00 00 
  80042036b7:	ff d0                	callq  *%rax
  80042036b9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if(temp==NULL)
  80042036bd:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042036c2:	75 07                	jne    80042036cb <page_lookup+0x45>
                return NULL;
  80042036c4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042036c9:	eb 36                	jmp    8004203701 <page_lookup+0x7b>

        physaddr_t temp1 = *temp & ~0xFFF;
  80042036cb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042036cf:	48 8b 00             	mov    (%rax),%rax
  80042036d2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042036d8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        //addr= addr&(0xffffffffff000);

        if(pte_store!=NULL)
  80042036dc:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042036e1:	74 0b                	je     80042036ee <page_lookup+0x68>
        {
                *pte_store=temp;
  80042036e3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042036e7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042036eb:	48 89 10             	mov    %rdx,(%rax)

        }
        //*pte_store=temp;
        // Fill this function in
        return pa2page(temp1);
  80042036ee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042036f2:	48 89 c7             	mov    %rax,%rdi
  80042036f5:	48 b8 bd 19 20 04 80 	movabs $0x80042019bd,%rax
  80042036fc:	00 00 00 
  80042036ff:	ff d0                	callq  *%rax

}
  8004203701:	c9                   	leaveq 
  8004203702:	c3                   	retq   

0000008004203703 <page_remove>:
// Hint: The TA solution is implemented using page_lookup,
// 	tlb_invalidate, and page_decref.
//
void
page_remove(pml4e_t *pml4e, void *va)
{
  8004203703:	55                   	push   %rbp
  8004203704:	48 89 e5             	mov    %rsp,%rbp
  8004203707:	48 83 ec 20          	sub    $0x20,%rsp
  800420370b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420370f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Fill this function in
	struct PageInfo *page;
        pte_t *ptestore,*lookup;
        page=page_lookup(pml4e,va,&ptestore);
  8004203713:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8004203717:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420371b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420371f:	48 89 ce             	mov    %rcx,%rsi
  8004203722:	48 89 c7             	mov    %rax,%rdi
  8004203725:	48 b8 86 36 20 04 80 	movabs $0x8004203686,%rax
  800420372c:	00 00 00 
  800420372f:	ff d0                	callq  *%rax
  8004203731:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        if(page==NULL)
  8004203735:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420373a:	74 3a                	je     8004203776 <page_remove+0x73>
                return;
        *ptestore=0;
  800420373c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203740:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        page_decref(page);
  8004203747:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420374b:	48 89 c7             	mov    %rax,%rdi
  800420374e:	48 b8 0e 2e 20 04 80 	movabs $0x8004202e0e,%rax
  8004203755:	00 00 00 
  8004203758:	ff d0                	callq  *%rax
        //lookup=pml4e_walk(pml4e,va,0);
        //*lookup=0;
        tlb_invalidate(pml4e,va);
  800420375a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420375e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203762:	48 89 d6             	mov    %rdx,%rsi
  8004203765:	48 89 c7             	mov    %rax,%rdi
  8004203768:	48 b8 79 37 20 04 80 	movabs $0x8004203779,%rax
  800420376f:	00 00 00 
  8004203772:	ff d0                	callq  *%rax
  8004203774:	eb 01                	jmp    8004203777 <page_remove+0x74>
	// Fill this function in
	struct PageInfo *page;
        pte_t *ptestore,*lookup;
        page=page_lookup(pml4e,va,&ptestore);
        if(page==NULL)
                return;
  8004203776:	90                   	nop
        *ptestore=0;
        page_decref(page);
        //lookup=pml4e_walk(pml4e,va,0);
        //*lookup=0;
        tlb_invalidate(pml4e,va);
}
  8004203777:	c9                   	leaveq 
  8004203778:	c3                   	retq   

0000008004203779 <tlb_invalidate>:
// Invalidate a TLB entry, but only if the page tables being
// edited are the ones currently in use by the processor.
//
	void
tlb_invalidate(pml4e_t *pml4e, void *va)
{
  8004203779:	55                   	push   %rbp
  800420377a:	48 89 e5             	mov    %rsp,%rbp
  800420377d:	48 83 ec 20          	sub    $0x20,%rsp
  8004203781:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203785:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Flush the entry only if we're modifying the current address space.
	assert(pml4e!=NULL);
  8004203789:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420378e:	75 35                	jne    80042037c5 <tlb_invalidate+0x4c>
  8004203790:	48 b9 e9 74 21 04 80 	movabs $0x80042174e9,%rcx
  8004203797:	00 00 00 
  800420379a:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042037a1:	00 00 00 
  80042037a4:	be 81 03 00 00       	mov    $0x381,%esi
  80042037a9:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042037b0:	00 00 00 
  80042037b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042037b8:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042037bf:	00 00 00 
  80042037c2:	41 ff d0             	callq  *%r8
	if (!curenv || curenv->env_pml4e == pml4e)
  80042037c5:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  80042037cc:	00 00 00 
  80042037cf:	ff d0                	callq  *%rax
  80042037d1:	48 98                	cltq   
  80042037d3:	48 c1 e0 03          	shl    $0x3,%rax
  80042037d7:	48 89 c2             	mov    %rax,%rdx
  80042037da:	48 c1 e2 04          	shl    $0x4,%rdx
  80042037de:	48 29 c2             	sub    %rax,%rdx
  80042037e1:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  80042037e8:	00 00 00 
  80042037eb:	48 01 d0             	add    %rdx,%rax
  80042037ee:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042037f2:	48 85 c0             	test   %rax,%rax
  80042037f5:	74 3a                	je     8004203831 <tlb_invalidate+0xb8>
  80042037f7:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  80042037fe:	00 00 00 
  8004203801:	ff d0                	callq  *%rax
  8004203803:	48 98                	cltq   
  8004203805:	48 c1 e0 03          	shl    $0x3,%rax
  8004203809:	48 89 c2             	mov    %rax,%rdx
  800420380c:	48 c1 e2 04          	shl    $0x4,%rdx
  8004203810:	48 29 c2             	sub    %rax,%rdx
  8004203813:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420381a:	00 00 00 
  800420381d:	48 01 d0             	add    %rdx,%rax
  8004203820:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004203824:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420382b:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800420382f:	75 0f                	jne    8004203840 <tlb_invalidate+0xc7>
  8004203831:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203835:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

static __inline void 
invlpg(void *addr)
{ 
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
  8004203839:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420383d:	0f 01 38             	invlpg (%rax)
		invlpg(va);
}
  8004203840:	c9                   	leaveq 
  8004203841:	c3                   	retq   

0000008004203842 <mmio_map_region>:
// location.  Return the base of the reserved region.  size does *not*
// have to be multiple of PGSIZE.
//
	void *
mmio_map_region(physaddr_t pa, size_t size)
{
  8004203842:	55                   	push   %rbp
  8004203843:	48 89 e5             	mov    %rsp,%rbp
  8004203846:	48 83 ec 40          	sub    $0x40,%rsp
  800420384a:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420384e:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
	//
	// Hint: The staff solution uses boot_map_region.
	//
	// Your code here:
	uintptr_t alloc_base,check_addr;
	int new_size=ROUNDUP(size,PGSIZE);
  8004203852:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  8004203859:	00 
  800420385a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420385e:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004203862:	48 01 d0             	add    %rdx,%rax
  8004203865:	48 83 e8 01          	sub    $0x1,%rax
  8004203869:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420386d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203871:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203876:	48 f7 75 f8          	divq   -0x8(%rbp)
  800420387a:	48 89 d0             	mov    %rdx,%rax
  800420387d:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004203881:	48 89 d1             	mov    %rdx,%rcx
  8004203884:	48 29 c1             	sub    %rax,%rcx
  8004203887:	48 89 c8             	mov    %rcx,%rax
  800420388a:	89 45 ec             	mov    %eax,-0x14(%rbp)
	check_addr=new_size+base;
  800420388d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004203890:	48 63 d0             	movslq %eax,%rdx
  8004203893:	48 b8 c8 a5 22 04 80 	movabs $0x800422a5c8,%rax
  800420389a:	00 00 00 
  800420389d:	48 8b 00             	mov    (%rax),%rax
  80042038a0:	48 01 d0             	add    %rdx,%rax
  80042038a3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if(check_addr > MMIOLIM)
  80042038a7:	48 b8 00 00 e0 03 80 	movabs $0x8003e00000,%rax
  80042038ae:	00 00 00 
  80042038b1:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  80042038b5:	76 2a                	jbe    80042038e1 <mmio_map_region+0x9f>
		panic("mmio_map_region:MMIOLIM reached!");
  80042038b7:	48 ba f8 74 21 04 80 	movabs $0x80042174f8,%rdx
  80042038be:	00 00 00 
  80042038c1:	be aa 03 00 00       	mov    $0x3aa,%esi
  80042038c6:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042038cd:	00 00 00 
  80042038d0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042038d5:	48 b9 f2 04 20 04 80 	movabs $0x80042004f2,%rcx
  80042038dc:	00 00 00 
  80042038df:	ff d1                	callq  *%rcx
	boot_map_region(boot_pml4e, base, new_size, pa, PTE_W | PTE_PCD | PTE_PWT | PTE_P);
  80042038e1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042038e4:	48 63 d0             	movslq %eax,%rdx
  80042038e7:	48 b8 c8 a5 22 04 80 	movabs $0x800422a5c8,%rax
  80042038ee:	00 00 00 
  80042038f1:	48 8b 30             	mov    (%rax),%rsi
  80042038f4:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  80042038fb:	00 00 00 
  80042038fe:	48 8b 00             	mov    (%rax),%rax
  8004203901:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004203905:	41 b8 1b 00 00 00    	mov    $0x1b,%r8d
  800420390b:	48 89 c7             	mov    %rax,%rdi
  800420390e:	48 b8 b2 34 20 04 80 	movabs $0x80042034b2,%rax
  8004203915:	00 00 00 
  8004203918:	ff d0                	callq  *%rax
	alloc_base=base;
  800420391a:	48 b8 c8 a5 22 04 80 	movabs $0x800422a5c8,%rax
  8004203921:	00 00 00 
  8004203924:	48 8b 00             	mov    (%rax),%rax
  8004203927:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	base+=new_size;
  800420392b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420392e:	48 63 d0             	movslq %eax,%rdx
  8004203931:	48 b8 c8 a5 22 04 80 	movabs $0x800422a5c8,%rax
  8004203938:	00 00 00 
  800420393b:	48 8b 00             	mov    (%rax),%rax
  800420393e:	48 01 c2             	add    %rax,%rdx
  8004203941:	48 b8 c8 a5 22 04 80 	movabs $0x800422a5c8,%rax
  8004203948:	00 00 00 
  800420394b:	48 89 10             	mov    %rdx,(%rax)
	return (void *)alloc_base;
  800420394e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
	//panic("mmio_map_region not implemented");
}
  8004203952:	c9                   	leaveq 
  8004203953:	c3                   	retq   

0000008004203954 <user_mem_check>:
//
// Returns 0 if the user program can access this range of addresses,
// and -E_FAULT otherwise.
//
int user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
  8004203954:	55                   	push   %rbp
  8004203955:	48 89 e5             	mov    %rsp,%rbp
  8004203958:	48 83 ec 70          	sub    $0x70,%rsp
  800420395c:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004203960:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  8004203964:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  8004203968:	89 4d 94             	mov    %ecx,-0x6c(%rbp)
	// LAB 3: Your code here.
	user_mem_check_addr = (uintptr_t) va; 
  800420396b:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420396f:	48 b8 40 b2 63 04 80 	movabs $0x800463b240,%rax
  8004203976:	00 00 00 
  8004203979:	48 89 10             	mov    %rdx,(%rax)
	uintptr_t start_addr=(uintptr_t)va;
  800420397c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203980:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uintptr_t end_addr=start_addr+len;
  8004203984:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004203988:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420398c:	48 01 d0             	add    %rdx,%rax
  800420398f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	uintptr_t addr;	
	for(addr=start_addr;addr<end_addr;addr++)
  8004203993:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203997:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420399b:	eb 43                	jmp    80042039e0 <user_mem_check+0x8c>
	{
		if(addr>=ULIM)
  800420399d:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  80042039a4:	00 00 00 
  80042039a7:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042039ab:	76 2e                	jbe    80042039db <user_mem_check+0x87>
		{
			if(user_mem_check_addr < addr) {
  80042039ad:	48 b8 40 b2 63 04 80 	movabs $0x800463b240,%rax
  80042039b4:	00 00 00 
  80042039b7:	48 8b 00             	mov    (%rax),%rax
  80042039ba:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042039be:	73 11                	jae    80042039d1 <user_mem_check+0x7d>
				user_mem_check_addr =  addr;
  80042039c0:	48 b8 40 b2 63 04 80 	movabs $0x800463b240,%rax
  80042039c7:	00 00 00 
  80042039ca:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042039ce:	48 89 10             	mov    %rdx,(%rax)
			}
			return -E_FAULT;
  80042039d1:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  80042039d6:	e9 2b 01 00 00       	jmpq   8004203b06 <user_mem_check+0x1b2>
	// LAB 3: Your code here.
	user_mem_check_addr = (uintptr_t) va; 
	uintptr_t start_addr=(uintptr_t)va;
	uintptr_t end_addr=start_addr+len;
	uintptr_t addr;	
	for(addr=start_addr;addr<end_addr;addr++)
  80042039db:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  80042039e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042039e4:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042039e8:	72 b3                	jb     800420399d <user_mem_check+0x49>
				user_mem_check_addr =  addr;
			}
			return -E_FAULT;
		}	
	}
	uintptr_t start_page=ROUNDDOWN(start_addr, PGSIZE);
  80042039ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042039ee:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042039f2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042039f6:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042039fc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	uintptr_t end_page=ROUNDUP(end_addr, PGSIZE);
  8004203a00:	48 c7 45 d0 00 10 00 	movq   $0x1000,-0x30(%rbp)
  8004203a07:	00 
  8004203a08:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203a0c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004203a10:	48 01 d0             	add    %rdx,%rax
  8004203a13:	48 83 e8 01          	sub    $0x1,%rax
  8004203a17:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004203a1b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203a1f:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203a24:	48 f7 75 d0          	divq   -0x30(%rbp)
  8004203a28:	48 89 d0             	mov    %rdx,%rax
  8004203a2b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004203a2f:	48 89 d1             	mov    %rdx,%rcx
  8004203a32:	48 29 c1             	sub    %rax,%rcx
  8004203a35:	48 89 c8             	mov    %rcx,%rax
  8004203a38:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	pte_t *pte;
	pte_t entry;
	while(start_page < end_page)
  8004203a3c:	e9 b2 00 00 00       	jmpq   8004203af3 <user_mem_check+0x19f>
	{
		pte = pml4e_walk(env->env_pml4e,(const void *)start_page, 0);
  8004203a41:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8004203a45:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203a49:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004203a50:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203a55:	48 89 ce             	mov    %rcx,%rsi
  8004203a58:	48 89 c7             	mov    %rax,%rdi
  8004203a5b:	48 b8 4f 2e 20 04 80 	movabs $0x8004202e4f,%rax
  8004203a62:	00 00 00 
  8004203a65:	ff d0                	callq  *%rax
  8004203a67:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		if(!pte){
  8004203a6b:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004203a70:	75 2b                	jne    8004203a9d <user_mem_check+0x149>
			if(user_mem_check_addr < start_page) {
  8004203a72:	48 b8 40 b2 63 04 80 	movabs $0x800463b240,%rax
  8004203a79:	00 00 00 
  8004203a7c:	48 8b 00             	mov    (%rax),%rax
  8004203a7f:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004203a83:	73 11                	jae    8004203a96 <user_mem_check+0x142>
				user_mem_check_addr =  start_page;
  8004203a85:	48 b8 40 b2 63 04 80 	movabs $0x800463b240,%rax
  8004203a8c:	00 00 00 
  8004203a8f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004203a93:	48 89 10             	mov    %rdx,(%rax)
			}
			return -E_FAULT;
  8004203a96:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  8004203a9b:	eb 69                	jmp    8004203b06 <user_mem_check+0x1b2>
		}
 		entry = *pte;
  8004203a9d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203aa1:	48 8b 00             	mov    (%rax),%rax
  8004203aa4:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		perm = perm | PTE_P | PTE_U;
  8004203aa8:	83 4d 94 05          	orl    $0x5,-0x6c(%rbp)
		entry = entry & perm;
  8004203aac:	8b 45 94             	mov    -0x6c(%rbp),%eax
  8004203aaf:	48 98                	cltq   
  8004203ab1:	48 21 45 b0          	and    %rax,-0x50(%rbp)
		if(entry != perm)
  8004203ab5:	8b 45 94             	mov    -0x6c(%rbp),%eax
  8004203ab8:	48 98                	cltq   
  8004203aba:	48 3b 45 b0          	cmp    -0x50(%rbp),%rax
  8004203abe:	74 2b                	je     8004203aeb <user_mem_check+0x197>
		{
			if(user_mem_check_addr < start_page) {
  8004203ac0:	48 b8 40 b2 63 04 80 	movabs $0x800463b240,%rax
  8004203ac7:	00 00 00 
  8004203aca:	48 8b 00             	mov    (%rax),%rax
  8004203acd:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004203ad1:	73 11                	jae    8004203ae4 <user_mem_check+0x190>
				user_mem_check_addr =  start_page;
  8004203ad3:	48 b8 40 b2 63 04 80 	movabs $0x800463b240,%rax
  8004203ada:	00 00 00 
  8004203add:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004203ae1:	48 89 10             	mov    %rdx,(%rax)
			}
			return -E_FAULT;   	
  8004203ae4:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  8004203ae9:	eb 1b                	jmp    8004203b06 <user_mem_check+0x1b2>
		}
		start_page+=PGSIZE;
  8004203aeb:	48 81 45 f0 00 10 00 	addq   $0x1000,-0x10(%rbp)
  8004203af2:	00 
	}
	uintptr_t start_page=ROUNDDOWN(start_addr, PGSIZE);
	uintptr_t end_page=ROUNDUP(end_addr, PGSIZE);
	pte_t *pte;
	pte_t entry;
	while(start_page < end_page)
  8004203af3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203af7:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004203afb:	0f 82 40 ff ff ff    	jb     8004203a41 <user_mem_check+0xed>
			}
			return -E_FAULT;   	
		}
		start_page+=PGSIZE;
	}
	return 0;
  8004203b01:	b8 00 00 00 00       	mov    $0x0,%eax

}
  8004203b06:	c9                   	leaveq 
  8004203b07:	c3                   	retq   

0000008004203b08 <user_mem_assert>:
// If it cannot, 'env' is destroyed and, if env is the current
// environment, this function will not return.
//
	void
user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
{
  8004203b08:	55                   	push   %rbp
  8004203b09:	48 89 e5             	mov    %rsp,%rbp
  8004203b0c:	48 83 ec 20          	sub    $0x20,%rsp
  8004203b10:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004203b14:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004203b18:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004203b1c:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
  8004203b1f:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203b22:	89 c1                	mov    %eax,%ecx
  8004203b24:	83 c9 04             	or     $0x4,%ecx
  8004203b27:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203b2b:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004203b2f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203b33:	48 89 c7             	mov    %rax,%rdi
  8004203b36:	48 b8 54 39 20 04 80 	movabs $0x8004203954,%rax
  8004203b3d:	00 00 00 
  8004203b40:	ff d0                	callq  *%rax
  8004203b42:	85 c0                	test   %eax,%eax
  8004203b44:	79 47                	jns    8004203b8d <user_mem_assert+0x85>
		cprintf("[%08x] user_mem_check assertion failure for "
  8004203b46:	48 b8 40 b2 63 04 80 	movabs $0x800463b240,%rax
  8004203b4d:	00 00 00 
  8004203b50:	48 8b 10             	mov    (%rax),%rdx
			"va %08x\n", env->env_id, user_mem_check_addr);
  8004203b53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
//
	void
user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
{
	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
		cprintf("[%08x] user_mem_check assertion failure for "
  8004203b57:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004203b5d:	89 c6                	mov    %eax,%esi
  8004203b5f:	48 bf 20 75 21 04 80 	movabs $0x8004217520,%rdi
  8004203b66:	00 00 00 
  8004203b69:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203b6e:	48 b9 f2 89 20 04 80 	movabs $0x80042089f2,%rcx
  8004203b75:	00 00 00 
  8004203b78:	ff d1                	callq  *%rcx
			"va %08x\n", env->env_id, user_mem_check_addr);
		env_destroy(env);	// may not return
  8004203b7a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203b7e:	48 89 c7             	mov    %rax,%rdi
  8004203b81:	48 b8 f4 82 20 04 80 	movabs $0x80042082f4,%rax
  8004203b88:	00 00 00 
  8004203b8b:	ff d0                	callq  *%rax
	}
}
  8004203b8d:	c9                   	leaveq 
  8004203b8e:	c3                   	retq   

0000008004203b8f <check_page_free_list>:
// Check that the pages on the page_free_list are reasonable.
//

static void
check_page_free_list(bool only_low_memory)
{
  8004203b8f:	55                   	push   %rbp
  8004203b90:	48 89 e5             	mov    %rsp,%rbp
  8004203b93:	48 83 ec 60          	sub    $0x60,%rsp
  8004203b97:	89 f8                	mov    %edi,%eax
  8004203b99:	88 45 ac             	mov    %al,-0x54(%rbp)
	struct PageInfo *pp;
	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
  8004203b9c:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004203ba0:	74 07                	je     8004203ba9 <check_page_free_list+0x1a>
  8004203ba2:	b8 01 00 00 00       	mov    $0x1,%eax
  8004203ba7:	eb 05                	jmp    8004203bae <check_page_free_list+0x1f>
  8004203ba9:	b8 00 02 00 00       	mov    $0x200,%eax
  8004203bae:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	uint64_t nfree_basemem = 0, nfree_extmem = 0;
  8004203bb1:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004203bb8:	00 
  8004203bb9:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203bc0:	00 
	char *first_free_page;

	if (!page_free_list)
  8004203bc1:	48 b8 38 b2 63 04 80 	movabs $0x800463b238,%rax
  8004203bc8:	00 00 00 
  8004203bcb:	48 8b 00             	mov    (%rax),%rax
  8004203bce:	48 85 c0             	test   %rax,%rax
  8004203bd1:	75 2a                	jne    8004203bfd <check_page_free_list+0x6e>
		panic("'page_free_list' is a null pointer!");
  8004203bd3:	48 ba 58 75 21 04 80 	movabs $0x8004217558,%rdx
  8004203bda:	00 00 00 
  8004203bdd:	be 17 04 00 00       	mov    $0x417,%esi
  8004203be2:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004203be9:	00 00 00 
  8004203bec:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203bf1:	48 b9 f2 04 20 04 80 	movabs $0x80042004f2,%rcx
  8004203bf8:	00 00 00 
  8004203bfb:	ff d1                	callq  *%rcx

	if (only_low_memory) {
  8004203bfd:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004203c01:	0f 84 aa 00 00 00    	je     8004203cb1 <check_page_free_list+0x122>
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
  8004203c07:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8004203c0b:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004203c0f:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
  8004203c13:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203c17:	48 b8 38 b2 63 04 80 	movabs $0x800463b238,%rax
  8004203c1e:	00 00 00 
  8004203c21:	48 8b 00             	mov    (%rax),%rax
  8004203c24:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203c28:	eb 59                	jmp    8004203c83 <check_page_free_list+0xf4>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
  8004203c2a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203c2e:	48 89 c7             	mov    %rax,%rdi
  8004203c31:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  8004203c38:	00 00 00 
  8004203c3b:	ff d0                	callq  *%rax
  8004203c3d:	48 c1 e8 15          	shr    $0x15,%rax
  8004203c41:	48 89 c2             	mov    %rax,%rdx
  8004203c44:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203c4a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203c4d:	48 39 c2             	cmp    %rax,%rdx
  8004203c50:	0f 93 c0             	setae  %al
  8004203c53:	0f b6 c0             	movzbl %al,%eax
  8004203c56:	89 45 e0             	mov    %eax,-0x20(%rbp)
			*tp[pagetype] = pp;
  8004203c59:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004203c5c:	48 98                	cltq   
  8004203c5e:	48 8b 44 c5 b0       	mov    -0x50(%rbp,%rax,8),%rax
  8004203c63:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203c67:	48 89 10             	mov    %rdx,(%rax)
			tp[pagetype] = &pp->pp_link;
  8004203c6a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203c6e:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004203c71:	48 98                	cltq   
  8004203c73:	48 89 54 c5 b0       	mov    %rdx,-0x50(%rbp,%rax,8)
	if (only_low_memory) {
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203c78:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203c7c:	48 8b 00             	mov    (%rax),%rax
  8004203c7f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203c83:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203c88:	75 a0                	jne    8004203c2a <check_page_free_list+0x9b>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
			*tp[pagetype] = pp;
			tp[pagetype] = &pp->pp_link;
		}
		*tp[1] = 0;
  8004203c8a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203c8e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		*tp[0] = pp2;
  8004203c95:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203c99:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004203c9d:	48 89 10             	mov    %rdx,(%rax)
		page_free_list = pp1;
  8004203ca0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203ca4:	48 b8 38 b2 63 04 80 	movabs $0x800463b238,%rax
  8004203cab:	00 00 00 
  8004203cae:	48 89 10             	mov    %rdx,(%rax)
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004203cb1:	48 b8 38 b2 63 04 80 	movabs $0x800463b238,%rax
  8004203cb8:	00 00 00 
  8004203cbb:	48 8b 00             	mov    (%rax),%rax
  8004203cbe:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203cc2:	eb 5f                	jmp    8004203d23 <check_page_free_list+0x194>
		if (PDX(page2pa(pp)) < pdx_limit)
  8004203cc4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203cc8:	48 89 c7             	mov    %rax,%rdi
  8004203ccb:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  8004203cd2:	00 00 00 
  8004203cd5:	ff d0                	callq  *%rax
  8004203cd7:	48 c1 e8 15          	shr    $0x15,%rax
  8004203cdb:	48 89 c2             	mov    %rax,%rdx
  8004203cde:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004203ce4:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203ce7:	48 39 c2             	cmp    %rax,%rdx
  8004203cea:	73 2c                	jae    8004203d18 <check_page_free_list+0x189>
			memset(page2kva(pp), 0x97, 128);
  8004203cec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203cf0:	48 89 c7             	mov    %rax,%rdi
  8004203cf3:	48 b8 2e 1a 20 04 80 	movabs $0x8004201a2e,%rax
  8004203cfa:	00 00 00 
  8004203cfd:	ff d0                	callq  *%rax
  8004203cff:	ba 80 00 00 00       	mov    $0x80,%edx
  8004203d04:	be 97 00 00 00       	mov    $0x97,%esi
  8004203d09:	48 89 c7             	mov    %rax,%rdi
  8004203d0c:	48 b8 53 e6 20 04 80 	movabs $0x800420e653,%rax
  8004203d13:	00 00 00 
  8004203d16:	ff d0                	callq  *%rax
		page_free_list = pp1;
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004203d18:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d1c:	48 8b 00             	mov    (%rax),%rax
  8004203d1f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203d23:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203d28:	75 9a                	jne    8004203cc4 <check_page_free_list+0x135>
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
  8004203d2a:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203d2f:	48 b8 4a 23 20 04 80 	movabs $0x800420234a,%rax
  8004203d36:	00 00 00 
  8004203d39:	ff d0                	callq  *%rax
  8004203d3b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203d3f:	48 b8 38 b2 63 04 80 	movabs $0x800463b238,%rax
  8004203d46:	00 00 00 
  8004203d49:	48 8b 00             	mov    (%rax),%rax
  8004203d4c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203d50:	e9 23 03 00 00       	jmpq   8004204078 <check_page_free_list+0x4e9>
		// check that we didn't corrupt the free list itself
		assert(pp >= pages);
  8004203d55:	48 b8 e8 c7 63 04 80 	movabs $0x800463c7e8,%rax
  8004203d5c:	00 00 00 
  8004203d5f:	48 8b 00             	mov    (%rax),%rax
  8004203d62:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004203d66:	73 35                	jae    8004203d9d <check_page_free_list+0x20e>
  8004203d68:	48 b9 7c 75 21 04 80 	movabs $0x800421757c,%rcx
  8004203d6f:	00 00 00 
  8004203d72:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004203d79:	00 00 00 
  8004203d7c:	be 31 04 00 00       	mov    $0x431,%esi
  8004203d81:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004203d88:	00 00 00 
  8004203d8b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203d90:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004203d97:	00 00 00 
  8004203d9a:	41 ff d0             	callq  *%r8
		assert(pp < pages + npages);
  8004203d9d:	48 b8 e8 c7 63 04 80 	movabs $0x800463c7e8,%rax
  8004203da4:	00 00 00 
  8004203da7:	48 8b 10             	mov    (%rax),%rdx
  8004203daa:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004203db1:	00 00 00 
  8004203db4:	48 8b 00             	mov    (%rax),%rax
  8004203db7:	48 c1 e0 04          	shl    $0x4,%rax
  8004203dbb:	48 01 d0             	add    %rdx,%rax
  8004203dbe:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004203dc2:	77 35                	ja     8004203df9 <check_page_free_list+0x26a>
  8004203dc4:	48 b9 88 75 21 04 80 	movabs $0x8004217588,%rcx
  8004203dcb:	00 00 00 
  8004203dce:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004203dd5:	00 00 00 
  8004203dd8:	be 32 04 00 00       	mov    $0x432,%esi
  8004203ddd:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004203de4:	00 00 00 
  8004203de7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203dec:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004203df3:	00 00 00 
  8004203df6:	41 ff d0             	callq  *%r8
		assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
  8004203df9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203dfd:	48 b8 e8 c7 63 04 80 	movabs $0x800463c7e8,%rax
  8004203e04:	00 00 00 
  8004203e07:	48 8b 00             	mov    (%rax),%rax
  8004203e0a:	48 89 d1             	mov    %rdx,%rcx
  8004203e0d:	48 29 c1             	sub    %rax,%rcx
  8004203e10:	48 89 c8             	mov    %rcx,%rax
  8004203e13:	83 e0 0f             	and    $0xf,%eax
  8004203e16:	48 85 c0             	test   %rax,%rax
  8004203e19:	74 35                	je     8004203e50 <check_page_free_list+0x2c1>
  8004203e1b:	48 b9 a0 75 21 04 80 	movabs $0x80042175a0,%rcx
  8004203e22:	00 00 00 
  8004203e25:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004203e2c:	00 00 00 
  8004203e2f:	be 33 04 00 00       	mov    $0x433,%esi
  8004203e34:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004203e3b:	00 00 00 
  8004203e3e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203e43:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004203e4a:	00 00 00 
  8004203e4d:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp) != 0);
  8004203e50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203e54:	48 89 c7             	mov    %rax,%rdi
  8004203e57:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  8004203e5e:	00 00 00 
  8004203e61:	ff d0                	callq  *%rax
  8004203e63:	48 85 c0             	test   %rax,%rax
  8004203e66:	75 35                	jne    8004203e9d <check_page_free_list+0x30e>
  8004203e68:	48 b9 d2 75 21 04 80 	movabs $0x80042175d2,%rcx
  8004203e6f:	00 00 00 
  8004203e72:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004203e79:	00 00 00 
  8004203e7c:	be 36 04 00 00       	mov    $0x436,%esi
  8004203e81:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004203e88:	00 00 00 
  8004203e8b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203e90:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004203e97:	00 00 00 
  8004203e9a:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != IOPHYSMEM);
  8004203e9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ea1:	48 89 c7             	mov    %rax,%rdi
  8004203ea4:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  8004203eab:	00 00 00 
  8004203eae:	ff d0                	callq  *%rax
  8004203eb0:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004203eb6:	75 35                	jne    8004203eed <check_page_free_list+0x35e>
  8004203eb8:	48 b9 e3 75 21 04 80 	movabs $0x80042175e3,%rcx
  8004203ebf:	00 00 00 
  8004203ec2:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004203ec9:	00 00 00 
  8004203ecc:	be 37 04 00 00       	mov    $0x437,%esi
  8004203ed1:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004203ed8:	00 00 00 
  8004203edb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203ee0:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004203ee7:	00 00 00 
  8004203eea:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
  8004203eed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ef1:	48 89 c7             	mov    %rax,%rdi
  8004203ef4:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  8004203efb:	00 00 00 
  8004203efe:	ff d0                	callq  *%rax
  8004203f00:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004203f06:	75 35                	jne    8004203f3d <check_page_free_list+0x3ae>
  8004203f08:	48 b9 00 76 21 04 80 	movabs $0x8004217600,%rcx
  8004203f0f:	00 00 00 
  8004203f12:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004203f19:	00 00 00 
  8004203f1c:	be 38 04 00 00       	mov    $0x438,%esi
  8004203f21:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004203f28:	00 00 00 
  8004203f2b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203f30:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004203f37:	00 00 00 
  8004203f3a:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM);
  8004203f3d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f41:	48 89 c7             	mov    %rax,%rdi
  8004203f44:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  8004203f4b:	00 00 00 
  8004203f4e:	ff d0                	callq  *%rax
  8004203f50:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  8004203f56:	75 35                	jne    8004203f8d <check_page_free_list+0x3fe>
  8004203f58:	48 b9 23 76 21 04 80 	movabs $0x8004217623,%rcx
  8004203f5f:	00 00 00 
  8004203f62:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004203f69:	00 00 00 
  8004203f6c:	be 39 04 00 00       	mov    $0x439,%esi
  8004203f71:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004203f78:	00 00 00 
  8004203f7b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203f80:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004203f87:	00 00 00 
  8004203f8a:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);
  8004203f8d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f91:	48 89 c7             	mov    %rax,%rdi
  8004203f94:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  8004203f9b:	00 00 00 
  8004203f9e:	ff d0                	callq  *%rax
  8004203fa0:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  8004203fa6:	76 4e                	jbe    8004203ff6 <check_page_free_list+0x467>
  8004203fa8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203fac:	48 89 c7             	mov    %rax,%rdi
  8004203faf:	48 b8 2e 1a 20 04 80 	movabs $0x8004201a2e,%rax
  8004203fb6:	00 00 00 
  8004203fb9:	ff d0                	callq  *%rax
  8004203fbb:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004203fbf:	73 35                	jae    8004203ff6 <check_page_free_list+0x467>
  8004203fc1:	48 b9 40 76 21 04 80 	movabs $0x8004217640,%rcx
  8004203fc8:	00 00 00 
  8004203fcb:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004203fd2:	00 00 00 
  8004203fd5:	be 3a 04 00 00       	mov    $0x43a,%esi
  8004203fda:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004203fe1:	00 00 00 
  8004203fe4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203fe9:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004203ff0:	00 00 00 
  8004203ff3:	41 ff d0             	callq  *%r8
		// (new test for lab 4)
		assert(page2pa(pp) != MPENTRY_PADDR);
  8004203ff6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ffa:	48 89 c7             	mov    %rax,%rdi
  8004203ffd:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  8004204004:	00 00 00 
  8004204007:	ff d0                	callq  *%rax
  8004204009:	48 3d 00 70 00 00    	cmp    $0x7000,%rax
  800420400f:	75 35                	jne    8004204046 <check_page_free_list+0x4b7>
  8004204011:	48 b9 85 76 21 04 80 	movabs $0x8004217685,%rcx
  8004204018:	00 00 00 
  800420401b:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004204022:	00 00 00 
  8004204025:	be 3c 04 00 00       	mov    $0x43c,%esi
  800420402a:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004204031:	00 00 00 
  8004204034:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204039:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204040:	00 00 00 
  8004204043:	41 ff d0             	callq  *%r8

		if (page2pa(pp) < EXTPHYSMEM)
  8004204046:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420404a:	48 89 c7             	mov    %rax,%rdi
  800420404d:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  8004204054:	00 00 00 
  8004204057:	ff d0                	callq  *%rax
  8004204059:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  800420405f:	77 07                	ja     8004204068 <check_page_free_list+0x4d9>
			++nfree_basemem;
  8004204061:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004204066:	eb 05                	jmp    800420406d <check_page_free_list+0x4de>
		else
			++nfree_extmem;
  8004204068:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link)
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  800420406d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204071:	48 8b 00             	mov    (%rax),%rax
  8004204074:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204078:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420407d:	0f 85 d2 fc ff ff    	jne    8004203d55 <check_page_free_list+0x1c6>
			++nfree_basemem;
		else
			++nfree_extmem;
	}

	assert(nfree_extmem > 0);
  8004204083:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204088:	75 35                	jne    80042040bf <check_page_free_list+0x530>
  800420408a:	48 b9 a2 76 21 04 80 	movabs $0x80042176a2,%rcx
  8004204091:	00 00 00 
  8004204094:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  800420409b:	00 00 00 
  800420409e:	be 44 04 00 00       	mov    $0x444,%esi
  80042040a3:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042040aa:	00 00 00 
  80042040ad:	b8 00 00 00 00       	mov    $0x0,%eax
  80042040b2:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042040b9:	00 00 00 
  80042040bc:	41 ff d0             	callq  *%r8
	//cprintf("check_page_free_list(%d) succeeded!\n",only_low_memory);
}
  80042040bf:	c9                   	leaveq 
  80042040c0:	c3                   	retq   

00000080042040c1 <check_page_alloc>:
// Check the physical page allocator (page_alloc(), page_free(),
// and page_init()).
//
static void
check_page_alloc(void)
{
  80042040c1:	55                   	push   %rbp
  80042040c2:	48 89 e5             	mov    %rsp,%rbp
  80042040c5:	48 83 ec 40          	sub    $0x40,%rsp
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  80042040c9:	48 b8 38 b2 63 04 80 	movabs $0x800463b238,%rax
  80042040d0:	00 00 00 
  80042040d3:	48 8b 00             	mov    (%rax),%rax
  80042040d6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042040da:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  80042040e1:	eb 37                	jmp    800420411a <check_page_alloc+0x59>
		memset(page2kva(pp0), 0x97, PGSIZE);
  80042040e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042040e7:	48 89 c7             	mov    %rax,%rdi
  80042040ea:	48 b8 2e 1a 20 04 80 	movabs $0x8004201a2e,%rax
  80042040f1:	00 00 00 
  80042040f4:	ff d0                	callq  *%rax
  80042040f6:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042040fb:	be 97 00 00 00       	mov    $0x97,%esi
  8004204100:	48 89 c7             	mov    %rax,%rdi
  8004204103:	48 b8 53 e6 20 04 80 	movabs $0x800420e653,%rax
  800420410a:	00 00 00 
  800420410d:	ff d0                	callq  *%rax
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  800420410f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204113:	48 8b 00             	mov    (%rax),%rax
  8004204116:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420411a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420411f:	75 c2                	jne    80042040e3 <check_page_alloc+0x22>
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204121:	48 b8 38 b2 63 04 80 	movabs $0x800463b238,%rax
  8004204128:	00 00 00 
  800420412b:	48 8b 00             	mov    (%rax),%rax
  800420412e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204132:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  8004204139:	e9 ec 01 00 00       	jmpq   800420432a <check_page_alloc+0x269>
		// check that we didn't corrupt the free list itself
		assert(pp0 >= pages);
  800420413e:	48 b8 e8 c7 63 04 80 	movabs $0x800463c7e8,%rax
  8004204145:	00 00 00 
  8004204148:	48 8b 00             	mov    (%rax),%rax
  800420414b:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800420414f:	73 35                	jae    8004204186 <check_page_alloc+0xc5>
  8004204151:	48 b9 b3 76 21 04 80 	movabs $0x80042176b3,%rcx
  8004204158:	00 00 00 
  800420415b:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004204162:	00 00 00 
  8004204165:	be 5f 04 00 00       	mov    $0x45f,%esi
  800420416a:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004204171:	00 00 00 
  8004204174:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204179:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204180:	00 00 00 
  8004204183:	41 ff d0             	callq  *%r8
		assert(pp0 < pages + npages);
  8004204186:	48 b8 e8 c7 63 04 80 	movabs $0x800463c7e8,%rax
  800420418d:	00 00 00 
  8004204190:	48 8b 10             	mov    (%rax),%rdx
  8004204193:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  800420419a:	00 00 00 
  800420419d:	48 8b 00             	mov    (%rax),%rax
  80042041a0:	48 c1 e0 04          	shl    $0x4,%rax
  80042041a4:	48 01 d0             	add    %rdx,%rax
  80042041a7:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042041ab:	77 35                	ja     80042041e2 <check_page_alloc+0x121>
  80042041ad:	48 b9 c0 76 21 04 80 	movabs $0x80042176c0,%rcx
  80042041b4:	00 00 00 
  80042041b7:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042041be:	00 00 00 
  80042041c1:	be 60 04 00 00       	mov    $0x460,%esi
  80042041c6:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042041cd:	00 00 00 
  80042041d0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042041d5:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042041dc:	00 00 00 
  80042041df:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp0) != 0);
  80042041e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042041e6:	48 89 c7             	mov    %rax,%rdi
  80042041e9:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  80042041f0:	00 00 00 
  80042041f3:	ff d0                	callq  *%rax
  80042041f5:	48 85 c0             	test   %rax,%rax
  80042041f8:	75 35                	jne    800420422f <check_page_alloc+0x16e>
  80042041fa:	48 b9 d5 76 21 04 80 	movabs $0x80042176d5,%rcx
  8004204201:	00 00 00 
  8004204204:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  800420420b:	00 00 00 
  800420420e:	be 63 04 00 00       	mov    $0x463,%esi
  8004204213:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420421a:	00 00 00 
  800420421d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204222:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204229:	00 00 00 
  800420422c:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != IOPHYSMEM);
  800420422f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204233:	48 89 c7             	mov    %rax,%rdi
  8004204236:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  800420423d:	00 00 00 
  8004204240:	ff d0                	callq  *%rax
  8004204242:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004204248:	75 35                	jne    800420427f <check_page_alloc+0x1be>
  800420424a:	48 b9 e7 76 21 04 80 	movabs $0x80042176e7,%rcx
  8004204251:	00 00 00 
  8004204254:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  800420425b:	00 00 00 
  800420425e:	be 64 04 00 00       	mov    $0x464,%esi
  8004204263:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420426a:	00 00 00 
  800420426d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204272:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204279:	00 00 00 
  800420427c:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
  800420427f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204283:	48 89 c7             	mov    %rax,%rdi
  8004204286:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  800420428d:	00 00 00 
  8004204290:	ff d0                	callq  *%rax
  8004204292:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004204298:	75 35                	jne    80042042cf <check_page_alloc+0x20e>
  800420429a:	48 b9 08 77 21 04 80 	movabs $0x8004217708,%rcx
  80042042a1:	00 00 00 
  80042042a4:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042042ab:	00 00 00 
  80042042ae:	be 65 04 00 00       	mov    $0x465,%esi
  80042042b3:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042042ba:	00 00 00 
  80042042bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042042c2:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042042c9:	00 00 00 
  80042042cc:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM);
  80042042cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042042d3:	48 89 c7             	mov    %rax,%rdi
  80042042d6:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  80042042dd:	00 00 00 
  80042042e0:	ff d0                	callq  *%rax
  80042042e2:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  80042042e8:	75 35                	jne    800420431f <check_page_alloc+0x25e>
  80042042ea:	48 b9 2c 77 21 04 80 	movabs $0x800421772c,%rcx
  80042042f1:	00 00 00 
  80042042f4:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042042fb:	00 00 00 
  80042042fe:	be 66 04 00 00       	mov    $0x466,%esi
  8004204303:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420430a:	00 00 00 
  800420430d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204312:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204319:	00 00 00 
  800420431c:	41 ff d0             	callq  *%r8
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
		memset(page2kva(pp0), 0x97, PGSIZE);
	}

	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  800420431f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204323:	48 8b 00             	mov    (%rax),%rax
  8004204326:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420432a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420432f:	0f 85 09 fe ff ff    	jne    800420413e <check_page_alloc+0x7d>
		assert(page2pa(pp0) != IOPHYSMEM);
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
		assert(page2pa(pp0) != EXTPHYSMEM);
	}
	// should be able to allocate three pages
	pp0 = pp1 = pp2 = 0;
  8004204335:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420433c:	00 
  800420433d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204341:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204345:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204349:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  800420434d:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204352:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  8004204359:	00 00 00 
  800420435c:	ff d0                	callq  *%rax
  800420435e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204362:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204367:	75 35                	jne    800420439e <check_page_alloc+0x2dd>
  8004204369:	48 b9 47 77 21 04 80 	movabs $0x8004217747,%rcx
  8004204370:	00 00 00 
  8004204373:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  800420437a:	00 00 00 
  800420437d:	be 6a 04 00 00       	mov    $0x46a,%esi
  8004204382:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004204389:	00 00 00 
  800420438c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204391:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204398:	00 00 00 
  800420439b:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  800420439e:	bf 00 00 00 00       	mov    $0x0,%edi
  80042043a3:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  80042043aa:	00 00 00 
  80042043ad:	ff d0                	callq  *%rax
  80042043af:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042043b3:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042043b8:	75 35                	jne    80042043ef <check_page_alloc+0x32e>
  80042043ba:	48 b9 5d 77 21 04 80 	movabs $0x800421775d,%rcx
  80042043c1:	00 00 00 
  80042043c4:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042043cb:	00 00 00 
  80042043ce:	be 6b 04 00 00       	mov    $0x46b,%esi
  80042043d3:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042043da:	00 00 00 
  80042043dd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042043e2:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042043e9:	00 00 00 
  80042043ec:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  80042043ef:	bf 00 00 00 00       	mov    $0x0,%edi
  80042043f4:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  80042043fb:	00 00 00 
  80042043fe:	ff d0                	callq  *%rax
  8004204400:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004204404:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204409:	75 35                	jne    8004204440 <check_page_alloc+0x37f>
  800420440b:	48 b9 73 77 21 04 80 	movabs $0x8004217773,%rcx
  8004204412:	00 00 00 
  8004204415:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  800420441c:	00 00 00 
  800420441f:	be 6c 04 00 00       	mov    $0x46c,%esi
  8004204424:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420442b:	00 00 00 
  800420442e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204433:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420443a:	00 00 00 
  800420443d:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004204440:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204445:	75 35                	jne    800420447c <check_page_alloc+0x3bb>
  8004204447:	48 b9 89 77 21 04 80 	movabs $0x8004217789,%rcx
  800420444e:	00 00 00 
  8004204451:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004204458:	00 00 00 
  800420445b:	be 6d 04 00 00       	mov    $0x46d,%esi
  8004204460:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004204467:	00 00 00 
  800420446a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420446f:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204476:	00 00 00 
  8004204479:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  800420447c:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204481:	74 0a                	je     800420448d <check_page_alloc+0x3cc>
  8004204483:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204487:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420448b:	75 35                	jne    80042044c2 <check_page_alloc+0x401>
  800420448d:	48 b9 8d 77 21 04 80 	movabs $0x800421778d,%rcx
  8004204494:	00 00 00 
  8004204497:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  800420449e:	00 00 00 
  80042044a1:	be 6e 04 00 00       	mov    $0x46e,%esi
  80042044a6:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042044ad:	00 00 00 
  80042044b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042044b5:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042044bc:	00 00 00 
  80042044bf:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  80042044c2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042044c7:	74 14                	je     80042044dd <check_page_alloc+0x41c>
  80042044c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042044cd:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042044d1:	74 0a                	je     80042044dd <check_page_alloc+0x41c>
  80042044d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042044d7:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042044db:	75 35                	jne    8004204512 <check_page_alloc+0x451>
  80042044dd:	48 b9 a0 77 21 04 80 	movabs $0x80042177a0,%rcx
  80042044e4:	00 00 00 
  80042044e7:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042044ee:	00 00 00 
  80042044f1:	be 6f 04 00 00       	mov    $0x46f,%esi
  80042044f6:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042044fd:	00 00 00 
  8004204500:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204505:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420450c:	00 00 00 
  800420450f:	41 ff d0             	callq  *%r8
	assert(page2pa(pp0) < npages*PGSIZE);
  8004204512:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204516:	48 89 c7             	mov    %rax,%rdi
  8004204519:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  8004204520:	00 00 00 
  8004204523:	ff d0                	callq  *%rax
  8004204525:	48 ba e0 c7 63 04 80 	movabs $0x800463c7e0,%rdx
  800420452c:	00 00 00 
  800420452f:	48 8b 12             	mov    (%rdx),%rdx
  8004204532:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004204536:	48 39 d0             	cmp    %rdx,%rax
  8004204539:	72 35                	jb     8004204570 <check_page_alloc+0x4af>
  800420453b:	48 b9 c0 77 21 04 80 	movabs $0x80042177c0,%rcx
  8004204542:	00 00 00 
  8004204545:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  800420454c:	00 00 00 
  800420454f:	be 70 04 00 00       	mov    $0x470,%esi
  8004204554:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420455b:	00 00 00 
  800420455e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204563:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420456a:	00 00 00 
  800420456d:	41 ff d0             	callq  *%r8
	assert(page2pa(pp1) < npages*PGSIZE);
  8004204570:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204574:	48 89 c7             	mov    %rax,%rdi
  8004204577:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  800420457e:	00 00 00 
  8004204581:	ff d0                	callq  *%rax
  8004204583:	48 ba e0 c7 63 04 80 	movabs $0x800463c7e0,%rdx
  800420458a:	00 00 00 
  800420458d:	48 8b 12             	mov    (%rdx),%rdx
  8004204590:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004204594:	48 39 d0             	cmp    %rdx,%rax
  8004204597:	72 35                	jb     80042045ce <check_page_alloc+0x50d>
  8004204599:	48 b9 dd 77 21 04 80 	movabs $0x80042177dd,%rcx
  80042045a0:	00 00 00 
  80042045a3:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042045aa:	00 00 00 
  80042045ad:	be 71 04 00 00       	mov    $0x471,%esi
  80042045b2:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042045b9:	00 00 00 
  80042045bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042045c1:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042045c8:	00 00 00 
  80042045cb:	41 ff d0             	callq  *%r8
	assert(page2pa(pp2) < npages*PGSIZE);
  80042045ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042045d2:	48 89 c7             	mov    %rax,%rdi
  80042045d5:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  80042045dc:	00 00 00 
  80042045df:	ff d0                	callq  *%rax
  80042045e1:	48 ba e0 c7 63 04 80 	movabs $0x800463c7e0,%rdx
  80042045e8:	00 00 00 
  80042045eb:	48 8b 12             	mov    (%rdx),%rdx
  80042045ee:	48 c1 e2 0c          	shl    $0xc,%rdx
  80042045f2:	48 39 d0             	cmp    %rdx,%rax
  80042045f5:	72 35                	jb     800420462c <check_page_alloc+0x56b>
  80042045f7:	48 b9 fa 77 21 04 80 	movabs $0x80042177fa,%rcx
  80042045fe:	00 00 00 
  8004204601:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004204608:	00 00 00 
  800420460b:	be 72 04 00 00       	mov    $0x472,%esi
  8004204610:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004204617:	00 00 00 
  800420461a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420461f:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204626:	00 00 00 
  8004204629:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  800420462c:	48 b8 38 b2 63 04 80 	movabs $0x800463b238,%rax
  8004204633:	00 00 00 
  8004204636:	48 8b 00             	mov    (%rax),%rax
  8004204639:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	page_free_list = 0;
  800420463d:	48 b8 38 b2 63 04 80 	movabs $0x800463b238,%rax
  8004204644:	00 00 00 
  8004204647:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  800420464e:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204653:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  800420465a:	00 00 00 
  800420465d:	ff d0                	callq  *%rax
  800420465f:	48 85 c0             	test   %rax,%rax
  8004204662:	74 35                	je     8004204699 <check_page_alloc+0x5d8>
  8004204664:	48 b9 17 78 21 04 80 	movabs $0x8004217817,%rcx
  800420466b:	00 00 00 
  800420466e:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004204675:	00 00 00 
  8004204678:	be 79 04 00 00       	mov    $0x479,%esi
  800420467d:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004204684:	00 00 00 
  8004204687:	b8 00 00 00 00       	mov    $0x0,%eax
  800420468c:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204693:	00 00 00 
  8004204696:	41 ff d0             	callq  *%r8

	// free and re-allocate?
	page_free(pp0);
  8004204699:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420469d:	48 89 c7             	mov    %rax,%rdi
  80042046a0:	48 b8 85 2d 20 04 80 	movabs $0x8004202d85,%rax
  80042046a7:	00 00 00 
  80042046aa:	ff d0                	callq  *%rax
	page_free(pp1);
  80042046ac:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042046b0:	48 89 c7             	mov    %rax,%rdi
  80042046b3:	48 b8 85 2d 20 04 80 	movabs $0x8004202d85,%rax
  80042046ba:	00 00 00 
  80042046bd:	ff d0                	callq  *%rax
	page_free(pp2);
  80042046bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042046c3:	48 89 c7             	mov    %rax,%rdi
  80042046c6:	48 b8 85 2d 20 04 80 	movabs $0x8004202d85,%rax
  80042046cd:	00 00 00 
  80042046d0:	ff d0                	callq  *%rax
	pp0 = pp1 = pp2 = 0;
  80042046d2:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042046d9:	00 
  80042046da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042046de:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042046e2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042046e6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  80042046ea:	bf 00 00 00 00       	mov    $0x0,%edi
  80042046ef:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  80042046f6:	00 00 00 
  80042046f9:	ff d0                	callq  *%rax
  80042046fb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042046ff:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204704:	75 35                	jne    800420473b <check_page_alloc+0x67a>
  8004204706:	48 b9 47 77 21 04 80 	movabs $0x8004217747,%rcx
  800420470d:	00 00 00 
  8004204710:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004204717:	00 00 00 
  800420471a:	be 80 04 00 00       	mov    $0x480,%esi
  800420471f:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004204726:	00 00 00 
  8004204729:	b8 00 00 00 00       	mov    $0x0,%eax
  800420472e:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204735:	00 00 00 
  8004204738:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  800420473b:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204740:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  8004204747:	00 00 00 
  800420474a:	ff d0                	callq  *%rax
  800420474c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204750:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204755:	75 35                	jne    800420478c <check_page_alloc+0x6cb>
  8004204757:	48 b9 5d 77 21 04 80 	movabs $0x800421775d,%rcx
  800420475e:	00 00 00 
  8004204761:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004204768:	00 00 00 
  800420476b:	be 81 04 00 00       	mov    $0x481,%esi
  8004204770:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004204777:	00 00 00 
  800420477a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420477f:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204786:	00 00 00 
  8004204789:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  800420478c:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204791:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  8004204798:	00 00 00 
  800420479b:	ff d0                	callq  *%rax
  800420479d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042047a1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042047a6:	75 35                	jne    80042047dd <check_page_alloc+0x71c>
  80042047a8:	48 b9 73 77 21 04 80 	movabs $0x8004217773,%rcx
  80042047af:	00 00 00 
  80042047b2:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042047b9:	00 00 00 
  80042047bc:	be 82 04 00 00       	mov    $0x482,%esi
  80042047c1:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042047c8:	00 00 00 
  80042047cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042047d0:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042047d7:	00 00 00 
  80042047da:	41 ff d0             	callq  *%r8
	assert(pp0);
  80042047dd:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042047e2:	75 35                	jne    8004204819 <check_page_alloc+0x758>
  80042047e4:	48 b9 89 77 21 04 80 	movabs $0x8004217789,%rcx
  80042047eb:	00 00 00 
  80042047ee:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042047f5:	00 00 00 
  80042047f8:	be 83 04 00 00       	mov    $0x483,%esi
  80042047fd:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004204804:	00 00 00 
  8004204807:	b8 00 00 00 00       	mov    $0x0,%eax
  800420480c:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204813:	00 00 00 
  8004204816:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004204819:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420481e:	74 0a                	je     800420482a <check_page_alloc+0x769>
  8004204820:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204824:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204828:	75 35                	jne    800420485f <check_page_alloc+0x79e>
  800420482a:	48 b9 8d 77 21 04 80 	movabs $0x800421778d,%rcx
  8004204831:	00 00 00 
  8004204834:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  800420483b:	00 00 00 
  800420483e:	be 84 04 00 00       	mov    $0x484,%esi
  8004204843:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420484a:	00 00 00 
  800420484d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204852:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204859:	00 00 00 
  800420485c:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  800420485f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204864:	74 14                	je     800420487a <check_page_alloc+0x7b9>
  8004204866:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420486a:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420486e:	74 0a                	je     800420487a <check_page_alloc+0x7b9>
  8004204870:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204874:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204878:	75 35                	jne    80042048af <check_page_alloc+0x7ee>
  800420487a:	48 b9 a0 77 21 04 80 	movabs $0x80042177a0,%rcx
  8004204881:	00 00 00 
  8004204884:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  800420488b:	00 00 00 
  800420488e:	be 85 04 00 00       	mov    $0x485,%esi
  8004204893:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420489a:	00 00 00 
  800420489d:	b8 00 00 00 00       	mov    $0x0,%eax
  80042048a2:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042048a9:	00 00 00 
  80042048ac:	41 ff d0             	callq  *%r8
	assert(!page_alloc(0));
  80042048af:	bf 00 00 00 00       	mov    $0x0,%edi
  80042048b4:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  80042048bb:	00 00 00 
  80042048be:	ff d0                	callq  *%rax
  80042048c0:	48 85 c0             	test   %rax,%rax
  80042048c3:	74 35                	je     80042048fa <check_page_alloc+0x839>
  80042048c5:	48 b9 17 78 21 04 80 	movabs $0x8004217817,%rcx
  80042048cc:	00 00 00 
  80042048cf:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042048d6:	00 00 00 
  80042048d9:	be 86 04 00 00       	mov    $0x486,%esi
  80042048de:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042048e5:	00 00 00 
  80042048e8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042048ed:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042048f4:	00 00 00 
  80042048f7:	41 ff d0             	callq  *%r8

	// test flags
	memset(page2kva(pp0), 1, PGSIZE);
  80042048fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042048fe:	48 89 c7             	mov    %rax,%rdi
  8004204901:	48 b8 2e 1a 20 04 80 	movabs $0x8004201a2e,%rax
  8004204908:	00 00 00 
  800420490b:	ff d0                	callq  *%rax
  800420490d:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004204912:	be 01 00 00 00       	mov    $0x1,%esi
  8004204917:	48 89 c7             	mov    %rax,%rdi
  800420491a:	48 b8 53 e6 20 04 80 	movabs $0x800420e653,%rax
  8004204921:	00 00 00 
  8004204924:	ff d0                	callq  *%rax
	page_free(pp0);
  8004204926:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420492a:	48 89 c7             	mov    %rax,%rdi
  800420492d:	48 b8 85 2d 20 04 80 	movabs $0x8004202d85,%rax
  8004204934:	00 00 00 
  8004204937:	ff d0                	callq  *%rax
	assert((pp = page_alloc(ALLOC_ZERO)));
  8004204939:	bf 01 00 00 00       	mov    $0x1,%edi
  800420493e:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  8004204945:	00 00 00 
  8004204948:	ff d0                	callq  *%rax
  800420494a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420494e:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004204953:	75 35                	jne    800420498a <check_page_alloc+0x8c9>
  8004204955:	48 b9 26 78 21 04 80 	movabs $0x8004217826,%rcx
  800420495c:	00 00 00 
  800420495f:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004204966:	00 00 00 
  8004204969:	be 8b 04 00 00       	mov    $0x48b,%esi
  800420496e:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004204975:	00 00 00 
  8004204978:	b8 00 00 00 00       	mov    $0x0,%eax
  800420497d:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204984:	00 00 00 
  8004204987:	41 ff d0             	callq  *%r8
	assert(pp && pp0 == pp);
  800420498a:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420498f:	74 0a                	je     800420499b <check_page_alloc+0x8da>
  8004204991:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204995:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004204999:	74 35                	je     80042049d0 <check_page_alloc+0x90f>
  800420499b:	48 b9 44 78 21 04 80 	movabs $0x8004217844,%rcx
  80042049a2:	00 00 00 
  80042049a5:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042049ac:	00 00 00 
  80042049af:	be 8c 04 00 00       	mov    $0x48c,%esi
  80042049b4:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042049bb:	00 00 00 
  80042049be:	b8 00 00 00 00       	mov    $0x0,%eax
  80042049c3:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042049ca:	00 00 00 
  80042049cd:	41 ff d0             	callq  *%r8
	c = page2kva(pp);
  80042049d0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042049d4:	48 89 c7             	mov    %rax,%rdi
  80042049d7:	48 b8 2e 1a 20 04 80 	movabs $0x8004201a2e,%rax
  80042049de:	00 00 00 
  80042049e1:	ff d0                	callq  *%rax
  80042049e3:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < PGSIZE; i++)
  80042049e7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042049ee:	eb 49                	jmp    8004204a39 <check_page_alloc+0x978>
		assert(c[i] == 0);
  80042049f0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042049f3:	48 98                	cltq   
  80042049f5:	48 03 45 c8          	add    -0x38(%rbp),%rax
  80042049f9:	0f b6 00             	movzbl (%rax),%eax
  80042049fc:	84 c0                	test   %al,%al
  80042049fe:	74 35                	je     8004204a35 <check_page_alloc+0x974>
  8004204a00:	48 b9 54 78 21 04 80 	movabs $0x8004217854,%rcx
  8004204a07:	00 00 00 
  8004204a0a:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004204a11:	00 00 00 
  8004204a14:	be 8f 04 00 00       	mov    $0x48f,%esi
  8004204a19:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004204a20:	00 00 00 
  8004204a23:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a28:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204a2f:	00 00 00 
  8004204a32:	41 ff d0             	callq  *%r8
	memset(page2kva(pp0), 1, PGSIZE);
	page_free(pp0);
	assert((pp = page_alloc(ALLOC_ZERO)));
	assert(pp && pp0 == pp);
	c = page2kva(pp);
	for (i = 0; i < PGSIZE; i++)
  8004204a35:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004204a39:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%rbp)
  8004204a40:	7e ae                	jle    80042049f0 <check_page_alloc+0x92f>
		assert(c[i] == 0);

	// give free list back
	page_free_list = fl;
  8004204a42:	48 b8 38 b2 63 04 80 	movabs $0x800463b238,%rax
  8004204a49:	00 00 00 
  8004204a4c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004204a50:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_free(pp0);
  8004204a53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204a57:	48 89 c7             	mov    %rax,%rdi
  8004204a5a:	48 b8 85 2d 20 04 80 	movabs $0x8004202d85,%rax
  8004204a61:	00 00 00 
  8004204a64:	ff d0                	callq  *%rax
	page_free(pp1);
  8004204a66:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204a6a:	48 89 c7             	mov    %rax,%rdi
  8004204a6d:	48 b8 85 2d 20 04 80 	movabs $0x8004202d85,%rax
  8004204a74:	00 00 00 
  8004204a77:	ff d0                	callq  *%rax
	page_free(pp2);
  8004204a79:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204a7d:	48 89 c7             	mov    %rax,%rdi
  8004204a80:	48 b8 85 2d 20 04 80 	movabs $0x8004202d85,%rax
  8004204a87:	00 00 00 
  8004204a8a:	ff d0                	callq  *%rax

	cprintf("check_page_alloc() succeeded!\n");
  8004204a8c:	48 bf 60 78 21 04 80 	movabs $0x8004217860,%rdi
  8004204a93:	00 00 00 
  8004204a96:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a9b:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  8004204aa2:	00 00 00 
  8004204aa5:	ff d2                	callq  *%rdx
}
  8004204aa7:	c9                   	leaveq 
  8004204aa8:	c3                   	retq   

0000008004204aa9 <check_boot_pml4e>:
// but it is a pretty good sanity check.
//

static void
check_boot_pml4e(pml4e_t *pml4e)
{
  8004204aa9:	55                   	push   %rbp
  8004204aaa:	48 89 e5             	mov    %rsp,%rbp
  8004204aad:	53                   	push   %rbx
  8004204aae:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
  8004204ab5:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
	uint64_t i, n;

	pml4e = boot_pml4e;
  8004204abc:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004204ac3:	00 00 00 
  8004204ac6:	48 8b 00             	mov    (%rax),%rax
  8004204ac9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
  8004204acd:	48 c7 45 d0 00 10 00 	movq   $0x1000,-0x30(%rbp)
  8004204ad4:	00 
  8004204ad5:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004204adc:	00 00 00 
  8004204adf:	48 8b 00             	mov    (%rax),%rax
  8004204ae2:	48 c1 e0 04          	shl    $0x4,%rax
  8004204ae6:	48 03 45 d0          	add    -0x30(%rbp),%rax
  8004204aea:	48 83 e8 01          	sub    $0x1,%rax
  8004204aee:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004204af2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204af6:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204afb:	48 f7 75 d0          	divq   -0x30(%rbp)
  8004204aff:	48 89 d0             	mov    %rdx,%rax
  8004204b02:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004204b06:	48 89 d1             	mov    %rdx,%rcx
  8004204b09:	48 29 c1             	sub    %rax,%rcx
  8004204b0c:	48 89 c8             	mov    %rcx,%rax
  8004204b0f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	for (i = 0; i < n; i += PGSIZE) {
  8004204b13:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204b1a:	00 
  8004204b1b:	e9 ce 00 00 00       	jmpq   8004204bee <check_boot_pml4e+0x145>
		// cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
  8004204b20:	48 b8 00 00 a0 00 80 	movabs $0x8000a00000,%rax
  8004204b27:	00 00 00 
  8004204b2a:	48 89 c2             	mov    %rax,%rdx
  8004204b2d:	48 03 55 e8          	add    -0x18(%rbp),%rdx
  8004204b31:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204b35:	48 89 d6             	mov    %rdx,%rsi
  8004204b38:	48 89 c7             	mov    %rax,%rdi
  8004204b3b:	48 b8 f1 51 20 04 80 	movabs $0x80042051f1,%rax
  8004204b42:	00 00 00 
  8004204b45:	ff d0                	callq  *%rax
  8004204b47:	48 ba e8 c7 63 04 80 	movabs $0x800463c7e8,%rdx
  8004204b4e:	00 00 00 
  8004204b51:	48 8b 12             	mov    (%rdx),%rdx
  8004204b54:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  8004204b58:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004204b5f:	00 00 00 
  8004204b62:	48 39 55 c0          	cmp    %rdx,-0x40(%rbp)
  8004204b66:	77 32                	ja     8004204b9a <check_boot_pml4e+0xf1>
  8004204b68:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004204b6c:	48 89 c1             	mov    %rax,%rcx
  8004204b6f:	48 ba 88 74 21 04 80 	movabs $0x8004217488,%rdx
  8004204b76:	00 00 00 
  8004204b79:	be af 04 00 00       	mov    $0x4af,%esi
  8004204b7e:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004204b85:	00 00 00 
  8004204b88:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b8d:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204b94:	00 00 00 
  8004204b97:	41 ff d0             	callq  *%r8
  8004204b9a:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004204ba1:	ff ff ff 
  8004204ba4:	48 03 55 c0          	add    -0x40(%rbp),%rdx
  8004204ba8:	48 03 55 e8          	add    -0x18(%rbp),%rdx
  8004204bac:	48 39 d0             	cmp    %rdx,%rax
  8004204baf:	74 35                	je     8004204be6 <check_boot_pml4e+0x13d>
  8004204bb1:	48 b9 80 78 21 04 80 	movabs $0x8004217880,%rcx
  8004204bb8:	00 00 00 
  8004204bbb:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004204bc2:	00 00 00 
  8004204bc5:	be af 04 00 00       	mov    $0x4af,%esi
  8004204bca:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004204bd1:	00 00 00 
  8004204bd4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204bd9:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204be0:	00 00 00 
  8004204be3:	41 ff d0             	callq  *%r8

	pml4e = boot_pml4e;

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
	for (i = 0; i < n; i += PGSIZE) {
  8004204be6:	48 81 45 e8 00 10 00 	addq   $0x1000,-0x18(%rbp)
  8004204bed:	00 
  8004204bee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204bf2:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204bf6:	0f 82 24 ff ff ff    	jb     8004204b20 <check_boot_pml4e+0x77>
		// cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
  8004204bfc:	48 c7 45 b8 00 10 00 	movq   $0x1000,-0x48(%rbp)
  8004204c03:	00 
  8004204c04:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004204c08:	48 05 ff 7f 04 00    	add    $0x47fff,%rax
  8004204c0e:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004204c12:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004204c16:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204c1b:	48 f7 75 b8          	divq   -0x48(%rbp)
  8004204c1f:	48 89 d0             	mov    %rdx,%rax
  8004204c22:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004204c26:	48 89 d3             	mov    %rdx,%rbx
  8004204c29:	48 29 c3             	sub    %rax,%rbx
  8004204c2c:	48 89 d8             	mov    %rbx,%rax
  8004204c2f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	for (i = 0; i < n; i += PGSIZE)
  8004204c33:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204c3a:	00 
  8004204c3b:	e9 ce 00 00 00       	jmpq   8004204d0e <check_boot_pml4e+0x265>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);
  8004204c40:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  8004204c47:	00 00 00 
  8004204c4a:	48 89 c2             	mov    %rax,%rdx
  8004204c4d:	48 03 55 e8          	add    -0x18(%rbp),%rdx
  8004204c51:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204c55:	48 89 d6             	mov    %rdx,%rsi
  8004204c58:	48 89 c7             	mov    %rax,%rdi
  8004204c5b:	48 b8 f1 51 20 04 80 	movabs $0x80042051f1,%rax
  8004204c62:	00 00 00 
  8004204c65:	ff d0                	callq  *%rax
  8004204c67:	48 ba 50 b2 63 04 80 	movabs $0x800463b250,%rdx
  8004204c6e:	00 00 00 
  8004204c71:	48 8b 12             	mov    (%rdx),%rdx
  8004204c74:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  8004204c78:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004204c7f:	00 00 00 
  8004204c82:	48 39 55 a8          	cmp    %rdx,-0x58(%rbp)
  8004204c86:	77 32                	ja     8004204cba <check_boot_pml4e+0x211>
  8004204c88:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004204c8c:	48 89 c1             	mov    %rax,%rcx
  8004204c8f:	48 ba 88 74 21 04 80 	movabs $0x8004217488,%rdx
  8004204c96:	00 00 00 
  8004204c99:	be b5 04 00 00       	mov    $0x4b5,%esi
  8004204c9e:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004204ca5:	00 00 00 
  8004204ca8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204cad:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204cb4:	00 00 00 
  8004204cb7:	41 ff d0             	callq  *%r8
  8004204cba:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004204cc1:	ff ff ff 
  8004204cc4:	48 03 55 a8          	add    -0x58(%rbp),%rdx
  8004204cc8:	48 03 55 e8          	add    -0x18(%rbp),%rdx
  8004204ccc:	48 39 d0             	cmp    %rdx,%rax
  8004204ccf:	74 35                	je     8004204d06 <check_boot_pml4e+0x25d>
  8004204cd1:	48 b9 b8 78 21 04 80 	movabs $0x80042178b8,%rcx
  8004204cd8:	00 00 00 
  8004204cdb:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004204ce2:	00 00 00 
  8004204ce5:	be b5 04 00 00       	mov    $0x4b5,%esi
  8004204cea:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004204cf1:	00 00 00 
  8004204cf4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204cf9:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204d00:	00 00 00 
  8004204d03:	41 ff d0             	callq  *%r8
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
  8004204d06:	48 81 45 e8 00 10 00 	addq   $0x1000,-0x18(%rbp)
  8004204d0d:	00 
  8004204d0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204d12:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204d16:	0f 82 24 ff ff ff    	jb     8004204c40 <check_boot_pml4e+0x197>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  8004204d1c:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204d23:	00 
  8004204d24:	eb 6a                	jmp    8004204d90 <check_boot_pml4e+0x2e7>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);
  8004204d26:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004204d2d:	00 00 00 
  8004204d30:	48 89 c2             	mov    %rax,%rdx
  8004204d33:	48 03 55 e8          	add    -0x18(%rbp),%rdx
  8004204d37:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204d3b:	48 89 d6             	mov    %rdx,%rsi
  8004204d3e:	48 89 c7             	mov    %rax,%rdi
  8004204d41:	48 b8 f1 51 20 04 80 	movabs $0x80042051f1,%rax
  8004204d48:	00 00 00 
  8004204d4b:	ff d0                	callq  *%rax
  8004204d4d:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004204d51:	74 35                	je     8004204d88 <check_boot_pml4e+0x2df>
  8004204d53:	48 b9 f0 78 21 04 80 	movabs $0x80042178f0,%rcx
  8004204d5a:	00 00 00 
  8004204d5d:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004204d64:	00 00 00 
  8004204d67:	be b9 04 00 00       	mov    $0x4b9,%esi
  8004204d6c:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004204d73:	00 00 00 
  8004204d76:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204d7b:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204d82:	00 00 00 
  8004204d85:	41 ff d0             	callq  *%r8
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  8004204d88:	48 81 45 e8 00 10 00 	addq   $0x1000,-0x18(%rbp)
  8004204d8f:	00 
  8004204d90:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004204d97:	00 00 00 
  8004204d9a:	48 8b 00             	mov    (%rax),%rax
  8004204d9d:	48 c1 e0 0c          	shl    $0xc,%rax
  8004204da1:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004204da5:	0f 87 7b ff ff ff    	ja     8004204d26 <check_boot_pml4e+0x27d>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  8004204dab:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004204db2:	00 
  8004204db3:	e9 9e 01 00 00       	jmpq   8004204f56 <check_boot_pml4e+0x4ad>
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
  8004204db8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204dbc:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004204dc0:	48 89 d0             	mov    %rdx,%rax
  8004204dc3:	48 01 c0             	add    %rax,%rax
  8004204dc6:	48 01 d0             	add    %rdx,%rax
  8004204dc9:	48 c1 e0 0f          	shl    $0xf,%rax
  8004204dcd:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204dd4:	00 00 00 
  8004204dd7:	48 89 d1             	mov    %rdx,%rcx
  8004204dda:	48 29 c1             	sub    %rax,%rcx
  8004204ddd:	48 89 c8             	mov    %rcx,%rax
  8004204de0:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004204de4:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204deb:	00 
  8004204dec:	e9 da 00 00 00       	jmpq   8004204ecb <check_boot_pml4e+0x422>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
  8004204df1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204df5:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004204df9:	48 01 d0             	add    %rdx,%rax
  8004204dfc:	48 8d 90 00 80 00 00 	lea    0x8000(%rax),%rdx
  8004204e03:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204e07:	48 89 d6             	mov    %rdx,%rsi
  8004204e0a:	48 89 c7             	mov    %rax,%rdi
  8004204e0d:	48 b8 f1 51 20 04 80 	movabs $0x80042051f1,%rax
  8004204e14:	00 00 00 
  8004204e17:	ff d0                	callq  *%rax
  8004204e19:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004204e1d:	48 89 d1             	mov    %rdx,%rcx
  8004204e20:	48 c1 e1 10          	shl    $0x10,%rcx
  8004204e24:	48 ba 00 f0 67 04 80 	movabs $0x800467f000,%rdx
  8004204e2b:	00 00 00 
  8004204e2e:	48 01 ca             	add    %rcx,%rdx
  8004204e31:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  8004204e35:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004204e3c:	00 00 00 
  8004204e3f:	48 39 55 98          	cmp    %rdx,-0x68(%rbp)
  8004204e43:	77 32                	ja     8004204e77 <check_boot_pml4e+0x3ce>
  8004204e45:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004204e49:	48 89 c1             	mov    %rax,%rcx
  8004204e4c:	48 ba 88 74 21 04 80 	movabs $0x8004217488,%rdx
  8004204e53:	00 00 00 
  8004204e56:	be c1 04 00 00       	mov    $0x4c1,%esi
  8004204e5b:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004204e62:	00 00 00 
  8004204e65:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204e6a:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204e71:	00 00 00 
  8004204e74:	41 ff d0             	callq  *%r8
  8004204e77:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004204e7e:	ff ff ff 
  8004204e81:	48 03 55 98          	add    -0x68(%rbp),%rdx
  8004204e85:	48 03 55 e8          	add    -0x18(%rbp),%rdx
  8004204e89:	48 39 d0             	cmp    %rdx,%rax
  8004204e8c:	74 35                	je     8004204ec3 <check_boot_pml4e+0x41a>
  8004204e8e:	48 b9 18 79 21 04 80 	movabs $0x8004217918,%rcx
  8004204e95:	00 00 00 
  8004204e98:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004204e9f:	00 00 00 
  8004204ea2:	be c1 04 00 00       	mov    $0x4c1,%esi
  8004204ea7:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004204eae:	00 00 00 
  8004204eb1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204eb6:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204ebd:	00 00 00 
  8004204ec0:	41 ff d0             	callq  *%r8

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004204ec3:	48 81 45 e8 00 10 00 	addq   $0x1000,-0x18(%rbp)
  8004204eca:	00 
  8004204ecb:	48 81 7d e8 ff ff 00 	cmpq   $0xffff,-0x18(%rbp)
  8004204ed2:	00 
  8004204ed3:	0f 86 18 ff ff ff    	jbe    8004204df1 <check_boot_pml4e+0x348>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  8004204ed9:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204ee0:	00 
  8004204ee1:	eb 64                	jmp    8004204f47 <check_boot_pml4e+0x49e>
			assert(check_va2pa(pml4e, base + i) == ~0);
  8004204ee3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204ee7:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004204eeb:	48 01 c2             	add    %rax,%rdx
  8004204eee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204ef2:	48 89 d6             	mov    %rdx,%rsi
  8004204ef5:	48 89 c7             	mov    %rax,%rdi
  8004204ef8:	48 b8 f1 51 20 04 80 	movabs $0x80042051f1,%rax
  8004204eff:	00 00 00 
  8004204f02:	ff d0                	callq  *%rax
  8004204f04:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004204f08:	74 35                	je     8004204f3f <check_boot_pml4e+0x496>
  8004204f0a:	48 b9 60 79 21 04 80 	movabs $0x8004217960,%rcx
  8004204f11:	00 00 00 
  8004204f14:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004204f1b:	00 00 00 
  8004204f1e:	be c3 04 00 00       	mov    $0x4c3,%esi
  8004204f23:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004204f2a:	00 00 00 
  8004204f2d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f32:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204f39:	00 00 00 
  8004204f3c:	41 ff d0             	callq  *%r8
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  8004204f3f:	48 81 45 e8 00 10 00 	addq   $0x1000,-0x18(%rbp)
  8004204f46:	00 
  8004204f47:	48 81 7d e8 ff 7f 00 	cmpq   $0x7fff,-0x18(%rbp)
  8004204f4e:	00 
  8004204f4f:	76 92                	jbe    8004204ee3 <check_boot_pml4e+0x43a>
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  8004204f51:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
  8004204f56:	48 83 7d e0 07       	cmpq   $0x7,-0x20(%rbp)
  8004204f5b:	0f 86 57 fe ff ff    	jbe    8004204db8 <check_boot_pml4e+0x30f>
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
			assert(check_va2pa(pml4e, base + i) == ~0);
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
  8004204f61:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004204f68:	00 00 00 
  8004204f6b:	48 8b 00             	mov    (%rax),%rax
  8004204f6e:	48 83 c0 08          	add    $0x8,%rax
  8004204f72:	48 8b 00             	mov    (%rax),%rax
  8004204f75:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004204f7b:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  8004204f7f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004204f83:	48 c1 e8 0c          	shr    $0xc,%rax
  8004204f87:	89 45 8c             	mov    %eax,-0x74(%rbp)
  8004204f8a:	8b 55 8c             	mov    -0x74(%rbp),%edx
  8004204f8d:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004204f94:	00 00 00 
  8004204f97:	48 8b 00             	mov    (%rax),%rax
  8004204f9a:	48 39 c2             	cmp    %rax,%rdx
  8004204f9d:	72 32                	jb     8004204fd1 <check_boot_pml4e+0x528>
  8004204f9f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004204fa3:	48 89 c1             	mov    %rax,%rcx
  8004204fa6:	48 ba 60 73 21 04 80 	movabs $0x8004217360,%rdx
  8004204fad:	00 00 00 
  8004204fb0:	be c6 04 00 00       	mov    $0x4c6,%esi
  8004204fb5:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004204fbc:	00 00 00 
  8004204fbf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204fc4:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004204fcb:	00 00 00 
  8004204fce:	41 ff d0             	callq  *%r8
  8004204fd1:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004204fd8:	00 00 00 
  8004204fdb:	48 03 45 90          	add    -0x70(%rbp),%rax
  8004204fdf:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004204fe3:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004204fe7:	48 8b 00             	mov    (%rax),%rax
  8004204fea:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004204ff0:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004204ff7:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004204ffe:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205002:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
  8004205008:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
  800420500e:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004205015:	00 00 00 
  8004205018:	48 8b 00             	mov    (%rax),%rax
  800420501b:	48 39 c2             	cmp    %rax,%rdx
  800420501e:	72 35                	jb     8004205055 <check_boot_pml4e+0x5ac>
  8004205020:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205027:	48 89 c1             	mov    %rax,%rcx
  800420502a:	48 ba 60 73 21 04 80 	movabs $0x8004217360,%rdx
  8004205031:	00 00 00 
  8004205034:	be c7 04 00 00       	mov    $0x4c7,%esi
  8004205039:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205040:	00 00 00 
  8004205043:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205048:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420504f:	00 00 00 
  8004205052:	41 ff d0             	callq  *%r8
  8004205055:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  800420505c:	00 00 00 
  800420505f:	48 03 85 78 ff ff ff 	add    -0x88(%rbp),%rax
  8004205066:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  800420506d:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004205074:	00 
  8004205075:	e9 44 01 00 00       	jmpq   80042051be <check_boot_pml4e+0x715>
		switch (i) {
  800420507a:	48 83 7d e8 1f       	cmpq   $0x1f,-0x18(%rbp)
  800420507f:	77 71                	ja     80042050f2 <check_boot_pml4e+0x649>
  8004205081:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205085:	ba 01 00 00 00       	mov    $0x1,%edx
  800420508a:	48 89 d3             	mov    %rdx,%rbx
  800420508d:	89 c1                	mov    %eax,%ecx
  800420508f:	48 d3 e3             	shl    %cl,%rbx
  8004205092:	48 89 d8             	mov    %rbx,%rax
  8004205095:	25 30 00 00 80       	and    $0x80000030,%eax
  800420509a:	48 85 c0             	test   %rax,%rax
  800420509d:	74 53                	je     80042050f2 <check_boot_pml4e+0x649>
			//case PDX(UVPT):
			case PDX(KSTACKTOP - 1):
			case PDX(UPAGES):
			case PDX(UENVS):
				assert(pgdir[i] & PTE_P);
  800420509f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042050a3:	48 c1 e0 03          	shl    $0x3,%rax
  80042050a7:	48 03 85 68 ff ff ff 	add    -0x98(%rbp),%rax
  80042050ae:	48 8b 00             	mov    (%rax),%rax
  80042050b1:	83 e0 01             	and    $0x1,%eax
  80042050b4:	48 85 c0             	test   %rax,%rax
  80042050b7:	0f 85 f8 00 00 00    	jne    80042051b5 <check_boot_pml4e+0x70c>
  80042050bd:	48 b9 83 79 21 04 80 	movabs $0x8004217983,%rcx
  80042050c4:	00 00 00 
  80042050c7:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042050ce:	00 00 00 
  80042050d1:	be cf 04 00 00       	mov    $0x4cf,%esi
  80042050d6:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042050dd:	00 00 00 
  80042050e0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042050e5:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042050ec:	00 00 00 
  80042050ef:	41 ff d0             	callq  *%r8
				break;
			default:
				if (i >= PDX(KERNBASE)) {
  80042050f2:	48 83 7d e8 1f       	cmpq   $0x1f,-0x18(%rbp)
  80042050f7:	0f 86 bb 00 00 00    	jbe    80042051b8 <check_boot_pml4e+0x70f>
					if (pgdir[i] & PTE_P)
  80042050fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205101:	48 c1 e0 03          	shl    $0x3,%rax
  8004205105:	48 03 85 68 ff ff ff 	add    -0x98(%rbp),%rax
  800420510c:	48 8b 00             	mov    (%rax),%rax
  800420510f:	83 e0 01             	and    $0x1,%eax
  8004205112:	84 c0                	test   %al,%al
  8004205114:	74 53                	je     8004205169 <check_boot_pml4e+0x6c0>
                        assert(pgdir[i] & PTE_W);
  8004205116:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420511a:	48 c1 e0 03          	shl    $0x3,%rax
  800420511e:	48 03 85 68 ff ff ff 	add    -0x98(%rbp),%rax
  8004205125:	48 8b 00             	mov    (%rax),%rax
  8004205128:	83 e0 02             	and    $0x2,%eax
  800420512b:	48 85 c0             	test   %rax,%rax
  800420512e:	0f 85 84 00 00 00    	jne    80042051b8 <check_boot_pml4e+0x70f>
  8004205134:	48 b9 94 79 21 04 80 	movabs $0x8004217994,%rcx
  800420513b:	00 00 00 
  800420513e:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205145:	00 00 00 
  8004205148:	be d4 04 00 00       	mov    $0x4d4,%esi
  800420514d:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205154:	00 00 00 
  8004205157:	b8 00 00 00 00       	mov    $0x0,%eax
  800420515c:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004205163:	00 00 00 
  8004205166:	41 ff d0             	callq  *%r8
                    else
                        assert(pgdir[i] == 0);
  8004205169:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420516d:	48 c1 e0 03          	shl    $0x3,%rax
  8004205171:	48 03 85 68 ff ff ff 	add    -0x98(%rbp),%rax
  8004205178:	48 8b 00             	mov    (%rax),%rax
  800420517b:	48 85 c0             	test   %rax,%rax
  800420517e:	74 38                	je     80042051b8 <check_boot_pml4e+0x70f>
  8004205180:	48 b9 a5 79 21 04 80 	movabs $0x80042179a5,%rcx
  8004205187:	00 00 00 
  800420518a:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205191:	00 00 00 
  8004205194:	be d6 04 00 00       	mov    $0x4d6,%esi
  8004205199:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042051a0:	00 00 00 
  80042051a3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042051a8:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042051af:	00 00 00 
  80042051b2:	41 ff d0             	callq  *%r8
			//case PDX(UVPT):
			case PDX(KSTACKTOP - 1):
			case PDX(UPAGES):
			case PDX(UENVS):
				assert(pgdir[i] & PTE_P);
				break;
  80042051b5:	90                   	nop
  80042051b6:	eb 01                	jmp    80042051b9 <check_boot_pml4e+0x710>
					if (pgdir[i] & PTE_P)
                        assert(pgdir[i] & PTE_W);
                    else
                        assert(pgdir[i] == 0);
				} 
				break;
  80042051b8:	90                   	nop
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  80042051b9:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  80042051be:	48 81 7d e8 ff 01 00 	cmpq   $0x1ff,-0x18(%rbp)
  80042051c5:	00 
  80042051c6:	0f 86 ae fe ff ff    	jbe    800420507a <check_boot_pml4e+0x5d1>
                        assert(pgdir[i] == 0);
				} 
				break;
		}
	}
	cprintf("check_boot_pml4e() succeeded!\n");
  80042051cc:	48 bf b8 79 21 04 80 	movabs $0x80042179b8,%rdi
  80042051d3:	00 00 00 
  80042051d6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042051db:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  80042051e2:	00 00 00 
  80042051e5:	ff d2                	callq  *%rdx
}
  80042051e7:	48 81 c4 a8 00 00 00 	add    $0xa8,%rsp
  80042051ee:	5b                   	pop    %rbx
  80042051ef:	5d                   	pop    %rbp
  80042051f0:	c3                   	retq   

00000080042051f1 <check_va2pa>:
// this functionality for us!  We define our own version to help check
// the check_boot_pml4e() function; it shouldn't be used elsewhere.

	static physaddr_t
check_va2pa(pml4e_t *pml4e, uintptr_t va)
{
  80042051f1:	55                   	push   %rbp
  80042051f2:	48 89 e5             	mov    %rsp,%rbp
  80042051f5:	48 83 ec 60          	sub    $0x60,%rsp
  80042051f9:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  80042051fd:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	pte_t *pte;
	pdpe_t *pdpe;
	pde_t *pde;
	// cprintf("%x", va);
	pml4e = &pml4e[PML4(va)];
  8004205201:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205205:	48 c1 e8 27          	shr    $0x27,%rax
  8004205209:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420520e:	48 c1 e0 03          	shl    $0x3,%rax
  8004205212:	48 01 45 a8          	add    %rax,-0x58(%rbp)
	// cprintf(" %x %x " , PML4(va), *pml4e);
	if(!(*pml4e & PTE_P))
  8004205216:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420521a:	48 8b 00             	mov    (%rax),%rax
  800420521d:	83 e0 01             	and    $0x1,%eax
  8004205220:	48 85 c0             	test   %rax,%rax
  8004205223:	75 0c                	jne    8004205231 <check_va2pa+0x40>
		return ~0;
  8004205225:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  800420522c:	e9 13 02 00 00       	jmpq   8004205444 <check_va2pa+0x253>
	pdpe = (pdpe_t *) KADDR(PTE_ADDR(*pml4e));
  8004205231:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205235:	48 8b 00             	mov    (%rax),%rax
  8004205238:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420523e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004205242:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205246:	48 c1 e8 0c          	shr    $0xc,%rax
  800420524a:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800420524d:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004205250:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004205257:	00 00 00 
  800420525a:	48 8b 00             	mov    (%rax),%rax
  800420525d:	48 39 c2             	cmp    %rax,%rdx
  8004205260:	72 32                	jb     8004205294 <check_va2pa+0xa3>
  8004205262:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205266:	48 89 c1             	mov    %rax,%rcx
  8004205269:	48 ba 60 73 21 04 80 	movabs $0x8004217360,%rdx
  8004205270:	00 00 00 
  8004205273:	be ee 04 00 00       	mov    $0x4ee,%esi
  8004205278:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420527f:	00 00 00 
  8004205282:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205287:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420528e:	00 00 00 
  8004205291:	41 ff d0             	callq  *%r8
  8004205294:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  800420529b:	00 00 00 
  800420529e:	48 03 45 f8          	add    -0x8(%rbp),%rax
  80042052a2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	// cprintf(" %x %x " , pdpe, *pdpe);
	if (!(pdpe[PDPE(va)] & PTE_P))
  80042052a6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042052aa:	48 c1 e8 1e          	shr    $0x1e,%rax
  80042052ae:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042052b3:	48 c1 e0 03          	shl    $0x3,%rax
  80042052b7:	48 03 45 e8          	add    -0x18(%rbp),%rax
  80042052bb:	48 8b 00             	mov    (%rax),%rax
  80042052be:	83 e0 01             	and    $0x1,%eax
  80042052c1:	48 85 c0             	test   %rax,%rax
  80042052c4:	75 0c                	jne    80042052d2 <check_va2pa+0xe1>
		return ~0;
  80042052c6:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  80042052cd:	e9 72 01 00 00       	jmpq   8004205444 <check_va2pa+0x253>
	pde = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  80042052d2:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042052d6:	48 c1 e8 1e          	shr    $0x1e,%rax
  80042052da:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042052df:	48 c1 e0 03          	shl    $0x3,%rax
  80042052e3:	48 03 45 e8          	add    -0x18(%rbp),%rax
  80042052e7:	48 8b 00             	mov    (%rax),%rax
  80042052ea:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042052f0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042052f4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042052f8:	48 c1 e8 0c          	shr    $0xc,%rax
  80042052fc:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042052ff:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004205302:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004205309:	00 00 00 
  800420530c:	48 8b 00             	mov    (%rax),%rax
  800420530f:	48 39 c2             	cmp    %rax,%rdx
  8004205312:	72 32                	jb     8004205346 <check_va2pa+0x155>
  8004205314:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205318:	48 89 c1             	mov    %rax,%rcx
  800420531b:	48 ba 60 73 21 04 80 	movabs $0x8004217360,%rdx
  8004205322:	00 00 00 
  8004205325:	be f2 04 00 00       	mov    $0x4f2,%esi
  800420532a:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205331:	00 00 00 
  8004205334:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205339:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004205340:	00 00 00 
  8004205343:	41 ff d0             	callq  *%r8
  8004205346:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  800420534d:	00 00 00 
  8004205350:	48 03 45 e0          	add    -0x20(%rbp),%rax
  8004205354:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	// cprintf(" %x %x " , pde, *pde);
	pde = &pde[PDX(va)];
  8004205358:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420535c:	48 c1 e8 15          	shr    $0x15,%rax
  8004205360:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205365:	48 c1 e0 03          	shl    $0x3,%rax
  8004205369:	48 01 45 d0          	add    %rax,-0x30(%rbp)
	if (!(*pde & PTE_P))
  800420536d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205371:	48 8b 00             	mov    (%rax),%rax
  8004205374:	83 e0 01             	and    $0x1,%eax
  8004205377:	48 85 c0             	test   %rax,%rax
  800420537a:	75 0c                	jne    8004205388 <check_va2pa+0x197>
		return ~0;
  800420537c:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205383:	e9 bc 00 00 00       	jmpq   8004205444 <check_va2pa+0x253>
	pte = (pte_t*) KADDR(PTE_ADDR(*pde));
  8004205388:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420538c:	48 8b 00             	mov    (%rax),%rax
  800420538f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205395:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205399:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420539d:	48 c1 e8 0c          	shr    $0xc,%rax
  80042053a1:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  80042053a4:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042053a7:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  80042053ae:	00 00 00 
  80042053b1:	48 8b 00             	mov    (%rax),%rax
  80042053b4:	48 39 c2             	cmp    %rax,%rdx
  80042053b7:	72 32                	jb     80042053eb <check_va2pa+0x1fa>
  80042053b9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042053bd:	48 89 c1             	mov    %rax,%rcx
  80042053c0:	48 ba 60 73 21 04 80 	movabs $0x8004217360,%rdx
  80042053c7:	00 00 00 
  80042053ca:	be f7 04 00 00       	mov    $0x4f7,%esi
  80042053cf:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042053d6:	00 00 00 
  80042053d9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042053de:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042053e5:	00 00 00 
  80042053e8:	41 ff d0             	callq  *%r8
  80042053eb:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  80042053f2:	00 00 00 
  80042053f5:	48 03 45 c8          	add    -0x38(%rbp),%rax
  80042053f9:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	// cprintf(" %x %x " , pte, *pte);
	if (!(pte[PTX(va)] & PTE_P))
  80042053fd:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205401:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205405:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420540a:	48 c1 e0 03          	shl    $0x3,%rax
  800420540e:	48 03 45 b8          	add    -0x48(%rbp),%rax
  8004205412:	48 8b 00             	mov    (%rax),%rax
  8004205415:	83 e0 01             	and    $0x1,%eax
  8004205418:	48 85 c0             	test   %rax,%rax
  800420541b:	75 09                	jne    8004205426 <check_va2pa+0x235>
		return ~0;
  800420541d:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205424:	eb 1e                	jmp    8004205444 <check_va2pa+0x253>
	// cprintf(" %x %x\n" , PTX(va),  PTE_ADDR(pte[PTX(va)]));
	return PTE_ADDR(pte[PTX(va)]);
  8004205426:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420542a:	48 c1 e8 0c          	shr    $0xc,%rax
  800420542e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205433:	48 c1 e0 03          	shl    $0x3,%rax
  8004205437:	48 03 45 b8          	add    -0x48(%rbp),%rax
  800420543b:	48 8b 00             	mov    (%rax),%rax
  800420543e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
}
  8004205444:	c9                   	leaveq 
  8004205445:	c3                   	retq   

0000008004205446 <page_check>:


// check page_insert, page_remove, &c
static void
page_check(void)
{
  8004205446:	55                   	push   %rbp
  8004205447:	48 89 e5             	mov    %rsp,%rbp
  800420544a:	53                   	push   %rbx
  800420544b:	48 81 ec 18 01 00 00 	sub    $0x118,%rsp
	pdpe_t *pdpe;
	pde_t *pde;
	void *va;
	int i;
	uintptr_t mm1, mm2;
	pp0 = pp1 = pp2 = pp3 = pp4 = pp5 =0;
  8004205452:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004205459:	00 
  800420545a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420545e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004205462:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205466:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420546a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420546e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205472:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205476:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800420547a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420547e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	assert(pp0 = page_alloc(0));
  8004205482:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205487:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  800420548e:	00 00 00 
  8004205491:	ff d0                	callq  *%rax
  8004205493:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004205497:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  800420549c:	75 35                	jne    80042054d3 <page_check+0x8d>
  800420549e:	48 b9 d7 79 21 04 80 	movabs $0x80042179d7,%rcx
  80042054a5:	00 00 00 
  80042054a8:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042054af:	00 00 00 
  80042054b2:	be 0d 05 00 00       	mov    $0x50d,%esi
  80042054b7:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042054be:	00 00 00 
  80042054c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042054c6:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042054cd:	00 00 00 
  80042054d0:	41 ff d0             	callq  *%r8
	assert(pp1 = page_alloc(0));
  80042054d3:	bf 00 00 00 00       	mov    $0x0,%edi
  80042054d8:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  80042054df:	00 00 00 
  80042054e2:	ff d0                	callq  *%rax
  80042054e4:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80042054e8:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  80042054ed:	75 35                	jne    8004205524 <page_check+0xde>
  80042054ef:	48 b9 eb 79 21 04 80 	movabs $0x80042179eb,%rcx
  80042054f6:	00 00 00 
  80042054f9:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205500:	00 00 00 
  8004205503:	be 0e 05 00 00       	mov    $0x50e,%esi
  8004205508:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420550f:	00 00 00 
  8004205512:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205517:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420551e:	00 00 00 
  8004205521:	41 ff d0             	callq  *%r8
	assert(pp2 = page_alloc(0));
  8004205524:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205529:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  8004205530:	00 00 00 
  8004205533:	ff d0                	callq  *%rax
  8004205535:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205539:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420553e:	75 35                	jne    8004205575 <page_check+0x12f>
  8004205540:	48 b9 ff 79 21 04 80 	movabs $0x80042179ff,%rcx
  8004205547:	00 00 00 
  800420554a:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205551:	00 00 00 
  8004205554:	be 0f 05 00 00       	mov    $0x50f,%esi
  8004205559:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205560:	00 00 00 
  8004205563:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205568:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420556f:	00 00 00 
  8004205572:	41 ff d0             	callq  *%r8
	assert(pp3 = page_alloc(0));
  8004205575:	bf 00 00 00 00       	mov    $0x0,%edi
  800420557a:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  8004205581:	00 00 00 
  8004205584:	ff d0                	callq  *%rax
  8004205586:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420558a:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420558f:	75 35                	jne    80042055c6 <page_check+0x180>
  8004205591:	48 b9 13 7a 21 04 80 	movabs $0x8004217a13,%rcx
  8004205598:	00 00 00 
  800420559b:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042055a2:	00 00 00 
  80042055a5:	be 10 05 00 00       	mov    $0x510,%esi
  80042055aa:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042055b1:	00 00 00 
  80042055b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042055b9:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042055c0:	00 00 00 
  80042055c3:	41 ff d0             	callq  *%r8
	assert(pp4 = page_alloc(0));
  80042055c6:	bf 00 00 00 00       	mov    $0x0,%edi
  80042055cb:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  80042055d2:	00 00 00 
  80042055d5:	ff d0                	callq  *%rax
  80042055d7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042055db:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042055e0:	75 35                	jne    8004205617 <page_check+0x1d1>
  80042055e2:	48 b9 27 7a 21 04 80 	movabs $0x8004217a27,%rcx
  80042055e9:	00 00 00 
  80042055ec:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042055f3:	00 00 00 
  80042055f6:	be 11 05 00 00       	mov    $0x511,%esi
  80042055fb:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205602:	00 00 00 
  8004205605:	b8 00 00 00 00       	mov    $0x0,%eax
  800420560a:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004205611:	00 00 00 
  8004205614:	41 ff d0             	callq  *%r8
	assert(pp5 = page_alloc(0));
  8004205617:	bf 00 00 00 00       	mov    $0x0,%edi
  800420561c:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  8004205623:	00 00 00 
  8004205626:	ff d0                	callq  *%rax
  8004205628:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420562c:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205631:	75 35                	jne    8004205668 <page_check+0x222>
  8004205633:	48 b9 3b 7a 21 04 80 	movabs $0x8004217a3b,%rcx
  800420563a:	00 00 00 
  800420563d:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205644:	00 00 00 
  8004205647:	be 12 05 00 00       	mov    $0x512,%esi
  800420564c:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205653:	00 00 00 
  8004205656:	b8 00 00 00 00       	mov    $0x0,%eax
  800420565b:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004205662:	00 00 00 
  8004205665:	41 ff d0             	callq  *%r8

	assert(pp0);
  8004205668:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  800420566d:	75 35                	jne    80042056a4 <page_check+0x25e>
  800420566f:	48 b9 89 77 21 04 80 	movabs $0x8004217789,%rcx
  8004205676:	00 00 00 
  8004205679:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205680:	00 00 00 
  8004205683:	be 14 05 00 00       	mov    $0x514,%esi
  8004205688:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420568f:	00 00 00 
  8004205692:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205697:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420569e:	00 00 00 
  80042056a1:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  80042056a4:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  80042056a9:	74 0a                	je     80042056b5 <page_check+0x26f>
  80042056ab:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042056af:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042056b3:	75 35                	jne    80042056ea <page_check+0x2a4>
  80042056b5:	48 b9 8d 77 21 04 80 	movabs $0x800421778d,%rcx
  80042056bc:	00 00 00 
  80042056bf:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042056c6:	00 00 00 
  80042056c9:	be 15 05 00 00       	mov    $0x515,%esi
  80042056ce:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042056d5:	00 00 00 
  80042056d8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042056dd:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042056e4:	00 00 00 
  80042056e7:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  80042056ea:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042056ef:	74 14                	je     8004205705 <page_check+0x2bf>
  80042056f1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042056f5:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  80042056f9:	74 0a                	je     8004205705 <page_check+0x2bf>
  80042056fb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042056ff:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205703:	75 35                	jne    800420573a <page_check+0x2f4>
  8004205705:	48 b9 a0 77 21 04 80 	movabs $0x80042177a0,%rcx
  800420570c:	00 00 00 
  800420570f:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205716:	00 00 00 
  8004205719:	be 16 05 00 00       	mov    $0x516,%esi
  800420571e:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205725:	00 00 00 
  8004205728:	b8 00 00 00 00       	mov    $0x0,%eax
  800420572d:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004205734:	00 00 00 
  8004205737:	41 ff d0             	callq  *%r8
	assert(pp3 && pp3 != pp2 && pp3 != pp1 && pp3 != pp0);
  800420573a:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420573f:	74 1e                	je     800420575f <page_check+0x319>
  8004205741:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205745:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205749:	74 14                	je     800420575f <page_check+0x319>
  800420574b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420574f:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205753:	74 0a                	je     800420575f <page_check+0x319>
  8004205755:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205759:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  800420575d:	75 35                	jne    8004205794 <page_check+0x34e>
  800420575f:	48 b9 50 7a 21 04 80 	movabs $0x8004217a50,%rcx
  8004205766:	00 00 00 
  8004205769:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205770:	00 00 00 
  8004205773:	be 17 05 00 00       	mov    $0x517,%esi
  8004205778:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420577f:	00 00 00 
  8004205782:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205787:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420578e:	00 00 00 
  8004205791:	41 ff d0             	callq  *%r8
	assert(pp4 && pp4 != pp3 && pp4 != pp2 && pp4 != pp1 && pp4 != pp0);
  8004205794:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205799:	74 28                	je     80042057c3 <page_check+0x37d>
  800420579b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420579f:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042057a3:	74 1e                	je     80042057c3 <page_check+0x37d>
  80042057a5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042057a9:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042057ad:	74 14                	je     80042057c3 <page_check+0x37d>
  80042057af:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042057b3:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  80042057b7:	74 0a                	je     80042057c3 <page_check+0x37d>
  80042057b9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042057bd:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042057c1:	75 35                	jne    80042057f8 <page_check+0x3b2>
  80042057c3:	48 b9 80 7a 21 04 80 	movabs $0x8004217a80,%rcx
  80042057ca:	00 00 00 
  80042057cd:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042057d4:	00 00 00 
  80042057d7:	be 18 05 00 00       	mov    $0x518,%esi
  80042057dc:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042057e3:	00 00 00 
  80042057e6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042057eb:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042057f2:	00 00 00 
  80042057f5:	41 ff d0             	callq  *%r8
	assert(pp5 && pp5 != pp4 && pp5 != pp3 && pp5 != pp2 && pp5 != pp1 && pp5 != pp0);
  80042057f8:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042057fd:	74 32                	je     8004205831 <page_check+0x3eb>
  80042057ff:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205803:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004205807:	74 28                	je     8004205831 <page_check+0x3eb>
  8004205809:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420580d:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205811:	74 1e                	je     8004205831 <page_check+0x3eb>
  8004205813:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205817:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  800420581b:	74 14                	je     8004205831 <page_check+0x3eb>
  800420581d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205821:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205825:	74 0a                	je     8004205831 <page_check+0x3eb>
  8004205827:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420582b:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  800420582f:	75 35                	jne    8004205866 <page_check+0x420>
  8004205831:	48 b9 c0 7a 21 04 80 	movabs $0x8004217ac0,%rcx
  8004205838:	00 00 00 
  800420583b:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205842:	00 00 00 
  8004205845:	be 19 05 00 00       	mov    $0x519,%esi
  800420584a:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205851:	00 00 00 
  8004205854:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205859:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004205860:	00 00 00 
  8004205863:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004205866:	48 b8 38 b2 63 04 80 	movabs $0x800463b238,%rax
  800420586d:	00 00 00 
  8004205870:	48 8b 00             	mov    (%rax),%rax
  8004205873:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	page_free_list = NULL;
  8004205877:	48 b8 38 b2 63 04 80 	movabs $0x800463b238,%rax
  800420587e:	00 00 00 
  8004205881:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  8004205888:	bf 00 00 00 00       	mov    $0x0,%edi
  800420588d:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  8004205894:	00 00 00 
  8004205897:	ff d0                	callq  *%rax
  8004205899:	48 85 c0             	test   %rax,%rax
  800420589c:	74 35                	je     80042058d3 <page_check+0x48d>
  800420589e:	48 b9 17 78 21 04 80 	movabs $0x8004217817,%rcx
  80042058a5:	00 00 00 
  80042058a8:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042058af:	00 00 00 
  80042058b2:	be 20 05 00 00       	mov    $0x520,%esi
  80042058b7:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042058be:	00 00 00 
  80042058c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042058c6:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042058cd:	00 00 00 
  80042058d0:	41 ff d0             	callq  *%r8

	// there is no page allocated at address 0
	assert(page_lookup(boot_pml4e, (void *) 0x0, &ptep) == NULL);
  80042058d3:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  80042058da:	00 00 00 
  80042058dd:	48 8b 00             	mov    (%rax),%rax
  80042058e0:	48 8d 95 e8 fe ff ff 	lea    -0x118(%rbp),%rdx
  80042058e7:	be 00 00 00 00       	mov    $0x0,%esi
  80042058ec:	48 89 c7             	mov    %rax,%rdi
  80042058ef:	48 b8 86 36 20 04 80 	movabs $0x8004203686,%rax
  80042058f6:	00 00 00 
  80042058f9:	ff d0                	callq  *%rax
  80042058fb:	48 85 c0             	test   %rax,%rax
  80042058fe:	74 35                	je     8004205935 <page_check+0x4ef>
  8004205900:	48 b9 10 7b 21 04 80 	movabs $0x8004217b10,%rcx
  8004205907:	00 00 00 
  800420590a:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205911:	00 00 00 
  8004205914:	be 23 05 00 00       	mov    $0x523,%esi
  8004205919:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205920:	00 00 00 
  8004205923:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205928:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420592f:	00 00 00 
  8004205932:	41 ff d0             	callq  *%r8

	// there is no free memory, so we can't allocate a page table 
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  8004205935:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  800420593c:	00 00 00 
  800420593f:	48 8b 00             	mov    (%rax),%rax
  8004205942:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205946:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420594b:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205950:	48 89 c7             	mov    %rax,%rdi
  8004205953:	48 b8 4b 35 20 04 80 	movabs $0x800420354b,%rax
  800420595a:	00 00 00 
  800420595d:	ff d0                	callq  *%rax
  800420595f:	85 c0                	test   %eax,%eax
  8004205961:	78 35                	js     8004205998 <page_check+0x552>
  8004205963:	48 b9 48 7b 21 04 80 	movabs $0x8004217b48,%rcx
  800420596a:	00 00 00 
  800420596d:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205974:	00 00 00 
  8004205977:	be 26 05 00 00       	mov    $0x526,%esi
  800420597c:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205983:	00 00 00 
  8004205986:	b8 00 00 00 00       	mov    $0x0,%eax
  800420598b:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004205992:	00 00 00 
  8004205995:	41 ff d0             	callq  *%r8

	// free pp0 and try again: pp0 should be used for page table
	page_free(pp0);
  8004205998:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420599c:	48 89 c7             	mov    %rax,%rdi
  800420599f:	48 b8 85 2d 20 04 80 	movabs $0x8004202d85,%rax
  80042059a6:	00 00 00 
  80042059a9:	ff d0                	callq  *%rax
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  80042059ab:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  80042059b2:	00 00 00 
  80042059b5:	48 8b 00             	mov    (%rax),%rax
  80042059b8:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042059bc:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042059c1:	ba 00 00 00 00       	mov    $0x0,%edx
  80042059c6:	48 89 c7             	mov    %rax,%rdi
  80042059c9:	48 b8 4b 35 20 04 80 	movabs $0x800420354b,%rax
  80042059d0:	00 00 00 
  80042059d3:	ff d0                	callq  *%rax
  80042059d5:	85 c0                	test   %eax,%eax
  80042059d7:	78 35                	js     8004205a0e <page_check+0x5c8>
  80042059d9:	48 b9 48 7b 21 04 80 	movabs $0x8004217b48,%rcx
  80042059e0:	00 00 00 
  80042059e3:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042059ea:	00 00 00 
  80042059ed:	be 2a 05 00 00       	mov    $0x52a,%esi
  80042059f2:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042059f9:	00 00 00 
  80042059fc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a01:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004205a08:	00 00 00 
  8004205a0b:	41 ff d0             	callq  *%r8
	page_free(pp2);
  8004205a0e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205a12:	48 89 c7             	mov    %rax,%rdi
  8004205a15:	48 b8 85 2d 20 04 80 	movabs $0x8004202d85,%rax
  8004205a1c:	00 00 00 
  8004205a1f:	ff d0                	callq  *%rax
	page_free(pp3);
  8004205a21:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205a25:	48 89 c7             	mov    %rax,%rdi
  8004205a28:	48 b8 85 2d 20 04 80 	movabs $0x8004202d85,%rax
  8004205a2f:	00 00 00 
  8004205a32:	ff d0                	callq  *%rax
	//cprintf("pp1 ref count = %d\n",pp1->pp_ref);
	//cprintf("pp0 ref count = %d\n",pp0->pp_ref);
	//cprintf("pp2 ref count = %d\n",pp2->pp_ref);
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) == 0);
  8004205a34:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004205a3b:	00 00 00 
  8004205a3e:	48 8b 00             	mov    (%rax),%rax
  8004205a41:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205a45:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205a4a:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205a4f:	48 89 c7             	mov    %rax,%rdi
  8004205a52:	48 b8 4b 35 20 04 80 	movabs $0x800420354b,%rax
  8004205a59:	00 00 00 
  8004205a5c:	ff d0                	callq  *%rax
  8004205a5e:	85 c0                	test   %eax,%eax
  8004205a60:	74 35                	je     8004205a97 <page_check+0x651>
  8004205a62:	48 b9 78 7b 21 04 80 	movabs $0x8004217b78,%rcx
  8004205a69:	00 00 00 
  8004205a6c:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205a73:	00 00 00 
  8004205a76:	be 30 05 00 00       	mov    $0x530,%esi
  8004205a7b:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205a82:	00 00 00 
  8004205a85:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a8a:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004205a91:	00 00 00 
  8004205a94:	41 ff d0             	callq  *%r8
	assert((PTE_ADDR(boot_pml4e[0]) == page2pa(pp0) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp2) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp3) ));
  8004205a97:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004205a9e:	00 00 00 
  8004205aa1:	48 8b 00             	mov    (%rax),%rax
  8004205aa4:	48 8b 00             	mov    (%rax),%rax
  8004205aa7:	48 89 c3             	mov    %rax,%rbx
  8004205aaa:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
  8004205ab1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205ab5:	48 89 c7             	mov    %rax,%rdi
  8004205ab8:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  8004205abf:	00 00 00 
  8004205ac2:	ff d0                	callq  *%rax
  8004205ac4:	48 39 c3             	cmp    %rax,%rbx
  8004205ac7:	0f 84 99 00 00 00    	je     8004205b66 <page_check+0x720>
  8004205acd:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004205ad4:	00 00 00 
  8004205ad7:	48 8b 00             	mov    (%rax),%rax
  8004205ada:	48 8b 00             	mov    (%rax),%rax
  8004205add:	48 89 c3             	mov    %rax,%rbx
  8004205ae0:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
  8004205ae7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205aeb:	48 89 c7             	mov    %rax,%rdi
  8004205aee:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  8004205af5:	00 00 00 
  8004205af8:	ff d0                	callq  *%rax
  8004205afa:	48 39 c3             	cmp    %rax,%rbx
  8004205afd:	74 67                	je     8004205b66 <page_check+0x720>
  8004205aff:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004205b06:	00 00 00 
  8004205b09:	48 8b 00             	mov    (%rax),%rax
  8004205b0c:	48 8b 00             	mov    (%rax),%rax
  8004205b0f:	48 89 c3             	mov    %rax,%rbx
  8004205b12:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
  8004205b19:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205b1d:	48 89 c7             	mov    %rax,%rdi
  8004205b20:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  8004205b27:	00 00 00 
  8004205b2a:	ff d0                	callq  *%rax
  8004205b2c:	48 39 c3             	cmp    %rax,%rbx
  8004205b2f:	74 35                	je     8004205b66 <page_check+0x720>
  8004205b31:	48 b9 a8 7b 21 04 80 	movabs $0x8004217ba8,%rcx
  8004205b38:	00 00 00 
  8004205b3b:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205b42:	00 00 00 
  8004205b45:	be 31 05 00 00       	mov    $0x531,%esi
  8004205b4a:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205b51:	00 00 00 
  8004205b54:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b59:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004205b60:	00 00 00 
  8004205b63:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, 0x0) == page2pa(pp1));
  8004205b66:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004205b6d:	00 00 00 
  8004205b70:	48 8b 00             	mov    (%rax),%rax
  8004205b73:	be 00 00 00 00       	mov    $0x0,%esi
  8004205b78:	48 89 c7             	mov    %rax,%rdi
  8004205b7b:	48 b8 f1 51 20 04 80 	movabs $0x80042051f1,%rax
  8004205b82:	00 00 00 
  8004205b85:	ff d0                	callq  *%rax
  8004205b87:	48 89 c3             	mov    %rax,%rbx
  8004205b8a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205b8e:	48 89 c7             	mov    %rax,%rdi
  8004205b91:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  8004205b98:	00 00 00 
  8004205b9b:	ff d0                	callq  *%rax
  8004205b9d:	48 39 c3             	cmp    %rax,%rbx
  8004205ba0:	74 35                	je     8004205bd7 <page_check+0x791>
  8004205ba2:	48 b9 30 7c 21 04 80 	movabs $0x8004217c30,%rcx
  8004205ba9:	00 00 00 
  8004205bac:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205bb3:	00 00 00 
  8004205bb6:	be 32 05 00 00       	mov    $0x532,%esi
  8004205bbb:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205bc2:	00 00 00 
  8004205bc5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205bca:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004205bd1:	00 00 00 
  8004205bd4:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004205bd7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205bdb:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205bdf:	66 83 f8 01          	cmp    $0x1,%ax
  8004205be3:	74 35                	je     8004205c1a <page_check+0x7d4>
  8004205be5:	48 b9 5d 7c 21 04 80 	movabs $0x8004217c5d,%rcx
  8004205bec:	00 00 00 
  8004205bef:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205bf6:	00 00 00 
  8004205bf9:	be 33 05 00 00       	mov    $0x533,%esi
  8004205bfe:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205c05:	00 00 00 
  8004205c08:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c0d:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004205c14:	00 00 00 
  8004205c17:	41 ff d0             	callq  *%r8
	assert(pp0->pp_ref == 1);
  8004205c1a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205c1e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205c22:	66 83 f8 01          	cmp    $0x1,%ax
  8004205c26:	74 35                	je     8004205c5d <page_check+0x817>
  8004205c28:	48 b9 6e 7c 21 04 80 	movabs $0x8004217c6e,%rcx
  8004205c2f:	00 00 00 
  8004205c32:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205c39:	00 00 00 
  8004205c3c:	be 34 05 00 00       	mov    $0x534,%esi
  8004205c41:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205c48:	00 00 00 
  8004205c4b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c50:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004205c57:	00 00 00 
  8004205c5a:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 1);
  8004205c5d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205c61:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205c65:	66 83 f8 01          	cmp    $0x1,%ax
  8004205c69:	74 35                	je     8004205ca0 <page_check+0x85a>
  8004205c6b:	48 b9 7f 7c 21 04 80 	movabs $0x8004217c7f,%rcx
  8004205c72:	00 00 00 
  8004205c75:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205c7c:	00 00 00 
  8004205c7f:	be 35 05 00 00       	mov    $0x535,%esi
  8004205c84:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205c8b:	00 00 00 
  8004205c8e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c93:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004205c9a:	00 00 00 
  8004205c9d:	41 ff d0             	callq  *%r8
	//should be able to map pp3 at PGSIZE because pp0 is already allocated for page table
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004205ca0:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004205ca7:	00 00 00 
  8004205caa:	48 8b 00             	mov    (%rax),%rax
  8004205cad:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004205cb1:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205cb6:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205cbb:	48 89 c7             	mov    %rax,%rdi
  8004205cbe:	48 b8 4b 35 20 04 80 	movabs $0x800420354b,%rax
  8004205cc5:	00 00 00 
  8004205cc8:	ff d0                	callq  *%rax
  8004205cca:	85 c0                	test   %eax,%eax
  8004205ccc:	74 35                	je     8004205d03 <page_check+0x8bd>
  8004205cce:	48 b9 90 7c 21 04 80 	movabs $0x8004217c90,%rcx
  8004205cd5:	00 00 00 
  8004205cd8:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205cdf:	00 00 00 
  8004205ce2:	be 37 05 00 00       	mov    $0x537,%esi
  8004205ce7:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205cee:	00 00 00 
  8004205cf1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205cf6:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004205cfd:	00 00 00 
  8004205d00:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004205d03:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004205d0a:	00 00 00 
  8004205d0d:	48 8b 00             	mov    (%rax),%rax
  8004205d10:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205d15:	48 89 c7             	mov    %rax,%rdi
  8004205d18:	48 b8 f1 51 20 04 80 	movabs $0x80042051f1,%rax
  8004205d1f:	00 00 00 
  8004205d22:	ff d0                	callq  *%rax
  8004205d24:	48 89 c3             	mov    %rax,%rbx
  8004205d27:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205d2b:	48 89 c7             	mov    %rax,%rdi
  8004205d2e:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  8004205d35:	00 00 00 
  8004205d38:	ff d0                	callq  *%rax
  8004205d3a:	48 39 c3             	cmp    %rax,%rbx
  8004205d3d:	74 35                	je     8004205d74 <page_check+0x92e>
  8004205d3f:	48 b9 c8 7c 21 04 80 	movabs $0x8004217cc8,%rcx
  8004205d46:	00 00 00 
  8004205d49:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205d50:	00 00 00 
  8004205d53:	be 38 05 00 00       	mov    $0x538,%esi
  8004205d58:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205d5f:	00 00 00 
  8004205d62:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d67:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004205d6e:	00 00 00 
  8004205d71:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004205d74:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205d78:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205d7c:	66 83 f8 02          	cmp    $0x2,%ax
  8004205d80:	74 35                	je     8004205db7 <page_check+0x971>
  8004205d82:	48 b9 f8 7c 21 04 80 	movabs $0x8004217cf8,%rcx
  8004205d89:	00 00 00 
  8004205d8c:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205d93:	00 00 00 
  8004205d96:	be 39 05 00 00       	mov    $0x539,%esi
  8004205d9b:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205da2:	00 00 00 
  8004205da5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205daa:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004205db1:	00 00 00 
  8004205db4:	41 ff d0             	callq  *%r8

	// should be no free memory
	assert(!page_alloc(0));
  8004205db7:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205dbc:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  8004205dc3:	00 00 00 
  8004205dc6:	ff d0                	callq  *%rax
  8004205dc8:	48 85 c0             	test   %rax,%rax
  8004205dcb:	74 35                	je     8004205e02 <page_check+0x9bc>
  8004205dcd:	48 b9 17 78 21 04 80 	movabs $0x8004217817,%rcx
  8004205dd4:	00 00 00 
  8004205dd7:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205dde:	00 00 00 
  8004205de1:	be 3c 05 00 00       	mov    $0x53c,%esi
  8004205de6:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205ded:	00 00 00 
  8004205df0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205df5:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004205dfc:	00 00 00 
  8004205dff:	41 ff d0             	callq  *%r8

	// should be able to map pp3 at PGSIZE because it's already there
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004205e02:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004205e09:	00 00 00 
  8004205e0c:	48 8b 00             	mov    (%rax),%rax
  8004205e0f:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004205e13:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205e18:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205e1d:	48 89 c7             	mov    %rax,%rdi
  8004205e20:	48 b8 4b 35 20 04 80 	movabs $0x800420354b,%rax
  8004205e27:	00 00 00 
  8004205e2a:	ff d0                	callq  *%rax
  8004205e2c:	85 c0                	test   %eax,%eax
  8004205e2e:	74 35                	je     8004205e65 <page_check+0xa1f>
  8004205e30:	48 b9 90 7c 21 04 80 	movabs $0x8004217c90,%rcx
  8004205e37:	00 00 00 
  8004205e3a:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205e41:	00 00 00 
  8004205e44:	be 3f 05 00 00       	mov    $0x53f,%esi
  8004205e49:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205e50:	00 00 00 
  8004205e53:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e58:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004205e5f:	00 00 00 
  8004205e62:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004205e65:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004205e6c:	00 00 00 
  8004205e6f:	48 8b 00             	mov    (%rax),%rax
  8004205e72:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205e77:	48 89 c7             	mov    %rax,%rdi
  8004205e7a:	48 b8 f1 51 20 04 80 	movabs $0x80042051f1,%rax
  8004205e81:	00 00 00 
  8004205e84:	ff d0                	callq  *%rax
  8004205e86:	48 89 c3             	mov    %rax,%rbx
  8004205e89:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205e8d:	48 89 c7             	mov    %rax,%rdi
  8004205e90:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  8004205e97:	00 00 00 
  8004205e9a:	ff d0                	callq  *%rax
  8004205e9c:	48 39 c3             	cmp    %rax,%rbx
  8004205e9f:	74 35                	je     8004205ed6 <page_check+0xa90>
  8004205ea1:	48 b9 c8 7c 21 04 80 	movabs $0x8004217cc8,%rcx
  8004205ea8:	00 00 00 
  8004205eab:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205eb2:	00 00 00 
  8004205eb5:	be 40 05 00 00       	mov    $0x540,%esi
  8004205eba:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205ec1:	00 00 00 
  8004205ec4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ec9:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004205ed0:	00 00 00 
  8004205ed3:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004205ed6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205eda:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205ede:	66 83 f8 02          	cmp    $0x2,%ax
  8004205ee2:	74 35                	je     8004205f19 <page_check+0xad3>
  8004205ee4:	48 b9 f8 7c 21 04 80 	movabs $0x8004217cf8,%rcx
  8004205eeb:	00 00 00 
  8004205eee:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205ef5:	00 00 00 
  8004205ef8:	be 41 05 00 00       	mov    $0x541,%esi
  8004205efd:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205f04:	00 00 00 
  8004205f07:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f0c:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004205f13:	00 00 00 
  8004205f16:	41 ff d0             	callq  *%r8

	// pp3 should NOT be on the free list
	// could happen in ref counts are handled sloppily in page_insert
	assert(!page_alloc(0));
  8004205f19:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205f1e:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  8004205f25:	00 00 00 
  8004205f28:	ff d0                	callq  *%rax
  8004205f2a:	48 85 c0             	test   %rax,%rax
  8004205f2d:	74 35                	je     8004205f64 <page_check+0xb1e>
  8004205f2f:	48 b9 17 78 21 04 80 	movabs $0x8004217817,%rcx
  8004205f36:	00 00 00 
  8004205f39:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004205f40:	00 00 00 
  8004205f43:	be 45 05 00 00       	mov    $0x545,%esi
  8004205f48:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205f4f:	00 00 00 
  8004205f52:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f57:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004205f5e:	00 00 00 
  8004205f61:	41 ff d0             	callq  *%r8
	// check that pgdir_walk returns a pointer to the pte
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(PGSIZE)]));
  8004205f64:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004205f6b:	00 00 00 
  8004205f6e:	48 8b 00             	mov    (%rax),%rax
  8004205f71:	48 8b 00             	mov    (%rax),%rax
  8004205f74:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205f7a:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  8004205f7e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205f82:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205f86:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  8004205f89:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004205f8c:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004205f93:	00 00 00 
  8004205f96:	48 8b 00             	mov    (%rax),%rax
  8004205f99:	48 39 c2             	cmp    %rax,%rdx
  8004205f9c:	72 32                	jb     8004205fd0 <page_check+0xb8a>
  8004205f9e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205fa2:	48 89 c1             	mov    %rax,%rcx
  8004205fa5:	48 ba 60 73 21 04 80 	movabs $0x8004217360,%rdx
  8004205fac:	00 00 00 
  8004205faf:	be 47 05 00 00       	mov    $0x547,%esi
  8004205fb4:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004205fbb:	00 00 00 
  8004205fbe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205fc3:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004205fca:	00 00 00 
  8004205fcd:	41 ff d0             	callq  *%r8
  8004205fd0:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004205fd7:	00 00 00 
  8004205fda:	48 03 45 a8          	add    -0x58(%rbp),%rax
  8004205fde:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde = KADDR(PTE_ADDR(pdpe[PDPE(PGSIZE)]));
  8004205fe2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004205fe6:	48 8b 00             	mov    (%rax),%rax
  8004205fe9:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205fef:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  8004205ff3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205ff7:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205ffb:	89 45 8c             	mov    %eax,-0x74(%rbp)
  8004205ffe:	8b 55 8c             	mov    -0x74(%rbp),%edx
  8004206001:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004206008:	00 00 00 
  800420600b:	48 8b 00             	mov    (%rax),%rax
  800420600e:	48 39 c2             	cmp    %rax,%rdx
  8004206011:	72 32                	jb     8004206045 <page_check+0xbff>
  8004206013:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004206017:	48 89 c1             	mov    %rax,%rcx
  800420601a:	48 ba 60 73 21 04 80 	movabs $0x8004217360,%rdx
  8004206021:	00 00 00 
  8004206024:	be 48 05 00 00       	mov    $0x548,%esi
  8004206029:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004206030:	00 00 00 
  8004206033:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206038:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420603f:	00 00 00 
  8004206042:	41 ff d0             	callq  *%r8
  8004206045:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  800420604c:	00 00 00 
  800420604f:	48 03 45 90          	add    -0x70(%rbp),%rax
  8004206053:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep = KADDR(PTE_ADDR(pde[PDX(PGSIZE)]));
  8004206057:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800420605b:	48 8b 00             	mov    (%rax),%rax
  800420605e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206064:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  800420606b:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004206072:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206076:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
  800420607c:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
  8004206082:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004206089:	00 00 00 
  800420608c:	48 8b 00             	mov    (%rax),%rax
  800420608f:	48 39 c2             	cmp    %rax,%rdx
  8004206092:	72 35                	jb     80042060c9 <page_check+0xc83>
  8004206094:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420609b:	48 89 c1             	mov    %rax,%rcx
  800420609e:	48 ba 60 73 21 04 80 	movabs $0x8004217360,%rdx
  80042060a5:	00 00 00 
  80042060a8:	be 49 05 00 00       	mov    $0x549,%esi
  80042060ad:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042060b4:	00 00 00 
  80042060b7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042060bc:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042060c3:	00 00 00 
  80042060c6:	41 ff d0             	callq  *%r8
  80042060c9:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  80042060d0:	00 00 00 
  80042060d3:	48 03 85 78 ff ff ff 	add    -0x88(%rbp),%rax
  80042060da:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	assert(pml4e_walk(boot_pml4e, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
  80042060e1:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  80042060e8:	00 00 00 
  80042060eb:	48 8b 00             	mov    (%rax),%rax
  80042060ee:	ba 00 00 00 00       	mov    $0x0,%edx
  80042060f3:	be 00 10 00 00       	mov    $0x1000,%esi
  80042060f8:	48 89 c7             	mov    %rax,%rdi
  80042060fb:	48 b8 4f 2e 20 04 80 	movabs $0x8004202e4f,%rax
  8004206102:	00 00 00 
  8004206105:	ff d0                	callq  *%rax
  8004206107:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
  800420610e:	48 83 c2 08          	add    $0x8,%rdx
  8004206112:	48 39 d0             	cmp    %rdx,%rax
  8004206115:	74 35                	je     800420614c <page_check+0xd06>
  8004206117:	48 b9 10 7d 21 04 80 	movabs $0x8004217d10,%rcx
  800420611e:	00 00 00 
  8004206121:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004206128:	00 00 00 
  800420612b:	be 4a 05 00 00       	mov    $0x54a,%esi
  8004206130:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004206137:	00 00 00 
  800420613a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420613f:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004206146:	00 00 00 
  8004206149:	41 ff d0             	callq  *%r8

	// should be able to change permissions too.
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, PTE_U) == 0);
  800420614c:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004206153:	00 00 00 
  8004206156:	48 8b 00             	mov    (%rax),%rax
  8004206159:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420615d:	b9 04 00 00 00       	mov    $0x4,%ecx
  8004206162:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206167:	48 89 c7             	mov    %rax,%rdi
  800420616a:	48 b8 4b 35 20 04 80 	movabs $0x800420354b,%rax
  8004206171:	00 00 00 
  8004206174:	ff d0                	callq  *%rax
  8004206176:	85 c0                	test   %eax,%eax
  8004206178:	74 35                	je     80042061af <page_check+0xd69>
  800420617a:	48 b9 50 7d 21 04 80 	movabs $0x8004217d50,%rcx
  8004206181:	00 00 00 
  8004206184:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  800420618b:	00 00 00 
  800420618e:	be 4d 05 00 00       	mov    $0x54d,%esi
  8004206193:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420619a:	00 00 00 
  800420619d:	b8 00 00 00 00       	mov    $0x0,%eax
  80042061a2:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042061a9:	00 00 00 
  80042061ac:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  80042061af:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  80042061b6:	00 00 00 
  80042061b9:	48 8b 00             	mov    (%rax),%rax
  80042061bc:	be 00 10 00 00       	mov    $0x1000,%esi
  80042061c1:	48 89 c7             	mov    %rax,%rdi
  80042061c4:	48 b8 f1 51 20 04 80 	movabs $0x80042051f1,%rax
  80042061cb:	00 00 00 
  80042061ce:	ff d0                	callq  *%rax
  80042061d0:	48 89 c3             	mov    %rax,%rbx
  80042061d3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042061d7:	48 89 c7             	mov    %rax,%rdi
  80042061da:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  80042061e1:	00 00 00 
  80042061e4:	ff d0                	callq  *%rax
  80042061e6:	48 39 c3             	cmp    %rax,%rbx
  80042061e9:	74 35                	je     8004206220 <page_check+0xdda>
  80042061eb:	48 b9 c8 7c 21 04 80 	movabs $0x8004217cc8,%rcx
  80042061f2:	00 00 00 
  80042061f5:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042061fc:	00 00 00 
  80042061ff:	be 4e 05 00 00       	mov    $0x54e,%esi
  8004206204:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420620b:	00 00 00 
  800420620e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206213:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420621a:	00 00 00 
  800420621d:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004206220:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206224:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206228:	66 83 f8 02          	cmp    $0x2,%ax
  800420622c:	74 35                	je     8004206263 <page_check+0xe1d>
  800420622e:	48 b9 f8 7c 21 04 80 	movabs $0x8004217cf8,%rcx
  8004206235:	00 00 00 
  8004206238:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  800420623f:	00 00 00 
  8004206242:	be 4f 05 00 00       	mov    $0x54f,%esi
  8004206247:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420624e:	00 00 00 
  8004206251:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206256:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420625d:	00 00 00 
  8004206260:	41 ff d0             	callq  *%r8
	assert(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U);
  8004206263:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  800420626a:	00 00 00 
  800420626d:	48 8b 00             	mov    (%rax),%rax
  8004206270:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206275:	be 00 10 00 00       	mov    $0x1000,%esi
  800420627a:	48 89 c7             	mov    %rax,%rdi
  800420627d:	48 b8 4f 2e 20 04 80 	movabs $0x8004202e4f,%rax
  8004206284:	00 00 00 
  8004206287:	ff d0                	callq  *%rax
  8004206289:	48 8b 00             	mov    (%rax),%rax
  800420628c:	83 e0 04             	and    $0x4,%eax
  800420628f:	48 85 c0             	test   %rax,%rax
  8004206292:	75 35                	jne    80042062c9 <page_check+0xe83>
  8004206294:	48 b9 90 7d 21 04 80 	movabs $0x8004217d90,%rcx
  800420629b:	00 00 00 
  800420629e:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042062a5:	00 00 00 
  80042062a8:	be 50 05 00 00       	mov    $0x550,%esi
  80042062ad:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042062b4:	00 00 00 
  80042062b7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042062bc:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042062c3:	00 00 00 
  80042062c6:	41 ff d0             	callq  *%r8
	assert(boot_pml4e[0] & PTE_U);
  80042062c9:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  80042062d0:	00 00 00 
  80042062d3:	48 8b 00             	mov    (%rax),%rax
  80042062d6:	48 8b 00             	mov    (%rax),%rax
  80042062d9:	83 e0 04             	and    $0x4,%eax
  80042062dc:	48 85 c0             	test   %rax,%rax
  80042062df:	75 35                	jne    8004206316 <page_check+0xed0>
  80042062e1:	48 b9 c3 7d 21 04 80 	movabs $0x8004217dc3,%rcx
  80042062e8:	00 00 00 
  80042062eb:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042062f2:	00 00 00 
  80042062f5:	be 51 05 00 00       	mov    $0x551,%esi
  80042062fa:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004206301:	00 00 00 
  8004206304:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206309:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004206310:	00 00 00 
  8004206313:	41 ff d0             	callq  *%r8


	// should not be able to map at PTSIZE because need free page for page table
	assert(page_insert(boot_pml4e, pp0, (void*) PTSIZE, 0) < 0);
  8004206316:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  800420631d:	00 00 00 
  8004206320:	48 8b 00             	mov    (%rax),%rax
  8004206323:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004206327:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420632c:	ba 00 00 20 00       	mov    $0x200000,%edx
  8004206331:	48 89 c7             	mov    %rax,%rdi
  8004206334:	48 b8 4b 35 20 04 80 	movabs $0x800420354b,%rax
  800420633b:	00 00 00 
  800420633e:	ff d0                	callq  *%rax
  8004206340:	85 c0                	test   %eax,%eax
  8004206342:	78 35                	js     8004206379 <page_check+0xf33>
  8004206344:	48 b9 e0 7d 21 04 80 	movabs $0x8004217de0,%rcx
  800420634b:	00 00 00 
  800420634e:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004206355:	00 00 00 
  8004206358:	be 55 05 00 00       	mov    $0x555,%esi
  800420635d:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004206364:	00 00 00 
  8004206367:	b8 00 00 00 00       	mov    $0x0,%eax
  800420636c:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004206373:	00 00 00 
  8004206376:	41 ff d0             	callq  *%r8

	// insert pp1 at PGSIZE (replacing pp3)
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  8004206379:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004206380:	00 00 00 
  8004206383:	48 8b 00             	mov    (%rax),%rax
  8004206386:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420638a:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420638f:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206394:	48 89 c7             	mov    %rax,%rdi
  8004206397:	48 b8 4b 35 20 04 80 	movabs $0x800420354b,%rax
  800420639e:	00 00 00 
  80042063a1:	ff d0                	callq  *%rax
  80042063a3:	85 c0                	test   %eax,%eax
  80042063a5:	74 35                	je     80042063dc <page_check+0xf96>
  80042063a7:	48 b9 18 7e 21 04 80 	movabs $0x8004217e18,%rcx
  80042063ae:	00 00 00 
  80042063b1:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042063b8:	00 00 00 
  80042063bb:	be 58 05 00 00       	mov    $0x558,%esi
  80042063c0:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042063c7:	00 00 00 
  80042063ca:	b8 00 00 00 00       	mov    $0x0,%eax
  80042063cf:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042063d6:	00 00 00 
  80042063d9:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U));
  80042063dc:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  80042063e3:	00 00 00 
  80042063e6:	48 8b 00             	mov    (%rax),%rax
  80042063e9:	ba 00 00 00 00       	mov    $0x0,%edx
  80042063ee:	be 00 10 00 00       	mov    $0x1000,%esi
  80042063f3:	48 89 c7             	mov    %rax,%rdi
  80042063f6:	48 b8 4f 2e 20 04 80 	movabs $0x8004202e4f,%rax
  80042063fd:	00 00 00 
  8004206400:	ff d0                	callq  *%rax
  8004206402:	48 8b 00             	mov    (%rax),%rax
  8004206405:	83 e0 04             	and    $0x4,%eax
  8004206408:	48 85 c0             	test   %rax,%rax
  800420640b:	74 35                	je     8004206442 <page_check+0xffc>
  800420640d:	48 b9 50 7e 21 04 80 	movabs $0x8004217e50,%rcx
  8004206414:	00 00 00 
  8004206417:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  800420641e:	00 00 00 
  8004206421:	be 59 05 00 00       	mov    $0x559,%esi
  8004206426:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420642d:	00 00 00 
  8004206430:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206435:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420643c:	00 00 00 
  800420643f:	41 ff d0             	callq  *%r8

	// should have pp1 at both 0 and PGSIZE
	assert(check_va2pa(boot_pml4e, 0) == page2pa(pp1));
  8004206442:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004206449:	00 00 00 
  800420644c:	48 8b 00             	mov    (%rax),%rax
  800420644f:	be 00 00 00 00       	mov    $0x0,%esi
  8004206454:	48 89 c7             	mov    %rax,%rdi
  8004206457:	48 b8 f1 51 20 04 80 	movabs $0x80042051f1,%rax
  800420645e:	00 00 00 
  8004206461:	ff d0                	callq  *%rax
  8004206463:	48 89 c3             	mov    %rax,%rbx
  8004206466:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420646a:	48 89 c7             	mov    %rax,%rdi
  800420646d:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  8004206474:	00 00 00 
  8004206477:	ff d0                	callq  *%rax
  8004206479:	48 39 c3             	cmp    %rax,%rbx
  800420647c:	74 35                	je     80042064b3 <page_check+0x106d>
  800420647e:	48 b9 88 7e 21 04 80 	movabs $0x8004217e88,%rcx
  8004206485:	00 00 00 
  8004206488:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  800420648f:	00 00 00 
  8004206492:	be 5c 05 00 00       	mov    $0x55c,%esi
  8004206497:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420649e:	00 00 00 
  80042064a1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042064a6:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042064ad:	00 00 00 
  80042064b0:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  80042064b3:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  80042064ba:	00 00 00 
  80042064bd:	48 8b 00             	mov    (%rax),%rax
  80042064c0:	be 00 10 00 00       	mov    $0x1000,%esi
  80042064c5:	48 89 c7             	mov    %rax,%rdi
  80042064c8:	48 b8 f1 51 20 04 80 	movabs $0x80042051f1,%rax
  80042064cf:	00 00 00 
  80042064d2:	ff d0                	callq  *%rax
  80042064d4:	48 89 c3             	mov    %rax,%rbx
  80042064d7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042064db:	48 89 c7             	mov    %rax,%rdi
  80042064de:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  80042064e5:	00 00 00 
  80042064e8:	ff d0                	callq  *%rax
  80042064ea:	48 39 c3             	cmp    %rax,%rbx
  80042064ed:	74 35                	je     8004206524 <page_check+0x10de>
  80042064ef:	48 b9 b8 7e 21 04 80 	movabs $0x8004217eb8,%rcx
  80042064f6:	00 00 00 
  80042064f9:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004206500:	00 00 00 
  8004206503:	be 5d 05 00 00       	mov    $0x55d,%esi
  8004206508:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420650f:	00 00 00 
  8004206512:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206517:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420651e:	00 00 00 
  8004206521:	41 ff d0             	callq  *%r8
	// ... and ref counts should reflect this
	assert(pp1->pp_ref == 2);
  8004206524:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206528:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420652c:	66 83 f8 02          	cmp    $0x2,%ax
  8004206530:	74 35                	je     8004206567 <page_check+0x1121>
  8004206532:	48 b9 e8 7e 21 04 80 	movabs $0x8004217ee8,%rcx
  8004206539:	00 00 00 
  800420653c:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004206543:	00 00 00 
  8004206546:	be 5f 05 00 00       	mov    $0x55f,%esi
  800420654b:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004206552:	00 00 00 
  8004206555:	b8 00 00 00 00       	mov    $0x0,%eax
  800420655a:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004206561:	00 00 00 
  8004206564:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206567:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420656b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420656f:	66 83 f8 01          	cmp    $0x1,%ax
  8004206573:	74 35                	je     80042065aa <page_check+0x1164>
  8004206575:	48 b9 f9 7e 21 04 80 	movabs $0x8004217ef9,%rcx
  800420657c:	00 00 00 
  800420657f:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004206586:	00 00 00 
  8004206589:	be 60 05 00 00       	mov    $0x560,%esi
  800420658e:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004206595:	00 00 00 
  8004206598:	b8 00 00 00 00       	mov    $0x0,%eax
  800420659d:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042065a4:	00 00 00 
  80042065a7:	41 ff d0             	callq  *%r8


	// unmapping pp1 at 0 should keep pp1 at PGSIZE
	page_remove(boot_pml4e, 0x0);
  80042065aa:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  80042065b1:	00 00 00 
  80042065b4:	48 8b 00             	mov    (%rax),%rax
  80042065b7:	be 00 00 00 00       	mov    $0x0,%esi
  80042065bc:	48 89 c7             	mov    %rax,%rdi
  80042065bf:	48 b8 03 37 20 04 80 	movabs $0x8004203703,%rax
  80042065c6:	00 00 00 
  80042065c9:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  80042065cb:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  80042065d2:	00 00 00 
  80042065d5:	48 8b 00             	mov    (%rax),%rax
  80042065d8:	be 00 00 00 00       	mov    $0x0,%esi
  80042065dd:	48 89 c7             	mov    %rax,%rdi
  80042065e0:	48 b8 f1 51 20 04 80 	movabs $0x80042051f1,%rax
  80042065e7:	00 00 00 
  80042065ea:	ff d0                	callq  *%rax
  80042065ec:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  80042065f0:	74 35                	je     8004206627 <page_check+0x11e1>
  80042065f2:	48 b9 10 7f 21 04 80 	movabs $0x8004217f10,%rcx
  80042065f9:	00 00 00 
  80042065fc:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004206603:	00 00 00 
  8004206606:	be 65 05 00 00       	mov    $0x565,%esi
  800420660b:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004206612:	00 00 00 
  8004206615:	b8 00 00 00 00       	mov    $0x0,%eax
  800420661a:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004206621:	00 00 00 
  8004206624:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004206627:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  800420662e:	00 00 00 
  8004206631:	48 8b 00             	mov    (%rax),%rax
  8004206634:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206639:	48 89 c7             	mov    %rax,%rdi
  800420663c:	48 b8 f1 51 20 04 80 	movabs $0x80042051f1,%rax
  8004206643:	00 00 00 
  8004206646:	ff d0                	callq  *%rax
  8004206648:	48 89 c3             	mov    %rax,%rbx
  800420664b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420664f:	48 89 c7             	mov    %rax,%rdi
  8004206652:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  8004206659:	00 00 00 
  800420665c:	ff d0                	callq  *%rax
  800420665e:	48 39 c3             	cmp    %rax,%rbx
  8004206661:	74 35                	je     8004206698 <page_check+0x1252>
  8004206663:	48 b9 b8 7e 21 04 80 	movabs $0x8004217eb8,%rcx
  800420666a:	00 00 00 
  800420666d:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004206674:	00 00 00 
  8004206677:	be 66 05 00 00       	mov    $0x566,%esi
  800420667c:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004206683:	00 00 00 
  8004206686:	b8 00 00 00 00       	mov    $0x0,%eax
  800420668b:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004206692:	00 00 00 
  8004206695:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004206698:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420669c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042066a0:	66 83 f8 01          	cmp    $0x1,%ax
  80042066a4:	74 35                	je     80042066db <page_check+0x1295>
  80042066a6:	48 b9 5d 7c 21 04 80 	movabs $0x8004217c5d,%rcx
  80042066ad:	00 00 00 
  80042066b0:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042066b7:	00 00 00 
  80042066ba:	be 67 05 00 00       	mov    $0x567,%esi
  80042066bf:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042066c6:	00 00 00 
  80042066c9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042066ce:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042066d5:	00 00 00 
  80042066d8:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  80042066db:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042066df:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042066e3:	66 83 f8 01          	cmp    $0x1,%ax
  80042066e7:	74 35                	je     800420671e <page_check+0x12d8>
  80042066e9:	48 b9 f9 7e 21 04 80 	movabs $0x8004217ef9,%rcx
  80042066f0:	00 00 00 
  80042066f3:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042066fa:	00 00 00 
  80042066fd:	be 68 05 00 00       	mov    $0x568,%esi
  8004206702:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004206709:	00 00 00 
  800420670c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206711:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004206718:	00 00 00 
  800420671b:	41 ff d0             	callq  *%r8

	// Test re-inserting pp1 at PGSIZE.
	// Thanks to Varun Agrawal for suggesting this test case.
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  800420671e:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004206725:	00 00 00 
  8004206728:	48 8b 00             	mov    (%rax),%rax
  800420672b:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420672f:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206734:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206739:	48 89 c7             	mov    %rax,%rdi
  800420673c:	48 b8 4b 35 20 04 80 	movabs $0x800420354b,%rax
  8004206743:	00 00 00 
  8004206746:	ff d0                	callq  *%rax
  8004206748:	85 c0                	test   %eax,%eax
  800420674a:	74 35                	je     8004206781 <page_check+0x133b>
  800420674c:	48 b9 18 7e 21 04 80 	movabs $0x8004217e18,%rcx
  8004206753:	00 00 00 
  8004206756:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  800420675d:	00 00 00 
  8004206760:	be 6c 05 00 00       	mov    $0x56c,%esi
  8004206765:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420676c:	00 00 00 
  800420676f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206774:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420677b:	00 00 00 
  800420677e:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref);
  8004206781:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206785:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206789:	66 85 c0             	test   %ax,%ax
  800420678c:	75 35                	jne    80042067c3 <page_check+0x137d>
  800420678e:	48 b9 33 7f 21 04 80 	movabs $0x8004217f33,%rcx
  8004206795:	00 00 00 
  8004206798:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  800420679f:	00 00 00 
  80042067a2:	be 6d 05 00 00       	mov    $0x56d,%esi
  80042067a7:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042067ae:	00 00 00 
  80042067b1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042067b6:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042067bd:	00 00 00 
  80042067c0:	41 ff d0             	callq  *%r8
	assert(pp1->pp_link == NULL);
  80042067c3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042067c7:	48 8b 00             	mov    (%rax),%rax
  80042067ca:	48 85 c0             	test   %rax,%rax
  80042067cd:	74 35                	je     8004206804 <page_check+0x13be>
  80042067cf:	48 b9 3f 7f 21 04 80 	movabs $0x8004217f3f,%rcx
  80042067d6:	00 00 00 
  80042067d9:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042067e0:	00 00 00 
  80042067e3:	be 6e 05 00 00       	mov    $0x56e,%esi
  80042067e8:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042067ef:	00 00 00 
  80042067f2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042067f7:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042067fe:	00 00 00 
  8004206801:	41 ff d0             	callq  *%r8

	// unmapping pp1 at PGSIZE should free it
	page_remove(boot_pml4e, (void*) PGSIZE);
  8004206804:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  800420680b:	00 00 00 
  800420680e:	48 8b 00             	mov    (%rax),%rax
  8004206811:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206816:	48 89 c7             	mov    %rax,%rdi
  8004206819:	48 b8 03 37 20 04 80 	movabs $0x8004203703,%rax
  8004206820:	00 00 00 
  8004206823:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206825:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  800420682c:	00 00 00 
  800420682f:	48 8b 00             	mov    (%rax),%rax
  8004206832:	be 00 00 00 00       	mov    $0x0,%esi
  8004206837:	48 89 c7             	mov    %rax,%rdi
  800420683a:	48 b8 f1 51 20 04 80 	movabs $0x80042051f1,%rax
  8004206841:	00 00 00 
  8004206844:	ff d0                	callq  *%rax
  8004206846:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  800420684a:	74 35                	je     8004206881 <page_check+0x143b>
  800420684c:	48 b9 10 7f 21 04 80 	movabs $0x8004217f10,%rcx
  8004206853:	00 00 00 
  8004206856:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  800420685d:	00 00 00 
  8004206860:	be 72 05 00 00       	mov    $0x572,%esi
  8004206865:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420686c:	00 00 00 
  800420686f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206874:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420687b:	00 00 00 
  800420687e:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == ~0);
  8004206881:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004206888:	00 00 00 
  800420688b:	48 8b 00             	mov    (%rax),%rax
  800420688e:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206893:	48 89 c7             	mov    %rax,%rdi
  8004206896:	48 b8 f1 51 20 04 80 	movabs $0x80042051f1,%rax
  800420689d:	00 00 00 
  80042068a0:	ff d0                	callq  *%rax
  80042068a2:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  80042068a6:	74 35                	je     80042068dd <page_check+0x1497>
  80042068a8:	48 b9 58 7f 21 04 80 	movabs $0x8004217f58,%rcx
  80042068af:	00 00 00 
  80042068b2:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042068b9:	00 00 00 
  80042068bc:	be 73 05 00 00       	mov    $0x573,%esi
  80042068c1:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042068c8:	00 00 00 
  80042068cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042068d0:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042068d7:	00 00 00 
  80042068da:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  80042068dd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042068e1:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042068e5:	66 85 c0             	test   %ax,%ax
  80042068e8:	74 35                	je     800420691f <page_check+0x14d9>
  80042068ea:	48 b9 7e 7f 21 04 80 	movabs $0x8004217f7e,%rcx
  80042068f1:	00 00 00 
  80042068f4:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042068fb:	00 00 00 
  80042068fe:	be 74 05 00 00       	mov    $0x574,%esi
  8004206903:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420690a:	00 00 00 
  800420690d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206912:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004206919:	00 00 00 
  800420691c:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  800420691f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206923:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206927:	66 83 f8 01          	cmp    $0x1,%ax
  800420692b:	74 35                	je     8004206962 <page_check+0x151c>
  800420692d:	48 b9 f9 7e 21 04 80 	movabs $0x8004217ef9,%rcx
  8004206934:	00 00 00 
  8004206937:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  800420693e:	00 00 00 
  8004206941:	be 75 05 00 00       	mov    $0x575,%esi
  8004206946:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420694d:	00 00 00 
  8004206950:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206955:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420695c:	00 00 00 
  800420695f:	41 ff d0             	callq  *%r8
	page_remove(boot_pgdir, 0x0);
	assert(pp2->pp_ref == 0);
#endif

	// forcibly take pp3 back
	assert(PTE_ADDR(boot_pml4e[0]) == page2pa(pp3));
  8004206962:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004206969:	00 00 00 
  800420696c:	48 8b 00             	mov    (%rax),%rax
  800420696f:	48 8b 00             	mov    (%rax),%rax
  8004206972:	48 89 c3             	mov    %rax,%rbx
  8004206975:	48 81 e3 00 f0 ff ff 	and    $0xfffffffffffff000,%rbx
  800420697c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206980:	48 89 c7             	mov    %rax,%rdi
  8004206983:	48 b8 98 19 20 04 80 	movabs $0x8004201998,%rax
  800420698a:	00 00 00 
  800420698d:	ff d0                	callq  *%rax
  800420698f:	48 39 c3             	cmp    %rax,%rbx
  8004206992:	74 35                	je     80042069c9 <page_check+0x1583>
  8004206994:	48 b9 90 7f 21 04 80 	movabs $0x8004217f90,%rcx
  800420699b:	00 00 00 
  800420699e:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042069a5:	00 00 00 
  80042069a8:	be 89 05 00 00       	mov    $0x589,%esi
  80042069ad:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042069b4:	00 00 00 
  80042069b7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042069bc:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042069c3:	00 00 00 
  80042069c6:	41 ff d0             	callq  *%r8
	boot_pml4e[0] = 0;
  80042069c9:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  80042069d0:	00 00 00 
  80042069d3:	48 8b 00             	mov    (%rax),%rax
  80042069d6:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	assert(pp3->pp_ref == 1);
  80042069dd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042069e1:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042069e5:	66 83 f8 01          	cmp    $0x1,%ax
  80042069e9:	74 35                	je     8004206a20 <page_check+0x15da>
  80042069eb:	48 b9 f9 7e 21 04 80 	movabs $0x8004217ef9,%rcx
  80042069f2:	00 00 00 
  80042069f5:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042069fc:	00 00 00 
  80042069ff:	be 8b 05 00 00       	mov    $0x58b,%esi
  8004206a04:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004206a0b:	00 00 00 
  8004206a0e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a13:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004206a1a:	00 00 00 
  8004206a1d:	41 ff d0             	callq  *%r8
    page_decref(pp3);
  8004206a20:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206a24:	48 89 c7             	mov    %rax,%rdi
  8004206a27:	48 b8 0e 2e 20 04 80 	movabs $0x8004202e0e,%rax
  8004206a2e:	00 00 00 
  8004206a31:	ff d0                	callq  *%rax
	// check pointer arithmetic in pml4e_walk
	page_decref(pp0);
  8004206a33:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206a37:	48 89 c7             	mov    %rax,%rdi
  8004206a3a:	48 b8 0e 2e 20 04 80 	movabs $0x8004202e0e,%rax
  8004206a41:	00 00 00 
  8004206a44:	ff d0                	callq  *%rax
	page_decref(pp2);
  8004206a46:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206a4a:	48 89 c7             	mov    %rax,%rdi
  8004206a4d:	48 b8 0e 2e 20 04 80 	movabs $0x8004202e0e,%rax
  8004206a54:	00 00 00 
  8004206a57:	ff d0                	callq  *%rax
	va = (void*)(PGSIZE * 100);
  8004206a59:	48 c7 85 68 ff ff ff 	movq   $0x64000,-0x98(%rbp)
  8004206a60:	00 40 06 00 
	ptep = pml4e_walk(boot_pml4e, va, 1);
  8004206a64:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004206a6b:	00 00 00 
  8004206a6e:	48 8b 00             	mov    (%rax),%rax
  8004206a71:	48 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%rcx
  8004206a78:	ba 01 00 00 00       	mov    $0x1,%edx
  8004206a7d:	48 89 ce             	mov    %rcx,%rsi
  8004206a80:	48 89 c7             	mov    %rax,%rdi
  8004206a83:	48 b8 4f 2e 20 04 80 	movabs $0x8004202e4f,%rax
  8004206a8a:	00 00 00 
  8004206a8d:	ff d0                	callq  *%rax
  8004206a8f:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(va)]));
  8004206a96:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004206a9d:	00 00 00 
  8004206aa0:	48 8b 00             	mov    (%rax),%rax
  8004206aa3:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  8004206aaa:	48 c1 ea 27          	shr    $0x27,%rdx
  8004206aae:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004206ab4:	48 c1 e2 03          	shl    $0x3,%rdx
  8004206ab8:	48 01 d0             	add    %rdx,%rax
  8004206abb:	48 8b 00             	mov    (%rax),%rax
  8004206abe:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206ac4:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  8004206acb:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206ad2:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206ad6:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%rbp)
  8004206adc:	8b 95 5c ff ff ff    	mov    -0xa4(%rbp),%edx
  8004206ae2:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004206ae9:	00 00 00 
  8004206aec:	48 8b 00             	mov    (%rax),%rax
  8004206aef:	48 39 c2             	cmp    %rax,%rdx
  8004206af2:	72 35                	jb     8004206b29 <page_check+0x16e3>
  8004206af4:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206afb:	48 89 c1             	mov    %rax,%rcx
  8004206afe:	48 ba 60 73 21 04 80 	movabs $0x8004217360,%rdx
  8004206b05:	00 00 00 
  8004206b08:	be 92 05 00 00       	mov    $0x592,%esi
  8004206b0d:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004206b14:	00 00 00 
  8004206b17:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b1c:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004206b23:	00 00 00 
  8004206b26:	41 ff d0             	callq  *%r8
  8004206b29:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004206b30:	00 00 00 
  8004206b33:	48 03 85 60 ff ff ff 	add    -0xa0(%rbp),%rax
  8004206b3a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004206b3e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206b45:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004206b49:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206b4e:	48 c1 e0 03          	shl    $0x3,%rax
  8004206b52:	48 03 45 98          	add    -0x68(%rbp),%rax
  8004206b56:	48 8b 00             	mov    (%rax),%rax
  8004206b59:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206b5f:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
  8004206b66:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004206b6d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206b71:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
  8004206b77:	8b 95 4c ff ff ff    	mov    -0xb4(%rbp),%edx
  8004206b7d:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004206b84:	00 00 00 
  8004206b87:	48 8b 00             	mov    (%rax),%rax
  8004206b8a:	48 39 c2             	cmp    %rax,%rdx
  8004206b8d:	72 35                	jb     8004206bc4 <page_check+0x177e>
  8004206b8f:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004206b96:	48 89 c1             	mov    %rax,%rcx
  8004206b99:	48 ba 60 73 21 04 80 	movabs $0x8004217360,%rdx
  8004206ba0:	00 00 00 
  8004206ba3:	be 93 05 00 00       	mov    $0x593,%esi
  8004206ba8:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004206baf:	00 00 00 
  8004206bb2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206bb7:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004206bbe:	00 00 00 
  8004206bc1:	41 ff d0             	callq  *%r8
  8004206bc4:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004206bcb:	00 00 00 
  8004206bce:	48 03 85 50 ff ff ff 	add    -0xb0(%rbp),%rax
  8004206bd5:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep1 = KADDR(PTE_ADDR(pde[PDX(va)]));
  8004206bd9:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206be0:	48 c1 e8 15          	shr    $0x15,%rax
  8004206be4:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206be9:	48 c1 e0 03          	shl    $0x3,%rax
  8004206bed:	48 03 45 80          	add    -0x80(%rbp),%rax
  8004206bf1:	48 8b 00             	mov    (%rax),%rax
  8004206bf4:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206bfa:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004206c01:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004206c08:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206c0c:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%rbp)
  8004206c12:	8b 95 3c ff ff ff    	mov    -0xc4(%rbp),%edx
  8004206c18:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004206c1f:	00 00 00 
  8004206c22:	48 8b 00             	mov    (%rax),%rax
  8004206c25:	48 39 c2             	cmp    %rax,%rdx
  8004206c28:	72 35                	jb     8004206c5f <page_check+0x1819>
  8004206c2a:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004206c31:	48 89 c1             	mov    %rax,%rcx
  8004206c34:	48 ba 60 73 21 04 80 	movabs $0x8004217360,%rdx
  8004206c3b:	00 00 00 
  8004206c3e:	be 94 05 00 00       	mov    $0x594,%esi
  8004206c43:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004206c4a:	00 00 00 
  8004206c4d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c52:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004206c59:	00 00 00 
  8004206c5c:	41 ff d0             	callq  *%r8
  8004206c5f:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004206c66:	00 00 00 
  8004206c69:	48 03 85 40 ff ff ff 	add    -0xc0(%rbp),%rax
  8004206c70:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
	assert(ptep == ptep1 + PTX(va));
  8004206c77:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206c7e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206c82:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206c87:	48 c1 e0 03          	shl    $0x3,%rax
  8004206c8b:	48 89 c2             	mov    %rax,%rdx
  8004206c8e:	48 03 95 30 ff ff ff 	add    -0xd0(%rbp),%rdx
  8004206c95:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004206c9c:	48 39 c2             	cmp    %rax,%rdx
  8004206c9f:	74 35                	je     8004206cd6 <page_check+0x1890>
  8004206ca1:	48 b9 b8 7f 21 04 80 	movabs $0x8004217fb8,%rcx
  8004206ca8:	00 00 00 
  8004206cab:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004206cb2:	00 00 00 
  8004206cb5:	be 95 05 00 00       	mov    $0x595,%esi
  8004206cba:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004206cc1:	00 00 00 
  8004206cc4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206cc9:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004206cd0:	00 00 00 
  8004206cd3:	41 ff d0             	callq  *%r8
	
    // check that new page tables get cleared
    page_decref(pp4);
  8004206cd6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004206cda:	48 89 c7             	mov    %rax,%rdi
  8004206cdd:	48 b8 0e 2e 20 04 80 	movabs $0x8004202e0e,%rax
  8004206ce4:	00 00 00 
  8004206ce7:	ff d0                	callq  *%rax
	memset(page2kva(pp4), 0xFF, PGSIZE);
  8004206ce9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004206ced:	48 89 c7             	mov    %rax,%rdi
  8004206cf0:	48 b8 2e 1a 20 04 80 	movabs $0x8004201a2e,%rax
  8004206cf7:	00 00 00 
  8004206cfa:	ff d0                	callq  *%rax
  8004206cfc:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206d01:	be ff 00 00 00       	mov    $0xff,%esi
  8004206d06:	48 89 c7             	mov    %rax,%rdi
  8004206d09:	48 b8 53 e6 20 04 80 	movabs $0x800420e653,%rax
  8004206d10:	00 00 00 
  8004206d13:	ff d0                	callq  *%rax
	pml4e_walk(boot_pml4e, 0x0, 1);
  8004206d15:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004206d1c:	00 00 00 
  8004206d1f:	48 8b 00             	mov    (%rax),%rax
  8004206d22:	ba 01 00 00 00       	mov    $0x1,%edx
  8004206d27:	be 00 00 00 00       	mov    $0x0,%esi
  8004206d2c:	48 89 c7             	mov    %rax,%rdi
  8004206d2f:	48 b8 4f 2e 20 04 80 	movabs $0x8004202e4f,%rax
  8004206d36:	00 00 00 
  8004206d39:	ff d0                	callq  *%rax
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
  8004206d3b:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004206d42:	00 00 00 
  8004206d45:	48 8b 00             	mov    (%rax),%rax
  8004206d48:	48 8b 00             	mov    (%rax),%rax
  8004206d4b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206d51:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  8004206d58:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004206d5f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206d63:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%rbp)
  8004206d69:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  8004206d6f:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004206d76:	00 00 00 
  8004206d79:	48 8b 00             	mov    (%rax),%rax
  8004206d7c:	48 39 c2             	cmp    %rax,%rdx
  8004206d7f:	72 35                	jb     8004206db6 <page_check+0x1970>
  8004206d81:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004206d88:	48 89 c1             	mov    %rax,%rcx
  8004206d8b:	48 ba 60 73 21 04 80 	movabs $0x8004217360,%rdx
  8004206d92:	00 00 00 
  8004206d95:	be 9b 05 00 00       	mov    $0x59b,%esi
  8004206d9a:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004206da1:	00 00 00 
  8004206da4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206da9:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004206db0:	00 00 00 
  8004206db3:	41 ff d0             	callq  *%r8
  8004206db6:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004206dbd:	00 00 00 
  8004206dc0:	48 03 85 28 ff ff ff 	add    -0xd8(%rbp),%rax
  8004206dc7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    pde  = KADDR(PTE_ADDR(pdpe[0]));
  8004206dcb:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004206dcf:	48 8b 00             	mov    (%rax),%rax
  8004206dd2:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206dd8:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
  8004206ddf:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004206de6:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206dea:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
  8004206df0:	8b 95 14 ff ff ff    	mov    -0xec(%rbp),%edx
  8004206df6:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004206dfd:	00 00 00 
  8004206e00:	48 8b 00             	mov    (%rax),%rax
  8004206e03:	48 39 c2             	cmp    %rax,%rdx
  8004206e06:	72 35                	jb     8004206e3d <page_check+0x19f7>
  8004206e08:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004206e0f:	48 89 c1             	mov    %rax,%rcx
  8004206e12:	48 ba 60 73 21 04 80 	movabs $0x8004217360,%rdx
  8004206e19:	00 00 00 
  8004206e1c:	be 9c 05 00 00       	mov    $0x59c,%esi
  8004206e21:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004206e28:	00 00 00 
  8004206e2b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e30:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004206e37:	00 00 00 
  8004206e3a:	41 ff d0             	callq  *%r8
  8004206e3d:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004206e44:	00 00 00 
  8004206e47:	48 03 85 18 ff ff ff 	add    -0xe8(%rbp),%rax
  8004206e4e:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    ptep  = KADDR(PTE_ADDR(pde[0]));
  8004206e52:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004206e56:	48 8b 00             	mov    (%rax),%rax
  8004206e59:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206e5f:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
  8004206e66:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004206e6d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206e71:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%rbp)
  8004206e77:	8b 95 04 ff ff ff    	mov    -0xfc(%rbp),%edx
  8004206e7d:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004206e84:	00 00 00 
  8004206e87:	48 8b 00             	mov    (%rax),%rax
  8004206e8a:	48 39 c2             	cmp    %rax,%rdx
  8004206e8d:	72 35                	jb     8004206ec4 <page_check+0x1a7e>
  8004206e8f:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004206e96:	48 89 c1             	mov    %rax,%rcx
  8004206e99:	48 ba 60 73 21 04 80 	movabs $0x8004217360,%rdx
  8004206ea0:	00 00 00 
  8004206ea3:	be 9d 05 00 00       	mov    $0x59d,%esi
  8004206ea8:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004206eaf:	00 00 00 
  8004206eb2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206eb7:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004206ebe:	00 00 00 
  8004206ec1:	41 ff d0             	callq  *%r8
  8004206ec4:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004206ecb:	00 00 00 
  8004206ece:	48 03 85 08 ff ff ff 	add    -0xf8(%rbp),%rax
  8004206ed5:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	for(i=0; i<NPTENTRIES; i++)
  8004206edc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004206ee3:	eb 57                	jmp    8004206f3c <page_check+0x1af6>
		assert((ptep[i] & PTE_P) == 0);
  8004206ee5:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004206eec:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004206eef:	48 63 d2             	movslq %edx,%rdx
  8004206ef2:	48 c1 e2 03          	shl    $0x3,%rdx
  8004206ef6:	48 01 d0             	add    %rdx,%rax
  8004206ef9:	48 8b 00             	mov    (%rax),%rax
  8004206efc:	83 e0 01             	and    $0x1,%eax
  8004206eff:	84 c0                	test   %al,%al
  8004206f01:	74 35                	je     8004206f38 <page_check+0x1af2>
  8004206f03:	48 b9 d0 7f 21 04 80 	movabs $0x8004217fd0,%rcx
  8004206f0a:	00 00 00 
  8004206f0d:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004206f14:	00 00 00 
  8004206f17:	be 9f 05 00 00       	mov    $0x59f,%esi
  8004206f1c:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004206f23:	00 00 00 
  8004206f26:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f2b:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004206f32:	00 00 00 
  8004206f35:	41 ff d0             	callq  *%r8
	memset(page2kva(pp4), 0xFF, PGSIZE);
	pml4e_walk(boot_pml4e, 0x0, 1);
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
    pde  = KADDR(PTE_ADDR(pdpe[0]));
    ptep  = KADDR(PTE_ADDR(pde[0]));
	for(i=0; i<NPTENTRIES; i++)
  8004206f38:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004206f3c:	81 7d ec ff 01 00 00 	cmpl   $0x1ff,-0x14(%rbp)
  8004206f43:	7e a0                	jle    8004206ee5 <page_check+0x1a9f>
		assert((ptep[i] & PTE_P) == 0);
	boot_pml4e[0] = 0;
  8004206f45:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004206f4c:	00 00 00 
  8004206f4f:	48 8b 00             	mov    (%rax),%rax
  8004206f52:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// give free list back
	page_free_list = fl;
  8004206f59:	48 b8 38 b2 63 04 80 	movabs $0x800463b238,%rax
  8004206f60:	00 00 00 
  8004206f63:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004206f67:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_decref(pp0);
  8004206f6a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206f6e:	48 89 c7             	mov    %rax,%rdi
  8004206f71:	48 b8 0e 2e 20 04 80 	movabs $0x8004202e0e,%rax
  8004206f78:	00 00 00 
  8004206f7b:	ff d0                	callq  *%rax
	page_decref(pp1);
  8004206f7d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206f81:	48 89 c7             	mov    %rax,%rdi
  8004206f84:	48 b8 0e 2e 20 04 80 	movabs $0x8004202e0e,%rax
  8004206f8b:	00 00 00 
  8004206f8e:	ff d0                	callq  *%rax
	page_decref(pp2);
  8004206f90:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206f94:	48 89 c7             	mov    %rax,%rdi
  8004206f97:	48 b8 0e 2e 20 04 80 	movabs $0x8004202e0e,%rax
  8004206f9e:	00 00 00 
  8004206fa1:	ff d0                	callq  *%rax

	// test mmio_map_region
	mm1 = (uintptr_t) mmio_map_region(0, 4097);
  8004206fa3:	be 01 10 00 00       	mov    $0x1001,%esi
  8004206fa8:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206fad:	48 b8 42 38 20 04 80 	movabs $0x8004203842,%rax
  8004206fb4:	00 00 00 
  8004206fb7:	ff d0                	callq  *%rax
  8004206fb9:	48 89 85 f8 fe ff ff 	mov    %rax,-0x108(%rbp)
	mm2 = (uintptr_t) mmio_map_region(0, 4096);
  8004206fc0:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206fc5:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206fca:	48 b8 42 38 20 04 80 	movabs $0x8004203842,%rax
  8004206fd1:	00 00 00 
  8004206fd4:	ff d0                	callq  *%rax
  8004206fd6:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
	// check that they're in the right region
	assert(mm1 >= MMIOBASE && mm1 + 8096 < MMIOLIM);
  8004206fdd:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004206fe4:	00 00 00 
  8004206fe7:	48 39 85 f8 fe ff ff 	cmp    %rax,-0x108(%rbp)
  8004206fee:	76 1d                	jbe    800420700d <page_check+0x1bc7>
  8004206ff0:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004206ff7:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  8004206ffe:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004207005:	00 00 00 
  8004207008:	48 39 c2             	cmp    %rax,%rdx
  800420700b:	76 35                	jbe    8004207042 <page_check+0x1bfc>
  800420700d:	48 b9 e8 7f 21 04 80 	movabs $0x8004217fe8,%rcx
  8004207014:	00 00 00 
  8004207017:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  800420701e:	00 00 00 
  8004207021:	be ae 05 00 00       	mov    $0x5ae,%esi
  8004207026:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420702d:	00 00 00 
  8004207030:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207035:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420703c:	00 00 00 
  800420703f:	41 ff d0             	callq  *%r8
	assert(mm2 >= MMIOBASE && mm2 + 8096 < MMIOLIM);
  8004207042:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004207049:	00 00 00 
  800420704c:	48 39 85 f0 fe ff ff 	cmp    %rax,-0x110(%rbp)
  8004207053:	76 1d                	jbe    8004207072 <page_check+0x1c2c>
  8004207055:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  800420705c:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  8004207063:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  800420706a:	00 00 00 
  800420706d:	48 39 c2             	cmp    %rax,%rdx
  8004207070:	76 35                	jbe    80042070a7 <page_check+0x1c61>
  8004207072:	48 b9 10 80 21 04 80 	movabs $0x8004218010,%rcx
  8004207079:	00 00 00 
  800420707c:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004207083:	00 00 00 
  8004207086:	be af 05 00 00       	mov    $0x5af,%esi
  800420708b:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004207092:	00 00 00 
  8004207095:	b8 00 00 00 00       	mov    $0x0,%eax
  800420709a:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042070a1:	00 00 00 
  80042070a4:	41 ff d0             	callq  *%r8
	// check that they're page-aligned
	assert(mm1 % PGSIZE == 0 && mm2 % PGSIZE == 0);
  80042070a7:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  80042070ae:	25 ff 0f 00 00       	and    $0xfff,%eax
  80042070b3:	48 85 c0             	test   %rax,%rax
  80042070b6:	75 11                	jne    80042070c9 <page_check+0x1c83>
  80042070b8:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  80042070bf:	25 ff 0f 00 00       	and    $0xfff,%eax
  80042070c4:	48 85 c0             	test   %rax,%rax
  80042070c7:	74 35                	je     80042070fe <page_check+0x1cb8>
  80042070c9:	48 b9 38 80 21 04 80 	movabs $0x8004218038,%rcx
  80042070d0:	00 00 00 
  80042070d3:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042070da:	00 00 00 
  80042070dd:	be b1 05 00 00       	mov    $0x5b1,%esi
  80042070e2:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042070e9:	00 00 00 
  80042070ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80042070f1:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042070f8:	00 00 00 
  80042070fb:	41 ff d0             	callq  *%r8
	// check that they don't overlap
	assert(mm1 + 8096 <= mm2);
  80042070fe:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004207105:	48 05 a0 1f 00 00    	add    $0x1fa0,%rax
  800420710b:	48 3b 85 f0 fe ff ff 	cmp    -0x110(%rbp),%rax
  8004207112:	76 35                	jbe    8004207149 <page_check+0x1d03>
  8004207114:	48 b9 5f 80 21 04 80 	movabs $0x800421805f,%rcx
  800420711b:	00 00 00 
  800420711e:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004207125:	00 00 00 
  8004207128:	be b3 05 00 00       	mov    $0x5b3,%esi
  800420712d:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004207134:	00 00 00 
  8004207137:	b8 00 00 00 00       	mov    $0x0,%eax
  800420713c:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004207143:	00 00 00 
  8004207146:	41 ff d0             	callq  *%r8
	// check page mappings
	
	assert(check_va2pa(boot_pml4e, mm1) == 0);
  8004207149:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004207150:	00 00 00 
  8004207153:	48 8b 00             	mov    (%rax),%rax
  8004207156:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  800420715d:	48 89 d6             	mov    %rdx,%rsi
  8004207160:	48 89 c7             	mov    %rax,%rdi
  8004207163:	48 b8 f1 51 20 04 80 	movabs $0x80042051f1,%rax
  800420716a:	00 00 00 
  800420716d:	ff d0                	callq  *%rax
  800420716f:	48 85 c0             	test   %rax,%rax
  8004207172:	74 35                	je     80042071a9 <page_check+0x1d63>
  8004207174:	48 b9 78 80 21 04 80 	movabs $0x8004218078,%rcx
  800420717b:	00 00 00 
  800420717e:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004207185:	00 00 00 
  8004207188:	be b6 05 00 00       	mov    $0x5b6,%esi
  800420718d:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004207194:	00 00 00 
  8004207197:	b8 00 00 00 00       	mov    $0x0,%eax
  800420719c:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042071a3:	00 00 00 
  80042071a6:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm1+PGSIZE) == PGSIZE);
  80042071a9:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  80042071b0:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  80042071b7:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  80042071be:	00 00 00 
  80042071c1:	48 8b 00             	mov    (%rax),%rax
  80042071c4:	48 89 d6             	mov    %rdx,%rsi
  80042071c7:	48 89 c7             	mov    %rax,%rdi
  80042071ca:	48 b8 f1 51 20 04 80 	movabs $0x80042051f1,%rax
  80042071d1:	00 00 00 
  80042071d4:	ff d0                	callq  *%rax
  80042071d6:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  80042071dc:	74 35                	je     8004207213 <page_check+0x1dcd>
  80042071de:	48 b9 a0 80 21 04 80 	movabs $0x80042180a0,%rcx
  80042071e5:	00 00 00 
  80042071e8:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042071ef:	00 00 00 
  80042071f2:	be b7 05 00 00       	mov    $0x5b7,%esi
  80042071f7:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042071fe:	00 00 00 
  8004207201:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207206:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420720d:	00 00 00 
  8004207210:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2) == 0);
  8004207213:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  800420721a:	00 00 00 
  800420721d:	48 8b 00             	mov    (%rax),%rax
  8004207220:	48 8b 95 f0 fe ff ff 	mov    -0x110(%rbp),%rdx
  8004207227:	48 89 d6             	mov    %rdx,%rsi
  800420722a:	48 89 c7             	mov    %rax,%rdi
  800420722d:	48 b8 f1 51 20 04 80 	movabs $0x80042051f1,%rax
  8004207234:	00 00 00 
  8004207237:	ff d0                	callq  *%rax
  8004207239:	48 85 c0             	test   %rax,%rax
  800420723c:	74 35                	je     8004207273 <page_check+0x1e2d>
  800420723e:	48 b9 d0 80 21 04 80 	movabs $0x80042180d0,%rcx
  8004207245:	00 00 00 
  8004207248:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  800420724f:	00 00 00 
  8004207252:	be b8 05 00 00       	mov    $0x5b8,%esi
  8004207257:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420725e:	00 00 00 
  8004207261:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207266:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420726d:	00 00 00 
  8004207270:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2+PGSIZE) == ~0);
  8004207273:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  800420727a:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004207281:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004207288:	00 00 00 
  800420728b:	48 8b 00             	mov    (%rax),%rax
  800420728e:	48 89 d6             	mov    %rdx,%rsi
  8004207291:	48 89 c7             	mov    %rax,%rdi
  8004207294:	48 b8 f1 51 20 04 80 	movabs $0x80042051f1,%rax
  800420729b:	00 00 00 
  800420729e:	ff d0                	callq  *%rax
  80042072a0:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  80042072a4:	74 35                	je     80042072db <page_check+0x1e95>
  80042072a6:	48 b9 f8 80 21 04 80 	movabs $0x80042180f8,%rcx
  80042072ad:	00 00 00 
  80042072b0:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  80042072b7:	00 00 00 
  80042072ba:	be b9 05 00 00       	mov    $0x5b9,%esi
  80042072bf:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  80042072c6:	00 00 00 
  80042072c9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042072ce:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042072d5:	00 00 00 
  80042072d8:	41 ff d0             	callq  *%r8
	// check permissions
	assert(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & (PTE_W|PTE_PWT|PTE_PCD));
  80042072db:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  80042072e2:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  80042072e9:	00 00 00 
  80042072ec:	48 8b 00             	mov    (%rax),%rax
  80042072ef:	ba 00 00 00 00       	mov    $0x0,%edx
  80042072f4:	48 89 ce             	mov    %rcx,%rsi
  80042072f7:	48 89 c7             	mov    %rax,%rdi
  80042072fa:	48 b8 4f 2e 20 04 80 	movabs $0x8004202e4f,%rax
  8004207301:	00 00 00 
  8004207304:	ff d0                	callq  *%rax
  8004207306:	48 8b 00             	mov    (%rax),%rax
  8004207309:	83 e0 1a             	and    $0x1a,%eax
  800420730c:	48 85 c0             	test   %rax,%rax
  800420730f:	75 35                	jne    8004207346 <page_check+0x1f00>
  8004207311:	48 b9 28 81 21 04 80 	movabs $0x8004218128,%rcx
  8004207318:	00 00 00 
  800420731b:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  8004207322:	00 00 00 
  8004207325:	be bb 05 00 00       	mov    $0x5bb,%esi
  800420732a:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  8004207331:	00 00 00 
  8004207334:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207339:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004207340:	00 00 00 
  8004207343:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & PTE_U));
  8004207346:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  800420734d:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  8004207354:	00 00 00 
  8004207357:	48 8b 00             	mov    (%rax),%rax
  800420735a:	ba 00 00 00 00       	mov    $0x0,%edx
  800420735f:	48 89 ce             	mov    %rcx,%rsi
  8004207362:	48 89 c7             	mov    %rax,%rdi
  8004207365:	48 b8 4f 2e 20 04 80 	movabs $0x8004202e4f,%rax
  800420736c:	00 00 00 
  800420736f:	ff d0                	callq  *%rax
  8004207371:	48 8b 00             	mov    (%rax),%rax
  8004207374:	83 e0 04             	and    $0x4,%eax
  8004207377:	48 85 c0             	test   %rax,%rax
  800420737a:	74 35                	je     80042073b1 <page_check+0x1f6b>
  800420737c:	48 b9 70 81 21 04 80 	movabs $0x8004218170,%rcx
  8004207383:	00 00 00 
  8004207386:	48 ba d9 73 21 04 80 	movabs $0x80042173d9,%rdx
  800420738d:	00 00 00 
  8004207390:	be bc 05 00 00       	mov    $0x5bc,%esi
  8004207395:	48 bf ee 73 21 04 80 	movabs $0x80042173ee,%rdi
  800420739c:	00 00 00 
  800420739f:	b8 00 00 00 00       	mov    $0x0,%eax
  80042073a4:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042073ab:	00 00 00 
  80042073ae:	41 ff d0             	callq  *%r8
	// clear the mappings
	*pml4e_walk(boot_pml4e, (void*) mm1, 0) = 0;
  80042073b1:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  80042073b8:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  80042073bf:	00 00 00 
  80042073c2:	48 8b 00             	mov    (%rax),%rax
  80042073c5:	ba 00 00 00 00       	mov    $0x0,%edx
  80042073ca:	48 89 ce             	mov    %rcx,%rsi
  80042073cd:	48 89 c7             	mov    %rax,%rdi
  80042073d0:	48 b8 4f 2e 20 04 80 	movabs $0x8004202e4f,%rax
  80042073d7:	00 00 00 
  80042073da:	ff d0                	callq  *%rax
  80042073dc:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm1 + PGSIZE, 0) = 0;
  80042073e3:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  80042073ea:	48 05 00 10 00 00    	add    $0x1000,%rax
  80042073f0:	48 89 c1             	mov    %rax,%rcx
  80042073f3:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  80042073fa:	00 00 00 
  80042073fd:	48 8b 00             	mov    (%rax),%rax
  8004207400:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207405:	48 89 ce             	mov    %rcx,%rsi
  8004207408:	48 89 c7             	mov    %rax,%rdi
  800420740b:	48 b8 4f 2e 20 04 80 	movabs $0x8004202e4f,%rax
  8004207412:	00 00 00 
  8004207415:	ff d0                	callq  *%rax
  8004207417:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm2, 0) = 0;
  800420741e:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004207425:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  800420742c:	00 00 00 
  800420742f:	48 8b 00             	mov    (%rax),%rax
  8004207432:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207437:	48 89 ce             	mov    %rcx,%rsi
  800420743a:	48 89 c7             	mov    %rax,%rdi
  800420743d:	48 b8 4f 2e 20 04 80 	movabs $0x8004202e4f,%rax
  8004207444:	00 00 00 
  8004207447:	ff d0                	callq  *%rax
  8004207449:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	cprintf("check_page() succeeded!\n");
  8004207450:	48 bf a3 81 21 04 80 	movabs $0x80042181a3,%rdi
  8004207457:	00 00 00 
  800420745a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420745f:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  8004207466:	00 00 00 
  8004207469:	ff d2                	callq  *%rdx
}
  800420746b:	48 81 c4 18 01 00 00 	add    $0x118,%rsp
  8004207472:	5b                   	pop    %rbx
  8004207473:	5d                   	pop    %rbp
  8004207474:	c3                   	retq   
  8004207475:	00 00                	add    %al,(%rax)
	...

0000008004207478 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004207478:	55                   	push   %rbp
  8004207479:	48 89 e5             	mov    %rsp,%rbp
  800420747c:	48 83 ec 08          	sub    $0x8,%rsp
  8004207480:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004207484:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207488:	48 b8 e8 c7 63 04 80 	movabs $0x800463c7e8,%rax
  800420748f:	00 00 00 
  8004207492:	48 8b 00             	mov    (%rax),%rax
  8004207495:	48 89 d1             	mov    %rdx,%rcx
  8004207498:	48 29 c1             	sub    %rax,%rcx
  800420749b:	48 89 c8             	mov    %rcx,%rax
  800420749e:	48 c1 f8 04          	sar    $0x4,%rax
}
  80042074a2:	c9                   	leaveq 
  80042074a3:	c3                   	retq   

00000080042074a4 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  80042074a4:	55                   	push   %rbp
  80042074a5:	48 89 e5             	mov    %rsp,%rbp
  80042074a8:	48 83 ec 08          	sub    $0x8,%rsp
  80042074ac:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  80042074b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042074b4:	48 89 c7             	mov    %rax,%rdi
  80042074b7:	48 b8 78 74 20 04 80 	movabs $0x8004207478,%rax
  80042074be:	00 00 00 
  80042074c1:	ff d0                	callq  *%rax
  80042074c3:	48 c1 e0 0c          	shl    $0xc,%rax
}
  80042074c7:	c9                   	leaveq 
  80042074c8:	c3                   	retq   

00000080042074c9 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  80042074c9:	55                   	push   %rbp
  80042074ca:	48 89 e5             	mov    %rsp,%rbp
  80042074cd:	48 83 ec 10          	sub    $0x10,%rsp
  80042074d1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  80042074d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042074d9:	48 89 c2             	mov    %rax,%rdx
  80042074dc:	48 c1 ea 0c          	shr    $0xc,%rdx
  80042074e0:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  80042074e7:	00 00 00 
  80042074ea:	48 8b 00             	mov    (%rax),%rax
  80042074ed:	48 39 c2             	cmp    %rax,%rdx
  80042074f0:	72 2a                	jb     800420751c <pa2page+0x53>
		panic("pa2page called with invalid pa");
  80042074f2:	48 ba c0 81 21 04 80 	movabs $0x80042181c0,%rdx
  80042074f9:	00 00 00 
  80042074fc:	be 59 00 00 00       	mov    $0x59,%esi
  8004207501:	48 bf df 81 21 04 80 	movabs $0x80042181df,%rdi
  8004207508:	00 00 00 
  800420750b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207510:	48 b9 f2 04 20 04 80 	movabs $0x80042004f2,%rcx
  8004207517:	00 00 00 
  800420751a:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  800420751c:	48 b8 e8 c7 63 04 80 	movabs $0x800463c7e8,%rax
  8004207523:	00 00 00 
  8004207526:	48 8b 00             	mov    (%rax),%rax
  8004207529:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420752d:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004207531:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207535:	48 01 d0             	add    %rdx,%rax
}
  8004207538:	c9                   	leaveq 
  8004207539:	c3                   	retq   

000000800420753a <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  800420753a:	55                   	push   %rbp
  800420753b:	48 89 e5             	mov    %rsp,%rbp
  800420753e:	48 83 ec 20          	sub    $0x20,%rsp
  8004207542:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004207546:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420754a:	48 89 c7             	mov    %rax,%rdi
  800420754d:	48 b8 a4 74 20 04 80 	movabs $0x80042074a4,%rax
  8004207554:	00 00 00 
  8004207557:	ff d0                	callq  *%rax
  8004207559:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420755d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207561:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207565:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004207568:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420756b:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004207572:	00 00 00 
  8004207575:	48 8b 00             	mov    (%rax),%rax
  8004207578:	48 39 c2             	cmp    %rax,%rdx
  800420757b:	72 32                	jb     80042075af <page2kva+0x75>
  800420757d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207581:	48 89 c1             	mov    %rax,%rcx
  8004207584:	48 ba f0 81 21 04 80 	movabs $0x80042181f0,%rdx
  800420758b:	00 00 00 
  800420758e:	be 60 00 00 00       	mov    $0x60,%esi
  8004207593:	48 bf df 81 21 04 80 	movabs $0x80042181df,%rdi
  800420759a:	00 00 00 
  800420759d:	b8 00 00 00 00       	mov    $0x0,%eax
  80042075a2:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042075a9:	00 00 00 
  80042075ac:	41 ff d0             	callq  *%r8
  80042075af:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  80042075b6:	00 00 00 
  80042075b9:	48 03 45 f8          	add    -0x8(%rbp),%rax
}
  80042075bd:	c9                   	leaveq 
  80042075be:	c3                   	retq   

00000080042075bf <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  80042075bf:	55                   	push   %rbp
  80042075c0:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  80042075c3:	48 bf 80 a7 22 04 80 	movabs $0x800422a780,%rdi
  80042075ca:	00 00 00 
  80042075cd:	48 b8 39 5a 21 04 80 	movabs $0x8004215a39,%rax
  80042075d4:	00 00 00 
  80042075d7:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  80042075d9:	f3 90                	pause  
}
  80042075db:	5d                   	pop    %rbp
  80042075dc:	c3                   	retq   

00000080042075dd <envid2env>:
//   On success, sets *env_store to the environment.
//   On error, sets *env_store to NULL.
//
	int
envid2env(envid_t envid, struct Env **env_store, bool checkperm)
{
  80042075dd:	55                   	push   %rbp
  80042075de:	48 89 e5             	mov    %rsp,%rbp
  80042075e1:	53                   	push   %rbx
  80042075e2:	48 83 ec 28          	sub    $0x28,%rsp
  80042075e6:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80042075e9:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042075ed:	89 d0                	mov    %edx,%eax
  80042075ef:	88 45 d8             	mov    %al,-0x28(%rbp)
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
  80042075f2:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80042075f6:	75 3e                	jne    8004207636 <envid2env+0x59>
		*env_store = curenv;
  80042075f8:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  80042075ff:	00 00 00 
  8004207602:	ff d0                	callq  *%rax
  8004207604:	48 98                	cltq   
  8004207606:	48 c1 e0 03          	shl    $0x3,%rax
  800420760a:	48 89 c2             	mov    %rax,%rdx
  800420760d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207611:	48 29 c2             	sub    %rax,%rdx
  8004207614:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420761b:	00 00 00 
  800420761e:	48 01 d0             	add    %rdx,%rax
  8004207621:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004207625:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207629:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  800420762c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207631:	e9 02 01 00 00       	jmpq   8004207738 <envid2env+0x15b>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
  8004207636:	48 b8 50 b2 63 04 80 	movabs $0x800463b250,%rax
  800420763d:	00 00 00 
  8004207640:	48 8b 08             	mov    (%rax),%rcx
  8004207643:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004207646:	48 98                	cltq   
  8004207648:	48 89 c2             	mov    %rax,%rdx
  800420764b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
  8004207651:	48 89 d0             	mov    %rdx,%rax
  8004207654:	48 c1 e0 03          	shl    $0x3,%rax
  8004207658:	48 01 d0             	add    %rdx,%rax
  800420765b:	48 c1 e0 05          	shl    $0x5,%rax
  800420765f:	48 01 c8             	add    %rcx,%rax
  8004207662:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
  8004207666:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420766a:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004207670:	85 c0                	test   %eax,%eax
  8004207672:	74 0f                	je     8004207683 <envid2env+0xa6>
  8004207674:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207678:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420767e:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  8004207681:	74 15                	je     8004207698 <envid2env+0xbb>
		*env_store = 0;
  8004207683:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207687:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  800420768e:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004207693:	e9 a0 00 00 00       	jmpq   8004207738 <envid2env+0x15b>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
  8004207698:	80 7d d8 00          	cmpb   $0x0,-0x28(%rbp)
  800420769c:	0f 84 86 00 00 00    	je     8004207728 <envid2env+0x14b>
  80042076a2:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  80042076a9:	00 00 00 
  80042076ac:	ff d0                	callq  *%rax
  80042076ae:	48 98                	cltq   
  80042076b0:	48 c1 e0 03          	shl    $0x3,%rax
  80042076b4:	48 89 c2             	mov    %rax,%rdx
  80042076b7:	48 c1 e2 04          	shl    $0x4,%rdx
  80042076bb:	48 29 c2             	sub    %rax,%rdx
  80042076be:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  80042076c5:	00 00 00 
  80042076c8:	48 01 d0             	add    %rdx,%rax
  80042076cb:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042076cf:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042076d3:	74 53                	je     8004207728 <envid2env+0x14b>
  80042076d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042076d9:	8b 98 cc 00 00 00    	mov    0xcc(%rax),%ebx
  80042076df:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  80042076e6:	00 00 00 
  80042076e9:	ff d0                	callq  *%rax
  80042076eb:	48 98                	cltq   
  80042076ed:	48 c1 e0 03          	shl    $0x3,%rax
  80042076f1:	48 89 c2             	mov    %rax,%rdx
  80042076f4:	48 c1 e2 04          	shl    $0x4,%rdx
  80042076f8:	48 29 c2             	sub    %rax,%rdx
  80042076fb:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  8004207702:	00 00 00 
  8004207705:	48 01 d0             	add    %rdx,%rax
  8004207708:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420770c:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207712:	39 c3                	cmp    %eax,%ebx
  8004207714:	74 12                	je     8004207728 <envid2env+0x14b>
		*env_store = 0;
  8004207716:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420771a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004207721:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004207726:	eb 10                	jmp    8004207738 <envid2env+0x15b>
	}

	*env_store = e;
  8004207728:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420772c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207730:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  8004207733:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004207738:	48 83 c4 28          	add    $0x28,%rsp
  800420773c:	5b                   	pop    %rbx
  800420773d:	5d                   	pop    %rbp
  800420773e:	c3                   	retq   

000000800420773f <env_init>:
// they are in the envs array (i.e., so that the first call to
// env_alloc() returns envs[0]).
//
	void
env_init(void)
{
  800420773f:	55                   	push   %rbp
  8004207740:	48 89 e5             	mov    %rsp,%rbp
  8004207743:	48 83 ec 10          	sub    $0x10,%rsp
	
	// Set up envs array
	// LAB 3: Your code here.
	struct Env *curr = NULL;
  8004207747:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420774e:	00 
	int i;
	for(i=0;i<NENV;i++)
  800420774f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004207756:	e9 db 00 00 00       	jmpq   8004207836 <env_init+0xf7>
	{
		envs[i].env_id=0;
  800420775b:	48 b8 50 b2 63 04 80 	movabs $0x800463b250,%rax
  8004207762:	00 00 00 
  8004207765:	48 8b 08             	mov    (%rax),%rcx
  8004207768:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420776b:	48 63 d0             	movslq %eax,%rdx
  800420776e:	48 89 d0             	mov    %rdx,%rax
  8004207771:	48 c1 e0 03          	shl    $0x3,%rax
  8004207775:	48 01 d0             	add    %rdx,%rax
  8004207778:	48 c1 e0 05          	shl    $0x5,%rax
  800420777c:	48 01 c8             	add    %rcx,%rax
  800420777f:	c7 80 c8 00 00 00 00 	movl   $0x0,0xc8(%rax)
  8004207786:	00 00 00 
		envs[i].env_status=ENV_FREE;
  8004207789:	48 b8 50 b2 63 04 80 	movabs $0x800463b250,%rax
  8004207790:	00 00 00 
  8004207793:	48 8b 08             	mov    (%rax),%rcx
  8004207796:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004207799:	48 63 d0             	movslq %eax,%rdx
  800420779c:	48 89 d0             	mov    %rdx,%rax
  800420779f:	48 c1 e0 03          	shl    $0x3,%rax
  80042077a3:	48 01 d0             	add    %rdx,%rax
  80042077a6:	48 c1 e0 05          	shl    $0x5,%rax
  80042077aa:	48 01 c8             	add    %rcx,%rax
  80042077ad:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  80042077b4:	00 00 00 
		if(curr)
  80042077b7:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042077bc:	74 32                	je     80042077f0 <env_init+0xb1>
			curr->env_link=&envs[i];
  80042077be:	48 b8 50 b2 63 04 80 	movabs $0x800463b250,%rax
  80042077c5:	00 00 00 
  80042077c8:	48 8b 08             	mov    (%rax),%rcx
  80042077cb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042077ce:	48 63 d0             	movslq %eax,%rdx
  80042077d1:	48 89 d0             	mov    %rdx,%rax
  80042077d4:	48 c1 e0 03          	shl    $0x3,%rax
  80042077d8:	48 01 d0             	add    %rdx,%rax
  80042077db:	48 c1 e0 05          	shl    $0x5,%rax
  80042077df:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042077e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042077e7:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
  80042077ee:	eb 1a                	jmp    800420780a <env_init+0xcb>
		else
			env_free_list=envs;
  80042077f0:	48 b8 50 b2 63 04 80 	movabs $0x800463b250,%rax
  80042077f7:	00 00 00 
  80042077fa:	48 8b 10             	mov    (%rax),%rdx
  80042077fd:	48 b8 58 b2 63 04 80 	movabs $0x800463b258,%rax
  8004207804:	00 00 00 
  8004207807:	48 89 10             	mov    %rdx,(%rax)
		curr = &envs[i];
  800420780a:	48 b8 50 b2 63 04 80 	movabs $0x800463b250,%rax
  8004207811:	00 00 00 
  8004207814:	48 8b 08             	mov    (%rax),%rcx
  8004207817:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420781a:	48 63 d0             	movslq %eax,%rdx
  800420781d:	48 89 d0             	mov    %rdx,%rax
  8004207820:	48 c1 e0 03          	shl    $0x3,%rax
  8004207824:	48 01 d0             	add    %rdx,%rax
  8004207827:	48 c1 e0 05          	shl    $0x5,%rax
  800420782b:	48 01 c8             	add    %rcx,%rax
  800420782e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	
	// Set up envs array
	// LAB 3: Your code here.
	struct Env *curr = NULL;
	int i;
	for(i=0;i<NENV;i++)
  8004207832:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004207836:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%rbp)
  800420783d:	0f 8e 18 ff ff ff    	jle    800420775b <env_init+0x1c>
		else
			env_free_list=envs;
		curr = &envs[i];
	}
	// Per-CPU part of the initialization
	env_init_percpu();
  8004207843:	48 b8 51 78 20 04 80 	movabs $0x8004207851,%rax
  800420784a:	00 00 00 
  800420784d:	ff d0                	callq  *%rax
}
  800420784f:	c9                   	leaveq 
  8004207850:	c3                   	retq   

0000008004207851 <env_init_percpu>:

// Load GDT and segment descriptors.
void
env_init_percpu(void)
{
  8004207851:	55                   	push   %rbp
  8004207852:	48 89 e5             	mov    %rsp,%rbp
  8004207855:	53                   	push   %rbx
  8004207856:	48 83 ec 10          	sub    $0x10,%rsp
  800420785a:	48 b8 88 a6 22 04 80 	movabs $0x800422a688,%rax
  8004207861:	00 00 00 
  8004207864:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}

static __inline void
lgdt(void *p)
{
	__asm __volatile("lgdt (%0)" : : "r" (p));
  8004207868:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420786c:	0f 01 10             	lgdt   (%rax)
lgdt(&gdt_pd);

// The kernel never uses GS or FS, so we leave those set to
// the user data segment.
asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
  800420786f:	b8 23 00 00 00       	mov    $0x23,%eax
  8004207874:	8e e8                	mov    %eax,%gs
asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
  8004207876:	b8 23 00 00 00       	mov    $0x23,%eax
  800420787b:	8e e0                	mov    %eax,%fs
// The kernel does use ES, DS, and SS.  We'll change between
// the kernel and user data segments as needed.
asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
  800420787d:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207882:	8e c0                	mov    %eax,%es
asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
  8004207884:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207889:	8e d8                	mov    %eax,%ds
asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
  800420788b:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207890:	8e d0                	mov    %eax,%ss
// Load the kernel text segment into CS.
asm volatile("pushq %%rbx \n \t movabs $1f,%%rax \n \t pushq %%rax \n\t lretq \n 1:\n" :: "b" (GD_KT):"cc","memory");
  8004207892:	b8 08 00 00 00       	mov    $0x8,%eax
  8004207897:	89 c3                	mov    %eax,%ebx
  8004207899:	53                   	push   %rbx
  800420789a:	48 b8 a7 78 20 04 80 	movabs $0x80042078a7,%rax
  80042078a1:	00 00 00 
  80042078a4:	50                   	push   %rax
  80042078a5:	48 cb                	lretq  
  80042078a7:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
}

static __inline void
lldt(uint16_t sel)
{
	__asm __volatile("lldt %0" : : "r" (sel));
  80042078ad:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  80042078b1:	0f 00 d0             	lldt   %ax
// For good measure, clear the local descriptor table (LDT),
// since we don't use it.
lldt(0);
}
  80042078b4:	48 83 c4 10          	add    $0x10,%rsp
  80042078b8:	5b                   	pop    %rbx
  80042078b9:	5d                   	pop    %rbp
  80042078ba:	c3                   	retq   

00000080042078bb <env_setup_vm>:
// Returns 0 on success, < 0 on error.  Errors include:
//	-E_NO_MEM if page directory or table could not be allocated.
//
	static int
env_setup_vm(struct Env *e)
{
  80042078bb:	55                   	push   %rbp
  80042078bc:	48 89 e5             	mov    %rsp,%rbp
  80042078bf:	48 83 ec 20          	sub    $0x20,%rsp
  80042078c3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int r;
	int i;
	struct PageInfo *p = NULL;
  80042078c7:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042078ce:	00 

	// Allocate a page for the page directory
	if (!(p = page_alloc(0)))
  80042078cf:	bf 00 00 00 00       	mov    $0x0,%edi
  80042078d4:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  80042078db:	00 00 00 
  80042078de:	ff d0                	callq  *%rax
  80042078e0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042078e4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042078e9:	75 0a                	jne    80042078f5 <env_setup_vm+0x3a>
		return -E_NO_MEM;
  80042078eb:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80042078f0:	e9 9f 00 00 00       	jmpq   8004207994 <env_setup_vm+0xd9>
	//	pp_ref for env_free to work correctly.
	//    - The functions in kern/pmap.h are handy.

	// LAB 3: Your code here.

	e->env_pml4e=(pml4e_t *)page2kva(p);
  80042078f5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042078f9:	48 89 c7             	mov    %rax,%rdi
  80042078fc:	48 b8 3a 75 20 04 80 	movabs $0x800420753a,%rax
  8004207903:	00 00 00 
  8004207906:	ff d0                	callq  *%rax
  8004207908:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420790c:	48 89 82 e0 00 00 00 	mov    %rax,0xe0(%rdx)
	e->env_cr3=page2pa(p);
  8004207913:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207917:	48 89 c7             	mov    %rax,%rdi
  800420791a:	48 b8 a4 74 20 04 80 	movabs $0x80042074a4,%rax
  8004207921:	00 00 00 
  8004207924:	ff d0                	callq  *%rax
  8004207926:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420792a:	48 89 82 e8 00 00 00 	mov    %rax,0xe8(%rdx)
	p->pp_ref++;
  8004207931:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207935:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207939:	8d 50 01             	lea    0x1(%rax),%edx
  800420793c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207940:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_pml4e[1]=boot_pml4e[1] | (PTE_P & ~(PTE_W|PTE_U));
  8004207944:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207948:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420794f:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004207953:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  800420795a:	00 00 00 
  800420795d:	48 8b 00             	mov    (%rax),%rax
  8004207960:	48 83 c0 08          	add    $0x8,%rax
  8004207964:	48 8b 00             	mov    (%rax),%rax
  8004207967:	48 83 c8 01          	or     $0x1,%rax
  800420796b:	48 89 02             	mov    %rax,(%rdx)
	// UVPT maps the env's own page table read-only.
	// Permissions: kernel R, user R
	e->env_pml4e[PML4(UVPT)] = e->env_cr3 | PTE_P | PTE_U;
  800420796e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207972:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207979:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420797d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207981:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004207988:	48 83 c8 05          	or     $0x5,%rax
  800420798c:	48 89 02             	mov    %rax,(%rdx)
	return 0;
  800420798f:	b8 00 00 00 00       	mov    $0x0,%eax

}
  8004207994:	c9                   	leaveq 
  8004207995:	c3                   	retq   

0000008004207996 <env_alloc>:
//	-E_NO_FREE_ENV if all NENVS environments are allocated
//	-E_NO_MEM on memory exhaustion
//
	int
env_alloc(struct Env **newenv_store, envid_t parent_id)
{
  8004207996:	55                   	push   %rbp
  8004207997:	48 89 e5             	mov    %rsp,%rbp
  800420799a:	48 83 ec 30          	sub    $0x30,%rsp
  800420799e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042079a2:	89 75 d4             	mov    %esi,-0x2c(%rbp)
	int32_t generation;
	int r;
	struct Env *e;

	if (!(e = env_free_list))
  80042079a5:	48 b8 58 b2 63 04 80 	movabs $0x800463b258,%rax
  80042079ac:	00 00 00 
  80042079af:	48 8b 00             	mov    (%rax),%rax
  80042079b2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042079b6:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042079bb:	75 0a                	jne    80042079c7 <env_alloc+0x31>
		return -E_NO_FREE_ENV;
  80042079bd:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  80042079c2:	e9 81 01 00 00       	jmpq   8004207b48 <env_alloc+0x1b2>

	// Allocate and set up the page directory for this environment.
	if ((r = env_setup_vm(e)) < 0)
  80042079c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042079cb:	48 89 c7             	mov    %rax,%rdi
  80042079ce:	48 b8 bb 78 20 04 80 	movabs $0x80042078bb,%rax
  80042079d5:	00 00 00 
  80042079d8:	ff d0                	callq  *%rax
  80042079da:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042079dd:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  80042079e1:	79 08                	jns    80042079eb <env_alloc+0x55>
		return r;
  80042079e3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042079e6:	e9 5d 01 00 00       	jmpq   8004207b48 <env_alloc+0x1b2>

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  80042079eb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042079ef:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  80042079f5:	05 00 10 00 00       	add    $0x1000,%eax
  80042079fa:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  80042079ff:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (generation <= 0)	// Don't create a negative env_id.
  8004207a02:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004207a06:	7f 07                	jg     8004207a0f <env_alloc+0x79>
		generation = 1 << ENVGENSHIFT;
  8004207a08:	c7 45 fc 00 10 00 00 	movl   $0x1000,-0x4(%rbp)
	e->env_id = generation | (e - envs);
  8004207a0f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207a13:	48 b8 50 b2 63 04 80 	movabs $0x800463b250,%rax
  8004207a1a:	00 00 00 
  8004207a1d:	48 8b 00             	mov    (%rax),%rax
  8004207a20:	48 89 d1             	mov    %rdx,%rcx
  8004207a23:	48 29 c1             	sub    %rax,%rcx
  8004207a26:	48 89 c8             	mov    %rcx,%rax
  8004207a29:	48 89 c2             	mov    %rax,%rdx
  8004207a2c:	48 c1 fa 05          	sar    $0x5,%rdx
  8004207a30:	48 b8 39 8e e3 38 8e 	movabs $0x8e38e38e38e38e39,%rax
  8004207a37:	e3 38 8e 
  8004207a3a:	48 0f af c2          	imul   %rdx,%rax
  8004207a3e:	89 c2                	mov    %eax,%edx
  8004207a40:	0b 55 fc             	or     -0x4(%rbp),%edx
  8004207a43:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207a47:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)

	// Set the basic status variables.
	e->env_parent_id = parent_id;
  8004207a4d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207a51:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004207a54:	89 90 cc 00 00 00    	mov    %edx,0xcc(%rax)
	e->env_type = ENV_TYPE_USER;
  8004207a5a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207a5e:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%rax)
  8004207a65:	00 00 00 
	e->env_status = ENV_RUNNABLE;
  8004207a68:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207a6c:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004207a73:	00 00 00 
	e->env_runs = 0;
  8004207a76:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207a7a:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  8004207a81:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(&e->env_tf, 0, sizeof(e->env_tf));
  8004207a84:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207a88:	ba c0 00 00 00       	mov    $0xc0,%edx
  8004207a8d:	be 00 00 00 00       	mov    $0x0,%esi
  8004207a92:	48 89 c7             	mov    %rax,%rdi
  8004207a95:	48 b8 53 e6 20 04 80 	movabs $0x800420e653,%rax
  8004207a9c:	00 00 00 
  8004207a9f:	ff d0                	callq  *%rax
	// The low 2 bits of each segment register contains the
	// Requestor Privilege Level (RPL); 3 means user mode.  When
	// we switch privilege levels, the hardware does various
	// checks involving the RPL and the Descriptor Privilege Level
	// (DPL) stored in the descriptors themselves.
	e->env_tf.tf_ds = GD_UD | 3;
  8004207aa1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207aa5:	66 c7 80 80 00 00 00 	movw   $0x23,0x80(%rax)
  8004207aac:	23 00 
	e->env_tf.tf_es = GD_UD | 3;
  8004207aae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207ab2:	66 c7 40 78 23 00    	movw   $0x23,0x78(%rax)
	e->env_tf.tf_ss = GD_UD | 3;
  8004207ab8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207abc:	66 c7 80 b8 00 00 00 	movw   $0x23,0xb8(%rax)
  8004207ac3:	23 00 
	e->env_tf.tf_rsp = USTACKTOP;
  8004207ac5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207ac9:	c7 80 b0 00 00 00 00 	movl   $0xef7fe000,0xb0(%rax)
  8004207ad0:	e0 7f ef 
  8004207ad3:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%rax)
  8004207ada:	00 00 00 
	e->env_tf.tf_cs = GD_UT | 3;
  8004207add:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207ae1:	66 c7 80 a0 00 00 00 	movw   $0x1b,0xa0(%rax)
  8004207ae8:	1b 00 
	//cprintf("\nInside env_alloc:tf_cs:%d",e->env_tf.tf_cs);
	// You will set e->env_tf.tf_rip later.

	// Enable interrupts while in user mode.
	// LAB 4: Your code here.
	e->env_tf.tf_eflags=e->env_tf.tf_eflags|FL_IF;	
  8004207aea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207aee:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  8004207af5:	48 89 c2             	mov    %rax,%rdx
  8004207af8:	80 ce 02             	or     $0x2,%dh
  8004207afb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207aff:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
	// Clear the page fault handler until user installs one.
	e->env_pgfault_upcall = 0;
  8004207b06:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207b0a:	48 c7 80 f0 00 00 00 	movq   $0x0,0xf0(%rax)
  8004207b11:	00 00 00 00 

	// Also clear the IPC receiving flag.
	e->env_ipc_recving = 0;
  8004207b15:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207b19:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)

	// commit the allocation
	env_free_list = e->env_link;
  8004207b20:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207b24:	48 8b 90 c0 00 00 00 	mov    0xc0(%rax),%rdx
  8004207b2b:	48 b8 58 b2 63 04 80 	movabs $0x800463b258,%rax
  8004207b32:	00 00 00 
  8004207b35:	48 89 10             	mov    %rdx,(%rax)
	*newenv_store = e;
  8004207b38:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207b3c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207b40:	48 89 10             	mov    %rdx,(%rax)

	// cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
	return 0;
  8004207b43:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004207b48:	c9                   	leaveq 
  8004207b49:	c3                   	retq   

0000008004207b4a <region_alloc>:
// Pages should be writable by user and kernel.
// Panic if any allocation attempt fails.
//
static void
region_alloc(struct Env *e, void *va, size_t len)
{
  8004207b4a:	55                   	push   %rbp
  8004207b4b:	48 89 e5             	mov    %rsp,%rbp
  8004207b4e:	48 83 ec 60          	sub    $0x60,%rsp
  8004207b52:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004207b56:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004207b5a:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
	// LAB 3: Your code here.
        // (But only if you need it for load_icode.)
        //
        struct PageInfo *temppage;
	//uint64_t va64=(uint64_t)va;
	uintptr_t start_page=ROUNDDOWN((uintptr_t)va,PGSIZE);
  8004207b5e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004207b62:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004207b66:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207b6a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207b70:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	uintptr_t end_page=ROUNDUP((uintptr_t)va+len,PGSIZE);
  8004207b74:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  8004207b7b:	00 
  8004207b7c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004207b80:	48 03 45 a8          	add    -0x58(%rbp),%rax
  8004207b84:	48 03 45 e8          	add    -0x18(%rbp),%rax
  8004207b88:	48 83 e8 01          	sub    $0x1,%rax
  8004207b8c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004207b90:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207b94:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207b99:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004207b9d:	48 89 d0             	mov    %rdx,%rax
  8004207ba0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004207ba4:	48 89 d1             	mov    %rdx,%rcx
  8004207ba7:	48 29 c1             	sub    %rax,%rcx
  8004207baa:	48 89 c8             	mov    %rcx,%rax
  8004207bad:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	int result;
	//int i, npages, result;
	//uint64_t *tempva=(uint64_t *)va64;
	//npages=(end_page-start_page)/PGSIZE;
	while(start_page < end_page)
  8004207bb1:	e9 a8 00 00 00       	jmpq   8004207c5e <region_alloc+0x114>
	{
		//tempva+=i*PGSIZE;
		temppage=page_alloc(0);
  8004207bb6:	bf 00 00 00 00       	mov    $0x0,%edi
  8004207bbb:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  8004207bc2:	00 00 00 
  8004207bc5:	ff d0                	callq  *%rax
  8004207bc7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(temppage==NULL)
  8004207bcb:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004207bd0:	75 2a                	jne    8004207bfc <region_alloc+0xb2>
		{
			panic("region_alloc:page_alloc fails");
  8004207bd2:	48 ba 13 82 21 04 80 	movabs $0x8004218213,%rdx
  8004207bd9:	00 00 00 
  8004207bdc:	be 3c 01 00 00       	mov    $0x13c,%esi
  8004207be1:	48 bf 31 82 21 04 80 	movabs $0x8004218231,%rdi
  8004207be8:	00 00 00 
  8004207beb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207bf0:	48 b9 f2 04 20 04 80 	movabs $0x80042004f2,%rcx
  8004207bf7:	00 00 00 
  8004207bfa:	ff d1                	callq  *%rcx
			return;
		}
		//cprintf("start_page:%x\n",start_page);
		//cprintf("%x\n",va);
		result=page_insert(e->env_pml4e,temppage,(void *)start_page,PTE_U|PTE_W | PTE_P);
  8004207bfc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207c00:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207c04:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207c0b:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004207c0f:	b9 07 00 00 00       	mov    $0x7,%ecx
  8004207c14:	48 89 c7             	mov    %rax,%rdi
  8004207c17:	48 b8 4b 35 20 04 80 	movabs $0x800420354b,%rax
  8004207c1e:	00 00 00 
  8004207c21:	ff d0                	callq  *%rax
  8004207c23:	89 45 cc             	mov    %eax,-0x34(%rbp)
		if(result!=0)
  8004207c26:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004207c2a:	74 2a                	je     8004207c56 <region_alloc+0x10c>
		{
			panic("region_alloc:page_insert fails");	
  8004207c2c:	48 ba 40 82 21 04 80 	movabs $0x8004218240,%rdx
  8004207c33:	00 00 00 
  8004207c36:	be 44 01 00 00       	mov    $0x144,%esi
  8004207c3b:	48 bf 31 82 21 04 80 	movabs $0x8004218231,%rdi
  8004207c42:	00 00 00 
  8004207c45:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207c4a:	48 b9 f2 04 20 04 80 	movabs $0x80042004f2,%rcx
  8004207c51:	00 00 00 
  8004207c54:	ff d1                	callq  *%rcx
			return;
		}
		start_page+=PGSIZE;
  8004207c56:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004207c5d:	00 
	uintptr_t end_page=ROUNDUP((uintptr_t)va+len,PGSIZE);
	int result;
	//int i, npages, result;
	//uint64_t *tempva=(uint64_t *)va64;
	//npages=(end_page-start_page)/PGSIZE;
	while(start_page < end_page)
  8004207c5e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207c62:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004207c66:	0f 82 4a ff ff ff    	jb     8004207bb6 <region_alloc+0x6c>
		start_page+=PGSIZE;
	}
	//   'va' and 'len' values that are not page-aligned.
	//   You should round va down, and round (va + len) up.
	//   (Watch out for corner-cases!)
}
  8004207c6c:	c9                   	leaveq 
  8004207c6d:	c3                   	retq   

0000008004207c6e <load_icode>:
// load_icode panics if it encounters problems.
//  - How might load_icode fail?  What might be wrong with the given input?
//
void
load_icode(struct Env *e, uint8_t *binary)
{
  8004207c6e:	55                   	push   %rbp
  8004207c6f:	48 89 e5             	mov    %rsp,%rbp
  8004207c72:	48 83 ec 30          	sub    $0x30,%rsp
  8004207c76:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004207c7a:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	// LAB 3: Your code here.
   	// e->elf = binary;
 	
	struct Proghdr *ph, *eph;
        struct Elf *elf;
        elf=(struct Elf *)binary;
  8004207c7e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207c82:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        if (elf->e_magic != ELF_MAGIC)
  8004207c86:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207c8a:	8b 00                	mov    (%rax),%eax
  8004207c8c:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
  8004207c91:	74 2a                	je     8004207cbd <load_icode+0x4f>
                panic("Not a valid ELF !!!!");
  8004207c93:	48 ba 5f 82 21 04 80 	movabs $0x800421825f,%rdx
  8004207c9a:	00 00 00 
  8004207c9d:	be 8f 01 00 00       	mov    $0x18f,%esi
  8004207ca2:	48 bf 31 82 21 04 80 	movabs $0x8004218231,%rdi
  8004207ca9:	00 00 00 
  8004207cac:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207cb1:	48 b9 f2 04 20 04 80 	movabs $0x80042004f2,%rcx
  8004207cb8:	00 00 00 
  8004207cbb:	ff d1                	callq  *%rcx
        ph = (struct Proghdr *) ((uint8_t *) elf + elf->e_phoff);
  8004207cbd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207cc1:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004207cc5:	48 03 45 f0          	add    -0x10(%rbp),%rax
  8004207cc9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        eph = ph + elf->e_phnum;
  8004207ccd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207cd1:	0f b7 40 38          	movzwl 0x38(%rax),%eax
  8004207cd5:	0f b7 c0             	movzwl %ax,%eax
  8004207cd8:	48 c1 e0 03          	shl    $0x3,%rax
  8004207cdc:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207ce3:	00 
  8004207ce4:	48 89 d1             	mov    %rdx,%rcx
  8004207ce7:	48 29 c1             	sub    %rax,%rcx
  8004207cea:	48 89 c8             	mov    %rcx,%rax
  8004207ced:	48 03 45 f8          	add    -0x8(%rbp),%rax
  8004207cf1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	
	lcr3(e->env_cr3);
  8004207cf5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207cf9:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004207d00:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004207d04:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207d08:	0f 22 d8             	mov    %rax,%cr3
	
        for (; ph < eph; ph++)
  8004207d0b:	e9 a8 00 00 00       	jmpq   8004207db8 <load_icode+0x14a>
        {
                if(ph->p_type==ELF_PROG_LOAD)
  8004207d10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207d14:	8b 00                	mov    (%rax),%eax
  8004207d16:	83 f8 01             	cmp    $0x1,%eax
  8004207d19:	0f 85 94 00 00 00    	jne    8004207db3 <load_icode+0x145>
                {
                        region_alloc(e,(void*)ph->p_va,ph->p_memsz);
  8004207d1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207d23:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004207d27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207d2b:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004207d2f:	48 89 c1             	mov    %rax,%rcx
  8004207d32:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207d36:	48 89 ce             	mov    %rcx,%rsi
  8004207d39:	48 89 c7             	mov    %rax,%rdi
  8004207d3c:	48 b8 4a 7b 20 04 80 	movabs $0x8004207b4a,%rax
  8004207d43:	00 00 00 
  8004207d46:	ff d0                	callq  *%rax
                        memcpy((void *)ph->p_va,binary + ph->p_offset,ph->p_filesz);
  8004207d48:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207d4c:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004207d50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207d54:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004207d58:	48 89 c1             	mov    %rax,%rcx
  8004207d5b:	48 03 4d d0          	add    -0x30(%rbp),%rcx
  8004207d5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207d63:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004207d67:	48 89 ce             	mov    %rcx,%rsi
  8004207d6a:	48 89 c7             	mov    %rax,%rdi
  8004207d6d:	48 b8 f5 e7 20 04 80 	movabs $0x800420e7f5,%rax
  8004207d74:	00 00 00 
  8004207d77:	ff d0                	callq  *%rax
			memset((void *)(ph->p_va+ph->p_filesz),0,ph->p_memsz-ph->p_filesz);
  8004207d79:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207d7d:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004207d81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207d85:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004207d89:	48 29 c2             	sub    %rax,%rdx
  8004207d8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207d90:	48 8b 48 10          	mov    0x10(%rax),%rcx
  8004207d94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207d98:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004207d9c:	48 01 c8             	add    %rcx,%rax
  8004207d9f:	be 00 00 00 00       	mov    $0x0,%esi
  8004207da4:	48 89 c7             	mov    %rax,%rdi
  8004207da7:	48 b8 53 e6 20 04 80 	movabs $0x800420e653,%rax
  8004207dae:	00 00 00 
  8004207db1:	ff d0                	callq  *%rax
        ph = (struct Proghdr *) ((uint8_t *) elf + elf->e_phoff);
        eph = ph + elf->e_phnum;
	
	lcr3(e->env_cr3);
	
        for (; ph < eph; ph++)
  8004207db3:	48 83 45 f8 38       	addq   $0x38,-0x8(%rbp)
  8004207db8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207dbc:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004207dc0:	0f 82 4a ff ff ff    	jb     8004207d10 <load_icode+0xa2>
	if(page_insert(e->env_pml4e,pg,(void *)USTACKTOP-PGSIZE, PTE_U|PTE_W)!=0)
	{
		panic("load_icode:page_insert() failed");
		return;
	}*/
	region_alloc(e,(void *)(USTACKTOP-PGSIZE), PGSIZE);
  8004207dc6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207dca:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004207dcf:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  8004207dd4:	48 89 c7             	mov    %rax,%rdi
  8004207dd7:	48 b8 4a 7b 20 04 80 	movabs $0x8004207b4a,%rax
  8004207dde:	00 00 00 
  8004207de1:	ff d0                	callq  *%rax
	//((void (*)(void)) ((uint32_t)(elf->e_entry)))();
	e->elf=binary;
  8004207de3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207de7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004207deb:	48 89 90 18 01 00 00 	mov    %rdx,0x118(%rax)
	e->env_tf.tf_rip=elf->e_entry;
  8004207df2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207df6:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004207dfa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207dfe:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
}
  8004207e05:	c9                   	leaveq 
  8004207e06:	c3                   	retq   

0000008004207e07 <env_create>:
// before running the first user-mode environment.
// The new env's parent ID is set to 0.
//
void
env_create(uint8_t *binary, enum EnvType type)
{
  8004207e07:	55                   	push   %rbp
  8004207e08:	48 89 e5             	mov    %rsp,%rbp
  8004207e0b:	48 83 ec 20          	sub    $0x20,%rsp
  8004207e0f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004207e13:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.
	// LAB 5: Your code here.
//=======
	struct Env *newenv;
	int result;
	result=env_alloc(&newenv,0);
  8004207e16:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  8004207e1a:	be 00 00 00 00       	mov    $0x0,%esi
  8004207e1f:	48 89 c7             	mov    %rax,%rdi
  8004207e22:	48 b8 96 79 20 04 80 	movabs $0x8004207996,%rax
  8004207e29:	00 00 00 
  8004207e2c:	ff d0                	callq  *%rax
  8004207e2e:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(result<0)
  8004207e31:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004207e35:	79 2a                	jns    8004207e61 <env_create+0x5a>
	{
		panic("env_create:env_alloc() failed");
  8004207e37:	48 ba 74 82 21 04 80 	movabs $0x8004218274,%rdx
  8004207e3e:	00 00 00 
  8004207e41:	be c7 01 00 00       	mov    $0x1c7,%esi
  8004207e46:	48 bf 31 82 21 04 80 	movabs $0x8004218231,%rdi
  8004207e4d:	00 00 00 
  8004207e50:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207e55:	48 b9 f2 04 20 04 80 	movabs $0x80042004f2,%rcx
  8004207e5c:	00 00 00 
  8004207e5f:	ff d1                	callq  *%rcx
		return;
	}
	load_icode(newenv,binary);
  8004207e61:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207e65:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207e69:	48 89 d6             	mov    %rdx,%rsi
  8004207e6c:	48 89 c7             	mov    %rax,%rdi
  8004207e6f:	48 b8 6e 7c 20 04 80 	movabs $0x8004207c6e,%rax
  8004207e76:	00 00 00 
  8004207e79:	ff d0                	callq  *%rax
	newenv->env_type=type;
  8004207e7b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207e7f:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004207e82:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)
	if(type == ENV_TYPE_FS)
  8004207e88:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  8004207e8c:	75 19                	jne    8004207ea7 <env_create+0xa0>
		newenv->env_tf.tf_eflags |= FL_IOPL_MASK;
  8004207e8e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207e92:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207e96:	48 8b 92 a8 00 00 00 	mov    0xa8(%rdx),%rdx
  8004207e9d:	80 ce 30             	or     $0x30,%dh
  8004207ea0:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
	//else
	//	newenv->env_tf.tf_eflags |= FL_IOPL_0;
//>>>>>>> lab4
}
  8004207ea7:	c9                   	leaveq 
  8004207ea8:	c3                   	retq   

0000008004207ea9 <env_free>:
//
// Frees env e and all memory it uses.
//
	void
env_free(struct Env *e)
{
  8004207ea9:	55                   	push   %rbp
  8004207eaa:	48 89 e5             	mov    %rsp,%rbp
  8004207ead:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  8004207eb4:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
	physaddr_t pa;

	// If freeing the current environment, switch to kern_pgdir
	// before freeing the page directory, just in case the page
	// gets reused.
	if (e == curenv)
  8004207ebb:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  8004207ec2:	00 00 00 
  8004207ec5:	ff d0                	callq  *%rax
  8004207ec7:	48 98                	cltq   
  8004207ec9:	48 c1 e0 03          	shl    $0x3,%rax
  8004207ecd:	48 89 c2             	mov    %rax,%rdx
  8004207ed0:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207ed4:	48 29 c2             	sub    %rax,%rdx
  8004207ed7:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  8004207ede:	00 00 00 
  8004207ee1:	48 01 d0             	add    %rdx,%rax
  8004207ee4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004207ee8:	48 3b 85 78 ff ff ff 	cmp    -0x88(%rbp),%rax
  8004207eef:	75 18                	jne    8004207f09 <env_free+0x60>
		lcr3(boot_cr3);
  8004207ef1:	48 b8 d0 c7 63 04 80 	movabs $0x800463c7d0,%rax
  8004207ef8:	00 00 00 
  8004207efb:	48 8b 00             	mov    (%rax),%rax
  8004207efe:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004207f02:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004207f06:	0f 22 d8             	mov    %rax,%cr3

	// Note the environment's demise.
	// cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);

	// Flush all mapped pages in the user portion of the address space
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
  8004207f09:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004207f10:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207f17:	48 8b 00             	mov    (%rax),%rax
  8004207f1a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207f20:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004207f24:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207f28:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207f2c:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004207f2f:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004207f32:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004207f39:	00 00 00 
  8004207f3c:	48 8b 00             	mov    (%rax),%rax
  8004207f3f:	48 39 c2             	cmp    %rax,%rdx
  8004207f42:	72 32                	jb     8004207f76 <env_free+0xcd>
  8004207f44:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207f48:	48 89 c1             	mov    %rax,%rcx
  8004207f4b:	48 ba f0 81 21 04 80 	movabs $0x80042181f0,%rdx
  8004207f52:	00 00 00 
  8004207f55:	be e7 01 00 00       	mov    $0x1e7,%esi
  8004207f5a:	48 bf 31 82 21 04 80 	movabs $0x8004218231,%rdi
  8004207f61:	00 00 00 
  8004207f64:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207f69:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004207f70:	00 00 00 
  8004207f73:	41 ff d0             	callq  *%r8
  8004207f76:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004207f7d:	00 00 00 
  8004207f80:	48 03 45 e0          	add    -0x20(%rbp),%rax
  8004207f84:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  8004207f88:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004207f8f:	00 
  8004207f90:	e9 70 02 00 00       	jmpq   8004208205 <env_free+0x35c>
		if(!(env_pdpe[pdpe_index] & PTE_P))
  8004207f95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207f99:	48 c1 e0 03          	shl    $0x3,%rax
  8004207f9d:	48 03 45 d0          	add    -0x30(%rbp),%rax
  8004207fa1:	48 8b 00             	mov    (%rax),%rax
  8004207fa4:	83 e0 01             	and    $0x1,%eax
  8004207fa7:	48 85 c0             	test   %rax,%rax
  8004207faa:	0f 84 4f 02 00 00    	je     80042081ff <env_free+0x356>
			continue;
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
  8004207fb0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207fb4:	48 c1 e0 03          	shl    $0x3,%rax
  8004207fb8:	48 03 45 d0          	add    -0x30(%rbp),%rax
  8004207fbc:	48 8b 00             	mov    (%rax),%rax
  8004207fbf:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207fc5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004207fc9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207fcd:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207fd1:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004207fd4:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004207fd7:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004207fde:	00 00 00 
  8004207fe1:	48 8b 00             	mov    (%rax),%rax
  8004207fe4:	48 39 c2             	cmp    %rax,%rdx
  8004207fe7:	72 32                	jb     800420801b <env_free+0x172>
  8004207fe9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207fed:	48 89 c1             	mov    %rax,%rcx
  8004207ff0:	48 ba f0 81 21 04 80 	movabs $0x80042181f0,%rdx
  8004207ff7:	00 00 00 
  8004207ffa:	be ef 01 00 00       	mov    $0x1ef,%esi
  8004207fff:	48 bf 31 82 21 04 80 	movabs $0x8004218231,%rdi
  8004208006:	00 00 00 
  8004208009:	b8 00 00 00 00       	mov    $0x0,%eax
  800420800e:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004208015:	00 00 00 
  8004208018:	41 ff d0             	callq  *%r8
  800420801b:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004208022:	00 00 00 
  8004208025:	48 03 45 c8          	add    -0x38(%rbp),%rax
  8004208029:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
  800420802d:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  8004208032:	75 07                	jne    800420803b <env_free+0x192>
  8004208034:	b8 04 00 00 00       	mov    $0x4,%eax
  8004208039:	eb 05                	jmp    8004208040 <env_free+0x197>
  800420803b:	b8 ff 01 00 00       	mov    $0x1ff,%eax
  8004208040:	89 45 b4             	mov    %eax,-0x4c(%rbp)
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004208043:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420804a:	00 
  800420804b:	e9 50 01 00 00       	jmpq   80042081a0 <env_free+0x2f7>

			// only look at mapped page tables
			if (!(env_pgdir[pdeno] & PTE_P))
  8004208050:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208054:	48 c1 e0 03          	shl    $0x3,%rax
  8004208058:	48 03 45 b8          	add    -0x48(%rbp),%rax
  800420805c:	48 8b 00             	mov    (%rax),%rax
  800420805f:	83 e0 01             	and    $0x1,%eax
  8004208062:	48 85 c0             	test   %rax,%rax
  8004208065:	0f 84 2f 01 00 00    	je     800420819a <env_free+0x2f1>
				continue;
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
  800420806b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420806f:	48 c1 e0 03          	shl    $0x3,%rax
  8004208073:	48 03 45 b8          	add    -0x48(%rbp),%rax
  8004208077:	48 8b 00             	mov    (%rax),%rax
  800420807a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208080:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			pt = (pte_t*) KADDR(pa);
  8004208084:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208088:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  800420808c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004208090:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208094:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8004208097:	8b 55 9c             	mov    -0x64(%rbp),%edx
  800420809a:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  80042080a1:	00 00 00 
  80042080a4:	48 8b 00             	mov    (%rax),%rax
  80042080a7:	48 39 c2             	cmp    %rax,%rdx
  80042080aa:	72 32                	jb     80042080de <env_free+0x235>
  80042080ac:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042080b0:	48 89 c1             	mov    %rax,%rcx
  80042080b3:	48 ba f0 81 21 04 80 	movabs $0x80042181f0,%rdx
  80042080ba:	00 00 00 
  80042080bd:	be f9 01 00 00       	mov    $0x1f9,%esi
  80042080c2:	48 bf 31 82 21 04 80 	movabs $0x8004218231,%rdi
  80042080c9:	00 00 00 
  80042080cc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042080d1:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042080d8:	00 00 00 
  80042080db:	41 ff d0             	callq  *%r8
  80042080de:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  80042080e5:	00 00 00 
  80042080e8:	48 03 45 a0          	add    -0x60(%rbp),%rax
  80042080ec:	48 89 45 90          	mov    %rax,-0x70(%rbp)

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  80042080f0:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042080f7:	00 
  80042080f8:	eb 5f                	jmp    8004208159 <env_free+0x2b0>
				if (pt[pteno] & PTE_P){
  80042080fa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042080fe:	48 c1 e0 03          	shl    $0x3,%rax
  8004208102:	48 03 45 90          	add    -0x70(%rbp),%rax
  8004208106:	48 8b 00             	mov    (%rax),%rax
  8004208109:	83 e0 01             	and    $0x1,%eax
  800420810c:	84 c0                	test   %al,%al
  800420810e:	74 44                	je     8004208154 <env_free+0x2ab>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
  8004208110:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208114:	48 89 c2             	mov    %rax,%rdx
  8004208117:	48 c1 e2 1e          	shl    $0x1e,%rdx
  800420811b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420811f:	48 c1 e0 15          	shl    $0x15,%rax
  8004208123:	48 09 c2             	or     %rax,%rdx
  8004208126:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420812a:	48 c1 e0 0c          	shl    $0xc,%rax
  800420812e:	48 09 d0             	or     %rdx,%rax
  8004208131:	48 89 c2             	mov    %rax,%rdx
  8004208134:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420813b:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208142:	48 89 d6             	mov    %rdx,%rsi
  8004208145:	48 89 c7             	mov    %rax,%rdi
  8004208148:	48 b8 03 37 20 04 80 	movabs $0x8004203703,%rax
  800420814f:	00 00 00 
  8004208152:	ff d0                	callq  *%rax
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
			pt = (pte_t*) KADDR(pa);

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  8004208154:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004208159:	48 81 7d f0 fe 01 00 	cmpq   $0x1fe,-0x10(%rbp)
  8004208160:	00 
  8004208161:	76 97                	jbe    80042080fa <env_free+0x251>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
				}
			}

			// free the page table itself
			env_pgdir[pdeno] = 0;
  8004208163:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208167:	48 c1 e0 03          	shl    $0x3,%rax
  800420816b:	48 03 45 b8          	add    -0x48(%rbp),%rax
  800420816f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			page_decref(pa2page(pa));
  8004208176:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420817a:	48 89 c7             	mov    %rax,%rdi
  800420817d:	48 b8 c9 74 20 04 80 	movabs $0x80042074c9,%rax
  8004208184:	00 00 00 
  8004208187:	ff d0                	callq  *%rax
  8004208189:	48 89 c7             	mov    %rax,%rdi
  800420818c:	48 b8 0e 2e 20 04 80 	movabs $0x8004202e0e,%rax
  8004208193:	00 00 00 
  8004208196:	ff d0                	callq  *%rax
  8004208198:	eb 01                	jmp    800420819b <env_free+0x2f2>
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {

			// only look at mapped page tables
			if (!(env_pgdir[pdeno] & PTE_P))
				continue;
  800420819a:	90                   	nop
		if(!(env_pdpe[pdpe_index] & PTE_P))
			continue;
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  800420819b:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  80042081a0:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  80042081a3:	48 98                	cltq   
  80042081a5:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042081a9:	0f 87 a1 fe ff ff    	ja     8004208050 <env_free+0x1a7>
			// free the page table itself
			env_pgdir[pdeno] = 0;
			page_decref(pa2page(pa));
		}
		// free the page directory
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
  80042081af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042081b3:	48 c1 e0 03          	shl    $0x3,%rax
  80042081b7:	48 03 45 d0          	add    -0x30(%rbp),%rax
  80042081bb:	48 8b 00             	mov    (%rax),%rax
  80042081be:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042081c4:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
		env_pdpe[pdpe_index] = 0;
  80042081c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042081cc:	48 c1 e0 03          	shl    $0x3,%rax
  80042081d0:	48 03 45 d0          	add    -0x30(%rbp),%rax
  80042081d4:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		page_decref(pa2page(pa));
  80042081db:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042081df:	48 89 c7             	mov    %rax,%rdi
  80042081e2:	48 b8 c9 74 20 04 80 	movabs $0x80042074c9,%rax
  80042081e9:	00 00 00 
  80042081ec:	ff d0                	callq  *%rax
  80042081ee:	48 89 c7             	mov    %rax,%rdi
  80042081f1:	48 b8 0e 2e 20 04 80 	movabs $0x8004202e0e,%rax
  80042081f8:	00 00 00 
  80042081fb:	ff d0                	callq  *%rax
  80042081fd:	eb 01                	jmp    8004208200 <env_free+0x357>
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
		if(!(env_pdpe[pdpe_index] & PTE_P))
			continue;
  80042081ff:	90                   	nop
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  8004208200:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004208205:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  800420820a:	0f 86 85 fd ff ff    	jbe    8004207f95 <env_free+0xec>
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
		env_pdpe[pdpe_index] = 0;
		page_decref(pa2page(pa));
	}
	// free the page directory pointer
	page_decref(pa2page(PTE_ADDR(e->env_pml4e[0])));
  8004208210:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208217:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420821e:	48 8b 00             	mov    (%rax),%rax
  8004208221:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208227:	48 89 c7             	mov    %rax,%rdi
  800420822a:	48 b8 c9 74 20 04 80 	movabs $0x80042074c9,%rax
  8004208231:	00 00 00 
  8004208234:	ff d0                	callq  *%rax
  8004208236:	48 89 c7             	mov    %rax,%rdi
  8004208239:	48 b8 0e 2e 20 04 80 	movabs $0x8004202e0e,%rax
  8004208240:	00 00 00 
  8004208243:	ff d0                	callq  *%rax
	// free the page map level 4 (PML4)
	e->env_pml4e[0] = 0;
  8004208245:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420824c:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208253:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	pa = e->env_cr3;
  800420825a:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208261:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208268:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	e->env_pml4e = 0;
  800420826c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208273:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  800420827a:	00 00 00 00 
	e->env_cr3 = 0;
  800420827e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208285:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  800420828c:	00 00 00 00 
	page_decref(pa2page(pa));
  8004208290:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208294:	48 89 c7             	mov    %rax,%rdi
  8004208297:	48 b8 c9 74 20 04 80 	movabs $0x80042074c9,%rax
  800420829e:	00 00 00 
  80042082a1:	ff d0                	callq  *%rax
  80042082a3:	48 89 c7             	mov    %rax,%rdi
  80042082a6:	48 b8 0e 2e 20 04 80 	movabs $0x8004202e0e,%rax
  80042082ad:	00 00 00 
  80042082b0:	ff d0                	callq  *%rax

	// return the environment to the free list
	e->env_status = ENV_FREE;
  80042082b2:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042082b9:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  80042082c0:	00 00 00 
	e->env_link = env_free_list;
  80042082c3:	48 b8 58 b2 63 04 80 	movabs $0x800463b258,%rax
  80042082ca:	00 00 00 
  80042082cd:	48 8b 10             	mov    (%rax),%rdx
  80042082d0:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042082d7:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
	env_free_list = e;
  80042082de:	48 b8 58 b2 63 04 80 	movabs $0x800463b258,%rax
  80042082e5:	00 00 00 
  80042082e8:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  80042082ef:	48 89 10             	mov    %rdx,(%rax)
}
  80042082f2:	c9                   	leaveq 
  80042082f3:	c3                   	retq   

00000080042082f4 <env_destroy>:
// If e was the current env, then runs a new environment (and does not return
// to the caller).
//
	void
env_destroy(struct Env *e)
{
  80042082f4:	55                   	push   %rbp
  80042082f5:	48 89 e5             	mov    %rsp,%rbp
  80042082f8:	48 83 ec 10          	sub    $0x10,%rsp
  80042082fc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// If e is currently running on other CPUs, we change its state to
	// ENV_DYING. A zombie environment will be freed the next time
	// it traps to the kernel.
	if (e->env_status == ENV_RUNNING && curenv != e) {
  8004208300:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208304:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420830a:	83 f8 03             	cmp    $0x3,%eax
  800420830d:	75 46                	jne    8004208355 <env_destroy+0x61>
  800420830f:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  8004208316:	00 00 00 
  8004208319:	ff d0                	callq  *%rax
  800420831b:	48 98                	cltq   
  800420831d:	48 c1 e0 03          	shl    $0x3,%rax
  8004208321:	48 89 c2             	mov    %rax,%rdx
  8004208324:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208328:	48 29 c2             	sub    %rax,%rdx
  800420832b:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  8004208332:	00 00 00 
  8004208335:	48 01 d0             	add    %rdx,%rax
  8004208338:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420833c:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208340:	74 13                	je     8004208355 <env_destroy+0x61>
		e->env_status = ENV_DYING;
  8004208342:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208346:	c7 80 d4 00 00 00 01 	movl   $0x1,0xd4(%rax)
  800420834d:	00 00 00 
		return;
  8004208350:	e9 83 00 00 00       	jmpq   80042083d8 <env_destroy+0xe4>
	}

	env_free(e);
  8004208355:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208359:	48 89 c7             	mov    %rax,%rdi
  800420835c:	48 b8 a9 7e 20 04 80 	movabs $0x8004207ea9,%rax
  8004208363:	00 00 00 
  8004208366:	ff d0                	callq  *%rax

	if (curenv == e) {
  8004208368:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420836f:	00 00 00 
  8004208372:	ff d0                	callq  *%rax
  8004208374:	48 98                	cltq   
  8004208376:	48 c1 e0 03          	shl    $0x3,%rax
  800420837a:	48 89 c2             	mov    %rax,%rdx
  800420837d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208381:	48 29 c2             	sub    %rax,%rdx
  8004208384:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420838b:	00 00 00 
  800420838e:	48 01 d0             	add    %rdx,%rax
  8004208391:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004208395:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208399:	75 3d                	jne    80042083d8 <env_destroy+0xe4>
		curenv = NULL;
  800420839b:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  80042083a2:	00 00 00 
  80042083a5:	ff d0                	callq  *%rax
  80042083a7:	48 98                	cltq   
  80042083a9:	48 c1 e0 03          	shl    $0x3,%rax
  80042083ad:	48 89 c2             	mov    %rax,%rdx
  80042083b0:	48 c1 e2 04          	shl    $0x4,%rdx
  80042083b4:	48 29 c2             	sub    %rax,%rdx
  80042083b7:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  80042083be:	00 00 00 
  80042083c1:	48 01 d0             	add    %rdx,%rax
  80042083c4:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80042083cb:	00 
		sched_yield();
  80042083cc:	48 b8 db bc 20 04 80 	movabs $0x800420bcdb,%rax
  80042083d3:	00 00 00 
  80042083d6:	ff d0                	callq  *%rax
	}
}
  80042083d8:	c9                   	leaveq 
  80042083d9:	c3                   	retq   

00000080042083da <env_pop_tf>:
//
// This function does not return.
//
	void
env_pop_tf(struct Trapframe *tf)
{
  80042083da:	55                   	push   %rbp
  80042083db:	48 89 e5             	mov    %rsp,%rbp
  80042083de:	53                   	push   %rbx
  80042083df:	48 83 ec 18          	sub    $0x18,%rsp
  80042083e3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
//<<<<<<< HEAD
	// Record the CPU we are running on for user-space debugging
	curenv->env_cpunum = cpunum();
  80042083e7:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  80042083ee:	00 00 00 
  80042083f1:	ff d0                	callq  *%rax
  80042083f3:	48 98                	cltq   
  80042083f5:	48 c1 e0 03          	shl    $0x3,%rax
  80042083f9:	48 89 c2             	mov    %rax,%rdx
  80042083fc:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208400:	48 29 c2             	sub    %rax,%rdx
  8004208403:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420840a:	00 00 00 
  800420840d:	48 01 d0             	add    %rdx,%rax
  8004208410:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004208414:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420841b:	00 00 00 
  800420841e:	ff d0                	callq  *%rax
  8004208420:	89 83 dc 00 00 00    	mov    %eax,0xdc(%rbx)

//=======
	//cprintf("Trap frame address:%x",tf);
//>>>>>>> lab3
	__asm __volatile("movq %0,%%rsp\n"
  8004208426:	48 8b 65 e8          	mov    -0x18(%rbp),%rsp
  800420842a:	4c 8b 3c 24          	mov    (%rsp),%r15
  800420842e:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  8004208433:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  8004208438:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  800420843d:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  8004208442:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  8004208447:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  800420844c:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  8004208451:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  8004208456:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  800420845b:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  8004208460:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  8004208465:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  800420846a:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  800420846f:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  8004208474:	48 83 c4 78          	add    $0x78,%rsp
  8004208478:	8e 04 24             	mov    (%rsp),%es
  800420847b:	8e 5c 24 08          	mov    0x8(%rsp),%ds
  800420847f:	48 83 c4 10          	add    $0x10,%rsp
  8004208483:	48 83 c4 10          	add    $0x10,%rsp
  8004208487:	48 cf                	iretq  
			 "movw 8(%%rsp),%%ds\n"
			 "addq $16,%%rsp\n"
			 "\taddq $16,%%rsp\n" /* skip tf_trapno and tf_errcode */
			 "\tiretq"
			 : : "g" (tf) : "memory");
	panic("iret failed");  /* mostly to placate the compiler */
  8004208489:	48 ba 92 82 21 04 80 	movabs $0x8004218292,%rdx
  8004208490:	00 00 00 
  8004208493:	be 4c 02 00 00       	mov    $0x24c,%esi
  8004208498:	48 bf 31 82 21 04 80 	movabs $0x8004218231,%rdi
  800420849f:	00 00 00 
  80042084a2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042084a7:	48 b9 f2 04 20 04 80 	movabs $0x80042004f2,%rcx
  80042084ae:	00 00 00 
  80042084b1:	ff d1                	callq  *%rcx

00000080042084b3 <env_run>:
//
// This function does not return.
//
void
env_run(struct Env *e)
{
  80042084b3:	55                   	push   %rbp
  80042084b4:	48 89 e5             	mov    %rsp,%rbp
  80042084b7:	48 83 ec 20          	sub    $0x20,%rsp
  80042084bb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	//	e->env_tf.  Go back through the code you wrote above
	//	and make sure you have set the relevant parts of
	//	e->env_tf to sensible values.

	// LAB 3: Your code here.
	if(curenv && curenv->env_status==ENV_RUNNING)
  80042084bf:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  80042084c6:	00 00 00 
  80042084c9:	ff d0                	callq  *%rax
  80042084cb:	48 98                	cltq   
  80042084cd:	48 c1 e0 03          	shl    $0x3,%rax
  80042084d1:	48 89 c2             	mov    %rax,%rdx
  80042084d4:	48 c1 e2 04          	shl    $0x4,%rdx
  80042084d8:	48 29 c2             	sub    %rax,%rdx
  80042084db:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  80042084e2:	00 00 00 
  80042084e5:	48 01 d0             	add    %rdx,%rax
  80042084e8:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042084ec:	48 85 c0             	test   %rax,%rax
  80042084ef:	74 6f                	je     8004208560 <env_run+0xad>
  80042084f1:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  80042084f8:	00 00 00 
  80042084fb:	ff d0                	callq  *%rax
  80042084fd:	48 98                	cltq   
  80042084ff:	48 c1 e0 03          	shl    $0x3,%rax
  8004208503:	48 89 c2             	mov    %rax,%rdx
  8004208506:	48 c1 e2 04          	shl    $0x4,%rdx
  800420850a:	48 29 c2             	sub    %rax,%rdx
  800420850d:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  8004208514:	00 00 00 
  8004208517:	48 01 d0             	add    %rdx,%rax
  800420851a:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420851e:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004208524:	83 f8 03             	cmp    $0x3,%eax
  8004208527:	75 37                	jne    8004208560 <env_run+0xad>
			curenv->env_status=ENV_RUNNABLE;
  8004208529:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  8004208530:	00 00 00 
  8004208533:	ff d0                	callq  *%rax
  8004208535:	48 98                	cltq   
  8004208537:	48 c1 e0 03          	shl    $0x3,%rax
  800420853b:	48 89 c2             	mov    %rax,%rdx
  800420853e:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208542:	48 29 c2             	sub    %rax,%rdx
  8004208545:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420854c:	00 00 00 
  800420854f:	48 01 d0             	add    %rdx,%rax
  8004208552:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004208556:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420855d:	00 00 00 
	curenv=e;
  8004208560:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  8004208567:	00 00 00 
  800420856a:	ff d0                	callq  *%rax
  800420856c:	48 98                	cltq   
  800420856e:	48 c1 e0 03          	shl    $0x3,%rax
  8004208572:	48 89 c2             	mov    %rax,%rdx
  8004208575:	48 c1 e2 04          	shl    $0x4,%rdx
  8004208579:	48 29 c2             	sub    %rax,%rdx
  800420857c:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  8004208583:	00 00 00 
  8004208586:	48 01 c2             	add    %rax,%rdx
  8004208589:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420858d:	48 89 42 08          	mov    %rax,0x8(%rdx)
	curenv->env_status=ENV_RUNNING;
  8004208591:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  8004208598:	00 00 00 
  800420859b:	ff d0                	callq  *%rax
  800420859d:	48 98                	cltq   
  800420859f:	48 c1 e0 03          	shl    $0x3,%rax
  80042085a3:	48 89 c2             	mov    %rax,%rdx
  80042085a6:	48 c1 e2 04          	shl    $0x4,%rdx
  80042085aa:	48 29 c2             	sub    %rax,%rdx
  80042085ad:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  80042085b4:	00 00 00 
  80042085b7:	48 01 d0             	add    %rdx,%rax
  80042085ba:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042085be:	c7 80 d4 00 00 00 03 	movl   $0x3,0xd4(%rax)
  80042085c5:	00 00 00 
	curenv->env_runs++;
  80042085c8:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  80042085cf:	00 00 00 
  80042085d2:	ff d0                	callq  *%rax
  80042085d4:	48 98                	cltq   
  80042085d6:	48 c1 e0 03          	shl    $0x3,%rax
  80042085da:	48 89 c2             	mov    %rax,%rdx
  80042085dd:	48 c1 e2 04          	shl    $0x4,%rdx
  80042085e1:	48 29 c2             	sub    %rax,%rdx
  80042085e4:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  80042085eb:	00 00 00 
  80042085ee:	48 01 d0             	add    %rdx,%rax
  80042085f1:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042085f5:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  80042085fb:	83 c2 01             	add    $0x1,%edx
  80042085fe:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
	//cprintf("[%08x]:e->env_pml4e:%x\n",e->env_id,e->env_pml4e);
	lcr3(curenv->env_cr3);
  8004208604:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420860b:	00 00 00 
  800420860e:	ff d0                	callq  *%rax
  8004208610:	48 98                	cltq   
  8004208612:	48 c1 e0 03          	shl    $0x3,%rax
  8004208616:	48 89 c2             	mov    %rax,%rdx
  8004208619:	48 c1 e2 04          	shl    $0x4,%rdx
  800420861d:	48 29 c2             	sub    %rax,%rdx
  8004208620:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  8004208627:	00 00 00 
  800420862a:	48 01 d0             	add    %rdx,%rax
  800420862d:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004208631:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208638:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420863c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208640:	0f 22 d8             	mov    %rax,%cr3
	unlock_kernel();
  8004208643:	48 b8 bf 75 20 04 80 	movabs $0x80042075bf,%rax
  800420864a:	00 00 00 
  800420864d:	ff d0                	callq  *%rax
	env_pop_tf(&e->env_tf);
  800420864f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208653:	48 89 c7             	mov    %rax,%rdi
  8004208656:	48 b8 da 83 20 04 80 	movabs $0x80042083da,%rax
  800420865d:	00 00 00 
  8004208660:	ff d0                	callq  *%rax
	...

0000008004208664 <mc146818_read>:
#include <kern/kclock.h>


unsigned
mc146818_read(unsigned reg)
{
  8004208664:	55                   	push   %rbp
  8004208665:	48 89 e5             	mov    %rsp,%rbp
  8004208668:	53                   	push   %rbx
  8004208669:	48 83 ec 18          	sub    $0x18,%rsp
  800420866d:	89 7d e4             	mov    %edi,-0x1c(%rbp)
	outb(IO_RTC, reg);
  8004208670:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004208673:	0f b6 c0             	movzbl %al,%eax
  8004208676:	c7 45 f4 70 00 00 00 	movl   $0x70,-0xc(%rbp)
  800420867d:	88 45 f3             	mov    %al,-0xd(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004208680:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208684:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208687:	ee                   	out    %al,(%dx)
  8004208688:	c7 45 ec 71 00 00 00 	movl   $0x71,-0x14(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420868f:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004208692:	89 55 e0             	mov    %edx,-0x20(%rbp)
  8004208695:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004208698:	ec                   	in     (%dx),%al
  8004208699:	89 c3                	mov    %eax,%ebx
  800420869b:	88 5d eb             	mov    %bl,-0x15(%rbp)
	return data;
  800420869e:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
	return inb(IO_RTC+1);
  80042086a2:	0f b6 c0             	movzbl %al,%eax
}
  80042086a5:	48 83 c4 18          	add    $0x18,%rsp
  80042086a9:	5b                   	pop    %rbx
  80042086aa:	5d                   	pop    %rbp
  80042086ab:	c3                   	retq   

00000080042086ac <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
  80042086ac:	55                   	push   %rbp
  80042086ad:	48 89 e5             	mov    %rsp,%rbp
  80042086b0:	48 83 ec 18          	sub    $0x18,%rsp
  80042086b4:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80042086b7:	89 75 e8             	mov    %esi,-0x18(%rbp)
	outb(IO_RTC, reg);
  80042086ba:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042086bd:	0f b6 c0             	movzbl %al,%eax
  80042086c0:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  80042086c7:	88 45 fb             	mov    %al,-0x5(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042086ca:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042086ce:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042086d1:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
  80042086d2:	8b 45 e8             	mov    -0x18(%rbp),%eax
  80042086d5:	0f b6 c0             	movzbl %al,%eax
  80042086d8:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)
  80042086df:	88 45 f3             	mov    %al,-0xd(%rbp)
  80042086e2:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  80042086e6:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042086e9:	ee                   	out    %al,(%dx)
}
  80042086ea:	c9                   	leaveq 
  80042086eb:	c3                   	retq   

00000080042086ec <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
  80042086ec:	55                   	push   %rbp
  80042086ed:	48 89 e5             	mov    %rsp,%rbp
  80042086f0:	48 83 ec 70          	sub    $0x70,%rsp
	didinit = 1;
  80042086f4:	48 b8 60 b2 63 04 80 	movabs $0x800463b260,%rax
  80042086fb:	00 00 00 
  80042086fe:	c6 00 01             	movb   $0x1,(%rax)
  8004208701:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%rbp)
  8004208708:	c6 45 fb ff          	movb   $0xff,-0x5(%rbp)
  800420870c:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208710:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208713:	ee                   	out    %al,(%dx)
  8004208714:	c7 45 f4 a1 00 00 00 	movl   $0xa1,-0xc(%rbp)
  800420871b:	c6 45 f3 ff          	movb   $0xff,-0xd(%rbp)
  800420871f:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208723:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208726:	ee                   	out    %al,(%dx)
  8004208727:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%rbp)
  800420872e:	c6 45 eb 11          	movb   $0x11,-0x15(%rbp)
  8004208732:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004208736:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004208739:	ee                   	out    %al,(%dx)
  800420873a:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%rbp)
  8004208741:	c6 45 e3 20          	movb   $0x20,-0x1d(%rbp)
  8004208745:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004208749:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800420874c:	ee                   	out    %al,(%dx)
  800420874d:	c7 45 dc 21 00 00 00 	movl   $0x21,-0x24(%rbp)
  8004208754:	c6 45 db 04          	movb   $0x4,-0x25(%rbp)
  8004208758:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  800420875c:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800420875f:	ee                   	out    %al,(%dx)
  8004208760:	c7 45 d4 21 00 00 00 	movl   $0x21,-0x2c(%rbp)
  8004208767:	c6 45 d3 03          	movb   $0x3,-0x2d(%rbp)
  800420876b:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  800420876f:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004208772:	ee                   	out    %al,(%dx)
  8004208773:	c7 45 cc a0 00 00 00 	movl   $0xa0,-0x34(%rbp)
  800420877a:	c6 45 cb 11          	movb   $0x11,-0x35(%rbp)
  800420877e:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004208782:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004208785:	ee                   	out    %al,(%dx)
  8004208786:	c7 45 c4 a1 00 00 00 	movl   $0xa1,-0x3c(%rbp)
  800420878d:	c6 45 c3 28          	movb   $0x28,-0x3d(%rbp)
  8004208791:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
  8004208795:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004208798:	ee                   	out    %al,(%dx)
  8004208799:	c7 45 bc a1 00 00 00 	movl   $0xa1,-0x44(%rbp)
  80042087a0:	c6 45 bb 02          	movb   $0x2,-0x45(%rbp)
  80042087a4:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  80042087a8:	8b 55 bc             	mov    -0x44(%rbp),%edx
  80042087ab:	ee                   	out    %al,(%dx)
  80042087ac:	c7 45 b4 a1 00 00 00 	movl   $0xa1,-0x4c(%rbp)
  80042087b3:	c6 45 b3 01          	movb   $0x1,-0x4d(%rbp)
  80042087b7:	0f b6 45 b3          	movzbl -0x4d(%rbp),%eax
  80042087bb:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  80042087be:	ee                   	out    %al,(%dx)
  80042087bf:	c7 45 ac 20 00 00 00 	movl   $0x20,-0x54(%rbp)
  80042087c6:	c6 45 ab 68          	movb   $0x68,-0x55(%rbp)
  80042087ca:	0f b6 45 ab          	movzbl -0x55(%rbp),%eax
  80042087ce:	8b 55 ac             	mov    -0x54(%rbp),%edx
  80042087d1:	ee                   	out    %al,(%dx)
  80042087d2:	c7 45 a4 20 00 00 00 	movl   $0x20,-0x5c(%rbp)
  80042087d9:	c6 45 a3 0a          	movb   $0xa,-0x5d(%rbp)
  80042087dd:	0f b6 45 a3          	movzbl -0x5d(%rbp),%eax
  80042087e1:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  80042087e4:	ee                   	out    %al,(%dx)
  80042087e5:	c7 45 9c a0 00 00 00 	movl   $0xa0,-0x64(%rbp)
  80042087ec:	c6 45 9b 68          	movb   $0x68,-0x65(%rbp)
  80042087f0:	0f b6 45 9b          	movzbl -0x65(%rbp),%eax
  80042087f4:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042087f7:	ee                   	out    %al,(%dx)
  80042087f8:	c7 45 94 a0 00 00 00 	movl   $0xa0,-0x6c(%rbp)
  80042087ff:	c6 45 93 0a          	movb   $0xa,-0x6d(%rbp)
  8004208803:	0f b6 45 93          	movzbl -0x6d(%rbp),%eax
  8004208807:	8b 55 94             	mov    -0x6c(%rbp),%edx
  800420880a:	ee                   	out    %al,(%dx)
	outb(IO_PIC1, 0x0a);             /* read IRR by default */

	outb(IO_PIC2, 0x68);               /* OCW3 */
	outb(IO_PIC2, 0x0a);               /* OCW3 */

	if (irq_mask_8259A != 0xFFFF)
  800420880b:	48 b8 94 a6 22 04 80 	movabs $0x800422a694,%rax
  8004208812:	00 00 00 
  8004208815:	0f b7 00             	movzwl (%rax),%eax
  8004208818:	66 83 f8 ff          	cmp    $0xffff,%ax
  800420881c:	74 1e                	je     800420883c <pic_init+0x150>
		irq_setmask_8259A(irq_mask_8259A);
  800420881e:	48 b8 94 a6 22 04 80 	movabs $0x800422a694,%rax
  8004208825:	00 00 00 
  8004208828:	0f b7 00             	movzwl (%rax),%eax
  800420882b:	0f b7 c0             	movzwl %ax,%eax
  800420882e:	89 c7                	mov    %eax,%edi
  8004208830:	48 b8 3e 88 20 04 80 	movabs $0x800420883e,%rax
  8004208837:	00 00 00 
  800420883a:	ff d0                	callq  *%rax
}
  800420883c:	c9                   	leaveq 
  800420883d:	c3                   	retq   

000000800420883e <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16_t mask)
{
  800420883e:	55                   	push   %rbp
  800420883f:	48 89 e5             	mov    %rsp,%rbp
  8004208842:	53                   	push   %rbx
  8004208843:	48 83 ec 38          	sub    $0x38,%rsp
  8004208847:	89 f8                	mov    %edi,%eax
  8004208849:	66 89 45 cc          	mov    %ax,-0x34(%rbp)
	int i;
	irq_mask_8259A = mask;
  800420884d:	48 b8 94 a6 22 04 80 	movabs $0x800422a694,%rax
  8004208854:	00 00 00 
  8004208857:	0f b7 55 cc          	movzwl -0x34(%rbp),%edx
  800420885b:	66 89 10             	mov    %dx,(%rax)
	if (!didinit)
  800420885e:	48 b8 60 b2 63 04 80 	movabs $0x800463b260,%rax
  8004208865:	00 00 00 
  8004208868:	0f b6 00             	movzbl (%rax),%eax
  800420886b:	83 f0 01             	xor    $0x1,%eax
  800420886e:	84 c0                	test   %al,%al
  8004208870:	0f 85 bb 00 00 00    	jne    8004208931 <irq_setmask_8259A+0xf3>
		return;
	outb(IO_PIC1+1, (char)mask);
  8004208876:	0f b7 45 cc          	movzwl -0x34(%rbp),%eax
  800420887a:	0f b6 c0             	movzbl %al,%eax
  800420887d:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%rbp)
  8004208884:	88 45 e7             	mov    %al,-0x19(%rbp)
  8004208887:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800420888b:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420888e:	ee                   	out    %al,(%dx)
	outb(IO_PIC2+1, (char)(mask >> 8));
  800420888f:	0f b7 45 cc          	movzwl -0x34(%rbp),%eax
  8004208893:	66 c1 e8 08          	shr    $0x8,%ax
  8004208897:	0f b6 c0             	movzbl %al,%eax
  800420889a:	c7 45 e0 a1 00 00 00 	movl   $0xa1,-0x20(%rbp)
  80042088a1:	88 45 df             	mov    %al,-0x21(%rbp)
  80042088a4:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  80042088a8:	8b 55 e0             	mov    -0x20(%rbp),%edx
  80042088ab:	ee                   	out    %al,(%dx)
	cprintf("enabled interrupts:");
  80042088ac:	48 bf 9e 82 21 04 80 	movabs $0x800421829e,%rdi
  80042088b3:	00 00 00 
  80042088b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042088bb:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  80042088c2:	00 00 00 
  80042088c5:	ff d2                	callq  *%rdx
	for (i = 0; i < 16; i++)
  80042088c7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  80042088ce:	eb 3e                	jmp    800420890e <irq_setmask_8259A+0xd0>
		if (~mask & (1<<i))
  80042088d0:	0f b7 45 cc          	movzwl -0x34(%rbp),%eax
  80042088d4:	89 c2                	mov    %eax,%edx
  80042088d6:	f7 d2                	not    %edx
  80042088d8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042088db:	89 d3                	mov    %edx,%ebx
  80042088dd:	89 c1                	mov    %eax,%ecx
  80042088df:	d3 fb                	sar    %cl,%ebx
  80042088e1:	89 d8                	mov    %ebx,%eax
  80042088e3:	83 e0 01             	and    $0x1,%eax
  80042088e6:	84 c0                	test   %al,%al
  80042088e8:	74 20                	je     800420890a <irq_setmask_8259A+0xcc>
			cprintf(" %d", i);
  80042088ea:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042088ed:	89 c6                	mov    %eax,%esi
  80042088ef:	48 bf b2 82 21 04 80 	movabs $0x80042182b2,%rdi
  80042088f6:	00 00 00 
  80042088f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042088fe:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  8004208905:	00 00 00 
  8004208908:	ff d2                	callq  *%rdx
	if (!didinit)
		return;
	outb(IO_PIC1+1, (char)mask);
	outb(IO_PIC2+1, (char)(mask >> 8));
	cprintf("enabled interrupts:");
	for (i = 0; i < 16; i++)
  800420890a:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  800420890e:	83 7d ec 0f          	cmpl   $0xf,-0x14(%rbp)
  8004208912:	7e bc                	jle    80042088d0 <irq_setmask_8259A+0x92>
		if (~mask & (1<<i))
			cprintf(" %d", i);
	cprintf("\n");
  8004208914:	48 bf b6 82 21 04 80 	movabs $0x80042182b6,%rdi
  800420891b:	00 00 00 
  800420891e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208923:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420892a:	00 00 00 
  800420892d:	ff d2                	callq  *%rdx
  800420892f:	eb 01                	jmp    8004208932 <irq_setmask_8259A+0xf4>
irq_setmask_8259A(uint16_t mask)
{
	int i;
	irq_mask_8259A = mask;
	if (!didinit)
		return;
  8004208931:	90                   	nop
	cprintf("enabled interrupts:");
	for (i = 0; i < 16; i++)
		if (~mask & (1<<i))
			cprintf(" %d", i);
	cprintf("\n");
}
  8004208932:	48 83 c4 38          	add    $0x38,%rsp
  8004208936:	5b                   	pop    %rbx
  8004208937:	5d                   	pop    %rbp
  8004208938:	c3                   	retq   

0000008004208939 <irq_eoi>:

void
irq_eoi(void)
{
  8004208939:	55                   	push   %rbp
  800420893a:	48 89 e5             	mov    %rsp,%rbp
  800420893d:	48 83 ec 10          	sub    $0x10,%rsp
  8004208941:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%rbp)
  8004208948:	c6 45 fb 20          	movb   $0x20,-0x5(%rbp)
  800420894c:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208950:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208953:	ee                   	out    %al,(%dx)
  8004208954:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%rbp)
  800420895b:	c6 45 f3 20          	movb   $0x20,-0xd(%rbp)
  800420895f:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208963:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208966:	ee                   	out    %al,(%dx)
	//   s: specific
	//   e: end-of-interrupt
	// xxx: specific interrupt line
	outb(IO_PIC1, 0x20);
	outb(IO_PIC2, 0x20);
}
  8004208967:	c9                   	leaveq 
  8004208968:	c3                   	retq   
  8004208969:	00 00                	add    %al,(%rax)
	...

000000800420896c <putch>:
#include <inc/stdarg.h>


static void
putch(int ch, int *cnt)
{
  800420896c:	55                   	push   %rbp
  800420896d:	48 89 e5             	mov    %rsp,%rbp
  8004208970:	48 83 ec 10          	sub    $0x10,%rsp
  8004208974:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004208977:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	cputchar(ch);
  800420897b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420897e:	89 c7                	mov    %eax,%edi
  8004208980:	48 b8 aa 12 20 04 80 	movabs $0x80042012aa,%rax
  8004208987:	00 00 00 
  800420898a:	ff d0                	callq  *%rax
	*cnt++;
  800420898c:	48 83 45 f0 04       	addq   $0x4,-0x10(%rbp)
}
  8004208991:	c9                   	leaveq 
  8004208992:	c3                   	retq   

0000008004208993 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  8004208993:	55                   	push   %rbp
  8004208994:	48 89 e5             	mov    %rsp,%rbp
  8004208997:	48 83 ec 30          	sub    $0x30,%rsp
  800420899b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420899f:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int cnt = 0;
  80042089a3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    va_list aq;
    va_copy(aq,ap);
  80042089aa:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  80042089ae:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042089b2:	48 8b 0a             	mov    (%rdx),%rcx
  80042089b5:	48 89 08             	mov    %rcx,(%rax)
  80042089b8:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042089bc:	48 89 48 08          	mov    %rcx,0x8(%rax)
  80042089c0:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80042089c4:	48 89 50 10          	mov    %rdx,0x10(%rax)
	vprintfmt((void*)putch, &cnt, fmt, aq);
  80042089c8:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  80042089cc:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042089d0:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  80042089d4:	48 89 c6             	mov    %rax,%rsi
  80042089d7:	48 bf 6c 89 20 04 80 	movabs $0x800420896c,%rdi
  80042089de:	00 00 00 
  80042089e1:	48 b8 54 da 20 04 80 	movabs $0x800420da54,%rax
  80042089e8:	00 00 00 
  80042089eb:	ff d0                	callq  *%rax
    va_end(aq);
	return cnt;
  80042089ed:	8b 45 fc             	mov    -0x4(%rbp),%eax

}
  80042089f0:	c9                   	leaveq 
  80042089f1:	c3                   	retq   

00000080042089f2 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80042089f2:	55                   	push   %rbp
  80042089f3:	48 89 e5             	mov    %rsp,%rbp
  80042089f6:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  80042089fd:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  8004208a04:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  8004208a0b:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004208a12:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004208a19:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004208a20:	84 c0                	test   %al,%al
  8004208a22:	74 20                	je     8004208a44 <cprintf+0x52>
  8004208a24:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004208a28:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004208a2c:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004208a30:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004208a34:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004208a38:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004208a3c:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004208a40:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004208a44:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
	va_list ap;
	int cnt;
	va_start(ap, fmt);
  8004208a4b:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  8004208a52:	00 00 00 
  8004208a55:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  8004208a5c:	00 00 00 
  8004208a5f:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004208a63:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004208a6a:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004208a71:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    va_list aq;
    va_copy(aq,ap);
  8004208a78:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  8004208a7f:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  8004208a86:	48 8b 0a             	mov    (%rdx),%rcx
  8004208a89:	48 89 08             	mov    %rcx,(%rax)
  8004208a8c:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004208a90:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004208a94:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004208a98:	48 89 50 10          	mov    %rdx,0x10(%rax)
	cnt = vcprintf(fmt, aq);
  8004208a9c:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  8004208aa3:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004208aaa:	48 89 d6             	mov    %rdx,%rsi
  8004208aad:	48 89 c7             	mov    %rax,%rdi
  8004208ab0:	48 b8 93 89 20 04 80 	movabs $0x8004208993,%rax
  8004208ab7:	00 00 00 
  8004208aba:	ff d0                	callq  *%rax
  8004208abc:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return cnt;
  8004208ac2:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  8004208ac8:	c9                   	leaveq 
  8004208ac9:	c3                   	retq   
	...

0000008004208acc <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004208acc:	55                   	push   %rbp
  8004208acd:	48 89 e5             	mov    %rsp,%rbp
  8004208ad0:	53                   	push   %rbx
  8004208ad1:	48 83 ec 20          	sub    $0x20,%rsp
  8004208ad5:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
  8004208ad9:	89 75 dc             	mov    %esi,-0x24(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
	"+m" (*addr), "=a" (result):
  8004208adc:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004208ae0:	8b 45 dc             	mov    -0x24(%rbp),%eax
	"+m" (*addr), "=a" (result):
  8004208ae3:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004208ae7:	89 c3                	mov    %eax,%ebx
  8004208ae9:	89 d8                	mov    %ebx,%eax
  8004208aeb:	f0 87 02             	lock xchg %eax,(%rdx)
  8004208aee:	89 c3                	mov    %eax,%ebx
  8004208af0:	89 5d f4             	mov    %ebx,-0xc(%rbp)
	"+m" (*addr), "=a" (result):
	"1"(newval):
	"cc");
	return result;
  8004208af3:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  8004208af6:	48 83 c4 20          	add    $0x20,%rsp
  8004208afa:	5b                   	pop    %rbx
  8004208afb:	5d                   	pop    %rbp
  8004208afc:	c3                   	retq   

0000008004208afd <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  8004208afd:	55                   	push   %rbp
  8004208afe:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004208b01:	48 bf 80 a7 22 04 80 	movabs $0x800422a780,%rdi
  8004208b08:	00 00 00 
  8004208b0b:	48 b8 61 59 21 04 80 	movabs $0x8004215961,%rax
  8004208b12:	00 00 00 
  8004208b15:	ff d0                	callq  *%rax
}
  8004208b17:	5d                   	pop    %rbp
  8004208b18:	c3                   	retq   

0000008004208b19 <trapname>:
 * shifted function addresses can't be represented in relocation records.)
 */
struct Gatedesc idt[256] = { { 0 } };
struct Pseudodesc idt_pd = {0,0};
static const char *trapname(int trapno)
{
  8004208b19:	55                   	push   %rbp
  8004208b1a:	48 89 e5             	mov    %rsp,%rbp
  8004208b1d:	48 83 ec 08          	sub    $0x8,%rsp
  8004208b21:	89 7d fc             	mov    %edi,-0x4(%rbp)
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
  8004208b24:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208b27:	83 f8 13             	cmp    $0x13,%eax
  8004208b2a:	77 16                	ja     8004208b42 <trapname+0x29>
		return excnames[trapno];
  8004208b2c:	48 b8 e0 86 21 04 80 	movabs $0x80042186e0,%rax
  8004208b33:	00 00 00 
  8004208b36:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208b39:	48 63 d2             	movslq %edx,%rdx
  8004208b3c:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004208b40:	eb 34                	jmp    8004208b76 <trapname+0x5d>
	if (trapno == T_SYSCALL)
  8004208b42:	83 7d fc 30          	cmpl   $0x30,-0x4(%rbp)
  8004208b46:	75 0c                	jne    8004208b54 <trapname+0x3b>
		return "System call";
  8004208b48:	48 b8 c0 82 21 04 80 	movabs $0x80042182c0,%rax
  8004208b4f:	00 00 00 
  8004208b52:	eb 22                	jmp    8004208b76 <trapname+0x5d>
	if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16)
  8004208b54:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  8004208b58:	7e 12                	jle    8004208b6c <trapname+0x53>
  8004208b5a:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%rbp)
  8004208b5e:	7f 0c                	jg     8004208b6c <trapname+0x53>
		return "Hardware Interrupt";
  8004208b60:	48 b8 cc 82 21 04 80 	movabs $0x80042182cc,%rax
  8004208b67:	00 00 00 
  8004208b6a:	eb 0a                	jmp    8004208b76 <trapname+0x5d>
	return "(unknown trap)";
  8004208b6c:	48 b8 df 82 21 04 80 	movabs $0x80042182df,%rax
  8004208b73:	00 00 00 
}
  8004208b76:	c9                   	leaveq 
  8004208b77:	c3                   	retq   

0000008004208b78 <trap_init>:
void TRAPH_ide(void);
void TRAPH_err(void);

void
trap_init(void)
{
  8004208b78:	55                   	push   %rbp
  8004208b79:	48 89 e5             	mov    %rsp,%rbp
	extern struct Segdesc gdt[];
	// LAB 3: Your code here.
	SETGATE(idt[T_DIVIDE], 0, GD_KT, TRAPH_divide, 0);
  8004208b7c:	48 b8 30 bb 20 04 80 	movabs $0x800420bb30,%rax
  8004208b83:	00 00 00 
  8004208b86:	89 c2                	mov    %eax,%edx
  8004208b88:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208b8f:	00 00 00 
  8004208b92:	66 89 10             	mov    %dx,(%rax)
  8004208b95:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208b9c:	00 00 00 
  8004208b9f:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  8004208ba5:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208bac:	00 00 00 
  8004208baf:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004208bb3:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208bb6:	88 50 04             	mov    %dl,0x4(%rax)
  8004208bb9:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208bc0:	00 00 00 
  8004208bc3:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004208bc7:	83 e2 07             	and    $0x7,%edx
  8004208bca:	88 50 04             	mov    %dl,0x4(%rax)
  8004208bcd:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208bd4:	00 00 00 
  8004208bd7:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208bdb:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208bde:	83 ca 0e             	or     $0xe,%edx
  8004208be1:	88 50 05             	mov    %dl,0x5(%rax)
  8004208be4:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208beb:	00 00 00 
  8004208bee:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208bf2:	83 e2 ef             	and    $0xffffffef,%edx
  8004208bf5:	88 50 05             	mov    %dl,0x5(%rax)
  8004208bf8:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208bff:	00 00 00 
  8004208c02:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208c06:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208c09:	88 50 05             	mov    %dl,0x5(%rax)
  8004208c0c:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208c13:	00 00 00 
  8004208c16:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004208c1a:	83 ca 80             	or     $0xffffff80,%edx
  8004208c1d:	88 50 05             	mov    %dl,0x5(%rax)
  8004208c20:	48 b8 30 bb 20 04 80 	movabs $0x800420bb30,%rax
  8004208c27:	00 00 00 
  8004208c2a:	48 c1 e8 10          	shr    $0x10,%rax
  8004208c2e:	89 c2                	mov    %eax,%edx
  8004208c30:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208c37:	00 00 00 
  8004208c3a:	66 89 50 06          	mov    %dx,0x6(%rax)
  8004208c3e:	48 b8 30 bb 20 04 80 	movabs $0x800420bb30,%rax
  8004208c45:	00 00 00 
  8004208c48:	48 c1 e8 20          	shr    $0x20,%rax
  8004208c4c:	89 c2                	mov    %eax,%edx
  8004208c4e:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208c55:	00 00 00 
  8004208c58:	89 50 08             	mov    %edx,0x8(%rax)
  8004208c5b:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208c62:	00 00 00 
  8004208c65:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
	SETGATE(idt[T_DEBUG], 0, GD_KT,TRAPH_debug,0);
  8004208c6c:	48 b8 3a bb 20 04 80 	movabs $0x800420bb3a,%rax
  8004208c73:	00 00 00 
  8004208c76:	89 c2                	mov    %eax,%edx
  8004208c78:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208c7f:	00 00 00 
  8004208c82:	66 89 50 10          	mov    %dx,0x10(%rax)
  8004208c86:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208c8d:	00 00 00 
  8004208c90:	66 c7 40 12 08 00    	movw   $0x8,0x12(%rax)
  8004208c96:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208c9d:	00 00 00 
  8004208ca0:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  8004208ca4:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208ca7:	88 50 14             	mov    %dl,0x14(%rax)
  8004208caa:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208cb1:	00 00 00 
  8004208cb4:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  8004208cb8:	83 e2 07             	and    $0x7,%edx
  8004208cbb:	88 50 14             	mov    %dl,0x14(%rax)
  8004208cbe:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208cc5:	00 00 00 
  8004208cc8:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004208ccc:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208ccf:	83 ca 0e             	or     $0xe,%edx
  8004208cd2:	88 50 15             	mov    %dl,0x15(%rax)
  8004208cd5:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208cdc:	00 00 00 
  8004208cdf:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004208ce3:	83 e2 ef             	and    $0xffffffef,%edx
  8004208ce6:	88 50 15             	mov    %dl,0x15(%rax)
  8004208ce9:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208cf0:	00 00 00 
  8004208cf3:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004208cf7:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208cfa:	88 50 15             	mov    %dl,0x15(%rax)
  8004208cfd:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208d04:	00 00 00 
  8004208d07:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004208d0b:	83 ca 80             	or     $0xffffff80,%edx
  8004208d0e:	88 50 15             	mov    %dl,0x15(%rax)
  8004208d11:	48 b8 3a bb 20 04 80 	movabs $0x800420bb3a,%rax
  8004208d18:	00 00 00 
  8004208d1b:	48 c1 e8 10          	shr    $0x10,%rax
  8004208d1f:	89 c2                	mov    %eax,%edx
  8004208d21:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208d28:	00 00 00 
  8004208d2b:	66 89 50 16          	mov    %dx,0x16(%rax)
  8004208d2f:	48 b8 3a bb 20 04 80 	movabs $0x800420bb3a,%rax
  8004208d36:	00 00 00 
  8004208d39:	48 c1 e8 20          	shr    $0x20,%rax
  8004208d3d:	89 c2                	mov    %eax,%edx
  8004208d3f:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208d46:	00 00 00 
  8004208d49:	89 50 18             	mov    %edx,0x18(%rax)
  8004208d4c:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208d53:	00 00 00 
  8004208d56:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%rax)
	SETGATE(idt[T_NMI], 0, GD_KT, TRAPH_nmi,0);
  8004208d5d:	48 b8 40 bb 20 04 80 	movabs $0x800420bb40,%rax
  8004208d64:	00 00 00 
  8004208d67:	89 c2                	mov    %eax,%edx
  8004208d69:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208d70:	00 00 00 
  8004208d73:	66 89 50 20          	mov    %dx,0x20(%rax)
  8004208d77:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208d7e:	00 00 00 
  8004208d81:	66 c7 40 22 08 00    	movw   $0x8,0x22(%rax)
  8004208d87:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208d8e:	00 00 00 
  8004208d91:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  8004208d95:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208d98:	88 50 24             	mov    %dl,0x24(%rax)
  8004208d9b:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208da2:	00 00 00 
  8004208da5:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  8004208da9:	83 e2 07             	and    $0x7,%edx
  8004208dac:	88 50 24             	mov    %dl,0x24(%rax)
  8004208daf:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208db6:	00 00 00 
  8004208db9:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004208dbd:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208dc0:	83 ca 0e             	or     $0xe,%edx
  8004208dc3:	88 50 25             	mov    %dl,0x25(%rax)
  8004208dc6:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208dcd:	00 00 00 
  8004208dd0:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004208dd4:	83 e2 ef             	and    $0xffffffef,%edx
  8004208dd7:	88 50 25             	mov    %dl,0x25(%rax)
  8004208dda:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208de1:	00 00 00 
  8004208de4:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004208de8:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208deb:	88 50 25             	mov    %dl,0x25(%rax)
  8004208dee:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208df5:	00 00 00 
  8004208df8:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004208dfc:	83 ca 80             	or     $0xffffff80,%edx
  8004208dff:	88 50 25             	mov    %dl,0x25(%rax)
  8004208e02:	48 b8 40 bb 20 04 80 	movabs $0x800420bb40,%rax
  8004208e09:	00 00 00 
  8004208e0c:	48 c1 e8 10          	shr    $0x10,%rax
  8004208e10:	89 c2                	mov    %eax,%edx
  8004208e12:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208e19:	00 00 00 
  8004208e1c:	66 89 50 26          	mov    %dx,0x26(%rax)
  8004208e20:	48 b8 40 bb 20 04 80 	movabs $0x800420bb40,%rax
  8004208e27:	00 00 00 
  8004208e2a:	48 c1 e8 20          	shr    $0x20,%rax
  8004208e2e:	89 c2                	mov    %eax,%edx
  8004208e30:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208e37:	00 00 00 
  8004208e3a:	89 50 28             	mov    %edx,0x28(%rax)
  8004208e3d:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208e44:	00 00 00 
  8004208e47:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%rax)
	SETGATE(idt[T_BRKPT], 0, GD_KT, TRAPH_breakpoint,3);
  8004208e4e:	48 b8 46 bb 20 04 80 	movabs $0x800420bb46,%rax
  8004208e55:	00 00 00 
  8004208e58:	89 c2                	mov    %eax,%edx
  8004208e5a:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208e61:	00 00 00 
  8004208e64:	66 89 50 30          	mov    %dx,0x30(%rax)
  8004208e68:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208e6f:	00 00 00 
  8004208e72:	66 c7 40 32 08 00    	movw   $0x8,0x32(%rax)
  8004208e78:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208e7f:	00 00 00 
  8004208e82:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  8004208e86:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208e89:	88 50 34             	mov    %dl,0x34(%rax)
  8004208e8c:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208e93:	00 00 00 
  8004208e96:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  8004208e9a:	83 e2 07             	and    $0x7,%edx
  8004208e9d:	88 50 34             	mov    %dl,0x34(%rax)
  8004208ea0:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208ea7:	00 00 00 
  8004208eaa:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004208eae:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208eb1:	83 ca 0e             	or     $0xe,%edx
  8004208eb4:	88 50 35             	mov    %dl,0x35(%rax)
  8004208eb7:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208ebe:	00 00 00 
  8004208ec1:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004208ec5:	83 e2 ef             	and    $0xffffffef,%edx
  8004208ec8:	88 50 35             	mov    %dl,0x35(%rax)
  8004208ecb:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208ed2:	00 00 00 
  8004208ed5:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004208ed9:	83 ca 60             	or     $0x60,%edx
  8004208edc:	88 50 35             	mov    %dl,0x35(%rax)
  8004208edf:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208ee6:	00 00 00 
  8004208ee9:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004208eed:	83 ca 80             	or     $0xffffff80,%edx
  8004208ef0:	88 50 35             	mov    %dl,0x35(%rax)
  8004208ef3:	48 b8 46 bb 20 04 80 	movabs $0x800420bb46,%rax
  8004208efa:	00 00 00 
  8004208efd:	48 c1 e8 10          	shr    $0x10,%rax
  8004208f01:	89 c2                	mov    %eax,%edx
  8004208f03:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208f0a:	00 00 00 
  8004208f0d:	66 89 50 36          	mov    %dx,0x36(%rax)
  8004208f11:	48 b8 46 bb 20 04 80 	movabs $0x800420bb46,%rax
  8004208f18:	00 00 00 
  8004208f1b:	48 c1 e8 20          	shr    $0x20,%rax
  8004208f1f:	89 c2                	mov    %eax,%edx
  8004208f21:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208f28:	00 00 00 
  8004208f2b:	89 50 38             	mov    %edx,0x38(%rax)
  8004208f2e:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208f35:	00 00 00 
  8004208f38:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%rax)
	SETGATE(idt[T_OFLOW], 0, GD_KT, TRAPH_overflow,0);
  8004208f3f:	48 b8 4c bb 20 04 80 	movabs $0x800420bb4c,%rax
  8004208f46:	00 00 00 
  8004208f49:	89 c2                	mov    %eax,%edx
  8004208f4b:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208f52:	00 00 00 
  8004208f55:	66 89 50 40          	mov    %dx,0x40(%rax)
  8004208f59:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208f60:	00 00 00 
  8004208f63:	66 c7 40 42 08 00    	movw   $0x8,0x42(%rax)
  8004208f69:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208f70:	00 00 00 
  8004208f73:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  8004208f77:	83 e2 f8             	and    $0xfffffff8,%edx
  8004208f7a:	88 50 44             	mov    %dl,0x44(%rax)
  8004208f7d:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208f84:	00 00 00 
  8004208f87:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  8004208f8b:	83 e2 07             	and    $0x7,%edx
  8004208f8e:	88 50 44             	mov    %dl,0x44(%rax)
  8004208f91:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208f98:	00 00 00 
  8004208f9b:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004208f9f:	83 e2 f0             	and    $0xfffffff0,%edx
  8004208fa2:	83 ca 0e             	or     $0xe,%edx
  8004208fa5:	88 50 45             	mov    %dl,0x45(%rax)
  8004208fa8:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208faf:	00 00 00 
  8004208fb2:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004208fb6:	83 e2 ef             	and    $0xffffffef,%edx
  8004208fb9:	88 50 45             	mov    %dl,0x45(%rax)
  8004208fbc:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208fc3:	00 00 00 
  8004208fc6:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004208fca:	83 e2 9f             	and    $0xffffff9f,%edx
  8004208fcd:	88 50 45             	mov    %dl,0x45(%rax)
  8004208fd0:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208fd7:	00 00 00 
  8004208fda:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004208fde:	83 ca 80             	or     $0xffffff80,%edx
  8004208fe1:	88 50 45             	mov    %dl,0x45(%rax)
  8004208fe4:	48 b8 4c bb 20 04 80 	movabs $0x800420bb4c,%rax
  8004208feb:	00 00 00 
  8004208fee:	48 c1 e8 10          	shr    $0x10,%rax
  8004208ff2:	89 c2                	mov    %eax,%edx
  8004208ff4:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004208ffb:	00 00 00 
  8004208ffe:	66 89 50 46          	mov    %dx,0x46(%rax)
  8004209002:	48 b8 4c bb 20 04 80 	movabs $0x800420bb4c,%rax
  8004209009:	00 00 00 
  800420900c:	48 c1 e8 20          	shr    $0x20,%rax
  8004209010:	89 c2                	mov    %eax,%edx
  8004209012:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209019:	00 00 00 
  800420901c:	89 50 48             	mov    %edx,0x48(%rax)
  800420901f:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209026:	00 00 00 
  8004209029:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%rax)
	SETGATE(idt[T_BOUND], 0, GD_KT, TRAPH_boundcheck,0);
  8004209030:	48 b8 52 bb 20 04 80 	movabs $0x800420bb52,%rax
  8004209037:	00 00 00 
  800420903a:	89 c2                	mov    %eax,%edx
  800420903c:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209043:	00 00 00 
  8004209046:	66 89 50 50          	mov    %dx,0x50(%rax)
  800420904a:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209051:	00 00 00 
  8004209054:	66 c7 40 52 08 00    	movw   $0x8,0x52(%rax)
  800420905a:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209061:	00 00 00 
  8004209064:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  8004209068:	83 e2 f8             	and    $0xfffffff8,%edx
  800420906b:	88 50 54             	mov    %dl,0x54(%rax)
  800420906e:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209075:	00 00 00 
  8004209078:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  800420907c:	83 e2 07             	and    $0x7,%edx
  800420907f:	88 50 54             	mov    %dl,0x54(%rax)
  8004209082:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209089:	00 00 00 
  800420908c:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209090:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209093:	83 ca 0e             	or     $0xe,%edx
  8004209096:	88 50 55             	mov    %dl,0x55(%rax)
  8004209099:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042090a0:	00 00 00 
  80042090a3:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  80042090a7:	83 e2 ef             	and    $0xffffffef,%edx
  80042090aa:	88 50 55             	mov    %dl,0x55(%rax)
  80042090ad:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042090b4:	00 00 00 
  80042090b7:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  80042090bb:	83 e2 9f             	and    $0xffffff9f,%edx
  80042090be:	88 50 55             	mov    %dl,0x55(%rax)
  80042090c1:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042090c8:	00 00 00 
  80042090cb:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  80042090cf:	83 ca 80             	or     $0xffffff80,%edx
  80042090d2:	88 50 55             	mov    %dl,0x55(%rax)
  80042090d5:	48 b8 52 bb 20 04 80 	movabs $0x800420bb52,%rax
  80042090dc:	00 00 00 
  80042090df:	48 c1 e8 10          	shr    $0x10,%rax
  80042090e3:	89 c2                	mov    %eax,%edx
  80042090e5:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042090ec:	00 00 00 
  80042090ef:	66 89 50 56          	mov    %dx,0x56(%rax)
  80042090f3:	48 b8 52 bb 20 04 80 	movabs $0x800420bb52,%rax
  80042090fa:	00 00 00 
  80042090fd:	48 c1 e8 20          	shr    $0x20,%rax
  8004209101:	89 c2                	mov    %eax,%edx
  8004209103:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420910a:	00 00 00 
  800420910d:	89 50 58             	mov    %edx,0x58(%rax)
  8004209110:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209117:	00 00 00 
  800420911a:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
	SETGATE(idt[T_ILLOP], 0, GD_KT, TRAPH_illegalop,0);
  8004209121:	48 b8 58 bb 20 04 80 	movabs $0x800420bb58,%rax
  8004209128:	00 00 00 
  800420912b:	89 c2                	mov    %eax,%edx
  800420912d:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209134:	00 00 00 
  8004209137:	66 89 50 60          	mov    %dx,0x60(%rax)
  800420913b:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209142:	00 00 00 
  8004209145:	66 c7 40 62 08 00    	movw   $0x8,0x62(%rax)
  800420914b:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209152:	00 00 00 
  8004209155:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  8004209159:	83 e2 f8             	and    $0xfffffff8,%edx
  800420915c:	88 50 64             	mov    %dl,0x64(%rax)
  800420915f:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209166:	00 00 00 
  8004209169:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  800420916d:	83 e2 07             	and    $0x7,%edx
  8004209170:	88 50 64             	mov    %dl,0x64(%rax)
  8004209173:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420917a:	00 00 00 
  800420917d:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209181:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209184:	83 ca 0e             	or     $0xe,%edx
  8004209187:	88 50 65             	mov    %dl,0x65(%rax)
  800420918a:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209191:	00 00 00 
  8004209194:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209198:	83 e2 ef             	and    $0xffffffef,%edx
  800420919b:	88 50 65             	mov    %dl,0x65(%rax)
  800420919e:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042091a5:	00 00 00 
  80042091a8:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  80042091ac:	83 e2 9f             	and    $0xffffff9f,%edx
  80042091af:	88 50 65             	mov    %dl,0x65(%rax)
  80042091b2:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042091b9:	00 00 00 
  80042091bc:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  80042091c0:	83 ca 80             	or     $0xffffff80,%edx
  80042091c3:	88 50 65             	mov    %dl,0x65(%rax)
  80042091c6:	48 b8 58 bb 20 04 80 	movabs $0x800420bb58,%rax
  80042091cd:	00 00 00 
  80042091d0:	48 c1 e8 10          	shr    $0x10,%rax
  80042091d4:	89 c2                	mov    %eax,%edx
  80042091d6:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042091dd:	00 00 00 
  80042091e0:	66 89 50 66          	mov    %dx,0x66(%rax)
  80042091e4:	48 b8 58 bb 20 04 80 	movabs $0x800420bb58,%rax
  80042091eb:	00 00 00 
  80042091ee:	48 c1 e8 20          	shr    $0x20,%rax
  80042091f2:	89 c2                	mov    %eax,%edx
  80042091f4:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042091fb:	00 00 00 
  80042091fe:	89 50 68             	mov    %edx,0x68(%rax)
  8004209201:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209208:	00 00 00 
  800420920b:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%rax)
	SETGATE(idt[T_DEVICE], 0, GD_KT, TRAPH_devicena,0);
  8004209212:	48 b8 5e bb 20 04 80 	movabs $0x800420bb5e,%rax
  8004209219:	00 00 00 
  800420921c:	89 c2                	mov    %eax,%edx
  800420921e:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209225:	00 00 00 
  8004209228:	66 89 50 70          	mov    %dx,0x70(%rax)
  800420922c:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209233:	00 00 00 
  8004209236:	66 c7 40 72 08 00    	movw   $0x8,0x72(%rax)
  800420923c:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209243:	00 00 00 
  8004209246:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  800420924a:	83 e2 f8             	and    $0xfffffff8,%edx
  800420924d:	88 50 74             	mov    %dl,0x74(%rax)
  8004209250:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209257:	00 00 00 
  800420925a:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  800420925e:	83 e2 07             	and    $0x7,%edx
  8004209261:	88 50 74             	mov    %dl,0x74(%rax)
  8004209264:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420926b:	00 00 00 
  800420926e:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209272:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209275:	83 ca 0e             	or     $0xe,%edx
  8004209278:	88 50 75             	mov    %dl,0x75(%rax)
  800420927b:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209282:	00 00 00 
  8004209285:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209289:	83 e2 ef             	and    $0xffffffef,%edx
  800420928c:	88 50 75             	mov    %dl,0x75(%rax)
  800420928f:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209296:	00 00 00 
  8004209299:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  800420929d:	83 e2 9f             	and    $0xffffff9f,%edx
  80042092a0:	88 50 75             	mov    %dl,0x75(%rax)
  80042092a3:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042092aa:	00 00 00 
  80042092ad:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  80042092b1:	83 ca 80             	or     $0xffffff80,%edx
  80042092b4:	88 50 75             	mov    %dl,0x75(%rax)
  80042092b7:	48 b8 5e bb 20 04 80 	movabs $0x800420bb5e,%rax
  80042092be:	00 00 00 
  80042092c1:	48 c1 e8 10          	shr    $0x10,%rax
  80042092c5:	89 c2                	mov    %eax,%edx
  80042092c7:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042092ce:	00 00 00 
  80042092d1:	66 89 50 76          	mov    %dx,0x76(%rax)
  80042092d5:	48 b8 5e bb 20 04 80 	movabs $0x800420bb5e,%rax
  80042092dc:	00 00 00 
  80042092df:	48 c1 e8 20          	shr    $0x20,%rax
  80042092e3:	89 c2                	mov    %eax,%edx
  80042092e5:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042092ec:	00 00 00 
  80042092ef:	89 50 78             	mov    %edx,0x78(%rax)
  80042092f2:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042092f9:	00 00 00 
  80042092fc:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%rax)
	SETGATE(idt[T_DBLFLT], 0, GD_KT, TRAPH_doublefault,0);
  8004209303:	48 b8 64 bb 20 04 80 	movabs $0x800420bb64,%rax
  800420930a:	00 00 00 
  800420930d:	89 c2                	mov    %eax,%edx
  800420930f:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209316:	00 00 00 
  8004209319:	66 89 90 80 00 00 00 	mov    %dx,0x80(%rax)
  8004209320:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209327:	00 00 00 
  800420932a:	66 c7 80 82 00 00 00 	movw   $0x8,0x82(%rax)
  8004209331:	08 00 
  8004209333:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420933a:	00 00 00 
  800420933d:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  8004209344:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209347:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  800420934d:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209354:	00 00 00 
  8004209357:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  800420935e:	83 e2 07             	and    $0x7,%edx
  8004209361:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  8004209367:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420936e:	00 00 00 
  8004209371:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209378:	83 e2 f0             	and    $0xfffffff0,%edx
  800420937b:	83 ca 0e             	or     $0xe,%edx
  800420937e:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209384:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420938b:	00 00 00 
  800420938e:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209395:	83 e2 ef             	and    $0xffffffef,%edx
  8004209398:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  800420939e:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042093a5:	00 00 00 
  80042093a8:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  80042093af:	83 e2 9f             	and    $0xffffff9f,%edx
  80042093b2:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  80042093b8:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042093bf:	00 00 00 
  80042093c2:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  80042093c9:	83 ca 80             	or     $0xffffff80,%edx
  80042093cc:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  80042093d2:	48 b8 64 bb 20 04 80 	movabs $0x800420bb64,%rax
  80042093d9:	00 00 00 
  80042093dc:	48 c1 e8 10          	shr    $0x10,%rax
  80042093e0:	89 c2                	mov    %eax,%edx
  80042093e2:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042093e9:	00 00 00 
  80042093ec:	66 89 90 86 00 00 00 	mov    %dx,0x86(%rax)
  80042093f3:	48 b8 64 bb 20 04 80 	movabs $0x800420bb64,%rax
  80042093fa:	00 00 00 
  80042093fd:	48 c1 e8 20          	shr    $0x20,%rax
  8004209401:	89 c2                	mov    %eax,%edx
  8004209403:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420940a:	00 00 00 
  800420940d:	89 90 88 00 00 00    	mov    %edx,0x88(%rax)
  8004209413:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420941a:	00 00 00 
  800420941d:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%rax)
  8004209424:	00 00 00 
	SETGATE(idt[T_TSS], 0, GD_KT, TRAPH_invalidtss,0);
  8004209427:	48 b8 68 bb 20 04 80 	movabs $0x800420bb68,%rax
  800420942e:	00 00 00 
  8004209431:	89 c2                	mov    %eax,%edx
  8004209433:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420943a:	00 00 00 
  800420943d:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
  8004209444:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420944b:	00 00 00 
  800420944e:	66 c7 80 a2 00 00 00 	movw   $0x8,0xa2(%rax)
  8004209455:	08 00 
  8004209457:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420945e:	00 00 00 
  8004209461:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  8004209468:	83 e2 f8             	and    $0xfffffff8,%edx
  800420946b:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  8004209471:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209478:	00 00 00 
  800420947b:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  8004209482:	83 e2 07             	and    $0x7,%edx
  8004209485:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  800420948b:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209492:	00 00 00 
  8004209495:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420949c:	83 e2 f0             	and    $0xfffffff0,%edx
  800420949f:	83 ca 0e             	or     $0xe,%edx
  80042094a2:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  80042094a8:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042094af:	00 00 00 
  80042094b2:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  80042094b9:	83 e2 ef             	and    $0xffffffef,%edx
  80042094bc:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  80042094c2:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042094c9:	00 00 00 
  80042094cc:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  80042094d3:	83 e2 9f             	and    $0xffffff9f,%edx
  80042094d6:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  80042094dc:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042094e3:	00 00 00 
  80042094e6:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  80042094ed:	83 ca 80             	or     $0xffffff80,%edx
  80042094f0:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  80042094f6:	48 b8 68 bb 20 04 80 	movabs $0x800420bb68,%rax
  80042094fd:	00 00 00 
  8004209500:	48 c1 e8 10          	shr    $0x10,%rax
  8004209504:	89 c2                	mov    %eax,%edx
  8004209506:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420950d:	00 00 00 
  8004209510:	66 89 90 a6 00 00 00 	mov    %dx,0xa6(%rax)
  8004209517:	48 b8 68 bb 20 04 80 	movabs $0x800420bb68,%rax
  800420951e:	00 00 00 
  8004209521:	48 c1 e8 20          	shr    $0x20,%rax
  8004209525:	89 c2                	mov    %eax,%edx
  8004209527:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420952e:	00 00 00 
  8004209531:	89 90 a8 00 00 00    	mov    %edx,0xa8(%rax)
  8004209537:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420953e:	00 00 00 
  8004209541:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%rax)
  8004209548:	00 00 00 
	SETGATE(idt[T_SEGNP], 0, GD_KT, TRAPH_segmentnotpresent,0);
  800420954b:	48 b8 6c bb 20 04 80 	movabs $0x800420bb6c,%rax
  8004209552:	00 00 00 
  8004209555:	89 c2                	mov    %eax,%edx
  8004209557:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420955e:	00 00 00 
  8004209561:	66 89 90 b0 00 00 00 	mov    %dx,0xb0(%rax)
  8004209568:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420956f:	00 00 00 
  8004209572:	66 c7 80 b2 00 00 00 	movw   $0x8,0xb2(%rax)
  8004209579:	08 00 
  800420957b:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209582:	00 00 00 
  8004209585:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  800420958c:	83 e2 f8             	and    $0xfffffff8,%edx
  800420958f:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  8004209595:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420959c:	00 00 00 
  800420959f:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  80042095a6:	83 e2 07             	and    $0x7,%edx
  80042095a9:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  80042095af:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042095b6:	00 00 00 
  80042095b9:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  80042095c0:	83 e2 f0             	and    $0xfffffff0,%edx
  80042095c3:	83 ca 0e             	or     $0xe,%edx
  80042095c6:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  80042095cc:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042095d3:	00 00 00 
  80042095d6:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  80042095dd:	83 e2 ef             	and    $0xffffffef,%edx
  80042095e0:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  80042095e6:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042095ed:	00 00 00 
  80042095f0:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  80042095f7:	83 e2 9f             	and    $0xffffff9f,%edx
  80042095fa:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  8004209600:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209607:	00 00 00 
  800420960a:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  8004209611:	83 ca 80             	or     $0xffffff80,%edx
  8004209614:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420961a:	48 b8 6c bb 20 04 80 	movabs $0x800420bb6c,%rax
  8004209621:	00 00 00 
  8004209624:	48 c1 e8 10          	shr    $0x10,%rax
  8004209628:	89 c2                	mov    %eax,%edx
  800420962a:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209631:	00 00 00 
  8004209634:	66 89 90 b6 00 00 00 	mov    %dx,0xb6(%rax)
  800420963b:	48 b8 6c bb 20 04 80 	movabs $0x800420bb6c,%rax
  8004209642:	00 00 00 
  8004209645:	48 c1 e8 20          	shr    $0x20,%rax
  8004209649:	89 c2                	mov    %eax,%edx
  800420964b:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209652:	00 00 00 
  8004209655:	89 90 b8 00 00 00    	mov    %edx,0xb8(%rax)
  800420965b:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209662:	00 00 00 
  8004209665:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%rax)
  800420966c:	00 00 00 
	SETGATE(idt[T_STACK], 0, GD_KT,TRAPH_stackexception,0);
  800420966f:	48 b8 70 bb 20 04 80 	movabs $0x800420bb70,%rax
  8004209676:	00 00 00 
  8004209679:	89 c2                	mov    %eax,%edx
  800420967b:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209682:	00 00 00 
  8004209685:	66 89 90 c0 00 00 00 	mov    %dx,0xc0(%rax)
  800420968c:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209693:	00 00 00 
  8004209696:	66 c7 80 c2 00 00 00 	movw   $0x8,0xc2(%rax)
  800420969d:	08 00 
  800420969f:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042096a6:	00 00 00 
  80042096a9:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  80042096b0:	83 e2 f8             	and    $0xfffffff8,%edx
  80042096b3:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  80042096b9:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042096c0:	00 00 00 
  80042096c3:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  80042096ca:	83 e2 07             	and    $0x7,%edx
  80042096cd:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  80042096d3:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042096da:	00 00 00 
  80042096dd:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  80042096e4:	83 e2 f0             	and    $0xfffffff0,%edx
  80042096e7:	83 ca 0e             	or     $0xe,%edx
  80042096ea:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  80042096f0:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042096f7:	00 00 00 
  80042096fa:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209701:	83 e2 ef             	and    $0xffffffef,%edx
  8004209704:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420970a:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209711:	00 00 00 
  8004209714:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420971b:	83 e2 9f             	and    $0xffffff9f,%edx
  800420971e:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209724:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420972b:	00 00 00 
  800420972e:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209735:	83 ca 80             	or     $0xffffff80,%edx
  8004209738:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420973e:	48 b8 70 bb 20 04 80 	movabs $0x800420bb70,%rax
  8004209745:	00 00 00 
  8004209748:	48 c1 e8 10          	shr    $0x10,%rax
  800420974c:	89 c2                	mov    %eax,%edx
  800420974e:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209755:	00 00 00 
  8004209758:	66 89 90 c6 00 00 00 	mov    %dx,0xc6(%rax)
  800420975f:	48 b8 70 bb 20 04 80 	movabs $0x800420bb70,%rax
  8004209766:	00 00 00 
  8004209769:	48 c1 e8 20          	shr    $0x20,%rax
  800420976d:	89 c2                	mov    %eax,%edx
  800420976f:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209776:	00 00 00 
  8004209779:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)
  800420977f:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209786:	00 00 00 
  8004209789:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%rax)
  8004209790:	00 00 00 
	SETGATE(idt[T_GPFLT], 0, GD_KT, TRAPH_generalprotectionfault,0);
  8004209793:	48 b8 74 bb 20 04 80 	movabs $0x800420bb74,%rax
  800420979a:	00 00 00 
  800420979d:	89 c2                	mov    %eax,%edx
  800420979f:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042097a6:	00 00 00 
  80042097a9:	66 89 90 d0 00 00 00 	mov    %dx,0xd0(%rax)
  80042097b0:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042097b7:	00 00 00 
  80042097ba:	66 c7 80 d2 00 00 00 	movw   $0x8,0xd2(%rax)
  80042097c1:	08 00 
  80042097c3:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042097ca:	00 00 00 
  80042097cd:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  80042097d4:	83 e2 f8             	and    $0xfffffff8,%edx
  80042097d7:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  80042097dd:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042097e4:	00 00 00 
  80042097e7:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  80042097ee:	83 e2 07             	and    $0x7,%edx
  80042097f1:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  80042097f7:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042097fe:	00 00 00 
  8004209801:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209808:	83 e2 f0             	and    $0xfffffff0,%edx
  800420980b:	83 ca 0e             	or     $0xe,%edx
  800420980e:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209814:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420981b:	00 00 00 
  800420981e:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209825:	83 e2 ef             	and    $0xffffffef,%edx
  8004209828:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420982e:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209835:	00 00 00 
  8004209838:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420983f:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209842:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209848:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420984f:	00 00 00 
  8004209852:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209859:	83 ca 80             	or     $0xffffff80,%edx
  800420985c:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209862:	48 b8 74 bb 20 04 80 	movabs $0x800420bb74,%rax
  8004209869:	00 00 00 
  800420986c:	48 c1 e8 10          	shr    $0x10,%rax
  8004209870:	89 c2                	mov    %eax,%edx
  8004209872:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209879:	00 00 00 
  800420987c:	66 89 90 d6 00 00 00 	mov    %dx,0xd6(%rax)
  8004209883:	48 b8 74 bb 20 04 80 	movabs $0x800420bb74,%rax
  800420988a:	00 00 00 
  800420988d:	48 c1 e8 20          	shr    $0x20,%rax
  8004209891:	89 c2                	mov    %eax,%edx
  8004209893:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420989a:	00 00 00 
  800420989d:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
  80042098a3:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042098aa:	00 00 00 
  80042098ad:	c7 80 dc 00 00 00 00 	movl   $0x0,0xdc(%rax)
  80042098b4:	00 00 00 
	SETGATE(idt[T_PGFLT], 0, GD_KT, TRAPH_pagefault,0);
  80042098b7:	48 b8 78 bb 20 04 80 	movabs $0x800420bb78,%rax
  80042098be:	00 00 00 
  80042098c1:	89 c2                	mov    %eax,%edx
  80042098c3:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042098ca:	00 00 00 
  80042098cd:	66 89 90 e0 00 00 00 	mov    %dx,0xe0(%rax)
  80042098d4:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042098db:	00 00 00 
  80042098de:	66 c7 80 e2 00 00 00 	movw   $0x8,0xe2(%rax)
  80042098e5:	08 00 
  80042098e7:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042098ee:	00 00 00 
  80042098f1:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  80042098f8:	83 e2 f8             	and    $0xfffffff8,%edx
  80042098fb:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  8004209901:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209908:	00 00 00 
  800420990b:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  8004209912:	83 e2 07             	and    $0x7,%edx
  8004209915:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  800420991b:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209922:	00 00 00 
  8004209925:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420992c:	83 e2 f0             	and    $0xfffffff0,%edx
  800420992f:	83 ca 0e             	or     $0xe,%edx
  8004209932:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209938:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420993f:	00 00 00 
  8004209942:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209949:	83 e2 ef             	and    $0xffffffef,%edx
  800420994c:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209952:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209959:	00 00 00 
  800420995c:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209963:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209966:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420996c:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209973:	00 00 00 
  8004209976:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420997d:	83 ca 80             	or     $0xffffff80,%edx
  8004209980:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209986:	48 b8 78 bb 20 04 80 	movabs $0x800420bb78,%rax
  800420998d:	00 00 00 
  8004209990:	48 c1 e8 10          	shr    $0x10,%rax
  8004209994:	89 c2                	mov    %eax,%edx
  8004209996:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420999d:	00 00 00 
  80042099a0:	66 89 90 e6 00 00 00 	mov    %dx,0xe6(%rax)
  80042099a7:	48 b8 78 bb 20 04 80 	movabs $0x800420bb78,%rax
  80042099ae:	00 00 00 
  80042099b1:	48 c1 e8 20          	shr    $0x20,%rax
  80042099b5:	89 c2                	mov    %eax,%edx
  80042099b7:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042099be:	00 00 00 
  80042099c1:	89 90 e8 00 00 00    	mov    %edx,0xe8(%rax)
  80042099c7:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042099ce:	00 00 00 
  80042099d1:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%rax)
  80042099d8:	00 00 00 
	SETGATE(idt[T_SYSCALL], 0, GD_KT, TRAPH_syscall,3);
  80042099db:	48 b8 7c bb 20 04 80 	movabs $0x800420bb7c,%rax
  80042099e2:	00 00 00 
  80042099e5:	89 c2                	mov    %eax,%edx
  80042099e7:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042099ee:	00 00 00 
  80042099f1:	66 89 90 00 03 00 00 	mov    %dx,0x300(%rax)
  80042099f8:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  80042099ff:	00 00 00 
  8004209a02:	66 c7 80 02 03 00 00 	movw   $0x8,0x302(%rax)
  8004209a09:	08 00 
  8004209a0b:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209a12:	00 00 00 
  8004209a15:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  8004209a1c:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209a1f:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  8004209a25:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209a2c:	00 00 00 
  8004209a2f:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  8004209a36:	83 e2 07             	and    $0x7,%edx
  8004209a39:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  8004209a3f:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209a46:	00 00 00 
  8004209a49:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004209a50:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209a53:	83 ca 0e             	or     $0xe,%edx
  8004209a56:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  8004209a5c:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209a63:	00 00 00 
  8004209a66:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004209a6d:	83 e2 ef             	and    $0xffffffef,%edx
  8004209a70:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  8004209a76:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209a7d:	00 00 00 
  8004209a80:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004209a87:	83 ca 60             	or     $0x60,%edx
  8004209a8a:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  8004209a90:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209a97:	00 00 00 
  8004209a9a:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  8004209aa1:	83 ca 80             	or     $0xffffff80,%edx
  8004209aa4:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  8004209aaa:	48 b8 7c bb 20 04 80 	movabs $0x800420bb7c,%rax
  8004209ab1:	00 00 00 
  8004209ab4:	48 c1 e8 10          	shr    $0x10,%rax
  8004209ab8:	89 c2                	mov    %eax,%edx
  8004209aba:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209ac1:	00 00 00 
  8004209ac4:	66 89 90 06 03 00 00 	mov    %dx,0x306(%rax)
  8004209acb:	48 b8 7c bb 20 04 80 	movabs $0x800420bb7c,%rax
  8004209ad2:	00 00 00 
  8004209ad5:	48 c1 e8 20          	shr    $0x20,%rax
  8004209ad9:	89 c2                	mov    %eax,%edx
  8004209adb:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209ae2:	00 00 00 
  8004209ae5:	89 90 08 03 00 00    	mov    %edx,0x308(%rax)
  8004209aeb:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209af2:	00 00 00 
  8004209af5:	c7 80 0c 03 00 00 00 	movl   $0x0,0x30c(%rax)
  8004209afc:	00 00 00 
	SETGATE(idt[T_FPERR], 0, GD_KT, TRAPH_floatingpointerror,0);
  8004209aff:	48 b8 82 bb 20 04 80 	movabs $0x800420bb82,%rax
  8004209b06:	00 00 00 
  8004209b09:	89 c2                	mov    %eax,%edx
  8004209b0b:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209b12:	00 00 00 
  8004209b15:	66 89 90 00 01 00 00 	mov    %dx,0x100(%rax)
  8004209b1c:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209b23:	00 00 00 
  8004209b26:	66 c7 80 02 01 00 00 	movw   $0x8,0x102(%rax)
  8004209b2d:	08 00 
  8004209b2f:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209b36:	00 00 00 
  8004209b39:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  8004209b40:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209b43:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  8004209b49:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209b50:	00 00 00 
  8004209b53:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  8004209b5a:	83 e2 07             	and    $0x7,%edx
  8004209b5d:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  8004209b63:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209b6a:	00 00 00 
  8004209b6d:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209b74:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209b77:	83 ca 0e             	or     $0xe,%edx
  8004209b7a:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209b80:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209b87:	00 00 00 
  8004209b8a:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209b91:	83 e2 ef             	and    $0xffffffef,%edx
  8004209b94:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209b9a:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209ba1:	00 00 00 
  8004209ba4:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209bab:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209bae:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209bb4:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209bbb:	00 00 00 
  8004209bbe:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209bc5:	83 ca 80             	or     $0xffffff80,%edx
  8004209bc8:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209bce:	48 b8 82 bb 20 04 80 	movabs $0x800420bb82,%rax
  8004209bd5:	00 00 00 
  8004209bd8:	48 c1 e8 10          	shr    $0x10,%rax
  8004209bdc:	89 c2                	mov    %eax,%edx
  8004209bde:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209be5:	00 00 00 
  8004209be8:	66 89 90 06 01 00 00 	mov    %dx,0x106(%rax)
  8004209bef:	48 b8 82 bb 20 04 80 	movabs $0x800420bb82,%rax
  8004209bf6:	00 00 00 
  8004209bf9:	48 c1 e8 20          	shr    $0x20,%rax
  8004209bfd:	89 c2                	mov    %eax,%edx
  8004209bff:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209c06:	00 00 00 
  8004209c09:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
  8004209c0f:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209c16:	00 00 00 
  8004209c19:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%rax)
  8004209c20:	00 00 00 
	SETGATE(idt[T_ALIGN], 0, GD_KT, TRAPH_alignmentcheck,0);
  8004209c23:	48 b8 88 bb 20 04 80 	movabs $0x800420bb88,%rax
  8004209c2a:	00 00 00 
  8004209c2d:	89 c2                	mov    %eax,%edx
  8004209c2f:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209c36:	00 00 00 
  8004209c39:	66 89 90 10 01 00 00 	mov    %dx,0x110(%rax)
  8004209c40:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209c47:	00 00 00 
  8004209c4a:	66 c7 80 12 01 00 00 	movw   $0x8,0x112(%rax)
  8004209c51:	08 00 
  8004209c53:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209c5a:	00 00 00 
  8004209c5d:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  8004209c64:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209c67:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  8004209c6d:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209c74:	00 00 00 
  8004209c77:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  8004209c7e:	83 e2 07             	and    $0x7,%edx
  8004209c81:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  8004209c87:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209c8e:	00 00 00 
  8004209c91:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209c98:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209c9b:	83 ca 0e             	or     $0xe,%edx
  8004209c9e:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209ca4:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209cab:	00 00 00 
  8004209cae:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209cb5:	83 e2 ef             	and    $0xffffffef,%edx
  8004209cb8:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209cbe:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209cc5:	00 00 00 
  8004209cc8:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209ccf:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209cd2:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209cd8:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209cdf:	00 00 00 
  8004209ce2:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  8004209ce9:	83 ca 80             	or     $0xffffff80,%edx
  8004209cec:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  8004209cf2:	48 b8 88 bb 20 04 80 	movabs $0x800420bb88,%rax
  8004209cf9:	00 00 00 
  8004209cfc:	48 c1 e8 10          	shr    $0x10,%rax
  8004209d00:	89 c2                	mov    %eax,%edx
  8004209d02:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209d09:	00 00 00 
  8004209d0c:	66 89 90 16 01 00 00 	mov    %dx,0x116(%rax)
  8004209d13:	48 b8 88 bb 20 04 80 	movabs $0x800420bb88,%rax
  8004209d1a:	00 00 00 
  8004209d1d:	48 c1 e8 20          	shr    $0x20,%rax
  8004209d21:	89 c2                	mov    %eax,%edx
  8004209d23:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209d2a:	00 00 00 
  8004209d2d:	89 90 18 01 00 00    	mov    %edx,0x118(%rax)
  8004209d33:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209d3a:	00 00 00 
  8004209d3d:	c7 80 1c 01 00 00 00 	movl   $0x0,0x11c(%rax)
  8004209d44:	00 00 00 
        SETGATE(idt[T_MCHK], 0, GD_KT, TRAPH_machinecheck,0);
  8004209d47:	48 b8 8e bb 20 04 80 	movabs $0x800420bb8e,%rax
  8004209d4e:	00 00 00 
  8004209d51:	89 c2                	mov    %eax,%edx
  8004209d53:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209d5a:	00 00 00 
  8004209d5d:	66 89 90 20 01 00 00 	mov    %dx,0x120(%rax)
  8004209d64:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209d6b:	00 00 00 
  8004209d6e:	66 c7 80 22 01 00 00 	movw   $0x8,0x122(%rax)
  8004209d75:	08 00 
  8004209d77:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209d7e:	00 00 00 
  8004209d81:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  8004209d88:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209d8b:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  8004209d91:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209d98:	00 00 00 
  8004209d9b:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  8004209da2:	83 e2 07             	and    $0x7,%edx
  8004209da5:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  8004209dab:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209db2:	00 00 00 
  8004209db5:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  8004209dbc:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209dbf:	83 ca 0e             	or     $0xe,%edx
  8004209dc2:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  8004209dc8:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209dcf:	00 00 00 
  8004209dd2:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  8004209dd9:	83 e2 ef             	and    $0xffffffef,%edx
  8004209ddc:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  8004209de2:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209de9:	00 00 00 
  8004209dec:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  8004209df3:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209df6:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  8004209dfc:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209e03:	00 00 00 
  8004209e06:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  8004209e0d:	83 ca 80             	or     $0xffffff80,%edx
  8004209e10:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  8004209e16:	48 b8 8e bb 20 04 80 	movabs $0x800420bb8e,%rax
  8004209e1d:	00 00 00 
  8004209e20:	48 c1 e8 10          	shr    $0x10,%rax
  8004209e24:	89 c2                	mov    %eax,%edx
  8004209e26:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209e2d:	00 00 00 
  8004209e30:	66 89 90 26 01 00 00 	mov    %dx,0x126(%rax)
  8004209e37:	48 b8 8e bb 20 04 80 	movabs $0x800420bb8e,%rax
  8004209e3e:	00 00 00 
  8004209e41:	48 c1 e8 20          	shr    $0x20,%rax
  8004209e45:	89 c2                	mov    %eax,%edx
  8004209e47:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209e4e:	00 00 00 
  8004209e51:	89 90 28 01 00 00    	mov    %edx,0x128(%rax)
  8004209e57:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209e5e:	00 00 00 
  8004209e61:	c7 80 2c 01 00 00 00 	movl   $0x0,0x12c(%rax)
  8004209e68:	00 00 00 
	SETGATE(idt[T_SIMDERR], 0, GD_KT, TRAPH_simderror,0);
  8004209e6b:	48 b8 94 bb 20 04 80 	movabs $0x800420bb94,%rax
  8004209e72:	00 00 00 
  8004209e75:	89 c2                	mov    %eax,%edx
  8004209e77:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209e7e:	00 00 00 
  8004209e81:	66 89 90 30 01 00 00 	mov    %dx,0x130(%rax)
  8004209e88:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209e8f:	00 00 00 
  8004209e92:	66 c7 80 32 01 00 00 	movw   $0x8,0x132(%rax)
  8004209e99:	08 00 
  8004209e9b:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209ea2:	00 00 00 
  8004209ea5:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  8004209eac:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209eaf:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  8004209eb5:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209ebc:	00 00 00 
  8004209ebf:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  8004209ec6:	83 e2 07             	and    $0x7,%edx
  8004209ec9:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  8004209ecf:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209ed6:	00 00 00 
  8004209ed9:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  8004209ee0:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209ee3:	83 ca 0e             	or     $0xe,%edx
  8004209ee6:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  8004209eec:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209ef3:	00 00 00 
  8004209ef6:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  8004209efd:	83 e2 ef             	and    $0xffffffef,%edx
  8004209f00:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  8004209f06:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209f0d:	00 00 00 
  8004209f10:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  8004209f17:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209f1a:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  8004209f20:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209f27:	00 00 00 
  8004209f2a:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  8004209f31:	83 ca 80             	or     $0xffffff80,%edx
  8004209f34:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  8004209f3a:	48 b8 94 bb 20 04 80 	movabs $0x800420bb94,%rax
  8004209f41:	00 00 00 
  8004209f44:	48 c1 e8 10          	shr    $0x10,%rax
  8004209f48:	89 c2                	mov    %eax,%edx
  8004209f4a:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209f51:	00 00 00 
  8004209f54:	66 89 90 36 01 00 00 	mov    %dx,0x136(%rax)
  8004209f5b:	48 b8 94 bb 20 04 80 	movabs $0x800420bb94,%rax
  8004209f62:	00 00 00 
  8004209f65:	48 c1 e8 20          	shr    $0x20,%rax
  8004209f69:	89 c2                	mov    %eax,%edx
  8004209f6b:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209f72:	00 00 00 
  8004209f75:	89 90 38 01 00 00    	mov    %edx,0x138(%rax)
  8004209f7b:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209f82:	00 00 00 
  8004209f85:	c7 80 3c 01 00 00 00 	movl   $0x0,0x13c(%rax)
  8004209f8c:	00 00 00 
	SETGATE(idt[IRQ_TIMER + IRQ_OFFSET], 0, GD_KT, TRAPH_timer, 0);
  8004209f8f:	48 b8 9a bb 20 04 80 	movabs $0x800420bb9a,%rax
  8004209f96:	00 00 00 
  8004209f99:	89 c2                	mov    %eax,%edx
  8004209f9b:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209fa2:	00 00 00 
  8004209fa5:	66 89 90 00 02 00 00 	mov    %dx,0x200(%rax)
  8004209fac:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209fb3:	00 00 00 
  8004209fb6:	66 c7 80 02 02 00 00 	movw   $0x8,0x202(%rax)
  8004209fbd:	08 00 
  8004209fbf:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209fc6:	00 00 00 
  8004209fc9:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  8004209fd0:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209fd3:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  8004209fd9:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209fe0:	00 00 00 
  8004209fe3:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  8004209fea:	83 e2 07             	and    $0x7,%edx
  8004209fed:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  8004209ff3:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  8004209ffa:	00 00 00 
  8004209ffd:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a004:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a007:	83 ca 0e             	or     $0xe,%edx
  800420a00a:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a010:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a017:	00 00 00 
  800420a01a:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a021:	83 e2 ef             	and    $0xffffffef,%edx
  800420a024:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a02a:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a031:	00 00 00 
  800420a034:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a03b:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a03e:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a044:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a04b:	00 00 00 
  800420a04e:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a055:	83 ca 80             	or     $0xffffff80,%edx
  800420a058:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a05e:	48 b8 9a bb 20 04 80 	movabs $0x800420bb9a,%rax
  800420a065:	00 00 00 
  800420a068:	48 c1 e8 10          	shr    $0x10,%rax
  800420a06c:	89 c2                	mov    %eax,%edx
  800420a06e:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a075:	00 00 00 
  800420a078:	66 89 90 06 02 00 00 	mov    %dx,0x206(%rax)
  800420a07f:	48 b8 9a bb 20 04 80 	movabs $0x800420bb9a,%rax
  800420a086:	00 00 00 
  800420a089:	48 c1 e8 20          	shr    $0x20,%rax
  800420a08d:	89 c2                	mov    %eax,%edx
  800420a08f:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a096:	00 00 00 
  800420a099:	89 90 08 02 00 00    	mov    %edx,0x208(%rax)
  800420a09f:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a0a6:	00 00 00 
  800420a0a9:	c7 80 0c 02 00 00 00 	movl   $0x0,0x20c(%rax)
  800420a0b0:	00 00 00 
	SETGATE(idt[IRQ_KBD + IRQ_OFFSET], 0, GD_KT, TRAPH_keyboard, 0);
  800420a0b3:	48 b8 a0 bb 20 04 80 	movabs $0x800420bba0,%rax
  800420a0ba:	00 00 00 
  800420a0bd:	89 c2                	mov    %eax,%edx
  800420a0bf:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a0c6:	00 00 00 
  800420a0c9:	66 89 90 10 02 00 00 	mov    %dx,0x210(%rax)
  800420a0d0:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a0d7:	00 00 00 
  800420a0da:	66 c7 80 12 02 00 00 	movw   $0x8,0x212(%rax)
  800420a0e1:	08 00 
  800420a0e3:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a0ea:	00 00 00 
  800420a0ed:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420a0f4:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a0f7:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420a0fd:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a104:	00 00 00 
  800420a107:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420a10e:	83 e2 07             	and    $0x7,%edx
  800420a111:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420a117:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a11e:	00 00 00 
  800420a121:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a128:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a12b:	83 ca 0e             	or     $0xe,%edx
  800420a12e:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a134:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a13b:	00 00 00 
  800420a13e:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a145:	83 e2 ef             	and    $0xffffffef,%edx
  800420a148:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a14e:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a155:	00 00 00 
  800420a158:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a15f:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a162:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a168:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a16f:	00 00 00 
  800420a172:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a179:	83 ca 80             	or     $0xffffff80,%edx
  800420a17c:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a182:	48 b8 a0 bb 20 04 80 	movabs $0x800420bba0,%rax
  800420a189:	00 00 00 
  800420a18c:	48 c1 e8 10          	shr    $0x10,%rax
  800420a190:	89 c2                	mov    %eax,%edx
  800420a192:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a199:	00 00 00 
  800420a19c:	66 89 90 16 02 00 00 	mov    %dx,0x216(%rax)
  800420a1a3:	48 b8 a0 bb 20 04 80 	movabs $0x800420bba0,%rax
  800420a1aa:	00 00 00 
  800420a1ad:	48 c1 e8 20          	shr    $0x20,%rax
  800420a1b1:	89 c2                	mov    %eax,%edx
  800420a1b3:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a1ba:	00 00 00 
  800420a1bd:	89 90 18 02 00 00    	mov    %edx,0x218(%rax)
  800420a1c3:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a1ca:	00 00 00 
  800420a1cd:	c7 80 1c 02 00 00 00 	movl   $0x0,0x21c(%rax)
  800420a1d4:	00 00 00 
	SETGATE(idt[IRQ_SERIAL + IRQ_OFFSET], 0, GD_KT, TRAPH_serial, 0);
  800420a1d7:	48 b8 a6 bb 20 04 80 	movabs $0x800420bba6,%rax
  800420a1de:	00 00 00 
  800420a1e1:	89 c2                	mov    %eax,%edx
  800420a1e3:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a1ea:	00 00 00 
  800420a1ed:	66 89 90 40 02 00 00 	mov    %dx,0x240(%rax)
  800420a1f4:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a1fb:	00 00 00 
  800420a1fe:	66 c7 80 42 02 00 00 	movw   $0x8,0x242(%rax)
  800420a205:	08 00 
  800420a207:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a20e:	00 00 00 
  800420a211:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420a218:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a21b:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420a221:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a228:	00 00 00 
  800420a22b:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420a232:	83 e2 07             	and    $0x7,%edx
  800420a235:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420a23b:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a242:	00 00 00 
  800420a245:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a24c:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a24f:	83 ca 0e             	or     $0xe,%edx
  800420a252:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a258:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a25f:	00 00 00 
  800420a262:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a269:	83 e2 ef             	and    $0xffffffef,%edx
  800420a26c:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a272:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a279:	00 00 00 
  800420a27c:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a283:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a286:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a28c:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a293:	00 00 00 
  800420a296:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420a29d:	83 ca 80             	or     $0xffffff80,%edx
  800420a2a0:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420a2a6:	48 b8 a6 bb 20 04 80 	movabs $0x800420bba6,%rax
  800420a2ad:	00 00 00 
  800420a2b0:	48 c1 e8 10          	shr    $0x10,%rax
  800420a2b4:	89 c2                	mov    %eax,%edx
  800420a2b6:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a2bd:	00 00 00 
  800420a2c0:	66 89 90 46 02 00 00 	mov    %dx,0x246(%rax)
  800420a2c7:	48 b8 a6 bb 20 04 80 	movabs $0x800420bba6,%rax
  800420a2ce:	00 00 00 
  800420a2d1:	48 c1 e8 20          	shr    $0x20,%rax
  800420a2d5:	89 c2                	mov    %eax,%edx
  800420a2d7:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a2de:	00 00 00 
  800420a2e1:	89 90 48 02 00 00    	mov    %edx,0x248(%rax)
  800420a2e7:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a2ee:	00 00 00 
  800420a2f1:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%rax)
  800420a2f8:	00 00 00 
    	SETGATE(idt[IRQ_SPURIOUS + IRQ_OFFSET], 0, GD_KT, TRAPH_spurious, 0);
  800420a2fb:	48 b8 ac bb 20 04 80 	movabs $0x800420bbac,%rax
  800420a302:	00 00 00 
  800420a305:	89 c2                	mov    %eax,%edx
  800420a307:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a30e:	00 00 00 
  800420a311:	66 89 90 70 02 00 00 	mov    %dx,0x270(%rax)
  800420a318:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a31f:	00 00 00 
  800420a322:	66 c7 80 72 02 00 00 	movw   $0x8,0x272(%rax)
  800420a329:	08 00 
  800420a32b:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a332:	00 00 00 
  800420a335:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420a33c:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a33f:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420a345:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a34c:	00 00 00 
  800420a34f:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420a356:	83 e2 07             	and    $0x7,%edx
  800420a359:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420a35f:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a366:	00 00 00 
  800420a369:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a370:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a373:	83 ca 0e             	or     $0xe,%edx
  800420a376:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a37c:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a383:	00 00 00 
  800420a386:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a38d:	83 e2 ef             	and    $0xffffffef,%edx
  800420a390:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a396:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a39d:	00 00 00 
  800420a3a0:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a3a7:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a3aa:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a3b0:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a3b7:	00 00 00 
  800420a3ba:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420a3c1:	83 ca 80             	or     $0xffffff80,%edx
  800420a3c4:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420a3ca:	48 b8 ac bb 20 04 80 	movabs $0x800420bbac,%rax
  800420a3d1:	00 00 00 
  800420a3d4:	48 c1 e8 10          	shr    $0x10,%rax
  800420a3d8:	89 c2                	mov    %eax,%edx
  800420a3da:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a3e1:	00 00 00 
  800420a3e4:	66 89 90 76 02 00 00 	mov    %dx,0x276(%rax)
  800420a3eb:	48 b8 ac bb 20 04 80 	movabs $0x800420bbac,%rax
  800420a3f2:	00 00 00 
  800420a3f5:	48 c1 e8 20          	shr    $0x20,%rax
  800420a3f9:	89 c2                	mov    %eax,%edx
  800420a3fb:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a402:	00 00 00 
  800420a405:	89 90 78 02 00 00    	mov    %edx,0x278(%rax)
  800420a40b:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a412:	00 00 00 
  800420a415:	c7 80 7c 02 00 00 00 	movl   $0x0,0x27c(%rax)
  800420a41c:	00 00 00 
	SETGATE(idt[IRQ_OFFSET + IRQ_IDE], 0, GD_KT, TRAPH_ide, 0);
  800420a41f:	48 b8 b2 bb 20 04 80 	movabs $0x800420bbb2,%rax
  800420a426:	00 00 00 
  800420a429:	89 c2                	mov    %eax,%edx
  800420a42b:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a432:	00 00 00 
  800420a435:	66 89 90 e0 02 00 00 	mov    %dx,0x2e0(%rax)
  800420a43c:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a443:	00 00 00 
  800420a446:	66 c7 80 e2 02 00 00 	movw   $0x8,0x2e2(%rax)
  800420a44d:	08 00 
  800420a44f:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a456:	00 00 00 
  800420a459:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420a460:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a463:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420a469:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a470:	00 00 00 
  800420a473:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420a47a:	83 e2 07             	and    $0x7,%edx
  800420a47d:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420a483:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a48a:	00 00 00 
  800420a48d:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420a494:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a497:	83 ca 0e             	or     $0xe,%edx
  800420a49a:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420a4a0:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a4a7:	00 00 00 
  800420a4aa:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420a4b1:	83 e2 ef             	and    $0xffffffef,%edx
  800420a4b4:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420a4ba:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a4c1:	00 00 00 
  800420a4c4:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420a4cb:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a4ce:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420a4d4:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a4db:	00 00 00 
  800420a4de:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420a4e5:	83 ca 80             	or     $0xffffff80,%edx
  800420a4e8:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420a4ee:	48 b8 b2 bb 20 04 80 	movabs $0x800420bbb2,%rax
  800420a4f5:	00 00 00 
  800420a4f8:	48 c1 e8 10          	shr    $0x10,%rax
  800420a4fc:	89 c2                	mov    %eax,%edx
  800420a4fe:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a505:	00 00 00 
  800420a508:	66 89 90 e6 02 00 00 	mov    %dx,0x2e6(%rax)
  800420a50f:	48 b8 b2 bb 20 04 80 	movabs $0x800420bbb2,%rax
  800420a516:	00 00 00 
  800420a519:	48 c1 e8 20          	shr    $0x20,%rax
  800420a51d:	89 c2                	mov    %eax,%edx
  800420a51f:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a526:	00 00 00 
  800420a529:	89 90 e8 02 00 00    	mov    %edx,0x2e8(%rax)
  800420a52f:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a536:	00 00 00 
  800420a539:	c7 80 ec 02 00 00 00 	movl   $0x0,0x2ec(%rax)
  800420a540:	00 00 00 
        SETGATE(idt[IRQ_OFFSET + IRQ_ERROR], 0, GD_KT, TRAPH_err, 0);
  800420a543:	48 b8 b8 bb 20 04 80 	movabs $0x800420bbb8,%rax
  800420a54a:	00 00 00 
  800420a54d:	89 c2                	mov    %eax,%edx
  800420a54f:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a556:	00 00 00 
  800420a559:	66 89 90 30 03 00 00 	mov    %dx,0x330(%rax)
  800420a560:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a567:	00 00 00 
  800420a56a:	66 c7 80 32 03 00 00 	movw   $0x8,0x332(%rax)
  800420a571:	08 00 
  800420a573:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a57a:	00 00 00 
  800420a57d:	0f b6 90 34 03 00 00 	movzbl 0x334(%rax),%edx
  800420a584:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a587:	88 90 34 03 00 00    	mov    %dl,0x334(%rax)
  800420a58d:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a594:	00 00 00 
  800420a597:	0f b6 90 34 03 00 00 	movzbl 0x334(%rax),%edx
  800420a59e:	83 e2 07             	and    $0x7,%edx
  800420a5a1:	88 90 34 03 00 00    	mov    %dl,0x334(%rax)
  800420a5a7:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a5ae:	00 00 00 
  800420a5b1:	0f b6 90 35 03 00 00 	movzbl 0x335(%rax),%edx
  800420a5b8:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a5bb:	83 ca 0e             	or     $0xe,%edx
  800420a5be:	88 90 35 03 00 00    	mov    %dl,0x335(%rax)
  800420a5c4:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a5cb:	00 00 00 
  800420a5ce:	0f b6 90 35 03 00 00 	movzbl 0x335(%rax),%edx
  800420a5d5:	83 e2 ef             	and    $0xffffffef,%edx
  800420a5d8:	88 90 35 03 00 00    	mov    %dl,0x335(%rax)
  800420a5de:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a5e5:	00 00 00 
  800420a5e8:	0f b6 90 35 03 00 00 	movzbl 0x335(%rax),%edx
  800420a5ef:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a5f2:	88 90 35 03 00 00    	mov    %dl,0x335(%rax)
  800420a5f8:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a5ff:	00 00 00 
  800420a602:	0f b6 90 35 03 00 00 	movzbl 0x335(%rax),%edx
  800420a609:	83 ca 80             	or     $0xffffff80,%edx
  800420a60c:	88 90 35 03 00 00    	mov    %dl,0x335(%rax)
  800420a612:	48 b8 b8 bb 20 04 80 	movabs $0x800420bbb8,%rax
  800420a619:	00 00 00 
  800420a61c:	48 c1 e8 10          	shr    $0x10,%rax
  800420a620:	89 c2                	mov    %eax,%edx
  800420a622:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a629:	00 00 00 
  800420a62c:	66 89 90 36 03 00 00 	mov    %dx,0x336(%rax)
  800420a633:	48 b8 b8 bb 20 04 80 	movabs $0x800420bbb8,%rax
  800420a63a:	00 00 00 
  800420a63d:	48 c1 e8 20          	shr    $0x20,%rax
  800420a641:	89 c2                	mov    %eax,%edx
  800420a643:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a64a:	00 00 00 
  800420a64d:	89 90 38 03 00 00    	mov    %edx,0x338(%rax)
  800420a653:	48 b8 80 b2 63 04 80 	movabs $0x800463b280,%rax
  800420a65a:	00 00 00 
  800420a65d:	c7 80 3c 03 00 00 00 	movl   $0x0,0x33c(%rax)
  800420a664:	00 00 00 

	
	idt_pd.pd_lim = sizeof(idt)-1;
  800420a667:	48 b8 80 c2 63 04 80 	movabs $0x800463c280,%rax
  800420a66e:	00 00 00 
  800420a671:	66 c7 00 ff 0f       	movw   $0xfff,(%rax)
	idt_pd.pd_base = (uint64_t)idt;
  800420a676:	48 ba 80 b2 63 04 80 	movabs $0x800463b280,%rdx
  800420a67d:	00 00 00 
  800420a680:	48 b8 80 c2 63 04 80 	movabs $0x800463c280,%rax
  800420a687:	00 00 00 
  800420a68a:	48 89 50 02          	mov    %rdx,0x2(%rax)
	// Per-CPU setup
	trap_init_percpu();
  800420a68e:	48 b8 9c a6 20 04 80 	movabs $0x800420a69c,%rax
  800420a695:	00 00 00 
  800420a698:	ff d0                	callq  *%rax
}
  800420a69a:	5d                   	pop    %rbp
  800420a69b:	c3                   	retq   

000000800420a69c <trap_init_percpu>:

// Initialize and load the per-CPU TSS and IDT
void
trap_init_percpu(void)
{
  800420a69c:	55                   	push   %rbp
  800420a69d:	48 89 e5             	mov    %rsp,%rbp
  800420a6a0:	53                   	push   %rbx
  800420a6a1:	48 83 ec 18          	sub    $0x18,%rsp
	// LAB 4: Your code here:

	// Setup a TSS so that we get the right stack
	// when we trap to the kernel.
	//ts.ts_esp0 = KSTACKTOP;
	thiscpu->cpu_ts.ts_esp0 = KSTACKTOP - ((thiscpu->cpu_id) * (KSTKSIZE+KSTKGAP));
  800420a6a5:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420a6ac:	00 00 00 
  800420a6af:	ff d0                	callq  *%rax
  800420a6b1:	48 98                	cltq   
  800420a6b3:	48 c1 e0 03          	shl    $0x3,%rax
  800420a6b7:	48 89 c2             	mov    %rax,%rdx
  800420a6ba:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a6be:	48 29 c2             	sub    %rax,%rdx
  800420a6c1:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420a6c8:	00 00 00 
  800420a6cb:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420a6cf:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420a6d6:	00 00 00 
  800420a6d9:	ff d0                	callq  *%rax
  800420a6db:	48 98                	cltq   
  800420a6dd:	48 c1 e0 03          	shl    $0x3,%rax
  800420a6e1:	48 89 c2             	mov    %rax,%rdx
  800420a6e4:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a6e8:	48 29 c2             	sub    %rax,%rdx
  800420a6eb:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420a6f2:	00 00 00 
  800420a6f5:	48 01 d0             	add    %rdx,%rax
  800420a6f8:	0f b6 00             	movzbl (%rax),%eax
  800420a6fb:	0f b6 d0             	movzbl %al,%edx
  800420a6fe:	89 d0                	mov    %edx,%eax
  800420a700:	01 c0                	add    %eax,%eax
  800420a702:	01 d0                	add    %edx,%eax
  800420a704:	c1 e0 0f             	shl    $0xf,%eax
  800420a707:	48 98                	cltq   
  800420a709:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420a710:	00 00 00 
  800420a713:	48 89 d1             	mov    %rdx,%rcx
  800420a716:	48 29 c1             	sub    %rax,%rcx
  800420a719:	48 89 c8             	mov    %rcx,%rax
  800420a71c:	48 89 43 14          	mov    %rax,0x14(%rbx)
	
	// Initialize the TSS slot of the gdt.
	SETTSS((struct SystemSegdesc64*)(&gdt[(GD_TSS0>>3)+2*(thiscpu->cpu_id)]),STS_T64A,(uint64_t)(&thiscpu->cpu_ts),sizeof(struct Taskstate), 0);
  800420a720:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420a727:	00 00 00 
  800420a72a:	ff d0                	callq  *%rax
  800420a72c:	48 98                	cltq   
  800420a72e:	48 c1 e0 03          	shl    $0x3,%rax
  800420a732:	48 89 c2             	mov    %rax,%rdx
  800420a735:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a739:	48 29 c2             	sub    %rax,%rdx
  800420a73c:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420a743:	00 00 00 
  800420a746:	48 01 d0             	add    %rdx,%rax
  800420a749:	0f b6 00             	movzbl (%rax),%eax
  800420a74c:	0f b6 c0             	movzbl %al,%eax
  800420a74f:	48 c1 e0 04          	shl    $0x4,%rax
  800420a753:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420a757:	48 b8 e0 a5 22 04 80 	movabs $0x800422a5e0,%rax
  800420a75e:	00 00 00 
  800420a761:	48 01 d0             	add    %rdx,%rax
  800420a764:	66 c7 00 68 00       	movw   $0x68,(%rax)
  800420a769:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420a770:	00 00 00 
  800420a773:	ff d0                	callq  *%rax
  800420a775:	48 98                	cltq   
  800420a777:	48 c1 e0 03          	shl    $0x3,%rax
  800420a77b:	48 89 c2             	mov    %rax,%rdx
  800420a77e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a782:	48 29 c2             	sub    %rax,%rdx
  800420a785:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420a78c:	00 00 00 
  800420a78f:	48 01 d0             	add    %rdx,%rax
  800420a792:	0f b6 00             	movzbl (%rax),%eax
  800420a795:	0f b6 c0             	movzbl %al,%eax
  800420a798:	48 c1 e0 04          	shl    $0x4,%rax
  800420a79c:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420a7a0:	48 b8 e0 a5 22 04 80 	movabs $0x800422a5e0,%rax
  800420a7a7:	00 00 00 
  800420a7aa:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420a7ae:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420a7b5:	00 00 00 
  800420a7b8:	ff d0                	callq  *%rax
  800420a7ba:	48 98                	cltq   
  800420a7bc:	48 c1 e0 03          	shl    $0x3,%rax
  800420a7c0:	48 89 c2             	mov    %rax,%rdx
  800420a7c3:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a7c7:	48 29 c2             	sub    %rax,%rdx
  800420a7ca:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420a7d1:	00 00 00 
  800420a7d4:	48 01 d0             	add    %rdx,%rax
  800420a7d7:	48 83 c0 10          	add    $0x10,%rax
  800420a7db:	66 89 43 02          	mov    %ax,0x2(%rbx)
  800420a7df:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420a7e6:	00 00 00 
  800420a7e9:	ff d0                	callq  *%rax
  800420a7eb:	48 98                	cltq   
  800420a7ed:	48 c1 e0 03          	shl    $0x3,%rax
  800420a7f1:	48 89 c2             	mov    %rax,%rdx
  800420a7f4:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a7f8:	48 29 c2             	sub    %rax,%rdx
  800420a7fb:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420a802:	00 00 00 
  800420a805:	48 01 d0             	add    %rdx,%rax
  800420a808:	0f b6 00             	movzbl (%rax),%eax
  800420a80b:	0f b6 c0             	movzbl %al,%eax
  800420a80e:	48 c1 e0 04          	shl    $0x4,%rax
  800420a812:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420a816:	48 b8 e0 a5 22 04 80 	movabs $0x800422a5e0,%rax
  800420a81d:	00 00 00 
  800420a820:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420a824:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420a82b:	00 00 00 
  800420a82e:	ff d0                	callq  *%rax
  800420a830:	48 98                	cltq   
  800420a832:	48 c1 e0 03          	shl    $0x3,%rax
  800420a836:	48 89 c2             	mov    %rax,%rdx
  800420a839:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a83d:	48 29 c2             	sub    %rax,%rdx
  800420a840:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420a847:	00 00 00 
  800420a84a:	48 01 d0             	add    %rdx,%rax
  800420a84d:	48 83 c0 10          	add    $0x10,%rax
  800420a851:	48 c1 e8 10          	shr    $0x10,%rax
  800420a855:	88 43 04             	mov    %al,0x4(%rbx)
  800420a858:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420a85f:	00 00 00 
  800420a862:	ff d0                	callq  *%rax
  800420a864:	48 98                	cltq   
  800420a866:	48 c1 e0 03          	shl    $0x3,%rax
  800420a86a:	48 89 c2             	mov    %rax,%rdx
  800420a86d:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a871:	48 29 c2             	sub    %rax,%rdx
  800420a874:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420a87b:	00 00 00 
  800420a87e:	48 01 d0             	add    %rdx,%rax
  800420a881:	0f b6 00             	movzbl (%rax),%eax
  800420a884:	0f b6 c0             	movzbl %al,%eax
  800420a887:	48 c1 e0 04          	shl    $0x4,%rax
  800420a88b:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420a88f:	48 b8 e0 a5 22 04 80 	movabs $0x800422a5e0,%rax
  800420a896:	00 00 00 
  800420a899:	48 01 d0             	add    %rdx,%rax
  800420a89c:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420a8a0:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a8a3:	83 ca 09             	or     $0x9,%edx
  800420a8a6:	88 50 05             	mov    %dl,0x5(%rax)
  800420a8a9:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420a8b0:	00 00 00 
  800420a8b3:	ff d0                	callq  *%rax
  800420a8b5:	48 98                	cltq   
  800420a8b7:	48 c1 e0 03          	shl    $0x3,%rax
  800420a8bb:	48 89 c2             	mov    %rax,%rdx
  800420a8be:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a8c2:	48 29 c2             	sub    %rax,%rdx
  800420a8c5:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420a8cc:	00 00 00 
  800420a8cf:	48 01 d0             	add    %rdx,%rax
  800420a8d2:	0f b6 00             	movzbl (%rax),%eax
  800420a8d5:	0f b6 c0             	movzbl %al,%eax
  800420a8d8:	48 c1 e0 04          	shl    $0x4,%rax
  800420a8dc:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420a8e0:	48 b8 e0 a5 22 04 80 	movabs $0x800422a5e0,%rax
  800420a8e7:	00 00 00 
  800420a8ea:	48 01 d0             	add    %rdx,%rax
  800420a8ed:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420a8f1:	83 e2 ef             	and    $0xffffffef,%edx
  800420a8f4:	88 50 05             	mov    %dl,0x5(%rax)
  800420a8f7:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420a8fe:	00 00 00 
  800420a901:	ff d0                	callq  *%rax
  800420a903:	48 98                	cltq   
  800420a905:	48 c1 e0 03          	shl    $0x3,%rax
  800420a909:	48 89 c2             	mov    %rax,%rdx
  800420a90c:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a910:	48 29 c2             	sub    %rax,%rdx
  800420a913:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420a91a:	00 00 00 
  800420a91d:	48 01 d0             	add    %rdx,%rax
  800420a920:	0f b6 00             	movzbl (%rax),%eax
  800420a923:	0f b6 c0             	movzbl %al,%eax
  800420a926:	48 c1 e0 04          	shl    $0x4,%rax
  800420a92a:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420a92e:	48 b8 e0 a5 22 04 80 	movabs $0x800422a5e0,%rax
  800420a935:	00 00 00 
  800420a938:	48 01 d0             	add    %rdx,%rax
  800420a93b:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420a93f:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a942:	88 50 05             	mov    %dl,0x5(%rax)
  800420a945:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420a94c:	00 00 00 
  800420a94f:	ff d0                	callq  *%rax
  800420a951:	48 98                	cltq   
  800420a953:	48 c1 e0 03          	shl    $0x3,%rax
  800420a957:	48 89 c2             	mov    %rax,%rdx
  800420a95a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a95e:	48 29 c2             	sub    %rax,%rdx
  800420a961:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420a968:	00 00 00 
  800420a96b:	48 01 d0             	add    %rdx,%rax
  800420a96e:	0f b6 00             	movzbl (%rax),%eax
  800420a971:	0f b6 c0             	movzbl %al,%eax
  800420a974:	48 c1 e0 04          	shl    $0x4,%rax
  800420a978:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420a97c:	48 b8 e0 a5 22 04 80 	movabs $0x800422a5e0,%rax
  800420a983:	00 00 00 
  800420a986:	48 01 d0             	add    %rdx,%rax
  800420a989:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420a98d:	83 ca 80             	or     $0xffffff80,%edx
  800420a990:	88 50 05             	mov    %dl,0x5(%rax)
  800420a993:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420a99a:	00 00 00 
  800420a99d:	ff d0                	callq  *%rax
  800420a99f:	48 98                	cltq   
  800420a9a1:	48 c1 e0 03          	shl    $0x3,%rax
  800420a9a5:	48 89 c2             	mov    %rax,%rdx
  800420a9a8:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a9ac:	48 29 c2             	sub    %rax,%rdx
  800420a9af:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420a9b6:	00 00 00 
  800420a9b9:	48 01 d0             	add    %rdx,%rax
  800420a9bc:	0f b6 00             	movzbl (%rax),%eax
  800420a9bf:	0f b6 c0             	movzbl %al,%eax
  800420a9c2:	48 c1 e0 04          	shl    $0x4,%rax
  800420a9c6:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420a9ca:	48 b8 e0 a5 22 04 80 	movabs $0x800422a5e0,%rax
  800420a9d1:	00 00 00 
  800420a9d4:	48 01 d0             	add    %rdx,%rax
  800420a9d7:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420a9db:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a9de:	88 50 06             	mov    %dl,0x6(%rax)
  800420a9e1:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420a9e8:	00 00 00 
  800420a9eb:	ff d0                	callq  *%rax
  800420a9ed:	48 98                	cltq   
  800420a9ef:	48 c1 e0 03          	shl    $0x3,%rax
  800420a9f3:	48 89 c2             	mov    %rax,%rdx
  800420a9f6:	48 c1 e2 04          	shl    $0x4,%rdx
  800420a9fa:	48 29 c2             	sub    %rax,%rdx
  800420a9fd:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420aa04:	00 00 00 
  800420aa07:	48 01 d0             	add    %rdx,%rax
  800420aa0a:	0f b6 00             	movzbl (%rax),%eax
  800420aa0d:	0f b6 c0             	movzbl %al,%eax
  800420aa10:	48 c1 e0 04          	shl    $0x4,%rax
  800420aa14:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420aa18:	48 b8 e0 a5 22 04 80 	movabs $0x800422a5e0,%rax
  800420aa1f:	00 00 00 
  800420aa22:	48 01 d0             	add    %rdx,%rax
  800420aa25:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420aa29:	83 e2 ef             	and    $0xffffffef,%edx
  800420aa2c:	88 50 06             	mov    %dl,0x6(%rax)
  800420aa2f:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420aa36:	00 00 00 
  800420aa39:	ff d0                	callq  *%rax
  800420aa3b:	48 98                	cltq   
  800420aa3d:	48 c1 e0 03          	shl    $0x3,%rax
  800420aa41:	48 89 c2             	mov    %rax,%rdx
  800420aa44:	48 c1 e2 04          	shl    $0x4,%rdx
  800420aa48:	48 29 c2             	sub    %rax,%rdx
  800420aa4b:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420aa52:	00 00 00 
  800420aa55:	48 01 d0             	add    %rdx,%rax
  800420aa58:	0f b6 00             	movzbl (%rax),%eax
  800420aa5b:	0f b6 c0             	movzbl %al,%eax
  800420aa5e:	48 c1 e0 04          	shl    $0x4,%rax
  800420aa62:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420aa66:	48 b8 e0 a5 22 04 80 	movabs $0x800422a5e0,%rax
  800420aa6d:	00 00 00 
  800420aa70:	48 01 d0             	add    %rdx,%rax
  800420aa73:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420aa77:	83 e2 9f             	and    $0xffffff9f,%edx
  800420aa7a:	88 50 06             	mov    %dl,0x6(%rax)
  800420aa7d:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420aa84:	00 00 00 
  800420aa87:	ff d0                	callq  *%rax
  800420aa89:	48 98                	cltq   
  800420aa8b:	48 c1 e0 03          	shl    $0x3,%rax
  800420aa8f:	48 89 c2             	mov    %rax,%rdx
  800420aa92:	48 c1 e2 04          	shl    $0x4,%rdx
  800420aa96:	48 29 c2             	sub    %rax,%rdx
  800420aa99:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420aaa0:	00 00 00 
  800420aaa3:	48 01 d0             	add    %rdx,%rax
  800420aaa6:	0f b6 00             	movzbl (%rax),%eax
  800420aaa9:	0f b6 c0             	movzbl %al,%eax
  800420aaac:	48 c1 e0 04          	shl    $0x4,%rax
  800420aab0:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420aab4:	48 b8 e0 a5 22 04 80 	movabs $0x800422a5e0,%rax
  800420aabb:	00 00 00 
  800420aabe:	48 01 d0             	add    %rdx,%rax
  800420aac1:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420aac5:	83 e2 7f             	and    $0x7f,%edx
  800420aac8:	88 50 06             	mov    %dl,0x6(%rax)
  800420aacb:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420aad2:	00 00 00 
  800420aad5:	ff d0                	callq  *%rax
  800420aad7:	48 98                	cltq   
  800420aad9:	48 c1 e0 03          	shl    $0x3,%rax
  800420aadd:	48 89 c2             	mov    %rax,%rdx
  800420aae0:	48 c1 e2 04          	shl    $0x4,%rdx
  800420aae4:	48 29 c2             	sub    %rax,%rdx
  800420aae7:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420aaee:	00 00 00 
  800420aaf1:	48 01 d0             	add    %rdx,%rax
  800420aaf4:	0f b6 00             	movzbl (%rax),%eax
  800420aaf7:	0f b6 c0             	movzbl %al,%eax
  800420aafa:	48 c1 e0 04          	shl    $0x4,%rax
  800420aafe:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420ab02:	48 b8 e0 a5 22 04 80 	movabs $0x800422a5e0,%rax
  800420ab09:	00 00 00 
  800420ab0c:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420ab10:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420ab17:	00 00 00 
  800420ab1a:	ff d0                	callq  *%rax
  800420ab1c:	48 98                	cltq   
  800420ab1e:	48 c1 e0 03          	shl    $0x3,%rax
  800420ab22:	48 89 c2             	mov    %rax,%rdx
  800420ab25:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ab29:	48 29 c2             	sub    %rax,%rdx
  800420ab2c:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420ab33:	00 00 00 
  800420ab36:	48 01 d0             	add    %rdx,%rax
  800420ab39:	48 83 c0 10          	add    $0x10,%rax
  800420ab3d:	48 c1 e8 18          	shr    $0x18,%rax
  800420ab41:	88 43 07             	mov    %al,0x7(%rbx)
  800420ab44:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420ab4b:	00 00 00 
  800420ab4e:	ff d0                	callq  *%rax
  800420ab50:	48 98                	cltq   
  800420ab52:	48 c1 e0 03          	shl    $0x3,%rax
  800420ab56:	48 89 c2             	mov    %rax,%rdx
  800420ab59:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ab5d:	48 29 c2             	sub    %rax,%rdx
  800420ab60:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420ab67:	00 00 00 
  800420ab6a:	48 01 d0             	add    %rdx,%rax
  800420ab6d:	0f b6 00             	movzbl (%rax),%eax
  800420ab70:	0f b6 c0             	movzbl %al,%eax
  800420ab73:	48 c1 e0 04          	shl    $0x4,%rax
  800420ab77:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420ab7b:	48 b8 e0 a5 22 04 80 	movabs $0x800422a5e0,%rax
  800420ab82:	00 00 00 
  800420ab85:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420ab89:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420ab90:	00 00 00 
  800420ab93:	ff d0                	callq  *%rax
  800420ab95:	48 98                	cltq   
  800420ab97:	48 c1 e0 03          	shl    $0x3,%rax
  800420ab9b:	48 89 c2             	mov    %rax,%rdx
  800420ab9e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420aba2:	48 29 c2             	sub    %rax,%rdx
  800420aba5:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420abac:	00 00 00 
  800420abaf:	48 01 d0             	add    %rdx,%rax
  800420abb2:	48 83 c0 10          	add    $0x10,%rax
  800420abb6:	48 c1 e8 20          	shr    $0x20,%rax
  800420abba:	89 43 08             	mov    %eax,0x8(%rbx)
  800420abbd:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420abc4:	00 00 00 
  800420abc7:	ff d0                	callq  *%rax
  800420abc9:	48 98                	cltq   
  800420abcb:	48 c1 e0 03          	shl    $0x3,%rax
  800420abcf:	48 89 c2             	mov    %rax,%rdx
  800420abd2:	48 c1 e2 04          	shl    $0x4,%rdx
  800420abd6:	48 29 c2             	sub    %rax,%rdx
  800420abd9:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420abe0:	00 00 00 
  800420abe3:	48 01 d0             	add    %rdx,%rax
  800420abe6:	0f b6 00             	movzbl (%rax),%eax
  800420abe9:	0f b6 c0             	movzbl %al,%eax
  800420abec:	48 c1 e0 04          	shl    $0x4,%rax
  800420abf0:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420abf4:	48 b8 e0 a5 22 04 80 	movabs $0x800422a5e0,%rax
  800420abfb:	00 00 00 
  800420abfe:	48 01 d0             	add    %rdx,%rax
  800420ac01:	c6 40 0c 00          	movb   $0x0,0xc(%rax)
  800420ac05:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420ac0c:	00 00 00 
  800420ac0f:	ff d0                	callq  *%rax
  800420ac11:	48 98                	cltq   
  800420ac13:	48 c1 e0 03          	shl    $0x3,%rax
  800420ac17:	48 89 c2             	mov    %rax,%rdx
  800420ac1a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ac1e:	48 29 c2             	sub    %rax,%rdx
  800420ac21:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420ac28:	00 00 00 
  800420ac2b:	48 01 d0             	add    %rdx,%rax
  800420ac2e:	0f b6 00             	movzbl (%rax),%eax
  800420ac31:	0f b6 c0             	movzbl %al,%eax
  800420ac34:	48 c1 e0 04          	shl    $0x4,%rax
  800420ac38:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420ac3c:	48 b8 e0 a5 22 04 80 	movabs $0x800422a5e0,%rax
  800420ac43:	00 00 00 
  800420ac46:	48 01 d0             	add    %rdx,%rax
  800420ac49:	c6 40 0d 00          	movb   $0x0,0xd(%rax)
  800420ac4d:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420ac54:	00 00 00 
  800420ac57:	ff d0                	callq  *%rax
  800420ac59:	48 98                	cltq   
  800420ac5b:	48 c1 e0 03          	shl    $0x3,%rax
  800420ac5f:	48 89 c2             	mov    %rax,%rdx
  800420ac62:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ac66:	48 29 c2             	sub    %rax,%rdx
  800420ac69:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420ac70:	00 00 00 
  800420ac73:	48 01 d0             	add    %rdx,%rax
  800420ac76:	0f b6 00             	movzbl (%rax),%eax
  800420ac79:	0f b6 c0             	movzbl %al,%eax
  800420ac7c:	48 c1 e0 04          	shl    $0x4,%rax
  800420ac80:	48 8d 50 28          	lea    0x28(%rax),%rdx
  800420ac84:	48 b8 e0 a5 22 04 80 	movabs $0x800422a5e0,%rax
  800420ac8b:	00 00 00 
  800420ac8e:	48 01 d0             	add    %rdx,%rax
  800420ac91:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%rax)
	//gdt[(GD_TSS0 >> 3) + 2 * thicpu->cpu_id]=	
	// Load the TSS selector (like other segment selectors, the
	// bottom three bits are special; we leave them 0)
	ltr(GD_TSS0+(((2*thiscpu->cpu_id)<<3) & (~0x7)));
  800420ac97:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420ac9e:	00 00 00 
  800420aca1:	ff d0                	callq  *%rax
  800420aca3:	48 98                	cltq   
  800420aca5:	48 c1 e0 03          	shl    $0x3,%rax
  800420aca9:	48 89 c2             	mov    %rax,%rdx
  800420acac:	48 c1 e2 04          	shl    $0x4,%rdx
  800420acb0:	48 29 c2             	sub    %rax,%rdx
  800420acb3:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420acba:	00 00 00 
  800420acbd:	48 01 d0             	add    %rdx,%rax
  800420acc0:	0f b6 00             	movzbl (%rax),%eax
  800420acc3:	0f b6 c0             	movzbl %al,%eax
  800420acc6:	01 c0                	add    %eax,%eax
  800420acc8:	c1 e0 03             	shl    $0x3,%eax
  800420accb:	83 c0 28             	add    $0x28,%eax
  800420acce:	0f b7 c0             	movzwl %ax,%eax
  800420acd1:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
	__asm __volatile("lgdt (%0)" : : "r" (p));
}
static __inline void
ltr(uint16_t sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
  800420acd5:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  800420acd9:	0f 00 d8             	ltr    %ax
  800420acdc:	48 b8 80 c2 63 04 80 	movabs $0x800463c280,%rax
  800420ace3:	00 00 00 
  800420ace6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
}  

static __inline void
lidt(void *p)
{
	__asm __volatile("lidt (%0)" : : "r" (p));
  800420acea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420acee:	0f 01 18             	lidt   (%rax)

	// Load the IDT
	lidt(&idt_pd);
}
  800420acf1:	48 83 c4 18          	add    $0x18,%rsp
  800420acf5:	5b                   	pop    %rbx
  800420acf6:	5d                   	pop    %rbp
  800420acf7:	c3                   	retq   

000000800420acf8 <print_trapframe>:

void
print_trapframe(struct Trapframe *tf)
{
  800420acf8:	55                   	push   %rbp
  800420acf9:	48 89 e5             	mov    %rsp,%rbp
  800420acfc:	53                   	push   %rbx
  800420acfd:	48 83 ec 28          	sub    $0x28,%rsp
  800420ad01:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	cprintf("TRAP frame at %p from CPU %d\n", tf, cpunum());
  800420ad05:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420ad0c:	00 00 00 
  800420ad0f:	ff d0                	callq  *%rax
  800420ad11:	89 c2                	mov    %eax,%edx
  800420ad13:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ad17:	48 89 c6             	mov    %rax,%rsi
  800420ad1a:	48 bf ee 82 21 04 80 	movabs $0x80042182ee,%rdi
  800420ad21:	00 00 00 
  800420ad24:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ad29:	48 b9 f2 89 20 04 80 	movabs $0x80042089f2,%rcx
  800420ad30:	00 00 00 
  800420ad33:	ff d1                	callq  *%rcx
	print_regs(&tf->tf_regs);
  800420ad35:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ad39:	48 89 c7             	mov    %rax,%rdi
  800420ad3c:	48 b8 0e b0 20 04 80 	movabs $0x800420b00e,%rax
  800420ad43:	00 00 00 
  800420ad46:	ff d0                	callq  *%rax
	cprintf("  es   0x----%04x\n", tf->tf_es);
  800420ad48:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ad4c:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  800420ad50:	0f b7 c0             	movzwl %ax,%eax
  800420ad53:	89 c6                	mov    %eax,%esi
  800420ad55:	48 bf 0c 83 21 04 80 	movabs $0x800421830c,%rdi
  800420ad5c:	00 00 00 
  800420ad5f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ad64:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420ad6b:	00 00 00 
  800420ad6e:	ff d2                	callq  *%rdx
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
  800420ad70:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ad74:	0f b7 80 80 00 00 00 	movzwl 0x80(%rax),%eax
  800420ad7b:	0f b7 c0             	movzwl %ax,%eax
  800420ad7e:	89 c6                	mov    %eax,%esi
  800420ad80:	48 bf 1f 83 21 04 80 	movabs $0x800421831f,%rdi
  800420ad87:	00 00 00 
  800420ad8a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ad8f:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420ad96:	00 00 00 
  800420ad99:	ff d2                	callq  *%rdx
	//cprintf("\nHAHAHAHAHAHA:	%08x\n",tf->tf_trapno);
	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
  800420ad9b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ad9f:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420ada6:	89 c7                	mov    %eax,%edi
  800420ada8:	48 b8 19 8b 20 04 80 	movabs $0x8004208b19,%rax
  800420adaf:	00 00 00 
  800420adb2:	ff d0                	callq  *%rax
  800420adb4:	48 89 c2             	mov    %rax,%rdx
  800420adb7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420adbb:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420adc2:	48 89 c6             	mov    %rax,%rsi
  800420adc5:	48 bf 32 83 21 04 80 	movabs $0x8004218332,%rdi
  800420adcc:	00 00 00 
  800420adcf:	b8 00 00 00 00       	mov    $0x0,%eax
  800420add4:	48 b9 f2 89 20 04 80 	movabs $0x80042089f2,%rcx
  800420addb:	00 00 00 
  800420adde:	ff d1                	callq  *%rcx
	// If this trap was a page fault that just happened
	// (so %cr2 is meaningful), print the faulting linear address.
	if (tf == last_tf && tf->tf_trapno == T_PGFLT)
  800420ade0:	48 b8 08 c3 63 04 80 	movabs $0x800463c308,%rax
  800420ade7:	00 00 00 
  800420adea:	48 8b 00             	mov    (%rax),%rax
  800420aded:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  800420adf1:	75 3a                	jne    800420ae2d <print_trapframe+0x135>
  800420adf3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420adf7:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420adfe:	48 83 f8 0e          	cmp    $0xe,%rax
  800420ae02:	75 29                	jne    800420ae2d <print_trapframe+0x135>

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420ae04:	0f 20 d3             	mov    %cr2,%rbx
  800420ae07:	48 89 5d e8          	mov    %rbx,-0x18(%rbp)
	return val;
  800420ae0b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
		cprintf("  cr2  0x%08x\n", rcr2());
  800420ae0f:	48 89 c6             	mov    %rax,%rsi
  800420ae12:	48 bf 44 83 21 04 80 	movabs $0x8004218344,%rdi
  800420ae19:	00 00 00 
  800420ae1c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ae21:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420ae28:	00 00 00 
  800420ae2b:	ff d2                	callq  *%rdx
	cprintf("  err  0x%08x", tf->tf_err);
  800420ae2d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ae31:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420ae38:	48 89 c6             	mov    %rax,%rsi
  800420ae3b:	48 bf 53 83 21 04 80 	movabs $0x8004218353,%rdi
  800420ae42:	00 00 00 
  800420ae45:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ae4a:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420ae51:	00 00 00 
  800420ae54:	ff d2                	callq  *%rdx
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
  800420ae56:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ae5a:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420ae61:	48 83 f8 0e          	cmp    $0xe,%rax
  800420ae65:	0f 85 9b 00 00 00    	jne    800420af06 <print_trapframe+0x20e>
		cprintf(" [%s, %s, %s]\n",
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
  800420ae6b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ae6f:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420ae76:	83 e0 01             	and    $0x1,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420ae79:	84 c0                	test   %al,%al
  800420ae7b:	74 0c                	je     800420ae89 <print_trapframe+0x191>
  800420ae7d:	48 b9 61 83 21 04 80 	movabs $0x8004218361,%rcx
  800420ae84:	00 00 00 
  800420ae87:	eb 0a                	jmp    800420ae93 <print_trapframe+0x19b>
  800420ae89:	48 b9 6c 83 21 04 80 	movabs $0x800421836c,%rcx
  800420ae90:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
  800420ae93:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ae97:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420ae9e:	83 e0 02             	and    $0x2,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420aea1:	48 85 c0             	test   %rax,%rax
  800420aea4:	74 0c                	je     800420aeb2 <print_trapframe+0x1ba>
  800420aea6:	48 ba 78 83 21 04 80 	movabs $0x8004218378,%rdx
  800420aead:	00 00 00 
  800420aeb0:	eb 0a                	jmp    800420aebc <print_trapframe+0x1c4>
  800420aeb2:	48 ba 7e 83 21 04 80 	movabs $0x800421837e,%rdx
  800420aeb9:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
  800420aebc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420aec0:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420aec7:	83 e0 04             	and    $0x4,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420aeca:	48 85 c0             	test   %rax,%rax
  800420aecd:	74 0c                	je     800420aedb <print_trapframe+0x1e3>
  800420aecf:	48 b8 83 83 21 04 80 	movabs $0x8004218383,%rax
  800420aed6:	00 00 00 
  800420aed9:	eb 0a                	jmp    800420aee5 <print_trapframe+0x1ed>
  800420aedb:	48 b8 88 83 21 04 80 	movabs $0x8004218388,%rax
  800420aee2:	00 00 00 
  800420aee5:	48 89 c6             	mov    %rax,%rsi
  800420aee8:	48 bf 8f 83 21 04 80 	movabs $0x800421838f,%rdi
  800420aeef:	00 00 00 
  800420aef2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420aef7:	49 b8 f2 89 20 04 80 	movabs $0x80042089f2,%r8
  800420aefe:	00 00 00 
  800420af01:	41 ff d0             	callq  *%r8
  800420af04:	eb 1b                	jmp    800420af21 <print_trapframe+0x229>
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
	else
		cprintf("\n");
  800420af06:	48 bf 9e 83 21 04 80 	movabs $0x800421839e,%rdi
  800420af0d:	00 00 00 
  800420af10:	b8 00 00 00 00       	mov    $0x0,%eax
  800420af15:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420af1c:	00 00 00 
  800420af1f:	ff d2                	callq  *%rdx
	cprintf("  rip  0x%08x\n", tf->tf_rip);
  800420af21:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420af25:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800420af2c:	48 89 c6             	mov    %rax,%rsi
  800420af2f:	48 bf a0 83 21 04 80 	movabs $0x80042183a0,%rdi
  800420af36:	00 00 00 
  800420af39:	b8 00 00 00 00       	mov    $0x0,%eax
  800420af3e:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420af45:	00 00 00 
  800420af48:	ff d2                	callq  *%rdx
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
  800420af4a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420af4e:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420af55:	0f b7 c0             	movzwl %ax,%eax
  800420af58:	89 c6                	mov    %eax,%esi
  800420af5a:	48 bf af 83 21 04 80 	movabs $0x80042183af,%rdi
  800420af61:	00 00 00 
  800420af64:	b8 00 00 00 00       	mov    $0x0,%eax
  800420af69:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420af70:	00 00 00 
  800420af73:	ff d2                	callq  *%rdx
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
  800420af75:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420af79:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420af80:	48 89 c6             	mov    %rax,%rsi
  800420af83:	48 bf c2 83 21 04 80 	movabs $0x80042183c2,%rdi
  800420af8a:	00 00 00 
  800420af8d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420af92:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420af99:	00 00 00 
  800420af9c:	ff d2                	callq  *%rdx
	if ((tf->tf_cs & 3) != 0) {
  800420af9e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420afa2:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420afa9:	0f b7 c0             	movzwl %ax,%eax
  800420afac:	83 e0 03             	and    $0x3,%eax
  800420afaf:	85 c0                	test   %eax,%eax
  800420afb1:	74 54                	je     800420b007 <print_trapframe+0x30f>
		cprintf("  rsp  0x%08x\n", tf->tf_rsp);
  800420afb3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420afb7:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420afbe:	48 89 c6             	mov    %rax,%rsi
  800420afc1:	48 bf d1 83 21 04 80 	movabs $0x80042183d1,%rdi
  800420afc8:	00 00 00 
  800420afcb:	b8 00 00 00 00       	mov    $0x0,%eax
  800420afd0:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420afd7:	00 00 00 
  800420afda:	ff d2                	callq  *%rdx
		cprintf("  ss   0x----%04x\n", tf->tf_ss);
  800420afdc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420afe0:	0f b7 80 b8 00 00 00 	movzwl 0xb8(%rax),%eax
  800420afe7:	0f b7 c0             	movzwl %ax,%eax
  800420afea:	89 c6                	mov    %eax,%esi
  800420afec:	48 bf e0 83 21 04 80 	movabs $0x80042183e0,%rdi
  800420aff3:	00 00 00 
  800420aff6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420affb:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420b002:	00 00 00 
  800420b005:	ff d2                	callq  *%rdx
	}
}
  800420b007:	48 83 c4 28          	add    $0x28,%rsp
  800420b00b:	5b                   	pop    %rbx
  800420b00c:	5d                   	pop    %rbp
  800420b00d:	c3                   	retq   

000000800420b00e <print_regs>:

void
print_regs(struct PushRegs *regs)
{
  800420b00e:	55                   	push   %rbp
  800420b00f:	48 89 e5             	mov    %rsp,%rbp
  800420b012:	48 83 ec 10          	sub    $0x10,%rsp
  800420b016:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	cprintf("  r15  0x%08x\n", regs->reg_r15);
  800420b01a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b01e:	48 8b 00             	mov    (%rax),%rax
  800420b021:	48 89 c6             	mov    %rax,%rsi
  800420b024:	48 bf f3 83 21 04 80 	movabs $0x80042183f3,%rdi
  800420b02b:	00 00 00 
  800420b02e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b033:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420b03a:	00 00 00 
  800420b03d:	ff d2                	callq  *%rdx
	cprintf("  r14  0x%08x\n", regs->reg_r14);
  800420b03f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b043:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b047:	48 89 c6             	mov    %rax,%rsi
  800420b04a:	48 bf 02 84 21 04 80 	movabs $0x8004218402,%rdi
  800420b051:	00 00 00 
  800420b054:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b059:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420b060:	00 00 00 
  800420b063:	ff d2                	callq  *%rdx
	cprintf("  r13  0x%08x\n", regs->reg_r13);
  800420b065:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b069:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420b06d:	48 89 c6             	mov    %rax,%rsi
  800420b070:	48 bf 11 84 21 04 80 	movabs $0x8004218411,%rdi
  800420b077:	00 00 00 
  800420b07a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b07f:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420b086:	00 00 00 
  800420b089:	ff d2                	callq  *%rdx
	cprintf("  r12  0x%08x\n", regs->reg_r12);
  800420b08b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b08f:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420b093:	48 89 c6             	mov    %rax,%rsi
  800420b096:	48 bf 20 84 21 04 80 	movabs $0x8004218420,%rdi
  800420b09d:	00 00 00 
  800420b0a0:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b0a5:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420b0ac:	00 00 00 
  800420b0af:	ff d2                	callq  *%rdx
	cprintf("  r11  0x%08x\n", regs->reg_r11);
  800420b0b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b0b5:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420b0b9:	48 89 c6             	mov    %rax,%rsi
  800420b0bc:	48 bf 2f 84 21 04 80 	movabs $0x800421842f,%rdi
  800420b0c3:	00 00 00 
  800420b0c6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b0cb:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420b0d2:	00 00 00 
  800420b0d5:	ff d2                	callq  *%rdx
	cprintf("  r10  0x%08x\n", regs->reg_r10);
  800420b0d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b0db:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420b0df:	48 89 c6             	mov    %rax,%rsi
  800420b0e2:	48 bf 3e 84 21 04 80 	movabs $0x800421843e,%rdi
  800420b0e9:	00 00 00 
  800420b0ec:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b0f1:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420b0f8:	00 00 00 
  800420b0fb:	ff d2                	callq  *%rdx
	cprintf("  r9  0x%08x\n", regs->reg_r9);
  800420b0fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b101:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420b105:	48 89 c6             	mov    %rax,%rsi
  800420b108:	48 bf 4d 84 21 04 80 	movabs $0x800421844d,%rdi
  800420b10f:	00 00 00 
  800420b112:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b117:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420b11e:	00 00 00 
  800420b121:	ff d2                	callq  *%rdx
	cprintf("  r8  0x%08x\n", regs->reg_r8);
  800420b123:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b127:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420b12b:	48 89 c6             	mov    %rax,%rsi
  800420b12e:	48 bf 5b 84 21 04 80 	movabs $0x800421845b,%rdi
  800420b135:	00 00 00 
  800420b138:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b13d:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420b144:	00 00 00 
  800420b147:	ff d2                	callq  *%rdx
	cprintf("  rdi  0x%08x\n", regs->reg_rdi);
  800420b149:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b14d:	48 8b 40 48          	mov    0x48(%rax),%rax
  800420b151:	48 89 c6             	mov    %rax,%rsi
  800420b154:	48 bf 69 84 21 04 80 	movabs $0x8004218469,%rdi
  800420b15b:	00 00 00 
  800420b15e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b163:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420b16a:	00 00 00 
  800420b16d:	ff d2                	callq  *%rdx
	cprintf("  rsi  0x%08x\n", regs->reg_rsi);
  800420b16f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b173:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420b177:	48 89 c6             	mov    %rax,%rsi
  800420b17a:	48 bf 78 84 21 04 80 	movabs $0x8004218478,%rdi
  800420b181:	00 00 00 
  800420b184:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b189:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420b190:	00 00 00 
  800420b193:	ff d2                	callq  *%rdx
	cprintf("  rbp  0x%08x\n", regs->reg_rbp);
  800420b195:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b199:	48 8b 40 50          	mov    0x50(%rax),%rax
  800420b19d:	48 89 c6             	mov    %rax,%rsi
  800420b1a0:	48 bf 87 84 21 04 80 	movabs $0x8004218487,%rdi
  800420b1a7:	00 00 00 
  800420b1aa:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b1af:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420b1b6:	00 00 00 
  800420b1b9:	ff d2                	callq  *%rdx
	cprintf("  rbx  0x%08x\n", regs->reg_rbx);
  800420b1bb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b1bf:	48 8b 40 68          	mov    0x68(%rax),%rax
  800420b1c3:	48 89 c6             	mov    %rax,%rsi
  800420b1c6:	48 bf 96 84 21 04 80 	movabs $0x8004218496,%rdi
  800420b1cd:	00 00 00 
  800420b1d0:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b1d5:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420b1dc:	00 00 00 
  800420b1df:	ff d2                	callq  *%rdx
	cprintf("  rdx  0x%08x\n", regs->reg_rdx);
  800420b1e1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b1e5:	48 8b 40 58          	mov    0x58(%rax),%rax
  800420b1e9:	48 89 c6             	mov    %rax,%rsi
  800420b1ec:	48 bf a5 84 21 04 80 	movabs $0x80042184a5,%rdi
  800420b1f3:	00 00 00 
  800420b1f6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b1fb:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420b202:	00 00 00 
  800420b205:	ff d2                	callq  *%rdx
	cprintf("  rcx  0x%08x\n", regs->reg_rcx);
  800420b207:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b20b:	48 8b 40 60          	mov    0x60(%rax),%rax
  800420b20f:	48 89 c6             	mov    %rax,%rsi
  800420b212:	48 bf b4 84 21 04 80 	movabs $0x80042184b4,%rdi
  800420b219:	00 00 00 
  800420b21c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b221:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420b228:	00 00 00 
  800420b22b:	ff d2                	callq  *%rdx
	cprintf("  rax  0x%08x\n", regs->reg_rax);
  800420b22d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b231:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420b235:	48 89 c6             	mov    %rax,%rsi
  800420b238:	48 bf c3 84 21 04 80 	movabs $0x80042184c3,%rdi
  800420b23f:	00 00 00 
  800420b242:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b247:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420b24e:	00 00 00 
  800420b251:	ff d2                	callq  *%rdx
}
  800420b253:	c9                   	leaveq 
  800420b254:	c3                   	retq   

000000800420b255 <trap_dispatch>:

static void
trap_dispatch(struct Trapframe *tf)
{
  800420b255:	55                   	push   %rbp
  800420b256:	48 89 e5             	mov    %rsp,%rbp
  800420b259:	48 83 ec 10          	sub    $0x10,%rsp
  800420b25d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// LAB 3: Your code here.

	// Handle spurious interrupts
	// The hardware sometimes raises these because of noise on the
	// IRQ line or other reasons. We don't care.
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) {
  800420b261:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b265:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b26c:	48 83 f8 27          	cmp    $0x27,%rax
  800420b270:	75 33                	jne    800420b2a5 <trap_dispatch+0x50>
		cprintf("Spurious interrupt on irq 7\n");
  800420b272:	48 bf d2 84 21 04 80 	movabs $0x80042184d2,%rdi
  800420b279:	00 00 00 
  800420b27c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b281:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420b288:	00 00 00 
  800420b28b:	ff d2                	callq  *%rdx
		print_trapframe(tf);
  800420b28d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b291:	48 89 c7             	mov    %rax,%rdi
  800420b294:	48 b8 f8 ac 20 04 80 	movabs $0x800420acf8,%rax
  800420b29b:	00 00 00 
  800420b29e:	ff d0                	callq  *%rax
		return;
  800420b2a0:	e9 bc 01 00 00       	jmpq   800420b461 <trap_dispatch+0x20c>
	}

	// Handle clock interrupts. Don't forget to acknowledge the
	// interrupt using lapic_eoi() before calling the scheduler!
	// LAB 4: Your code here.
	if(tf->tf_trapno == IRQ_OFFSET + IRQ_TIMER )
  800420b2a5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b2a9:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b2b0:	48 83 f8 20          	cmp    $0x20,%rax
  800420b2b4:	75 24                	jne    800420b2da <trap_dispatch+0x85>
        {
		time_tick();
  800420b2b6:	48 b8 0e 6f 21 04 80 	movabs $0x8004216f0e,%rax
  800420b2bd:	00 00 00 
  800420b2c0:	ff d0                	callq  *%rax
                lapic_eoi();
  800420b2c2:	48 b8 0a 56 21 04 80 	movabs $0x800421560a,%rax
  800420b2c9:	00 00 00 
  800420b2cc:	ff d0                	callq  *%rax
                sched_yield();
  800420b2ce:	48 b8 db bc 20 04 80 	movabs $0x800420bcdb,%rax
  800420b2d5:	00 00 00 
  800420b2d8:	ff d0                	callq  *%rax
	// LAB 6: Your code here.


	// Handle keyboard and serial interrupts.
	// LAB 5: Your code here.
	if(tf->tf_trapno == IRQ_OFFSET+IRQ_KBD)
  800420b2da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b2de:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b2e5:	48 83 f8 21          	cmp    $0x21,%rax
  800420b2e9:	75 11                	jne    800420b2fc <trap_dispatch+0xa7>
	{
		kbd_intr();
  800420b2eb:	48 b8 81 10 20 04 80 	movabs $0x8004201081,%rax
  800420b2f2:	00 00 00 
  800420b2f5:	ff d0                	callq  *%rax
		return;
  800420b2f7:	e9 65 01 00 00       	jmpq   800420b461 <trap_dispatch+0x20c>
	}
	if(tf->tf_trapno == IRQ_OFFSET+IRQ_SERIAL)
  800420b2fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b300:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b307:	48 83 f8 24          	cmp    $0x24,%rax
  800420b30b:	75 11                	jne    800420b31e <trap_dispatch+0xc9>
	{
		serial_intr();
  800420b30d:	48 b8 d8 07 20 04 80 	movabs $0x80042007d8,%rax
  800420b314:	00 00 00 
  800420b317:	ff d0                	callq  *%rax
		return;
  800420b319:	e9 43 01 00 00       	jmpq   800420b461 <trap_dispatch+0x20c>
	}
	if(tf->tf_trapno == T_PGFLT)
  800420b31e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b322:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b329:	48 83 f8 0e          	cmp    $0xe,%rax
  800420b32d:	75 18                	jne    800420b347 <trap_dispatch+0xf2>
	{
		page_fault_handler(tf);
  800420b32f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b333:	48 89 c7             	mov    %rax,%rdi
  800420b336:	48 b8 a6 b7 20 04 80 	movabs $0x800420b7a6,%rax
  800420b33d:	00 00 00 
  800420b340:	ff d0                	callq  *%rax
		return;		
  800420b342:	e9 1a 01 00 00       	jmpq   800420b461 <trap_dispatch+0x20c>
	}
	
	else if(tf->tf_trapno == T_BRKPT)
  800420b347:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b34b:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b352:	48 83 f8 03          	cmp    $0x3,%rax
  800420b356:	75 18                	jne    800420b370 <trap_dispatch+0x11b>
	{	
		monitor(tf);
  800420b358:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b35c:	48 89 c7             	mov    %rax,%rdi
  800420b35f:	48 b8 c9 18 20 04 80 	movabs $0x80042018c9,%rax
  800420b366:	00 00 00 
  800420b369:	ff d0                	callq  *%rax
		return;
  800420b36b:	e9 f1 00 00 00       	jmpq   800420b461 <trap_dispatch+0x20c>
	}
	else if(tf->tf_trapno == T_SYSCALL)
  800420b370:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b374:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420b37b:	48 83 f8 30          	cmp    $0x30,%rax
  800420b37f:	75 55                	jne    800420b3d6 <trap_dispatch+0x181>
	{
		//print_trapframe(tf);
		tf->tf_regs.reg_rax=syscall(tf->tf_regs.reg_rax, tf->tf_regs.reg_rdx, tf->tf_regs.reg_rcx, tf->tf_regs.reg_rbx, tf->tf_regs.reg_rdi, tf->tf_regs.reg_rsi);
  800420b381:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b385:	4c 8b 40 40          	mov    0x40(%rax),%r8
  800420b389:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b38d:	48 8b 78 48          	mov    0x48(%rax),%rdi
  800420b391:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b395:	48 8b 48 68          	mov    0x68(%rax),%rcx
  800420b399:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b39d:	48 8b 50 60          	mov    0x60(%rax),%rdx
  800420b3a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b3a5:	48 8b 70 58          	mov    0x58(%rax),%rsi
  800420b3a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b3ad:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420b3b1:	4d 89 c1             	mov    %r8,%r9
  800420b3b4:	49 89 f8             	mov    %rdi,%r8
  800420b3b7:	48 89 c7             	mov    %rax,%rdi
  800420b3ba:	48 b8 ea cb 20 04 80 	movabs $0x800420cbea,%rax
  800420b3c1:	00 00 00 
  800420b3c4:	ff d0                	callq  *%rax
  800420b3c6:	48 89 c2             	mov    %rax,%rdx
  800420b3c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b3cd:	48 89 50 70          	mov    %rdx,0x70(%rax)
		return;
  800420b3d1:	e9 8b 00 00 00       	jmpq   800420b461 <trap_dispatch+0x20c>
	}
//>>>>>>> lab3
//>>>>>>> lab4
	// Unexpected trap: The user process or the kernel has a bug.
	print_trapframe(tf);
  800420b3d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b3da:	48 89 c7             	mov    %rax,%rdi
  800420b3dd:	48 b8 f8 ac 20 04 80 	movabs $0x800420acf8,%rax
  800420b3e4:	00 00 00 
  800420b3e7:	ff d0                	callq  *%rax
	if (tf->tf_cs == GD_KT)
  800420b3e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420b3ed:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420b3f4:	66 83 f8 08          	cmp    $0x8,%ax
  800420b3f8:	75 2a                	jne    800420b424 <trap_dispatch+0x1cf>
		panic("unhandled trap in kernel");
  800420b3fa:	48 ba ef 84 21 04 80 	movabs $0x80042184ef,%rdx
  800420b401:	00 00 00 
  800420b404:	be 28 01 00 00       	mov    $0x128,%esi
  800420b409:	48 bf 08 85 21 04 80 	movabs $0x8004218508,%rdi
  800420b410:	00 00 00 
  800420b413:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b418:	48 b9 f2 04 20 04 80 	movabs $0x80042004f2,%rcx
  800420b41f:	00 00 00 
  800420b422:	ff d1                	callq  *%rcx
	else {
		env_destroy(curenv);
  800420b424:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420b42b:	00 00 00 
  800420b42e:	ff d0                	callq  *%rax
  800420b430:	48 98                	cltq   
  800420b432:	48 c1 e0 03          	shl    $0x3,%rax
  800420b436:	48 89 c2             	mov    %rax,%rdx
  800420b439:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b43d:	48 29 c2             	sub    %rax,%rdx
  800420b440:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420b447:	00 00 00 
  800420b44a:	48 01 d0             	add    %rdx,%rax
  800420b44d:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b451:	48 89 c7             	mov    %rax,%rdi
  800420b454:	48 b8 f4 82 20 04 80 	movabs $0x80042082f4,%rax
  800420b45b:	00 00 00 
  800420b45e:	ff d0                	callq  *%rax
		return;
  800420b460:	90                   	nop
	}
}
  800420b461:	c9                   	leaveq 
  800420b462:	c3                   	retq   

000000800420b463 <trap>:

void
trap(struct Trapframe *tf)
{
  800420b463:	55                   	push   %rbp
  800420b464:	48 89 e5             	mov    %rsp,%rbp
  800420b467:	53                   	push   %rbx
  800420b468:	48 83 ec 28          	sub    $0x28,%rsp
  800420b46c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
   	 //struct Trapframe *tf = &tf_;
	// The environment may have set DF and some versions
	// of GCC rely on DF being clear
	asm volatile("cld" ::: "cc");
  800420b470:	fc                   	cld    

	// Halt the CPU if some other CPU has called panic()
	extern char *panicstr;
	if (panicstr)
  800420b471:	48 b8 c0 c7 63 04 80 	movabs $0x800463c7c0,%rax
  800420b478:	00 00 00 
  800420b47b:	48 8b 00             	mov    (%rax),%rax
  800420b47e:	48 85 c0             	test   %rax,%rax
  800420b481:	74 01                	je     800420b484 <trap+0x21>
		asm volatile("hlt");
  800420b483:	f4                   	hlt    

	// Re-acqurie the big kernel lock if we were halted in
	// sched_yield()
	if (xchg(&thiscpu->cpu_status, CPU_STARTED) == CPU_HALTED)
  800420b484:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420b48b:	00 00 00 
  800420b48e:	ff d0                	callq  *%rax
  800420b490:	48 98                	cltq   
  800420b492:	48 c1 e0 03          	shl    $0x3,%rax
  800420b496:	48 89 c2             	mov    %rax,%rdx
  800420b499:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b49d:	48 29 c2             	sub    %rax,%rdx
  800420b4a0:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420b4a7:	00 00 00 
  800420b4aa:	48 01 d0             	add    %rdx,%rax
  800420b4ad:	48 83 c0 04          	add    $0x4,%rax
  800420b4b1:	be 01 00 00 00       	mov    $0x1,%esi
  800420b4b6:	48 89 c7             	mov    %rax,%rdi
  800420b4b9:	48 b8 cc 8a 20 04 80 	movabs $0x8004208acc,%rax
  800420b4c0:	00 00 00 
  800420b4c3:	ff d0                	callq  *%rax
  800420b4c5:	83 f8 02             	cmp    $0x2,%eax
  800420b4c8:	75 0c                	jne    800420b4d6 <trap+0x73>
		lock_kernel();
  800420b4ca:	48 b8 fd 8a 20 04 80 	movabs $0x8004208afd,%rax
  800420b4d1:	00 00 00 
  800420b4d4:	ff d0                	callq  *%rax

static __inline uint64_t
read_eflags(void)
{
        uint64_t rflags;
        __asm __volatile("pushfq; popq %0" : "=r" (rflags));
  800420b4d6:	9c                   	pushfq 
  800420b4d7:	5b                   	pop    %rbx
  800420b4d8:	48 89 5d e8          	mov    %rbx,-0x18(%rbp)
        return rflags;
  800420b4dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
	// Check that interrupts are disabled.  If this assertion
	// fails, DO NOT be tempted to fix it by inserting a "cli" in
	// the interrupt path.
	assert(!(read_eflags() & FL_IF));
  800420b4e0:	25 00 02 00 00       	and    $0x200,%eax
  800420b4e5:	48 85 c0             	test   %rax,%rax
  800420b4e8:	74 35                	je     800420b51f <trap+0xbc>
  800420b4ea:	48 b9 14 85 21 04 80 	movabs $0x8004218514,%rcx
  800420b4f1:	00 00 00 
  800420b4f4:	48 ba 2d 85 21 04 80 	movabs $0x800421852d,%rdx
  800420b4fb:	00 00 00 
  800420b4fe:	be 43 01 00 00       	mov    $0x143,%esi
  800420b503:	48 bf 08 85 21 04 80 	movabs $0x8004218508,%rdi
  800420b50a:	00 00 00 
  800420b50d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b512:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420b519:	00 00 00 
  800420b51c:	41 ff d0             	callq  *%r8
//<<<<<<< HEAD
//=======
	//cprintf("\nIncoming TRAP frame at %p\n", tf);

//>>>>>>> lab3
	if ((tf->tf_cs & 3) == 3) {
  800420b51f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420b523:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420b52a:	0f b7 c0             	movzwl %ax,%eax
  800420b52d:	83 e0 03             	and    $0x3,%eax
  800420b530:	83 f8 03             	cmp    $0x3,%eax
  800420b533:	0f 85 97 01 00 00    	jne    800420b6d0 <trap+0x26d>
		// Trapped from user mode.
		// Acquire the big kernel lock before doing any
		// serious kernel work.
		// LAB 4: Your code here.
		lock_kernel();
  800420b539:	48 b8 fd 8a 20 04 80 	movabs $0x8004208afd,%rax
  800420b540:	00 00 00 
  800420b543:	ff d0                	callq  *%rax
		assert(curenv);
  800420b545:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420b54c:	00 00 00 
  800420b54f:	ff d0                	callq  *%rax
  800420b551:	48 98                	cltq   
  800420b553:	48 c1 e0 03          	shl    $0x3,%rax
  800420b557:	48 89 c2             	mov    %rax,%rdx
  800420b55a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b55e:	48 29 c2             	sub    %rax,%rdx
  800420b561:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420b568:	00 00 00 
  800420b56b:	48 01 d0             	add    %rdx,%rax
  800420b56e:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b572:	48 85 c0             	test   %rax,%rax
  800420b575:	75 35                	jne    800420b5ac <trap+0x149>
  800420b577:	48 b9 42 85 21 04 80 	movabs $0x8004218542,%rcx
  800420b57e:	00 00 00 
  800420b581:	48 ba 2d 85 21 04 80 	movabs $0x800421852d,%rdx
  800420b588:	00 00 00 
  800420b58b:	be 50 01 00 00       	mov    $0x150,%esi
  800420b590:	48 bf 08 85 21 04 80 	movabs $0x8004218508,%rdi
  800420b597:	00 00 00 
  800420b59a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b59f:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420b5a6:	00 00 00 
  800420b5a9:	41 ff d0             	callq  *%r8

		// Garbage collect if current enviroment is a zombie
		if (curenv->env_status == ENV_DYING) {
  800420b5ac:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420b5b3:	00 00 00 
  800420b5b6:	ff d0                	callq  *%rax
  800420b5b8:	48 98                	cltq   
  800420b5ba:	48 c1 e0 03          	shl    $0x3,%rax
  800420b5be:	48 89 c2             	mov    %rax,%rdx
  800420b5c1:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b5c5:	48 29 c2             	sub    %rax,%rdx
  800420b5c8:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420b5cf:	00 00 00 
  800420b5d2:	48 01 d0             	add    %rdx,%rax
  800420b5d5:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b5d9:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420b5df:	83 f8 01             	cmp    $0x1,%eax
  800420b5e2:	75 79                	jne    800420b65d <trap+0x1fa>
			env_free(curenv);
  800420b5e4:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420b5eb:	00 00 00 
  800420b5ee:	ff d0                	callq  *%rax
  800420b5f0:	48 98                	cltq   
  800420b5f2:	48 c1 e0 03          	shl    $0x3,%rax
  800420b5f6:	48 89 c2             	mov    %rax,%rdx
  800420b5f9:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b5fd:	48 29 c2             	sub    %rax,%rdx
  800420b600:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420b607:	00 00 00 
  800420b60a:	48 01 d0             	add    %rdx,%rax
  800420b60d:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b611:	48 89 c7             	mov    %rax,%rdi
  800420b614:	48 b8 a9 7e 20 04 80 	movabs $0x8004207ea9,%rax
  800420b61b:	00 00 00 
  800420b61e:	ff d0                	callq  *%rax
			curenv = NULL;
  800420b620:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420b627:	00 00 00 
  800420b62a:	ff d0                	callq  *%rax
  800420b62c:	48 98                	cltq   
  800420b62e:	48 c1 e0 03          	shl    $0x3,%rax
  800420b632:	48 89 c2             	mov    %rax,%rdx
  800420b635:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b639:	48 29 c2             	sub    %rax,%rdx
  800420b63c:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420b643:	00 00 00 
  800420b646:	48 01 d0             	add    %rdx,%rax
  800420b649:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  800420b650:	00 
			sched_yield();
  800420b651:	48 b8 db bc 20 04 80 	movabs $0x800420bcdb,%rax
  800420b658:	00 00 00 
  800420b65b:	ff d0                	callq  *%rax
		}

		// Copy trap frame (which is currently on the stack)
		// into 'curenv->env_tf', so that running the environment
		// will restart at the trap point.
		curenv->env_tf = *tf;
  800420b65d:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420b664:	00 00 00 
  800420b667:	ff d0                	callq  *%rax
  800420b669:	48 98                	cltq   
  800420b66b:	48 c1 e0 03          	shl    $0x3,%rax
  800420b66f:	48 89 c2             	mov    %rax,%rdx
  800420b672:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b676:	48 29 c2             	sub    %rax,%rdx
  800420b679:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420b680:	00 00 00 
  800420b683:	48 01 d0             	add    %rdx,%rax
  800420b686:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420b68a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420b68e:	48 89 c6             	mov    %rax,%rsi
  800420b691:	b8 18 00 00 00       	mov    $0x18,%eax
  800420b696:	48 89 d7             	mov    %rdx,%rdi
  800420b699:	48 89 c1             	mov    %rax,%rcx
  800420b69c:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		// The trapframe on the stack should be ignored from here on.
		tf = &curenv->env_tf;
  800420b69f:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420b6a6:	00 00 00 
  800420b6a9:	ff d0                	callq  *%rax
  800420b6ab:	48 98                	cltq   
  800420b6ad:	48 c1 e0 03          	shl    $0x3,%rax
  800420b6b1:	48 89 c2             	mov    %rax,%rdx
  800420b6b4:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b6b8:	48 29 c2             	sub    %rax,%rdx
  800420b6bb:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420b6c2:	00 00 00 
  800420b6c5:	48 01 d0             	add    %rdx,%rax
  800420b6c8:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b6cc:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	}

	// Record that tf is the last real trapframe so
	// print_trapframe can print some additional information.
	last_tf = tf;
  800420b6d0:	48 b8 08 c3 63 04 80 	movabs $0x800463c308,%rax
  800420b6d7:	00 00 00 
  800420b6da:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420b6de:	48 89 10             	mov    %rdx,(%rax)

	// Dispatch based on what type of trap occurred
	trap_dispatch(tf);
  800420b6e1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420b6e5:	48 89 c7             	mov    %rax,%rdi
  800420b6e8:	48 b8 55 b2 20 04 80 	movabs $0x800420b255,%rax
  800420b6ef:	00 00 00 
  800420b6f2:	ff d0                	callq  *%rax

	// If we made it to this point, then no other environment was
	// scheduled, so we should return to the current environment
	// if doing so makes sense.
	if (curenv && curenv->env_status == ENV_RUNNING)
  800420b6f4:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420b6fb:	00 00 00 
  800420b6fe:	ff d0                	callq  *%rax
  800420b700:	48 98                	cltq   
  800420b702:	48 c1 e0 03          	shl    $0x3,%rax
  800420b706:	48 89 c2             	mov    %rax,%rdx
  800420b709:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b70d:	48 29 c2             	sub    %rax,%rdx
  800420b710:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420b717:	00 00 00 
  800420b71a:	48 01 d0             	add    %rdx,%rax
  800420b71d:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b721:	48 85 c0             	test   %rax,%rax
  800420b724:	74 74                	je     800420b79a <trap+0x337>
  800420b726:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420b72d:	00 00 00 
  800420b730:	ff d0                	callq  *%rax
  800420b732:	48 98                	cltq   
  800420b734:	48 c1 e0 03          	shl    $0x3,%rax
  800420b738:	48 89 c2             	mov    %rax,%rdx
  800420b73b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b73f:	48 29 c2             	sub    %rax,%rdx
  800420b742:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420b749:	00 00 00 
  800420b74c:	48 01 d0             	add    %rdx,%rax
  800420b74f:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b753:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420b759:	83 f8 03             	cmp    $0x3,%eax
  800420b75c:	75 3c                	jne    800420b79a <trap+0x337>
		env_run(curenv);
  800420b75e:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420b765:	00 00 00 
  800420b768:	ff d0                	callq  *%rax
  800420b76a:	48 98                	cltq   
  800420b76c:	48 c1 e0 03          	shl    $0x3,%rax
  800420b770:	48 89 c2             	mov    %rax,%rdx
  800420b773:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b777:	48 29 c2             	sub    %rax,%rdx
  800420b77a:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420b781:	00 00 00 
  800420b784:	48 01 d0             	add    %rdx,%rax
  800420b787:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b78b:	48 89 c7             	mov    %rax,%rdi
  800420b78e:	48 b8 b3 84 20 04 80 	movabs $0x80042084b3,%rax
  800420b795:	00 00 00 
  800420b798:	ff d0                	callq  *%rax
	else
		sched_yield();
  800420b79a:	48 b8 db bc 20 04 80 	movabs $0x800420bcdb,%rax
  800420b7a1:	00 00 00 
  800420b7a4:	ff d0                	callq  *%rax

000000800420b7a6 <page_fault_handler>:
}


void
page_fault_handler(struct Trapframe *tf)
{
  800420b7a6:	55                   	push   %rbp
  800420b7a7:	48 89 e5             	mov    %rsp,%rbp
  800420b7aa:	53                   	push   %rbx
  800420b7ab:	48 83 ec 48          	sub    $0x48,%rsp
  800420b7af:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)

static __inline uint64_t
rcr2(void)
{
	uint64_t val;
	__asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420b7b3:	0f 20 d3             	mov    %cr2,%rbx
  800420b7b6:	48 89 5d c8          	mov    %rbx,-0x38(%rbp)
	return val;
  800420b7ba:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
	uint64_t fault_va;
	uint16_t mode;
	// Read processor's CR2 register to find the faulting address
	fault_va = rcr2();
  800420b7be:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	// Handle kernel-mode page faults.

	// LAB 3: Your code here.
	mode = (tf->tf_cs & 0x3);
  800420b7c2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420b7c6:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420b7cd:	83 e0 03             	and    $0x3,%eax
  800420b7d0:	66 89 45 de          	mov    %ax,-0x22(%rbp)
	if(mode == 0){//kernel mode
  800420b7d4:	66 83 7d de 00       	cmpw   $0x0,-0x22(%rbp)
  800420b7d9:	75 3d                	jne    800420b818 <page_fault_handler+0x72>
		print_trapframe(tf);
  800420b7db:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420b7df:	48 89 c7             	mov    %rax,%rdi
  800420b7e2:	48 b8 f8 ac 20 04 80 	movabs $0x800420acf8,%rax
  800420b7e9:	00 00 00 
  800420b7ec:	ff d0                	callq  *%rax
		panic("Kernel mode page fault!!");
  800420b7ee:	48 ba 49 85 21 04 80 	movabs $0x8004218549,%rdx
  800420b7f5:	00 00 00 
  800420b7f8:	be 80 01 00 00       	mov    $0x180,%esi
  800420b7fd:	48 bf 08 85 21 04 80 	movabs $0x8004218508,%rdi
  800420b804:	00 00 00 
  800420b807:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b80c:	48 b9 f2 04 20 04 80 	movabs $0x80042004f2,%rcx
  800420b813:	00 00 00 
  800420b816:	ff d1                	callq  *%rcx
	//   (the 'tf' variable points at 'curenv->env_tf').

	// LAB 4: Your code here.
	uint64_t ex_top_of_stack,size_of_word;
	struct UTrapframe *user_trap_frame;
	if(!(curenv->env_pgfault_upcall))
  800420b818:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420b81f:	00 00 00 
  800420b822:	ff d0                	callq  *%rax
  800420b824:	48 98                	cltq   
  800420b826:	48 c1 e0 03          	shl    $0x3,%rax
  800420b82a:	48 89 c2             	mov    %rax,%rdx
  800420b82d:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b831:	48 29 c2             	sub    %rax,%rdx
  800420b834:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420b83b:	00 00 00 
  800420b83e:	48 01 d0             	add    %rdx,%rax
  800420b841:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b845:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420b84c:	48 85 c0             	test   %rax,%rax
  800420b84f:	0f 85 b9 00 00 00    	jne    800420b90e <page_fault_handler+0x168>
	{
		 cprintf("[%08x] user fault va %08x ip %08x\n",
                 curenv->env_id, fault_va, tf->tf_rip);
  800420b855:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
	// LAB 4: Your code here.
	uint64_t ex_top_of_stack,size_of_word;
	struct UTrapframe *user_trap_frame;
	if(!(curenv->env_pgfault_upcall))
	{
		 cprintf("[%08x] user fault va %08x ip %08x\n",
  800420b859:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
                 curenv->env_id, fault_va, tf->tf_rip);
  800420b860:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420b867:	00 00 00 
  800420b86a:	ff d0                	callq  *%rax
  800420b86c:	48 98                	cltq   
  800420b86e:	48 c1 e0 03          	shl    $0x3,%rax
  800420b872:	48 89 c2             	mov    %rax,%rdx
  800420b875:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b879:	48 29 c2             	sub    %rax,%rdx
  800420b87c:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420b883:	00 00 00 
  800420b886:	48 01 d0             	add    %rdx,%rax
  800420b889:	48 8b 40 08          	mov    0x8(%rax),%rax
	// LAB 4: Your code here.
	uint64_t ex_top_of_stack,size_of_word;
	struct UTrapframe *user_trap_frame;
	if(!(curenv->env_pgfault_upcall))
	{
		 cprintf("[%08x] user fault va %08x ip %08x\n",
  800420b88d:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420b893:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420b897:	48 89 d9             	mov    %rbx,%rcx
  800420b89a:	89 c6                	mov    %eax,%esi
  800420b89c:	48 bf 68 85 21 04 80 	movabs $0x8004218568,%rdi
  800420b8a3:	00 00 00 
  800420b8a6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420b8ab:	49 b8 f2 89 20 04 80 	movabs $0x80042089f2,%r8
  800420b8b2:	00 00 00 
  800420b8b5:	41 ff d0             	callq  *%r8
                 curenv->env_id, fault_va, tf->tf_rip);
	         print_trapframe(tf);
  800420b8b8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420b8bc:	48 89 c7             	mov    %rax,%rdi
  800420b8bf:	48 b8 f8 ac 20 04 80 	movabs $0x800420acf8,%rax
  800420b8c6:	00 00 00 
  800420b8c9:	ff d0                	callq  *%rax
        	 env_destroy(curenv);
  800420b8cb:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420b8d2:	00 00 00 
  800420b8d5:	ff d0                	callq  *%rax
  800420b8d7:	48 98                	cltq   
  800420b8d9:	48 c1 e0 03          	shl    $0x3,%rax
  800420b8dd:	48 89 c2             	mov    %rax,%rdx
  800420b8e0:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b8e4:	48 29 c2             	sub    %rax,%rdx
  800420b8e7:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420b8ee:	00 00 00 
  800420b8f1:	48 01 d0             	add    %rdx,%rax
  800420b8f4:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b8f8:	48 89 c7             	mov    %rax,%rdi
  800420b8fb:	48 b8 f4 82 20 04 80 	movabs $0x80042082f4,%rax
  800420b902:	00 00 00 
  800420b905:	ff d0                	callq  *%rax
		user_trap_frame->utf_rsp=tf->tf_rsp;
		tf->tf_rsp=ex_top_of_stack;
        	tf->tf_rip = (uint64_t)curenv->env_pgfault_upcall;
		env_run(curenv);
	}
}
  800420b907:	48 83 c4 48          	add    $0x48,%rsp
  800420b90b:	5b                   	pop    %rbx
  800420b90c:	5d                   	pop    %rbp
  800420b90d:	c3                   	retq   
	         print_trapframe(tf);
        	 env_destroy(curenv);
	}
	else
	{
		if(tf->tf_rsp <=UXSTACKTOP-1 && tf->tf_rsp >= (UXSTACKTOP-PGSIZE))
  800420b90e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420b912:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420b919:	b8 ff ff 7f ef       	mov    $0xef7fffff,%eax
  800420b91e:	48 39 c2             	cmp    %rax,%rdx
  800420b921:	77 32                	ja     800420b955 <page_fault_handler+0x1af>
  800420b923:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420b927:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420b92e:	b8 ff ef 7f ef       	mov    $0xef7fefff,%eax
  800420b933:	48 39 c2             	cmp    %rax,%rdx
  800420b936:	76 1d                	jbe    800420b955 <page_fault_handler+0x1af>
		{
			ex_top_of_stack= tf->tf_rsp - sizeof(uint64_t);
  800420b938:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420b93c:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420b943:	48 83 e8 08          	sub    $0x8,%rax
  800420b947:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	                ex_top_of_stack = ex_top_of_stack-(sizeof(struct UTrapframe));
  800420b94b:	48 81 6d e8 a0 00 00 	subq   $0xa0,-0x18(%rbp)
  800420b952:	00 
  800420b953:	eb 16                	jmp    800420b96b <page_fault_handler+0x1c5>
		}
		else
		{
			 ex_top_of_stack = (uint64_t)UXSTACKTOP;
  800420b955:	c7 45 e8 00 00 80 ef 	movl   $0xef800000,-0x18(%rbp)
  800420b95c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
			 ex_top_of_stack = ex_top_of_stack-(sizeof(struct UTrapframe));
  800420b963:	48 81 6d e8 a0 00 00 	subq   $0xa0,-0x18(%rbp)
  800420b96a:	00 
		}

		user_mem_assert(curenv, (void *)ex_top_of_stack, sizeof(struct UTrapframe), PTE_U|PTE_W|PTE_P);
  800420b96b:	48 8b 5d e8          	mov    -0x18(%rbp),%rbx
  800420b96f:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420b976:	00 00 00 
  800420b979:	ff d0                	callq  *%rax
  800420b97b:	48 98                	cltq   
  800420b97d:	48 c1 e0 03          	shl    $0x3,%rax
  800420b981:	48 89 c2             	mov    %rax,%rdx
  800420b984:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b988:	48 29 c2             	sub    %rax,%rdx
  800420b98b:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420b992:	00 00 00 
  800420b995:	48 01 d0             	add    %rdx,%rax
  800420b998:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420b99c:	b9 07 00 00 00       	mov    $0x7,%ecx
  800420b9a1:	ba a0 00 00 00       	mov    $0xa0,%edx
  800420b9a6:	48 89 de             	mov    %rbx,%rsi
  800420b9a9:	48 89 c7             	mov    %rax,%rdi
  800420b9ac:	48 b8 08 3b 20 04 80 	movabs $0x8004203b08,%rax
  800420b9b3:	00 00 00 
  800420b9b6:	ff d0                	callq  *%rax
		user_trap_frame=(struct UTrapframe*)ex_top_of_stack;
  800420b9b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420b9bc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		user_trap_frame->utf_fault_va=fault_va;
  800420b9c0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420b9c4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420b9c8:	48 89 10             	mov    %rdx,(%rax)
        	user_trap_frame->utf_err=tf->tf_err;
  800420b9cb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420b9cf:	48 8b 90 90 00 00 00 	mov    0x90(%rax),%rdx
  800420b9d6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420b9da:	48 89 50 08          	mov    %rdx,0x8(%rax)
		user_trap_frame->utf_regs=tf->tf_regs;
  800420b9de:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420b9e2:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420b9e6:	48 8b 0a             	mov    (%rdx),%rcx
  800420b9e9:	48 89 48 10          	mov    %rcx,0x10(%rax)
  800420b9ed:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420b9f1:	48 89 48 18          	mov    %rcx,0x18(%rax)
  800420b9f5:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  800420b9f9:	48 89 48 20          	mov    %rcx,0x20(%rax)
  800420b9fd:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  800420ba01:	48 89 48 28          	mov    %rcx,0x28(%rax)
  800420ba05:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  800420ba09:	48 89 48 30          	mov    %rcx,0x30(%rax)
  800420ba0d:	48 8b 4a 28          	mov    0x28(%rdx),%rcx
  800420ba11:	48 89 48 38          	mov    %rcx,0x38(%rax)
  800420ba15:	48 8b 4a 30          	mov    0x30(%rdx),%rcx
  800420ba19:	48 89 48 40          	mov    %rcx,0x40(%rax)
  800420ba1d:	48 8b 4a 38          	mov    0x38(%rdx),%rcx
  800420ba21:	48 89 48 48          	mov    %rcx,0x48(%rax)
  800420ba25:	48 8b 4a 40          	mov    0x40(%rdx),%rcx
  800420ba29:	48 89 48 50          	mov    %rcx,0x50(%rax)
  800420ba2d:	48 8b 4a 48          	mov    0x48(%rdx),%rcx
  800420ba31:	48 89 48 58          	mov    %rcx,0x58(%rax)
  800420ba35:	48 8b 4a 50          	mov    0x50(%rdx),%rcx
  800420ba39:	48 89 48 60          	mov    %rcx,0x60(%rax)
  800420ba3d:	48 8b 4a 58          	mov    0x58(%rdx),%rcx
  800420ba41:	48 89 48 68          	mov    %rcx,0x68(%rax)
  800420ba45:	48 8b 4a 60          	mov    0x60(%rdx),%rcx
  800420ba49:	48 89 48 70          	mov    %rcx,0x70(%rax)
  800420ba4d:	48 8b 4a 68          	mov    0x68(%rdx),%rcx
  800420ba51:	48 89 48 78          	mov    %rcx,0x78(%rax)
  800420ba55:	48 8b 52 70          	mov    0x70(%rdx),%rdx
  800420ba59:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
		user_trap_frame->utf_rip=tf->tf_rip;
  800420ba60:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420ba64:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  800420ba6b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ba6f:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
		user_trap_frame->utf_eflags=tf->tf_eflags;
  800420ba76:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420ba7a:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
  800420ba81:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ba85:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
		user_trap_frame->utf_rsp=tf->tf_rsp;
  800420ba8c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420ba90:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420ba97:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ba9b:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		tf->tf_rsp=ex_top_of_stack;
  800420baa2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420baa6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420baaa:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
        	tf->tf_rip = (uint64_t)curenv->env_pgfault_upcall;
  800420bab1:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420bab8:	00 00 00 
  800420babb:	ff d0                	callq  *%rax
  800420babd:	48 98                	cltq   
  800420babf:	48 c1 e0 03          	shl    $0x3,%rax
  800420bac3:	48 89 c2             	mov    %rax,%rdx
  800420bac6:	48 c1 e2 04          	shl    $0x4,%rdx
  800420baca:	48 29 c2             	sub    %rax,%rdx
  800420bacd:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420bad4:	00 00 00 
  800420bad7:	48 01 d0             	add    %rdx,%rax
  800420bada:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420bade:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420bae5:	48 89 c2             	mov    %rax,%rdx
  800420bae8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420baec:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		env_run(curenv);
  800420baf3:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420bafa:	00 00 00 
  800420bafd:	ff d0                	callq  *%rax
  800420baff:	48 98                	cltq   
  800420bb01:	48 c1 e0 03          	shl    $0x3,%rax
  800420bb05:	48 89 c2             	mov    %rax,%rdx
  800420bb08:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bb0c:	48 29 c2             	sub    %rax,%rdx
  800420bb0f:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420bb16:	00 00 00 
  800420bb19:	48 01 d0             	add    %rdx,%rax
  800420bb1c:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420bb20:	48 89 c7             	mov    %rax,%rdi
  800420bb23:	48 b8 b3 84 20 04 80 	movabs $0x80042084b3,%rax
  800420bb2a:	00 00 00 
  800420bb2d:	ff d0                	callq  *%rax
	...

000000800420bb30 <TRAPH_divide>:
 * Lab 3: Your code here for generating entry points for the different traps.
   Find the PUSHA,POPA macros in kern/macro.h. Since amd64 doesn't support
   pusha,popa so you will find these macros handy.
 */

TRAPHANDLER_NOEC(TRAPH_divide, T_DIVIDE)
  800420bb30:	6a 00                	pushq  $0x0
  800420bb32:	6a 00                	pushq  $0x0
  800420bb34:	e9 85 00 00 00       	jmpq   800420bbbe <_alltraps>
  800420bb39:	90                   	nop

000000800420bb3a <TRAPH_debug>:
TRAPHANDLER_NOEC(TRAPH_debug, T_DEBUG)
  800420bb3a:	6a 00                	pushq  $0x0
  800420bb3c:	6a 01                	pushq  $0x1
  800420bb3e:	eb 7e                	jmp    800420bbbe <_alltraps>

000000800420bb40 <TRAPH_nmi>:
TRAPHANDLER_NOEC(TRAPH_nmi, T_NMI)
  800420bb40:	6a 00                	pushq  $0x0
  800420bb42:	6a 02                	pushq  $0x2
  800420bb44:	eb 78                	jmp    800420bbbe <_alltraps>

000000800420bb46 <TRAPH_breakpoint>:
TRAPHANDLER_NOEC(TRAPH_breakpoint, T_BRKPT)
  800420bb46:	6a 00                	pushq  $0x0
  800420bb48:	6a 03                	pushq  $0x3
  800420bb4a:	eb 72                	jmp    800420bbbe <_alltraps>

000000800420bb4c <TRAPH_overflow>:
TRAPHANDLER_NOEC(TRAPH_overflow, T_OFLOW)
  800420bb4c:	6a 00                	pushq  $0x0
  800420bb4e:	6a 04                	pushq  $0x4
  800420bb50:	eb 6c                	jmp    800420bbbe <_alltraps>

000000800420bb52 <TRAPH_boundcheck>:
TRAPHANDLER_NOEC(TRAPH_boundcheck, T_BOUND)
  800420bb52:	6a 00                	pushq  $0x0
  800420bb54:	6a 05                	pushq  $0x5
  800420bb56:	eb 66                	jmp    800420bbbe <_alltraps>

000000800420bb58 <TRAPH_illegalop>:
TRAPHANDLER_NOEC(TRAPH_illegalop, T_ILLOP)
  800420bb58:	6a 00                	pushq  $0x0
  800420bb5a:	6a 06                	pushq  $0x6
  800420bb5c:	eb 60                	jmp    800420bbbe <_alltraps>

000000800420bb5e <TRAPH_devicena>:
TRAPHANDLER_NOEC(TRAPH_devicena, T_DEVICE)
  800420bb5e:	6a 00                	pushq  $0x0
  800420bb60:	6a 07                	pushq  $0x7
  800420bb62:	eb 5a                	jmp    800420bbbe <_alltraps>

000000800420bb64 <TRAPH_doublefault>:
TRAPHANDLER(TRAPH_doublefault, T_DBLFLT)
  800420bb64:	6a 08                	pushq  $0x8
  800420bb66:	eb 56                	jmp    800420bbbe <_alltraps>

000000800420bb68 <TRAPH_invalidtss>:
TRAPHANDLER(TRAPH_invalidtss, T_TSS)
  800420bb68:	6a 0a                	pushq  $0xa
  800420bb6a:	eb 52                	jmp    800420bbbe <_alltraps>

000000800420bb6c <TRAPH_segmentnotpresent>:
TRAPHANDLER(TRAPH_segmentnotpresent, T_SEGNP)
  800420bb6c:	6a 0b                	pushq  $0xb
  800420bb6e:	eb 4e                	jmp    800420bbbe <_alltraps>

000000800420bb70 <TRAPH_stackexception>:
TRAPHANDLER(TRAPH_stackexception, T_STACK)
  800420bb70:	6a 0c                	pushq  $0xc
  800420bb72:	eb 4a                	jmp    800420bbbe <_alltraps>

000000800420bb74 <TRAPH_generalprotectionfault>:
TRAPHANDLER(TRAPH_generalprotectionfault, T_GPFLT)
  800420bb74:	6a 0d                	pushq  $0xd
  800420bb76:	eb 46                	jmp    800420bbbe <_alltraps>

000000800420bb78 <TRAPH_pagefault>:
TRAPHANDLER(TRAPH_pagefault, T_PGFLT)
  800420bb78:	6a 0e                	pushq  $0xe
  800420bb7a:	eb 42                	jmp    800420bbbe <_alltraps>

000000800420bb7c <TRAPH_syscall>:
TRAPHANDLER_NOEC(TRAPH_syscall, T_SYSCALL)
  800420bb7c:	6a 00                	pushq  $0x0
  800420bb7e:	6a 30                	pushq  $0x30
  800420bb80:	eb 3c                	jmp    800420bbbe <_alltraps>

000000800420bb82 <TRAPH_floatingpointerror>:
TRAPHANDLER_NOEC(TRAPH_floatingpointerror, T_FPERR)
  800420bb82:	6a 00                	pushq  $0x0
  800420bb84:	6a 10                	pushq  $0x10
  800420bb86:	eb 36                	jmp    800420bbbe <_alltraps>

000000800420bb88 <TRAPH_alignmentcheck>:
TRAPHANDLER_NOEC(TRAPH_alignmentcheck, T_ALIGN)
  800420bb88:	6a 00                	pushq  $0x0
  800420bb8a:	6a 11                	pushq  $0x11
  800420bb8c:	eb 30                	jmp    800420bbbe <_alltraps>

000000800420bb8e <TRAPH_machinecheck>:
TRAPHANDLER_NOEC(TRAPH_machinecheck, T_MCHK)
  800420bb8e:	6a 00                	pushq  $0x0
  800420bb90:	6a 12                	pushq  $0x12
  800420bb92:	eb 2a                	jmp    800420bbbe <_alltraps>

000000800420bb94 <TRAPH_simderror>:
TRAPHANDLER_NOEC(TRAPH_simderror, T_SIMDERR)
  800420bb94:	6a 00                	pushq  $0x0
  800420bb96:	6a 13                	pushq  $0x13
  800420bb98:	eb 24                	jmp    800420bbbe <_alltraps>

000000800420bb9a <TRAPH_timer>:
TRAPHANDLER_NOEC(TRAPH_timer, IRQ_OFFSET+IRQ_TIMER)
  800420bb9a:	6a 00                	pushq  $0x0
  800420bb9c:	6a 20                	pushq  $0x20
  800420bb9e:	eb 1e                	jmp    800420bbbe <_alltraps>

000000800420bba0 <TRAPH_keyboard>:
TRAPHANDLER_NOEC(TRAPH_keyboard, IRQ_OFFSET+IRQ_KBD)
  800420bba0:	6a 00                	pushq  $0x0
  800420bba2:	6a 21                	pushq  $0x21
  800420bba4:	eb 18                	jmp    800420bbbe <_alltraps>

000000800420bba6 <TRAPH_serial>:
TRAPHANDLER_NOEC(TRAPH_serial, IRQ_OFFSET+IRQ_SERIAL)
  800420bba6:	6a 00                	pushq  $0x0
  800420bba8:	6a 24                	pushq  $0x24
  800420bbaa:	eb 12                	jmp    800420bbbe <_alltraps>

000000800420bbac <TRAPH_spurious>:
TRAPHANDLER_NOEC(TRAPH_spurious,IRQ_OFFSET+IRQ_SPURIOUS)
  800420bbac:	6a 00                	pushq  $0x0
  800420bbae:	6a 27                	pushq  $0x27
  800420bbb0:	eb 0c                	jmp    800420bbbe <_alltraps>

000000800420bbb2 <TRAPH_ide>:
TRAPHANDLER_NOEC(TRAPH_ide,IRQ_OFFSET+IRQ_IDE)
  800420bbb2:	6a 00                	pushq  $0x0
  800420bbb4:	6a 2e                	pushq  $0x2e
  800420bbb6:	eb 06                	jmp    800420bbbe <_alltraps>

000000800420bbb8 <TRAPH_err>:
TRAPHANDLER_NOEC(TRAPH_err,IRQ_OFFSET+IRQ_ERROR)
  800420bbb8:	6a 00                	pushq  $0x0
  800420bbba:	6a 33                	pushq  $0x33
  800420bbbc:	eb 00                	jmp    800420bbbe <_alltraps>

000000800420bbbe <_alltraps>:
 *       for how to pass a pointer to the trapframe.
 */

_alltraps:
     
	subq $8,%rsp
  800420bbbe:	48 83 ec 08          	sub    $0x8,%rsp
	movw %ds, (%rsp)
  800420bbc2:	8c 1c 24             	mov    %ds,(%rsp)
	subq $8,%rsp
  800420bbc5:	48 83 ec 08          	sub    $0x8,%rsp
	movw %es, (%rsp)
  800420bbc9:	8c 04 24             	mov    %es,(%rsp)
	PUSHA
  800420bbcc:	48 83 ec 78          	sub    $0x78,%rsp
  800420bbd0:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  800420bbd5:	48 89 5c 24 68       	mov    %rbx,0x68(%rsp)
  800420bbda:	48 89 4c 24 60       	mov    %rcx,0x60(%rsp)
  800420bbdf:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)
  800420bbe4:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
  800420bbe9:	48 89 7c 24 48       	mov    %rdi,0x48(%rsp)
  800420bbee:	48 89 74 24 40       	mov    %rsi,0x40(%rsp)
  800420bbf3:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
  800420bbf8:	4c 89 4c 24 30       	mov    %r9,0x30(%rsp)
  800420bbfd:	4c 89 54 24 28       	mov    %r10,0x28(%rsp)
  800420bc02:	4c 89 5c 24 20       	mov    %r11,0x20(%rsp)
  800420bc07:	4c 89 64 24 18       	mov    %r12,0x18(%rsp)
  800420bc0c:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
  800420bc11:	4c 89 74 24 08       	mov    %r14,0x8(%rsp)
  800420bc16:	4c 89 3c 24          	mov    %r15,(%rsp)
	movq $(GD_KD), %rax
  800420bc1a:	48 c7 c0 10 00 00 00 	mov    $0x10,%rax
	movw %ax, %ds
  800420bc21:	8e d8                	mov    %eax,%ds
	movw %ax, %es
  800420bc23:	8e c0                	mov    %eax,%es
	movq %rsp, %rdi
  800420bc25:	48 89 e7             	mov    %rsp,%rdi
	call trap
  800420bc28:	e8 36 f8 ff ff       	callq  800420b463 <trap>
	POPA_
  800420bc2d:	4c 8b 3c 24          	mov    (%rsp),%r15
  800420bc31:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  800420bc36:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  800420bc3b:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  800420bc40:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  800420bc45:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  800420bc4a:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  800420bc4f:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  800420bc54:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  800420bc59:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  800420bc5e:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  800420bc63:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  800420bc68:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  800420bc6d:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  800420bc72:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  800420bc77:	48 83 c4 78          	add    $0x78,%rsp
	movw (%rsp), %es
  800420bc7b:	8e 04 24             	mov    (%rsp),%es
	add $8, %rsp
  800420bc7e:	48 83 c4 08          	add    $0x8,%rsp
	movw (%rsp), %ds
  800420bc82:	8e 1c 24             	mov    (%rsp),%ds
	add $8, %rsp
  800420bc85:	48 83 c4 08          	add    $0x8,%rsp
	iret
  800420bc89:	cf                   	iret   
	...

000000800420bc8c <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  800420bc8c:	55                   	push   %rbp
  800420bc8d:	48 89 e5             	mov    %rsp,%rbp
  800420bc90:	53                   	push   %rbx
  800420bc91:	48 83 ec 20          	sub    $0x20,%rsp
  800420bc95:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
  800420bc99:	89 75 dc             	mov    %esi,-0x24(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
	"+m" (*addr), "=a" (result):
  800420bc9c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800420bca0:	8b 45 dc             	mov    -0x24(%rbp),%eax
	"+m" (*addr), "=a" (result):
  800420bca3:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800420bca7:	89 c3                	mov    %eax,%ebx
  800420bca9:	89 d8                	mov    %ebx,%eax
  800420bcab:	f0 87 02             	lock xchg %eax,(%rdx)
  800420bcae:	89 c3                	mov    %eax,%ebx
  800420bcb0:	89 5d f4             	mov    %ebx,-0xc(%rbp)
	"+m" (*addr), "=a" (result):
	"1"(newval):
	"cc");
	return result;
  800420bcb3:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  800420bcb6:	48 83 c4 20          	add    $0x20,%rsp
  800420bcba:	5b                   	pop    %rbx
  800420bcbb:	5d                   	pop    %rbp
  800420bcbc:	c3                   	retq   

000000800420bcbd <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  800420bcbd:	55                   	push   %rbp
  800420bcbe:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  800420bcc1:	48 bf 80 a7 22 04 80 	movabs $0x800422a780,%rdi
  800420bcc8:	00 00 00 
  800420bccb:	48 b8 39 5a 21 04 80 	movabs $0x8004215a39,%rax
  800420bcd2:	00 00 00 
  800420bcd5:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  800420bcd7:	f3 90                	pause  
}
  800420bcd9:	5d                   	pop    %rbp
  800420bcda:	c3                   	retq   

000000800420bcdb <sched_yield>:
void sched_halt(void);

// Choose a user environment to run and run it.
void
sched_yield(void)
{
  800420bcdb:	55                   	push   %rbp
  800420bcdc:	48 89 e5             	mov    %rsp,%rbp
  800420bcdf:	48 83 ec 10          	sub    $0x10,%rsp
	// no runnable environments, simply drop through to the code
	// below to halt the cpu.

	// LAB 4: Your code here.

	int i,j,flag=0,next;
  800420bce3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	if(curenv == NULL)
  800420bcea:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420bcf1:	00 00 00 
  800420bcf4:	ff d0                	callq  *%rax
  800420bcf6:	48 98                	cltq   
  800420bcf8:	48 c1 e0 03          	shl    $0x3,%rax
  800420bcfc:	48 89 c2             	mov    %rax,%rdx
  800420bcff:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bd03:	48 29 c2             	sub    %rax,%rdx
  800420bd06:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420bd0d:	00 00 00 
  800420bd10:	48 01 d0             	add    %rdx,%rax
  800420bd13:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420bd17:	48 85 c0             	test   %rax,%rax
  800420bd1a:	75 09                	jne    800420bd25 <sched_yield+0x4a>
	{
		i=0;
  800420bd1c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420bd23:	eb 3b                	jmp    800420bd60 <sched_yield+0x85>
		
	}
	else
	{
		i=ENVX(curenv->env_id);
  800420bd25:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420bd2c:	00 00 00 
  800420bd2f:	ff d0                	callq  *%rax
  800420bd31:	48 98                	cltq   
  800420bd33:	48 c1 e0 03          	shl    $0x3,%rax
  800420bd37:	48 89 c2             	mov    %rax,%rdx
  800420bd3a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bd3e:	48 29 c2             	sub    %rax,%rdx
  800420bd41:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420bd48:	00 00 00 
  800420bd4b:	48 01 d0             	add    %rdx,%rax
  800420bd4e:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420bd52:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420bd58:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420bd5d:	89 45 fc             	mov    %eax,-0x4(%rbp)

	}
	for(j=0;j<NENV;j++)
  800420bd60:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  800420bd67:	e9 85 00 00 00       	jmpq   800420bdf1 <sched_yield+0x116>
	{
		i=(i+1)%NENV;	
  800420bd6c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420bd6f:	8d 50 01             	lea    0x1(%rax),%edx
  800420bd72:	89 d0                	mov    %edx,%eax
  800420bd74:	c1 f8 1f             	sar    $0x1f,%eax
  800420bd77:	c1 e8 16             	shr    $0x16,%eax
  800420bd7a:	01 c2                	add    %eax,%edx
  800420bd7c:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
  800420bd82:	89 d1                	mov    %edx,%ecx
  800420bd84:	29 c1                	sub    %eax,%ecx
  800420bd86:	89 c8                	mov    %ecx,%eax
  800420bd88:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if(envs[i].env_status == ENV_RUNNABLE)
  800420bd8b:	48 b8 50 b2 63 04 80 	movabs $0x800463b250,%rax
  800420bd92:	00 00 00 
  800420bd95:	48 8b 08             	mov    (%rax),%rcx
  800420bd98:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420bd9b:	48 63 d0             	movslq %eax,%rdx
  800420bd9e:	48 89 d0             	mov    %rdx,%rax
  800420bda1:	48 c1 e0 03          	shl    $0x3,%rax
  800420bda5:	48 01 d0             	add    %rdx,%rax
  800420bda8:	48 c1 e0 05          	shl    $0x5,%rax
  800420bdac:	48 01 c8             	add    %rcx,%rax
  800420bdaf:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420bdb5:	83 f8 02             	cmp    $0x2,%eax
  800420bdb8:	75 33                	jne    800420bded <sched_yield+0x112>
		{
			env_run(&envs[i]);
  800420bdba:	48 b8 50 b2 63 04 80 	movabs $0x800463b250,%rax
  800420bdc1:	00 00 00 
  800420bdc4:	48 8b 08             	mov    (%rax),%rcx
  800420bdc7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420bdca:	48 63 d0             	movslq %eax,%rdx
  800420bdcd:	48 89 d0             	mov    %rdx,%rax
  800420bdd0:	48 c1 e0 03          	shl    $0x3,%rax
  800420bdd4:	48 01 d0             	add    %rdx,%rax
  800420bdd7:	48 c1 e0 05          	shl    $0x5,%rax
  800420bddb:	48 01 c8             	add    %rcx,%rax
  800420bdde:	48 89 c7             	mov    %rax,%rdi
  800420bde1:	48 b8 b3 84 20 04 80 	movabs $0x80042084b3,%rax
  800420bde8:	00 00 00 
  800420bdeb:	ff d0                	callq  *%rax
	else
	{
		i=ENVX(curenv->env_id);

	}
	for(j=0;j<NENV;j++)
  800420bded:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  800420bdf1:	81 7d f8 ff 03 00 00 	cmpl   $0x3ff,-0x8(%rbp)
  800420bdf8:	0f 8e 6e ff ff ff    	jle    800420bd6c <sched_yield+0x91>
		if(envs[i].env_status == ENV_RUNNABLE)
		{
			env_run(&envs[i]);
		}
	}
	if(curenv !=NULL && curenv->env_status == ENV_RUNNING)
  800420bdfe:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420be05:	00 00 00 
  800420be08:	ff d0                	callq  *%rax
  800420be0a:	48 98                	cltq   
  800420be0c:	48 c1 e0 03          	shl    $0x3,%rax
  800420be10:	48 89 c2             	mov    %rax,%rdx
  800420be13:	48 c1 e2 04          	shl    $0x4,%rdx
  800420be17:	48 29 c2             	sub    %rax,%rdx
  800420be1a:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420be21:	00 00 00 
  800420be24:	48 01 d0             	add    %rdx,%rax
  800420be27:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420be2b:	48 85 c0             	test   %rax,%rax
  800420be2e:	74 74                	je     800420bea4 <sched_yield+0x1c9>
  800420be30:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420be37:	00 00 00 
  800420be3a:	ff d0                	callq  *%rax
  800420be3c:	48 98                	cltq   
  800420be3e:	48 c1 e0 03          	shl    $0x3,%rax
  800420be42:	48 89 c2             	mov    %rax,%rdx
  800420be45:	48 c1 e2 04          	shl    $0x4,%rdx
  800420be49:	48 29 c2             	sub    %rax,%rdx
  800420be4c:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420be53:	00 00 00 
  800420be56:	48 01 d0             	add    %rdx,%rax
  800420be59:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420be5d:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420be63:	83 f8 03             	cmp    $0x3,%eax
  800420be66:	75 3c                	jne    800420bea4 <sched_yield+0x1c9>
		env_run(curenv); 
  800420be68:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420be6f:	00 00 00 
  800420be72:	ff d0                	callq  *%rax
  800420be74:	48 98                	cltq   
  800420be76:	48 c1 e0 03          	shl    $0x3,%rax
  800420be7a:	48 89 c2             	mov    %rax,%rdx
  800420be7d:	48 c1 e2 04          	shl    $0x4,%rdx
  800420be81:	48 29 c2             	sub    %rax,%rdx
  800420be84:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420be8b:	00 00 00 
  800420be8e:	48 01 d0             	add    %rdx,%rax
  800420be91:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420be95:	48 89 c7             	mov    %rax,%rdi
  800420be98:	48 b8 b3 84 20 04 80 	movabs $0x80042084b3,%rax
  800420be9f:	00 00 00 
  800420bea2:	ff d0                	callq  *%rax
	// sched_halt never returns
	sched_halt();
  800420bea4:	48 b8 b2 be 20 04 80 	movabs $0x800420beb2,%rax
  800420beab:	00 00 00 
  800420beae:	ff d0                	callq  *%rax

}
  800420beb0:	c9                   	leaveq 
  800420beb1:	c3                   	retq   

000000800420beb2 <sched_halt>:


void
sched_halt(void)
{
  800420beb2:	55                   	push   %rbp
  800420beb3:	48 89 e5             	mov    %rsp,%rbp
  800420beb6:	48 83 ec 20          	sub    $0x20,%rsp
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420beba:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420bec1:	e9 91 00 00 00       	jmpq   800420bf57 <sched_halt+0xa5>
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420bec6:	48 b8 50 b2 63 04 80 	movabs $0x800463b250,%rax
  800420becd:	00 00 00 
  800420bed0:	48 8b 08             	mov    (%rax),%rcx
  800420bed3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420bed6:	48 63 d0             	movslq %eax,%rdx
  800420bed9:	48 89 d0             	mov    %rdx,%rax
  800420bedc:	48 c1 e0 03          	shl    $0x3,%rax
  800420bee0:	48 01 d0             	add    %rdx,%rax
  800420bee3:	48 c1 e0 05          	shl    $0x5,%rax
  800420bee7:	48 01 c8             	add    %rcx,%rax
  800420beea:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420bef0:	83 f8 02             	cmp    $0x2,%eax
  800420bef3:	74 6f                	je     800420bf64 <sched_halt+0xb2>
		     envs[i].env_status == ENV_RUNNING ||
  800420bef5:	48 b8 50 b2 63 04 80 	movabs $0x800463b250,%rax
  800420befc:	00 00 00 
  800420beff:	48 8b 08             	mov    (%rax),%rcx
  800420bf02:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420bf05:	48 63 d0             	movslq %eax,%rdx
  800420bf08:	48 89 d0             	mov    %rdx,%rax
  800420bf0b:	48 c1 e0 03          	shl    $0x3,%rax
  800420bf0f:	48 01 d0             	add    %rdx,%rax
  800420bf12:	48 c1 e0 05          	shl    $0x5,%rax
  800420bf16:	48 01 c8             	add    %rcx,%rax
  800420bf19:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||
  800420bf1f:	83 f8 03             	cmp    $0x3,%eax
  800420bf22:	74 40                	je     800420bf64 <sched_halt+0xb2>
		     envs[i].env_status == ENV_RUNNING ||
		     envs[i].env_status == ENV_DYING))
  800420bf24:	48 b8 50 b2 63 04 80 	movabs $0x800463b250,%rax
  800420bf2b:	00 00 00 
  800420bf2e:	48 8b 08             	mov    (%rax),%rcx
  800420bf31:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420bf34:	48 63 d0             	movslq %eax,%rdx
  800420bf37:	48 89 d0             	mov    %rdx,%rax
  800420bf3a:	48 c1 e0 03          	shl    $0x3,%rax
  800420bf3e:	48 01 d0             	add    %rdx,%rax
  800420bf41:	48 c1 e0 05          	shl    $0x5,%rax
  800420bf45:	48 01 c8             	add    %rcx,%rax
  800420bf48:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
		if ((envs[i].env_status == ENV_RUNNABLE ||
		     envs[i].env_status == ENV_RUNNING ||
  800420bf4e:	83 f8 01             	cmp    $0x1,%eax
  800420bf51:	74 11                	je     800420bf64 <sched_halt+0xb2>
{
	int i;

	// For debugging and testing purposes, if there are no runnable
	// environments in the system, then drop into the kernel monitor.
	for (i = 0; i < NENV; i++) {
  800420bf53:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420bf57:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800420bf5e:	0f 8e 62 ff ff ff    	jle    800420bec6 <sched_halt+0x14>
		if ((envs[i].env_status == ENV_RUNNABLE ||
		     envs[i].env_status == ENV_RUNNING ||
		     envs[i].env_status == ENV_DYING))
			break;
	}
	if (i == NENV) {
  800420bf64:	81 7d fc 00 04 00 00 	cmpl   $0x400,-0x4(%rbp)
  800420bf6b:	75 2e                	jne    800420bf9b <sched_halt+0xe9>
		cprintf("No runnable environments in the system!\n");
  800420bf6d:	48 bf 80 87 21 04 80 	movabs $0x8004218780,%rdi
  800420bf74:	00 00 00 
  800420bf77:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bf7c:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420bf83:	00 00 00 
  800420bf86:	ff d2                	callq  *%rdx
		while (1)
			monitor(NULL);
  800420bf88:	bf 00 00 00 00       	mov    $0x0,%edi
  800420bf8d:	48 b8 c9 18 20 04 80 	movabs $0x80042018c9,%rax
  800420bf94:	00 00 00 
  800420bf97:	ff d0                	callq  *%rax
  800420bf99:	eb ed                	jmp    800420bf88 <sched_halt+0xd6>
	}

	// Mark that no environment is running on this CPU
	curenv = NULL;
  800420bf9b:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420bfa2:	00 00 00 
  800420bfa5:	ff d0                	callq  *%rax
  800420bfa7:	48 98                	cltq   
  800420bfa9:	48 c1 e0 03          	shl    $0x3,%rax
  800420bfad:	48 89 c2             	mov    %rax,%rdx
  800420bfb0:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bfb4:	48 29 c2             	sub    %rax,%rdx
  800420bfb7:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420bfbe:	00 00 00 
  800420bfc1:	48 01 d0             	add    %rdx,%rax
  800420bfc4:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  800420bfcb:	00 
	lcr3(PADDR(boot_pml4e));
  800420bfcc:	48 b8 d8 c7 63 04 80 	movabs $0x800463c7d8,%rax
  800420bfd3:	00 00 00 
  800420bfd6:	48 8b 00             	mov    (%rax),%rax
  800420bfd9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420bfdd:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420bfe4:	00 00 00 
  800420bfe7:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420bfeb:	77 32                	ja     800420c01f <sched_halt+0x16d>
  800420bfed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420bff1:	48 89 c1             	mov    %rax,%rcx
  800420bff4:	48 ba b0 87 21 04 80 	movabs $0x80042187b0,%rdx
  800420bffb:	00 00 00 
  800420bffe:	be 51 00 00 00       	mov    $0x51,%esi
  800420c003:	48 bf d4 87 21 04 80 	movabs $0x80042187d4,%rdi
  800420c00a:	00 00 00 
  800420c00d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c012:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420c019:	00 00 00 
  800420c01c:	41 ff d0             	callq  *%r8
  800420c01f:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  800420c026:	ff ff ff 
  800420c029:	48 03 45 f0          	add    -0x10(%rbp),%rax
  800420c02d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
}

static __inline void
lcr3(uint64_t val)
{
	__asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420c031:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c035:	0f 22 d8             	mov    %rax,%cr3

	// Mark that this CPU is in the HALT state, so that when
	// timer interupts come in, we know we should re-acquire the
	// big kernel lock
	xchg(&thiscpu->cpu_status, CPU_HALTED);
  800420c038:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420c03f:	00 00 00 
  800420c042:	ff d0                	callq  *%rax
  800420c044:	48 98                	cltq   
  800420c046:	48 c1 e0 03          	shl    $0x3,%rax
  800420c04a:	48 89 c2             	mov    %rax,%rdx
  800420c04d:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c051:	48 29 c2             	sub    %rax,%rdx
  800420c054:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420c05b:	00 00 00 
  800420c05e:	48 01 d0             	add    %rdx,%rax
  800420c061:	48 83 c0 04          	add    $0x4,%rax
  800420c065:	be 02 00 00 00       	mov    $0x2,%esi
  800420c06a:	48 89 c7             	mov    %rax,%rdi
  800420c06d:	48 b8 8c bc 20 04 80 	movabs $0x800420bc8c,%rax
  800420c074:	00 00 00 
  800420c077:	ff d0                	callq  *%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();
  800420c079:	48 b8 bd bc 20 04 80 	movabs $0x800420bcbd,%rax
  800420c080:	00 00 00 
  800420c083:	ff d0                	callq  *%rax
		"movq %0, %%rsp\n"
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
	: : "a" (thiscpu->cpu_ts.ts_esp0));
  800420c085:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420c08c:	00 00 00 
  800420c08f:	ff d0                	callq  *%rax
  800420c091:	48 98                	cltq   
  800420c093:	48 c1 e0 03          	shl    $0x3,%rax
  800420c097:	48 89 c2             	mov    %rax,%rdx
  800420c09a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c09e:	48 29 c2             	sub    %rax,%rdx
  800420c0a1:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420c0a8:	00 00 00 
  800420c0ab:	48 01 d0             	add    %rdx,%rax
  800420c0ae:	48 8b 40 14          	mov    0x14(%rax),%rax

	// Release the big kernel lock as if we were "leaving" the kernel
	unlock_kernel();

	// Reset stack pointer, enable interrupts and then halt.
	asm volatile (
  800420c0b2:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp
  800420c0b9:	48 89 c4             	mov    %rax,%rsp
  800420c0bc:	6a 00                	pushq  $0x0
  800420c0be:	6a 00                	pushq  $0x0
  800420c0c0:	fb                   	sti    
  800420c0c1:	f4                   	hlt    
		"pushq $0\n"
		"pushq $0\n"
		"sti\n"
		"hlt\n"
	: : "a" (thiscpu->cpu_ts.ts_esp0));
}
  800420c0c2:	c9                   	leaveq 
  800420c0c3:	c3                   	retq   

000000800420c0c4 <sys_cputs>:
// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void
sys_cputs(const char *s, size_t len)
{
  800420c0c4:	55                   	push   %rbp
  800420c0c5:	48 89 e5             	mov    %rsp,%rbp
  800420c0c8:	48 83 ec 10          	sub    $0x10,%rsp
  800420c0cc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420c0d0:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// Check that the user has permission to read memory [s, s+len).
	// Destroy the environment if not.

	// LAB 3: Your code here.
	user_mem_assert(curenv, (const void *)s, len, PTE_P | PTE_U);	
  800420c0d4:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420c0db:	00 00 00 
  800420c0de:	ff d0                	callq  *%rax
  800420c0e0:	48 98                	cltq   
  800420c0e2:	48 c1 e0 03          	shl    $0x3,%rax
  800420c0e6:	48 89 c2             	mov    %rax,%rdx
  800420c0e9:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c0ed:	48 29 c2             	sub    %rax,%rdx
  800420c0f0:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420c0f7:	00 00 00 
  800420c0fa:	48 01 d0             	add    %rdx,%rax
  800420c0fd:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420c101:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420c105:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420c109:	b9 05 00 00 00       	mov    $0x5,%ecx
  800420c10e:	48 89 c7             	mov    %rax,%rdi
  800420c111:	48 b8 08 3b 20 04 80 	movabs $0x8004203b08,%rax
  800420c118:	00 00 00 
  800420c11b:	ff d0                	callq  *%rax
	// Print the string supplied by the user.
	cprintf("%.*s", len, s);
  800420c11d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420c121:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c125:	48 89 c6             	mov    %rax,%rsi
  800420c128:	48 bf e8 87 21 04 80 	movabs $0x80042187e8,%rdi
  800420c12f:	00 00 00 
  800420c132:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c137:	48 b9 f2 89 20 04 80 	movabs $0x80042089f2,%rcx
  800420c13e:	00 00 00 
  800420c141:	ff d1                	callq  *%rcx
}
  800420c143:	c9                   	leaveq 
  800420c144:	c3                   	retq   

000000800420c145 <sys_cgetc>:

// Read a character from the system console without blocking.
// Returns the character, or 0 if there is no input waiting.
static int
sys_cgetc(void)
{
  800420c145:	55                   	push   %rbp
  800420c146:	48 89 e5             	mov    %rsp,%rbp
	return cons_getc();
  800420c149:	48 b8 5d 11 20 04 80 	movabs $0x800420115d,%rax
  800420c150:	00 00 00 
  800420c153:	ff d0                	callq  *%rax
}
  800420c155:	5d                   	pop    %rbp
  800420c156:	c3                   	retq   

000000800420c157 <sys_getenvid>:

// Returns the current environment's envid.
static envid_t
sys_getenvid(void)
{
  800420c157:	55                   	push   %rbp
  800420c158:	48 89 e5             	mov    %rsp,%rbp
	return curenv->env_id;
  800420c15b:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420c162:	00 00 00 
  800420c165:	ff d0                	callq  *%rax
  800420c167:	48 98                	cltq   
  800420c169:	48 c1 e0 03          	shl    $0x3,%rax
  800420c16d:	48 89 c2             	mov    %rax,%rdx
  800420c170:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c174:	48 29 c2             	sub    %rax,%rdx
  800420c177:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420c17e:	00 00 00 
  800420c181:	48 01 d0             	add    %rdx,%rax
  800420c184:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420c188:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
}
  800420c18e:	5d                   	pop    %rbp
  800420c18f:	c3                   	retq   

000000800420c190 <sys_env_destroy>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_destroy(envid_t envid)
{
  800420c190:	55                   	push   %rbp
  800420c191:	48 89 e5             	mov    %rsp,%rbp
  800420c194:	48 83 ec 20          	sub    $0x20,%rsp
  800420c198:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420c19b:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420c19f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c1a2:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c1a7:	48 89 ce             	mov    %rcx,%rsi
  800420c1aa:	89 c7                	mov    %eax,%edi
  800420c1ac:	48 b8 dd 75 20 04 80 	movabs $0x80042075dd,%rax
  800420c1b3:	00 00 00 
  800420c1b6:	ff d0                	callq  *%rax
  800420c1b8:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420c1bb:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c1bf:	79 05                	jns    800420c1c6 <sys_env_destroy+0x36>
		return r;
  800420c1c1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c1c4:	eb 18                	jmp    800420c1de <sys_env_destroy+0x4e>
	env_destroy(e);
  800420c1c6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c1ca:	48 89 c7             	mov    %rax,%rdi
  800420c1cd:	48 b8 f4 82 20 04 80 	movabs $0x80042082f4,%rax
  800420c1d4:	00 00 00 
  800420c1d7:	ff d0                	callq  *%rax
	return 0;
  800420c1d9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420c1de:	c9                   	leaveq 
  800420c1df:	c3                   	retq   

000000800420c1e0 <sys_yield>:

// Deschedule current environment and pick a different one to run.
static void
sys_yield(void)
{
  800420c1e0:	55                   	push   %rbp
  800420c1e1:	48 89 e5             	mov    %rsp,%rbp
	sched_yield();
  800420c1e4:	48 b8 db bc 20 04 80 	movabs $0x800420bcdb,%rax
  800420c1eb:	00 00 00 
  800420c1ee:	ff d0                	callq  *%rax

000000800420c1f0 <sys_exofork>:
// Returns envid of new environment, or < 0 on error.  Errors are:
//	-E_NO_FREE_ENV if no free environment is available.
//	-E_NO_MEM on memory exhaustion.
static envid_t
sys_exofork(void)
{
  800420c1f0:	55                   	push   %rbp
  800420c1f1:	48 89 e5             	mov    %rsp,%rbp
  800420c1f4:	53                   	push   %rbx
  800420c1f5:	48 83 ec 18          	sub    $0x18,%rsp
	// from the current environment -- but tweaked so sys_exofork
	// will appear to return 0.

	// LAB 4: Your code here.
	struct Env *child;
	int r = env_alloc(&child, curenv->env_id);
  800420c1f9:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420c200:	00 00 00 
  800420c203:	ff d0                	callq  *%rax
  800420c205:	48 98                	cltq   
  800420c207:	48 c1 e0 03          	shl    $0x3,%rax
  800420c20b:	48 89 c2             	mov    %rax,%rdx
  800420c20e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c212:	48 29 c2             	sub    %rax,%rdx
  800420c215:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420c21c:	00 00 00 
  800420c21f:	48 01 d0             	add    %rdx,%rax
  800420c222:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420c226:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420c22c:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800420c230:	89 d6                	mov    %edx,%esi
  800420c232:	48 89 c7             	mov    %rax,%rdi
  800420c235:	48 b8 96 79 20 04 80 	movabs $0x8004207996,%rax
  800420c23c:	00 00 00 
  800420c23f:	ff d0                	callq  *%rax
  800420c241:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if(r < 0)
  800420c244:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420c248:	79 08                	jns    800420c252 <sys_exofork+0x62>
		return r;
  800420c24a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c24d:	e9 a6 00 00 00       	jmpq   800420c2f8 <sys_exofork+0x108>
	child->env_status = ENV_NOT_RUNNABLE;
  800420c252:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c256:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420c25d:	00 00 00 
	child->env_tf = curenv->env_tf;
  800420c260:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  800420c264:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420c26b:	00 00 00 
  800420c26e:	ff d0                	callq  *%rax
  800420c270:	48 98                	cltq   
  800420c272:	48 c1 e0 03          	shl    $0x3,%rax
  800420c276:	48 89 c2             	mov    %rax,%rdx
  800420c279:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c27d:	48 29 c2             	sub    %rax,%rdx
  800420c280:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420c287:	00 00 00 
  800420c28a:	48 01 d0             	add    %rdx,%rax
  800420c28d:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420c291:	48 89 da             	mov    %rbx,%rdx
  800420c294:	48 89 c6             	mov    %rax,%rsi
  800420c297:	b8 18 00 00 00       	mov    $0x18,%eax
  800420c29c:	48 89 d7             	mov    %rdx,%rdi
  800420c29f:	48 89 c1             	mov    %rax,%rcx
  800420c2a2:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	child->env_tf.tf_regs.reg_rax = 0;
  800420c2a5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c2a9:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420c2b0:	00 
	child->env_parent_id = curenv->env_id;
  800420c2b1:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  800420c2b5:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420c2bc:	00 00 00 
  800420c2bf:	ff d0                	callq  *%rax
  800420c2c1:	48 98                	cltq   
  800420c2c3:	48 c1 e0 03          	shl    $0x3,%rax
  800420c2c7:	48 89 c2             	mov    %rax,%rdx
  800420c2ca:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c2ce:	48 29 c2             	sub    %rax,%rdx
  800420c2d1:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420c2d8:	00 00 00 
  800420c2db:	48 01 d0             	add    %rdx,%rax
  800420c2de:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420c2e2:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420c2e8:	89 83 cc 00 00 00    	mov    %eax,0xcc(%rbx)
	return child->env_id;
  800420c2ee:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c2f2:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax

}
  800420c2f8:	48 83 c4 18          	add    $0x18,%rsp
  800420c2fc:	5b                   	pop    %rbx
  800420c2fd:	5d                   	pop    %rbp
  800420c2fe:	c3                   	retq   

000000800420c2ff <sys_env_set_status>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if status is not a valid status for an environment.
static int
sys_env_set_status(envid_t envid, int status)
{
  800420c2ff:	55                   	push   %rbp
  800420c300:	48 89 e5             	mov    %rsp,%rbp
  800420c303:	48 83 ec 20          	sub    $0x20,%rsp
  800420c307:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420c30a:	89 75 e8             	mov    %esi,-0x18(%rbp)
	// envid's status.

	// LAB 4: Your code here.
	int envid2env_return;
	struct Env *env;
	if((status!=ENV_RUNNABLE) && (status!=ENV_NOT_RUNNABLE))
  800420c30d:	83 7d e8 02          	cmpl   $0x2,-0x18(%rbp)
  800420c311:	74 0d                	je     800420c320 <sys_env_set_status+0x21>
  800420c313:	83 7d e8 04          	cmpl   $0x4,-0x18(%rbp)
  800420c317:	74 07                	je     800420c320 <sys_env_set_status+0x21>
		return -E_INVAL;
  800420c319:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c31e:	eb 3d                	jmp    800420c35d <sys_env_set_status+0x5e>
	envid2env_return=envid2env(envid,&env,1);
  800420c320:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420c324:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c327:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c32c:	48 89 ce             	mov    %rcx,%rsi
  800420c32f:	89 c7                	mov    %eax,%edi
  800420c331:	48 b8 dd 75 20 04 80 	movabs $0x80042075dd,%rax
  800420c338:	00 00 00 
  800420c33b:	ff d0                	callq  *%rax
  800420c33d:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(envid2env_return<0)
  800420c340:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c344:	79 05                	jns    800420c34b <sys_env_set_status+0x4c>
		return envid2env_return;
  800420c346:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c349:	eb 12                	jmp    800420c35d <sys_env_set_status+0x5e>
	env->env_status=status;
  800420c34b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c34f:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420c352:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
	return 0;
  800420c358:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_env_set_status not implemented");
}
  800420c35d:	c9                   	leaveq 
  800420c35e:	c3                   	retq   

000000800420c35f <sys_env_set_trapframe>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  800420c35f:	55                   	push   %rbp
  800420c360:	48 89 e5             	mov    %rsp,%rbp
  800420c363:	48 83 ec 20          	sub    $0x20,%rsp
  800420c367:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420c36a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// LAB 5: Your code here.
	// Remember to check whether the user has supplied us with a good
	// address!
	int r;
	struct Env *env;
	r=envid2env(envid, &env, 1);
  800420c36e:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420c372:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c375:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c37a:	48 89 ce             	mov    %rcx,%rsi
  800420c37d:	89 c7                	mov    %eax,%edi
  800420c37f:	48 b8 dd 75 20 04 80 	movabs $0x80042075dd,%rax
  800420c386:	00 00 00 
  800420c389:	ff d0                	callq  *%rax
  800420c38b:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(r<0)
  800420c38e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c392:	79 05                	jns    800420c399 <sys_env_set_trapframe+0x3a>
		return r;
  800420c394:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420c397:	eb 50                	jmp    800420c3e9 <sys_env_set_trapframe+0x8a>
	env->env_tf = *tf;
  800420c399:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420c39d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c3a1:	48 89 c6             	mov    %rax,%rsi
  800420c3a4:	b8 18 00 00 00       	mov    $0x18,%eax
  800420c3a9:	48 89 d7             	mov    %rdx,%rdi
  800420c3ac:	48 89 c1             	mov    %rax,%rcx
  800420c3af:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	env->env_tf.tf_eflags |= FL_IF;
  800420c3b2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c3b6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420c3ba:	48 8b 92 a8 00 00 00 	mov    0xa8(%rdx),%rdx
  800420c3c1:	80 ce 02             	or     $0x2,%dh
  800420c3c4:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
	env->env_tf.tf_cs |= 3;
  800420c3cb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c3cf:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420c3d3:	0f b7 92 a0 00 00 00 	movzwl 0xa0(%rdx),%edx
  800420c3da:	83 ca 03             	or     $0x3,%edx
  800420c3dd:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
	return 0;
  800420c3e4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420c3e9:	c9                   	leaveq 
  800420c3ea:	c3                   	retq   

000000800420c3eb <sys_env_set_pgfault_upcall>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_pgfault_upcall(envid_t envid, void *func)
{
  800420c3eb:	55                   	push   %rbp
  800420c3ec:	48 89 e5             	mov    %rsp,%rbp
  800420c3ef:	48 83 ec 20          	sub    $0x20,%rsp
  800420c3f3:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420c3f6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// LAB 4: Your code here.
	struct Env *env;
	int envid2env_return=envid2env(envid,&env,1);
  800420c3fa:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420c3fe:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c401:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c406:	48 89 ce             	mov    %rcx,%rsi
  800420c409:	89 c7                	mov    %eax,%edi
  800420c40b:	48 b8 dd 75 20 04 80 	movabs $0x80042075dd,%rax
  800420c412:	00 00 00 
  800420c415:	ff d0                	callq  *%rax
  800420c417:	89 45 fc             	mov    %eax,-0x4(%rbp)
        if(envid2env_return<0)
  800420c41a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c41e:	79 07                	jns    800420c427 <sys_env_set_pgfault_upcall+0x3c>
                return -E_BAD_ENV;
  800420c420:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420c425:	eb 14                	jmp    800420c43b <sys_env_set_pgfault_upcall+0x50>
        env->env_pgfault_upcall = func;
  800420c427:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c42b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420c42f:	48 89 90 f0 00 00 00 	mov    %rdx,0xf0(%rax)
        return 0;
  800420c436:	b8 00 00 00 00       	mov    $0x0,%eax
//	panic("sys_env_set_pgfault_upcall not implemented");
}
  800420c43b:	c9                   	leaveq 
  800420c43c:	c3                   	retq   

000000800420c43d <sys_page_alloc>:
//	-E_INVAL if perm is inappropriate (see above).
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  800420c43d:	55                   	push   %rbp
  800420c43e:	48 89 e5             	mov    %rsp,%rbp
  800420c441:	48 83 ec 30          	sub    $0x30,%rsp
  800420c445:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420c448:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420c44c:	89 55 d8             	mov    %edx,-0x28(%rbp)
	// LAB 4: Your code here.
	int envid2env_return,page_insert_return;
	struct Env *env;
	int permbits;
	struct PageInfo *pg;
	envid2env_return=envid2env(envid,&env,1);
  800420c44f:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  800420c453:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420c456:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c45b:	48 89 ce             	mov    %rcx,%rsi
  800420c45e:	89 c7                	mov    %eax,%edi
  800420c460:	48 b8 dd 75 20 04 80 	movabs $0x80042075dd,%rax
  800420c467:	00 00 00 
  800420c46a:	ff d0                	callq  *%rax
  800420c46c:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(envid2env_return<0)
  800420c46f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c473:	79 0a                	jns    800420c47f <sys_page_alloc+0x42>
		return -E_BAD_ENV;
  800420c475:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420c47a:	e9 c2 00 00 00       	jmpq   800420c541 <sys_page_alloc+0x104>
	if((uint64_t)va >= UTOP || ((uint64_t)va) %PGSIZE!=0)
  800420c47f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420c483:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420c48a:	00 00 00 
  800420c48d:	48 39 c2             	cmp    %rax,%rdx
  800420c490:	77 0e                	ja     800420c4a0 <sys_page_alloc+0x63>
  800420c492:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c496:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420c49b:	48 85 c0             	test   %rax,%rax
  800420c49e:	74 0a                	je     800420c4aa <sys_page_alloc+0x6d>
		return -E_INVAL;
  800420c4a0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c4a5:	e9 97 00 00 00       	jmpq   800420c541 <sys_page_alloc+0x104>
	permbits=PTE_U|PTE_P;
  800420c4aa:	c7 45 f8 05 00 00 00 	movl   $0x5,-0x8(%rbp)
	if((perm & permbits)!=permbits || (perm & ~PTE_SYSCALL))
  800420c4b1:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800420c4b4:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800420c4b7:	21 d0                	and    %edx,%eax
  800420c4b9:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  800420c4bc:	75 0c                	jne    800420c4ca <sys_page_alloc+0x8d>
  800420c4be:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420c4c1:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420c4c6:	85 c0                	test   %eax,%eax
  800420c4c8:	74 07                	je     800420c4d1 <sys_page_alloc+0x94>
		return -E_INVAL;                
  800420c4ca:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c4cf:	eb 70                	jmp    800420c541 <sys_page_alloc+0x104>
	pg=page_alloc(0);
  800420c4d1:	bf 00 00 00 00       	mov    $0x0,%edi
  800420c4d6:	48 b8 99 2c 20 04 80 	movabs $0x8004202c99,%rax
  800420c4dd:	00 00 00 
  800420c4e0:	ff d0                	callq  *%rax
  800420c4e2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(pg==NULL)
  800420c4e6:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420c4eb:	75 07                	jne    800420c4f4 <sys_page_alloc+0xb7>
		return -E_NO_MEM;
  800420c4ed:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420c4f2:	eb 4d                	jmp    800420c541 <sys_page_alloc+0x104>
	page_insert_return=page_insert(env->env_pml4e,pg,va,perm);
  800420c4f4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c4f8:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420c4ff:	8b 4d d8             	mov    -0x28(%rbp),%ecx
  800420c502:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420c506:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420c50a:	48 89 c7             	mov    %rax,%rdi
  800420c50d:	48 b8 4b 35 20 04 80 	movabs $0x800420354b,%rax
  800420c514:	00 00 00 
  800420c517:	ff d0                	callq  *%rax
  800420c519:	89 45 ec             	mov    %eax,-0x14(%rbp)
	if(page_insert_return<0)
  800420c51c:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420c520:	79 1a                	jns    800420c53c <sys_page_alloc+0xff>
	{	
		page_free(pg);
  800420c522:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c526:	48 89 c7             	mov    %rax,%rdi
  800420c529:	48 b8 85 2d 20 04 80 	movabs $0x8004202d85,%rax
  800420c530:	00 00 00 
  800420c533:	ff d0                	callq  *%rax
		return -E_NO_MEM;	
  800420c535:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420c53a:	eb 05                	jmp    800420c541 <sys_page_alloc+0x104>
	}
	//memset(page2kva(pg), 0, PGSIZE);
	return 0;
  800420c53c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420c541:	c9                   	leaveq 
  800420c542:	c3                   	retq   

000000800420c543 <sys_page_map>:
//		address space.
//	-E_NO_MEM if there's no memory to allocate any necessary page tables.
static int
sys_page_map(envid_t srcenvid, void *srcva,
	     envid_t dstenvid, void *dstva, int perm)
{
  800420c543:	55                   	push   %rbp
  800420c544:	48 89 e5             	mov    %rsp,%rbp
  800420c547:	48 83 ec 50          	sub    $0x50,%rsp
  800420c54b:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420c54e:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420c552:	89 55 c8             	mov    %edx,-0x38(%rbp)
  800420c555:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
  800420c559:	44 89 45 b4          	mov    %r8d,-0x4c(%rbp)
	// LAB 4: Your code here.
	int srcenvid_return,dstenvid_return,page_insert_return;
	struct Env *srcenv,*dstenv;
	struct PageInfo *pg;
	uint64_t *pte;
	srcenvid_return=envid2env(srcenvid,&srcenv,1);
  800420c55d:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  800420c561:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420c564:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c569:	48 89 ce             	mov    %rcx,%rsi
  800420c56c:	89 c7                	mov    %eax,%edi
  800420c56e:	48 b8 dd 75 20 04 80 	movabs $0x80042075dd,%rax
  800420c575:	00 00 00 
  800420c578:	ff d0                	callq  *%rax
  800420c57a:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(srcenvid_return<0)
  800420c57d:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c581:	79 0a                	jns    800420c58d <sys_page_map+0x4a>
		return -E_BAD_ENV;
  800420c583:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420c588:	e9 41 01 00 00       	jmpq   800420c6ce <sys_page_map+0x18b>
	dstenvid_return=envid2env(dstenvid,&dstenv,1);
  800420c58d:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800420c591:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800420c594:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c599:	48 89 ce             	mov    %rcx,%rsi
  800420c59c:	89 c7                	mov    %eax,%edi
  800420c59e:	48 b8 dd 75 20 04 80 	movabs $0x80042075dd,%rax
  800420c5a5:	00 00 00 
  800420c5a8:	ff d0                	callq  *%rax
  800420c5aa:	89 45 f8             	mov    %eax,-0x8(%rbp)
        if(dstenvid_return<0)
  800420c5ad:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420c5b1:	79 0a                	jns    800420c5bd <sys_page_map+0x7a>
                return -E_BAD_ENV;
  800420c5b3:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420c5b8:	e9 11 01 00 00       	jmpq   800420c6ce <sys_page_map+0x18b>
 	 if((uint64_t)srcva >= UTOP || ((uint64_t)srcva) %PGSIZE!=0)
  800420c5bd:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420c5c1:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420c5c8:	00 00 00 
  800420c5cb:	48 39 c2             	cmp    %rax,%rdx
  800420c5ce:	77 0e                	ja     800420c5de <sys_page_map+0x9b>
  800420c5d0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420c5d4:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420c5d9:	48 85 c0             	test   %rax,%rax
  800420c5dc:	74 0a                	je     800420c5e8 <sys_page_map+0xa5>
                return -E_INVAL;
  800420c5de:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c5e3:	e9 e6 00 00 00       	jmpq   800420c6ce <sys_page_map+0x18b>
	 if((uint64_t)dstva >= UTOP || ((uint64_t)dstva) %PGSIZE!=0)
  800420c5e8:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420c5ec:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420c5f3:	00 00 00 
  800420c5f6:	48 39 c2             	cmp    %rax,%rdx
  800420c5f9:	77 0e                	ja     800420c609 <sys_page_map+0xc6>
  800420c5fb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420c5ff:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420c604:	48 85 c0             	test   %rax,%rax
  800420c607:	74 0a                	je     800420c613 <sys_page_map+0xd0>
                return -E_INVAL;
  800420c609:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c60e:	e9 bb 00 00 00       	jmpq   800420c6ce <sys_page_map+0x18b>
	pg=page_lookup(srcenv->env_pml4e,srcva,&pte);
  800420c613:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c617:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420c61e:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  800420c622:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420c626:	48 89 ce             	mov    %rcx,%rsi
  800420c629:	48 89 c7             	mov    %rax,%rdi
  800420c62c:	48 b8 86 36 20 04 80 	movabs $0x8004203686,%rax
  800420c633:	00 00 00 
  800420c636:	ff d0                	callq  *%rax
  800420c638:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(pg==NULL)
  800420c63c:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420c641:	75 0a                	jne    800420c64d <sys_page_map+0x10a>
		return -E_INVAL;
  800420c643:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c648:	e9 81 00 00 00       	jmpq   800420c6ce <sys_page_map+0x18b>
	int permbits=PTE_U|PTE_P;
  800420c64d:	c7 45 ec 05 00 00 00 	movl   $0x5,-0x14(%rbp)
        if((perm & permbits)!=permbits || (perm & ~PTE_SYSCALL))
  800420c654:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c657:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  800420c65a:	21 d0                	and    %edx,%eax
  800420c65c:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800420c65f:	75 0c                	jne    800420c66d <sys_page_map+0x12a>
  800420c661:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420c664:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420c669:	85 c0                	test   %eax,%eax
  800420c66b:	74 07                	je     800420c674 <sys_page_map+0x131>
                return -E_INVAL;
  800420c66d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c672:	eb 5a                	jmp    800420c6ce <sys_page_map+0x18b>

	//if((perm & (PTE_P|PTE_U))==0)
          //      return -E_INVAL;
	if(perm & PTE_W)
  800420c674:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420c677:	83 e0 02             	and    $0x2,%eax
  800420c67a:	85 c0                	test   %eax,%eax
  800420c67c:	74 16                	je     800420c694 <sys_page_map+0x151>
		if(!(*pte & PTE_W))
  800420c67e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c682:	48 8b 00             	mov    (%rax),%rax
  800420c685:	83 e0 02             	and    $0x2,%eax
  800420c688:	48 85 c0             	test   %rax,%rax
  800420c68b:	75 07                	jne    800420c694 <sys_page_map+0x151>
			return -E_INVAL;
  800420c68d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c692:	eb 3a                	jmp    800420c6ce <sys_page_map+0x18b>
	page_insert_return=page_insert(dstenv->env_pml4e,pg,dstva,perm);
  800420c694:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420c698:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420c69f:	8b 4d b4             	mov    -0x4c(%rbp),%ecx
  800420c6a2:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420c6a6:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420c6aa:	48 89 c7             	mov    %rax,%rdi
  800420c6ad:	48 b8 4b 35 20 04 80 	movabs $0x800420354b,%rax
  800420c6b4:	00 00 00 
  800420c6b7:	ff d0                	callq  *%rax
  800420c6b9:	89 45 e8             	mov    %eax,-0x18(%rbp)
        if(page_insert_return<0)
  800420c6bc:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  800420c6c0:	79 07                	jns    800420c6c9 <sys_page_map+0x186>
        {
                //page_free(pg);
                return -E_NO_MEM;
  800420c6c2:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420c6c7:	eb 05                	jmp    800420c6ce <sys_page_map+0x18b>

        }

	return 0;
  800420c6c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420c6ce:	c9                   	leaveq 
  800420c6cf:	c3                   	retq   

000000800420c6d0 <sys_page_unmap>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int
sys_page_unmap(envid_t envid, void *va)
{
  800420c6d0:	55                   	push   %rbp
  800420c6d1:	48 89 e5             	mov    %rsp,%rbp
  800420c6d4:	48 83 ec 20          	sub    $0x20,%rsp
  800420c6d8:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420c6db:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Hint: This function is a wrapper around page_remove().

	// LAB 4: Your code here.
	struct Env *env;
	int envid2env_return;
	envid2env_return=envid2env(envid,&env,1);
  800420c6df:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420c6e3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420c6e6:	ba 01 00 00 00       	mov    $0x1,%edx
  800420c6eb:	48 89 ce             	mov    %rcx,%rsi
  800420c6ee:	89 c7                	mov    %eax,%edi
  800420c6f0:	48 b8 dd 75 20 04 80 	movabs $0x80042075dd,%rax
  800420c6f7:	00 00 00 
  800420c6fa:	ff d0                	callq  *%rax
  800420c6fc:	89 45 fc             	mov    %eax,-0x4(%rbp)
        if(envid2env_return<0)
  800420c6ff:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420c703:	79 07                	jns    800420c70c <sys_page_unmap+0x3c>
                return -E_BAD_ENV;
  800420c705:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420c70a:	eb 4e                	jmp    800420c75a <sys_page_unmap+0x8a>
	if((uint64_t)va >= UTOP || ((uint64_t)va) %PGSIZE!=0)
  800420c70c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420c710:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420c717:	00 00 00 
  800420c71a:	48 39 c2             	cmp    %rax,%rdx
  800420c71d:	77 0e                	ja     800420c72d <sys_page_unmap+0x5d>
  800420c71f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c723:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420c728:	48 85 c0             	test   %rax,%rax
  800420c72b:	74 07                	je     800420c734 <sys_page_unmap+0x64>
                return -E_INVAL;
  800420c72d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c732:	eb 26                	jmp    800420c75a <sys_page_unmap+0x8a>
	page_remove(env->env_pml4e,va);
  800420c734:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420c738:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420c73f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420c743:	48 89 d6             	mov    %rdx,%rsi
  800420c746:	48 89 c7             	mov    %rax,%rdi
  800420c749:	48 b8 03 37 20 04 80 	movabs $0x8004203703,%rax
  800420c750:	00 00 00 
  800420c753:	ff d0                	callq  *%rax
	return 0; 
  800420c755:	b8 00 00 00 00       	mov    $0x0,%eax
        


	//panic("sys_page_unmap not implemented");
}
  800420c75a:	c9                   	leaveq 
  800420c75b:	c3                   	retq   

000000800420c75c <sys_ipc_try_send>:
//		current environment's address space.
//	-E_NO_MEM if there's not enough memory to map srcva in envid's
//		address space.
static int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
{
  800420c75c:	55                   	push   %rbp
  800420c75d:	48 89 e5             	mov    %rsp,%rbp
  800420c760:	53                   	push   %rbx
  800420c761:	48 83 ec 58          	sub    $0x58,%rsp
  800420c765:	89 7d bc             	mov    %edi,-0x44(%rbp)
  800420c768:	89 75 b8             	mov    %esi,-0x48(%rbp)
  800420c76b:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  800420c76f:	89 4d ac             	mov    %ecx,-0x54(%rbp)
	int permbits;
	struct Env *send_env=curenv;
  800420c772:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420c779:	00 00 00 
  800420c77c:	ff d0                	callq  *%rax
  800420c77e:	48 98                	cltq   
  800420c780:	48 c1 e0 03          	shl    $0x3,%rax
  800420c784:	48 89 c2             	mov    %rax,%rdx
  800420c787:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c78b:	48 29 c2             	sub    %rax,%rdx
  800420c78e:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420c795:	00 00 00 
  800420c798:	48 01 d0             	add    %rdx,%rax
  800420c79b:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420c79f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	struct Env *recv_env;
	int r;
	pte_t *pte;
	struct PageInfo *pg;
	permbits=PTE_U|PTE_P;
  800420c7a3:	c7 45 e4 05 00 00 00 	movl   $0x5,-0x1c(%rbp)
        if((r=envid2env(envid,&recv_env,0))<0)
  800420c7aa:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800420c7ae:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420c7b1:	ba 00 00 00 00       	mov    $0x0,%edx
  800420c7b6:	48 89 ce             	mov    %rcx,%rsi
  800420c7b9:	89 c7                	mov    %eax,%edi
  800420c7bb:	48 b8 dd 75 20 04 80 	movabs $0x80042075dd,%rax
  800420c7c2:	00 00 00 
  800420c7c5:	ff d0                	callq  *%rax
  800420c7c7:	89 45 e0             	mov    %eax,-0x20(%rbp)
  800420c7ca:	83 7d e0 00          	cmpl   $0x0,-0x20(%rbp)
  800420c7ce:	79 0a                	jns    800420c7da <sys_ipc_try_send+0x7e>
		return -E_BAD_ENV;
  800420c7d0:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420c7d5:	e9 a6 01 00 00       	jmpq   800420c980 <sys_ipc_try_send+0x224>
	if(recv_env->env_ipc_recving == 0)
  800420c7da:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c7de:	0f b6 80 f8 00 00 00 	movzbl 0xf8(%rax),%eax
  800420c7e5:	83 f0 01             	xor    $0x1,%eax
  800420c7e8:	84 c0                	test   %al,%al
  800420c7ea:	74 0a                	je     800420c7f6 <sys_ipc_try_send+0x9a>
		return -E_IPC_NOT_RECV;
  800420c7ec:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  800420c7f1:	e9 8a 01 00 00       	jmpq   800420c980 <sys_ipc_try_send+0x224>
	recv_env->env_ipc_recving=0;
  800420c7f6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c7fa:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)
        recv_env->env_ipc_from=sys_getenvid();
  800420c801:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
  800420c805:	48 b8 57 c1 20 04 80 	movabs $0x800420c157,%rax
  800420c80c:	00 00 00 
  800420c80f:	ff d0                	callq  *%rax
  800420c811:	89 83 0c 01 00 00    	mov    %eax,0x10c(%rbx)
	recv_env->env_ipc_perm=0;
  800420c817:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c81b:	c7 80 10 01 00 00 00 	movl   $0x0,0x110(%rax)
  800420c822:	00 00 00 
	if((uint64_t)srcva<UTOP)
  800420c825:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420c829:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420c830:	00 00 00 
  800420c833:	48 39 c2             	cmp    %rax,%rdx
  800420c836:	0f 87 24 01 00 00    	ja     800420c960 <sys_ipc_try_send+0x204>
        {
                if((uint64_t)srcva%PGSIZE!=0)// checking for page alignment
  800420c83c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420c840:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420c845:	48 85 c0             	test   %rax,%rax
  800420c848:	74 0a                	je     800420c854 <sys_ipc_try_send+0xf8>
                        return -E_INVAL;
  800420c84a:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c84f:	e9 2c 01 00 00       	jmpq   800420c980 <sys_ipc_try_send+0x224>
	    	if((perm & permbits)!=permbits || (perm & ~PTE_SYSCALL))	//checking for permission
  800420c854:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420c857:	89 c2                	mov    %eax,%edx
  800420c859:	23 55 ac             	and    -0x54(%rbp),%edx
  800420c85c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420c85f:	39 c2                	cmp    %eax,%edx
  800420c861:	75 0c                	jne    800420c86f <sys_ipc_try_send+0x113>
  800420c863:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800420c866:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420c86b:	85 c0                	test   %eax,%eax
  800420c86d:	74 0a                	je     800420c879 <sys_ipc_try_send+0x11d>
        	        return -E_INVAL;
  800420c86f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c874:	e9 07 01 00 00       	jmpq   800420c980 <sys_ipc_try_send+0x224>
		if(!(pg=page_lookup(curenv->env_pml4e, srcva, &pte)))          //checking for lookup
  800420c879:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420c880:	00 00 00 
  800420c883:	ff d0                	callq  *%rax
  800420c885:	48 98                	cltq   
  800420c887:	48 c1 e0 03          	shl    $0x3,%rax
  800420c88b:	48 89 c2             	mov    %rax,%rdx
  800420c88e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c892:	48 29 c2             	sub    %rax,%rdx
  800420c895:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420c89c:	00 00 00 
  800420c89f:	48 01 d0             	add    %rdx,%rax
  800420c8a2:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420c8a6:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420c8ad:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
  800420c8b1:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800420c8b5:	48 89 ce             	mov    %rcx,%rsi
  800420c8b8:	48 89 c7             	mov    %rax,%rdi
  800420c8bb:	48 b8 86 36 20 04 80 	movabs $0x8004203686,%rax
  800420c8c2:	00 00 00 
  800420c8c5:	ff d0                	callq  *%rax
  800420c8c7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420c8cb:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420c8d0:	75 0a                	jne    800420c8dc <sys_ipc_try_send+0x180>
			return -E_INVAL;
  800420c8d2:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c8d7:	e9 a4 00 00 00       	jmpq   800420c980 <sys_ipc_try_send+0x224>
		if(perm & PTE_W)
  800420c8dc:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800420c8df:	83 e0 02             	and    $0x2,%eax
  800420c8e2:	85 c0                	test   %eax,%eax
  800420c8e4:	74 19                	je     800420c8ff <sys_ipc_try_send+0x1a3>
			if(!(*pte & PTE_W))						 			return -E_INVAL;
  800420c8e6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420c8ea:	48 8b 00             	mov    (%rax),%rax
  800420c8ed:	83 e0 02             	and    $0x2,%eax
  800420c8f0:	48 85 c0             	test   %rax,%rax
  800420c8f3:	75 0a                	jne    800420c8ff <sys_ipc_try_send+0x1a3>
  800420c8f5:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420c8fa:	e9 81 00 00 00       	jmpq   800420c980 <sys_ipc_try_send+0x224>
		if((uint64_t)recv_env->env_ipc_dstva < UTOP)
  800420c8ff:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c903:	48 8b 80 00 01 00 00 	mov    0x100(%rax),%rax
  800420c90a:	48 89 c2             	mov    %rax,%rdx
  800420c90d:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420c914:	00 00 00 
  800420c917:	48 39 c2             	cmp    %rax,%rdx
  800420c91a:	77 37                	ja     800420c953 <sys_ipc_try_send+0x1f7>
		{
			if((page_insert(recv_env->env_pml4e, pg, recv_env->env_ipc_dstva, perm))<0)
  800420c91c:	8b 4d ac             	mov    -0x54(%rbp),%ecx
  800420c91f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c923:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420c92a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c92e:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420c935:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  800420c939:	48 89 c7             	mov    %rax,%rdi
  800420c93c:	48 b8 4b 35 20 04 80 	movabs $0x800420354b,%rax
  800420c943:	00 00 00 
  800420c946:	ff d0                	callq  *%rax
  800420c948:	85 c0                	test   %eax,%eax
  800420c94a:	79 07                	jns    800420c953 <sys_ipc_try_send+0x1f7>
				return -E_NO_MEM;
  800420c94c:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420c951:	eb 2d                	jmp    800420c980 <sys_ipc_try_send+0x224>
		}
		recv_env->env_ipc_perm = perm;
  800420c953:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c957:	8b 55 ac             	mov    -0x54(%rbp),%edx
  800420c95a:	89 90 10 01 00 00    	mov    %edx,0x110(%rax)
	}
	recv_env->env_ipc_value=value;
  800420c960:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c964:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420c967:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
        recv_env->env_status=ENV_RUNNABLE;
  800420c96d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420c971:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420c978:	00 00 00 
	return 0;
  800420c97b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420c980:	48 83 c4 58          	add    $0x58,%rsp
  800420c984:	5b                   	pop    %rbx
  800420c985:	5d                   	pop    %rbp
  800420c986:	c3                   	retq   

000000800420c987 <sys_ipc_recv>:
// return 0 on success.
// Return < 0 on error.  Errors are:
//	-E_INVAL if dstva < UTOP but dstva is not page-aligned.
static int
sys_ipc_recv(void *dstva)
{
  800420c987:	55                   	push   %rbp
  800420c988:	48 89 e5             	mov    %rsp,%rbp
  800420c98b:	48 83 ec 20          	sub    $0x20,%rsp
  800420c98f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)

	// LAB 4: Your code here.
	struct Env *env=curenv;
  800420c993:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420c99a:	00 00 00 
  800420c99d:	ff d0                	callq  *%rax
  800420c99f:	48 98                	cltq   
  800420c9a1:	48 c1 e0 03          	shl    $0x3,%rax
  800420c9a5:	48 89 c2             	mov    %rax,%rdx
  800420c9a8:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c9ac:	48 29 c2             	sub    %rax,%rdx
  800420c9af:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420c9b6:	00 00 00 
  800420c9b9:	48 01 d0             	add    %rdx,%rax
  800420c9bc:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420c9c0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	uint64_t dest;
	dest=(uint64_t)dstva;
  800420c9c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c9c8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	curenv->env_ipc_recving=1;
  800420c9cc:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420c9d3:	00 00 00 
  800420c9d6:	ff d0                	callq  *%rax
  800420c9d8:	48 98                	cltq   
  800420c9da:	48 c1 e0 03          	shl    $0x3,%rax
  800420c9de:	48 89 c2             	mov    %rax,%rdx
  800420c9e1:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c9e5:	48 29 c2             	sub    %rax,%rdx
  800420c9e8:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420c9ef:	00 00 00 
  800420c9f2:	48 01 d0             	add    %rdx,%rax
  800420c9f5:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420c9f9:	c6 80 f8 00 00 00 01 	movb   $0x1,0xf8(%rax)
	if((uint64_t)dstva<UTOP)
  800420ca00:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ca04:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420ca0b:	00 00 00 
  800420ca0e:	48 39 c2             	cmp    %rax,%rdx
  800420ca11:	77 50                	ja     800420ca63 <sys_ipc_recv+0xdc>
	{ 
		if((dest%PGSIZE)!=0)
  800420ca13:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ca17:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420ca1c:	48 85 c0             	test   %rax,%rax
  800420ca1f:	74 0a                	je     800420ca2b <sys_ipc_recv+0xa4>
			return -E_INVAL;
  800420ca21:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420ca26:	e9 b5 00 00 00       	jmpq   800420cae0 <sys_ipc_recv+0x159>
		else
			curenv->env_ipc_dstva=dstva;
  800420ca2b:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420ca32:	00 00 00 
  800420ca35:	ff d0                	callq  *%rax
  800420ca37:	48 98                	cltq   
  800420ca39:	48 c1 e0 03          	shl    $0x3,%rax
  800420ca3d:	48 89 c2             	mov    %rax,%rdx
  800420ca40:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ca44:	48 29 c2             	sub    %rax,%rdx
  800420ca47:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420ca4e:	00 00 00 
  800420ca51:	48 01 d0             	add    %rdx,%rax
  800420ca54:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420ca58:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ca5c:	48 89 90 00 01 00 00 	mov    %rdx,0x100(%rax)
	}
	curenv->env_status=ENV_NOT_RUNNABLE;
  800420ca63:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420ca6a:	00 00 00 
  800420ca6d:	ff d0                	callq  *%rax
  800420ca6f:	48 98                	cltq   
  800420ca71:	48 c1 e0 03          	shl    $0x3,%rax
  800420ca75:	48 89 c2             	mov    %rax,%rdx
  800420ca78:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ca7c:	48 29 c2             	sub    %rax,%rdx
  800420ca7f:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420ca86:	00 00 00 
  800420ca89:	48 01 d0             	add    %rdx,%rax
  800420ca8c:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420ca90:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420ca97:	00 00 00 
	curenv->env_tf.tf_regs.reg_rax=0;
  800420ca9a:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420caa1:	00 00 00 
  800420caa4:	ff d0                	callq  *%rax
  800420caa6:	48 98                	cltq   
  800420caa8:	48 c1 e0 03          	shl    $0x3,%rax
  800420caac:	48 89 c2             	mov    %rax,%rdx
  800420caaf:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cab3:	48 29 c2             	sub    %rax,%rdx
  800420cab6:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420cabd:	00 00 00 
  800420cac0:	48 01 d0             	add    %rdx,%rax
  800420cac3:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420cac7:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420cace:	00 
	sys_yield();
  800420cacf:	48 b8 e0 c1 20 04 80 	movabs $0x800420c1e0,%rax
  800420cad6:	00 00 00 
  800420cad9:	ff d0                	callq  *%rax
	return 0;
  800420cadb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420cae0:	c9                   	leaveq 
  800420cae1:	c3                   	retq   

000000800420cae2 <sys_time_msec>:


// Return the current time.
static int
sys_time_msec(void)
{
  800420cae2:	55                   	push   %rbp
  800420cae3:	48 89 e5             	mov    %rsp,%rbp
	// LAB 6: Your code here.
	return time_msec();
  800420cae6:	48 b8 80 6f 21 04 80 	movabs $0x8004216f80,%rax
  800420caed:	00 00 00 
  800420caf0:	ff d0                	callq  *%rax
}
  800420caf2:	5d                   	pop    %rbp
  800420caf3:	c3                   	retq   

000000800420caf4 <sys_send_packet>:
// Send a packet out whose contents are mapped at [addr, addr+len)
static int 
sys_send_packet(void* addr,size_t len)
{
  800420caf4:	55                   	push   %rbp
  800420caf5:	48 89 e5             	mov    %rsp,%rbp
  800420caf8:	48 83 ec 20          	sub    $0x20,%rsp
  800420cafc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420cb00:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	//Check the pointer passed for User, read
	user_mem_assert(curenv, addr, len, PTE_U);
  800420cb04:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420cb0b:	00 00 00 
  800420cb0e:	ff d0                	callq  *%rax
  800420cb10:	48 98                	cltq   
  800420cb12:	48 c1 e0 03          	shl    $0x3,%rax
  800420cb16:	48 89 c2             	mov    %rax,%rdx
  800420cb19:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cb1d:	48 29 c2             	sub    %rax,%rdx
  800420cb20:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420cb27:	00 00 00 
  800420cb2a:	48 01 d0             	add    %rdx,%rax
  800420cb2d:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420cb31:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420cb35:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420cb39:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420cb3e:	48 89 c7             	mov    %rax,%rdi
  800420cb41:	48 b8 08 3b 20 04 80 	movabs $0x8004203b08,%rax
  800420cb48:	00 00 00 
  800420cb4b:	ff d0                	callq  *%rax
	int res = transmit_packet_e1000(addr, len);
  800420cb4d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420cb51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cb55:	48 89 d6             	mov    %rdx,%rsi
  800420cb58:	48 89 c7             	mov    %rax,%rdi
  800420cb5b:	48 b8 f3 5e 21 04 80 	movabs $0x8004215ef3,%rax
  800420cb62:	00 00 00 
  800420cb65:	ff d0                	callq  *%rax
  800420cb67:	89 45 fc             	mov    %eax,-0x4(%rbp)
	return res;
  800420cb6a:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420cb6d:	c9                   	leaveq 
  800420cb6e:	c3                   	retq   

000000800420cb6f <sys_receive_packet>:

static int
sys_receive_packet(void *addr,size_t len)
{
  800420cb6f:	55                   	push   %rbp
  800420cb70:	48 89 e5             	mov    %rsp,%rbp
  800420cb73:	48 83 ec 20          	sub    $0x20,%rsp
  800420cb77:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420cb7b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	//Check the pointer passed for User, write
	user_mem_assert(curenv, addr, len,  PTE_U | PTE_W);
  800420cb7f:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420cb86:	00 00 00 
  800420cb89:	ff d0                	callq  *%rax
  800420cb8b:	48 98                	cltq   
  800420cb8d:	48 c1 e0 03          	shl    $0x3,%rax
  800420cb91:	48 89 c2             	mov    %rax,%rdx
  800420cb94:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cb98:	48 29 c2             	sub    %rax,%rdx
  800420cb9b:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420cba2:	00 00 00 
  800420cba5:	48 01 d0             	add    %rdx,%rax
  800420cba8:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420cbac:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420cbb0:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420cbb4:	b9 06 00 00 00       	mov    $0x6,%ecx
  800420cbb9:	48 89 c7             	mov    %rax,%rdi
  800420cbbc:	48 b8 08 3b 20 04 80 	movabs $0x8004203b08,%rax
  800420cbc3:	00 00 00 
  800420cbc6:	ff d0                	callq  *%rax
	int res = receive_packet_e1000(addr, len);
  800420cbc8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420cbcc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cbd0:	48 89 d6             	mov    %rdx,%rsi
  800420cbd3:	48 89 c7             	mov    %rax,%rdi
  800420cbd6:	48 b8 d6 5f 21 04 80 	movabs $0x8004215fd6,%rax
  800420cbdd:	00 00 00 
  800420cbe0:	ff d0                	callq  *%rax
  800420cbe2:	89 45 fc             	mov    %eax,-0x4(%rbp)
	return res;
  800420cbe5:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420cbe8:	c9                   	leaveq 
  800420cbe9:	c3                   	retq   

000000800420cbea <syscall>:

// Dispatches to the correct kernel function, passing the arguments.
int64_t
syscall(uint64_t syscallno, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  800420cbea:	55                   	push   %rbp
  800420cbeb:	48 89 e5             	mov    %rsp,%rbp
  800420cbee:	48 83 ec 30          	sub    $0x30,%rsp
  800420cbf2:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420cbf6:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420cbfa:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420cbfe:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420cc02:	4c 89 45 d8          	mov    %r8,-0x28(%rbp)
  800420cc06:	4c 89 4d d0          	mov    %r9,-0x30(%rbp)
	// LAB 3: Your code here.
	
	//panic("syscall not implemented");

	
	switch (syscallno) 
  800420cc0a:	48 83 7d f8 10       	cmpq   $0x10,-0x8(%rbp)
  800420cc0f:	0f 87 00 02 00 00    	ja     800420ce15 <syscall+0x22b>
  800420cc15:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cc19:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420cc20:	00 
  800420cc21:	48 b8 f0 87 21 04 80 	movabs $0x80042187f0,%rax
  800420cc28:	00 00 00 
  800420cc2b:	48 01 d0             	add    %rdx,%rax
  800420cc2e:	48 8b 00             	mov    (%rax),%rax
  800420cc31:	ff e0                	jmpq   *%rax
	{
		case SYS_cputs :
                	sys_cputs((const char *)a1, (size_t)a2);
  800420cc33:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cc37:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cc3b:	48 89 d6             	mov    %rdx,%rsi
  800420cc3e:	48 89 c7             	mov    %rax,%rdi
  800420cc41:	48 b8 c4 c0 20 04 80 	movabs $0x800420c0c4,%rax
  800420cc48:	00 00 00 
  800420cc4b:	ff d0                	callq  *%rax
                	return 0;
  800420cc4d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cc52:	e9 c5 01 00 00       	jmpq   800420ce1c <syscall+0x232>
        	case SYS_cgetc :
                	return sys_cgetc();
  800420cc57:	48 b8 45 c1 20 04 80 	movabs $0x800420c145,%rax
  800420cc5e:	00 00 00 
  800420cc61:	ff d0                	callq  *%rax
  800420cc63:	48 98                	cltq   
  800420cc65:	e9 b2 01 00 00       	jmpq   800420ce1c <syscall+0x232>
        	case SYS_getenvid :
                	return sys_getenvid();
  800420cc6a:	48 b8 57 c1 20 04 80 	movabs $0x800420c157,%rax
  800420cc71:	00 00 00 
  800420cc74:	ff d0                	callq  *%rax
  800420cc76:	48 98                	cltq   
  800420cc78:	e9 9f 01 00 00       	jmpq   800420ce1c <syscall+0x232>
        	case SYS_env_destroy :
                	return sys_env_destroy(a1);
  800420cc7d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cc81:	89 c7                	mov    %eax,%edi
  800420cc83:	48 b8 90 c1 20 04 80 	movabs $0x800420c190,%rax
  800420cc8a:	00 00 00 
  800420cc8d:	ff d0                	callq  *%rax
  800420cc8f:	48 98                	cltq   
  800420cc91:	e9 86 01 00 00       	jmpq   800420ce1c <syscall+0x232>
        	case SYS_yield:
                	sys_yield();
  800420cc96:	48 b8 e0 c1 20 04 80 	movabs $0x800420c1e0,%rax
  800420cc9d:	00 00 00 
  800420cca0:	ff d0                	callq  *%rax
        	case SYS_exofork:
                	return sys_exofork();
  800420cca2:	48 b8 f0 c1 20 04 80 	movabs $0x800420c1f0,%rax
  800420cca9:	00 00 00 
  800420ccac:	ff d0                	callq  *%rax
  800420ccae:	48 98                	cltq   
  800420ccb0:	e9 67 01 00 00       	jmpq   800420ce1c <syscall+0x232>
        	case SYS_env_set_status:
                	return sys_env_set_status((envid_t)a1, (int)a2);
  800420ccb5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ccb9:	89 c2                	mov    %eax,%edx
  800420ccbb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ccbf:	89 d6                	mov    %edx,%esi
  800420ccc1:	89 c7                	mov    %eax,%edi
  800420ccc3:	48 b8 ff c2 20 04 80 	movabs $0x800420c2ff,%rax
  800420ccca:	00 00 00 
  800420cccd:	ff d0                	callq  *%rax
  800420cccf:	48 98                	cltq   
  800420ccd1:	e9 46 01 00 00       	jmpq   800420ce1c <syscall+0x232>
        	case SYS_page_alloc:
                	return sys_page_alloc((envid_t)a1, (void*)a2, (int)a3);
  800420ccd6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ccda:	89 c2                	mov    %eax,%edx
  800420ccdc:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420cce0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cce4:	48 89 ce             	mov    %rcx,%rsi
  800420cce7:	89 c7                	mov    %eax,%edi
  800420cce9:	48 b8 3d c4 20 04 80 	movabs $0x800420c43d,%rax
  800420ccf0:	00 00 00 
  800420ccf3:	ff d0                	callq  *%rax
  800420ccf5:	48 98                	cltq   
  800420ccf7:	e9 20 01 00 00       	jmpq   800420ce1c <syscall+0x232>
        	case SYS_page_map:
                	return sys_page_map((envid_t)a1, (void *)a2,(envid_t) a3, (void *)a4, (int)a5);
  800420ccfc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420cd00:	89 c7                	mov    %eax,%edi
  800420cd02:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420cd06:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420cd0a:	89 c2                	mov    %eax,%edx
  800420cd0c:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420cd10:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cd14:	41 89 f8             	mov    %edi,%r8d
  800420cd17:	89 c7                	mov    %eax,%edi
  800420cd19:	48 b8 43 c5 20 04 80 	movabs $0x800420c543,%rax
  800420cd20:	00 00 00 
  800420cd23:	ff d0                	callq  *%rax
  800420cd25:	48 98                	cltq   
  800420cd27:	e9 f0 00 00 00       	jmpq   800420ce1c <syscall+0x232>
        	case SYS_page_unmap:
                	return sys_page_unmap((envid_t)a1, (void*)a2);
  800420cd2c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cd30:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cd34:	48 89 d6             	mov    %rdx,%rsi
  800420cd37:	89 c7                	mov    %eax,%edi
  800420cd39:	48 b8 d0 c6 20 04 80 	movabs $0x800420c6d0,%rax
  800420cd40:	00 00 00 
  800420cd43:	ff d0                	callq  *%rax
  800420cd45:	48 98                	cltq   
  800420cd47:	e9 d0 00 00 00       	jmpq   800420ce1c <syscall+0x232>
        	case SYS_env_set_pgfault_upcall:
                	return sys_env_set_pgfault_upcall((envid_t)a1, (void*)a2);
  800420cd4c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cd50:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cd54:	48 89 d6             	mov    %rdx,%rsi
  800420cd57:	89 c7                	mov    %eax,%edi
  800420cd59:	48 b8 eb c3 20 04 80 	movabs $0x800420c3eb,%rax
  800420cd60:	00 00 00 
  800420cd63:	ff d0                	callq  *%rax
  800420cd65:	48 98                	cltq   
  800420cd67:	e9 b0 00 00 00       	jmpq   800420ce1c <syscall+0x232>
		case SYS_ipc_try_send:
			return sys_ipc_try_send((envid_t)a1, (uint32_t)a2, (void *)a3, (unsigned)a4);
  800420cd6c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cd70:	89 c1                	mov    %eax,%ecx
  800420cd72:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420cd76:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cd7a:	89 c6                	mov    %eax,%esi
  800420cd7c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cd80:	89 c7                	mov    %eax,%edi
  800420cd82:	48 b8 5c c7 20 04 80 	movabs $0x800420c75c,%rax
  800420cd89:	00 00 00 
  800420cd8c:	ff d0                	callq  *%rax
  800420cd8e:	48 98                	cltq   
  800420cd90:	e9 87 00 00 00       	jmpq   800420ce1c <syscall+0x232>
		case SYS_ipc_recv:
			return sys_ipc_recv((void *)a1);
  800420cd95:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cd99:	48 89 c7             	mov    %rax,%rdi
  800420cd9c:	48 b8 87 c9 20 04 80 	movabs $0x800420c987,%rax
  800420cda3:	00 00 00 
  800420cda6:	ff d0                	callq  *%rax
  800420cda8:	48 98                	cltq   
  800420cdaa:	eb 70                	jmp    800420ce1c <syscall+0x232>
		case SYS_env_set_trapframe:
			return sys_env_set_trapframe((envid_t)a1,(struct Trapframe *)a2);
  800420cdac:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cdb0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cdb4:	48 89 d6             	mov    %rdx,%rsi
  800420cdb7:	89 c7                	mov    %eax,%edi
  800420cdb9:	48 b8 5f c3 20 04 80 	movabs $0x800420c35f,%rax
  800420cdc0:	00 00 00 
  800420cdc3:	ff d0                	callq  *%rax
  800420cdc5:	48 98                	cltq   
  800420cdc7:	eb 53                	jmp    800420ce1c <syscall+0x232>
		case SYS_time_msec:
			return sys_time_msec();
  800420cdc9:	48 b8 e2 ca 20 04 80 	movabs $0x800420cae2,%rax
  800420cdd0:	00 00 00 
  800420cdd3:	ff d0                	callq  *%rax
  800420cdd5:	48 98                	cltq   
  800420cdd7:	eb 43                	jmp    800420ce1c <syscall+0x232>
		case SYS_send_packet:
			return sys_send_packet((void *)a1, (size_t)a2);
  800420cdd9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cddd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cde1:	48 89 d6             	mov    %rdx,%rsi
  800420cde4:	48 89 c7             	mov    %rax,%rdi
  800420cde7:	48 b8 f4 ca 20 04 80 	movabs $0x800420caf4,%rax
  800420cdee:	00 00 00 
  800420cdf1:	ff d0                	callq  *%rax
  800420cdf3:	48 98                	cltq   
  800420cdf5:	eb 25                	jmp    800420ce1c <syscall+0x232>
		case SYS_receive_packet:
			return sys_receive_packet((void *)a1, (size_t)a2);
  800420cdf7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420cdfb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cdff:	48 89 d6             	mov    %rdx,%rsi
  800420ce02:	48 89 c7             	mov    %rax,%rdi
  800420ce05:	48 b8 6f cb 20 04 80 	movabs $0x800420cb6f,%rax
  800420ce0c:	00 00 00 
  800420ce0f:	ff d0                	callq  *%rax
  800420ce11:	48 98                	cltq   
  800420ce13:	eb 07                	jmp    800420ce1c <syscall+0x232>
       	 	default:
                	return -E_INVAL;
  800420ce15:	48 c7 c0 fd ff ff ff 	mov    $0xfffffffffffffffd,%rax

	}
}
  800420ce1c:	c9                   	leaveq 
  800420ce1d:	c3                   	retq   
	...

000000800420ce20 <list_func_die>:
	const char *stabstr;
	const char *stabstr_end;
};

int list_func_die(struct Ripdebuginfo *info, Dwarf_Die *die, uint64_t addr)
{
  800420ce20:	55                   	push   %rbp
  800420ce21:	48 89 e5             	mov    %rsp,%rbp
  800420ce24:	48 81 ec b0 61 00 00 	sub    $0x61b0,%rsp
  800420ce2b:	48 89 bd a8 9e ff ff 	mov    %rdi,-0x6158(%rbp)
  800420ce32:	48 89 b5 a0 9e ff ff 	mov    %rsi,-0x6160(%rbp)
  800420ce39:	48 89 95 98 9e ff ff 	mov    %rdx,-0x6168(%rbp)
	_Dwarf_Line ln;
	Dwarf_Attribute *low;
	Dwarf_Attribute *high;
	Dwarf_CU *cu = die->cu_header;
  800420ce40:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420ce47:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  800420ce4e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	Dwarf_Die *cudie = die->cu_die; 
  800420ce52:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420ce59:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420ce60:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Dwarf_Die ret, sib=*die; 
  800420ce64:	48 8b 95 a0 9e ff ff 	mov    -0x6160(%rbp),%rdx
  800420ce6b:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420ce72:	48 89 d1             	mov    %rdx,%rcx
  800420ce75:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420ce7a:	48 89 ce             	mov    %rcx,%rsi
  800420ce7d:	48 89 c7             	mov    %rax,%rdi
  800420ce80:	48 b8 f5 e7 20 04 80 	movabs $0x800420e7f5,%rax
  800420ce87:	00 00 00 
  800420ce8a:	ff d0                	callq  *%rax
	Dwarf_Attribute *attr;
	uint64_t offset;
	uint64_t ret_val=8;
  800420ce8c:	48 c7 45 f8 08 00 00 	movq   $0x8,-0x8(%rbp)
  800420ce93:	00 
	
	if(die->die_tag != DW_TAG_subprogram)
  800420ce94:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420ce9b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420ce9f:	48 83 f8 2e          	cmp    $0x2e,%rax
  800420cea3:	74 0a                	je     800420ceaf <list_func_die+0x8f>
		return 0;
  800420cea5:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ceaa:	e9 de 04 00 00       	jmpq   800420d38d <list_func_die+0x56d>

	memset(&ln, 0, sizeof(_Dwarf_Line));
  800420ceaf:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420ceb3:	ba 38 00 00 00       	mov    $0x38,%edx
  800420ceb8:	be 00 00 00 00       	mov    $0x0,%esi
  800420cebd:	48 89 c7             	mov    %rax,%rdi
  800420cec0:	48 b8 53 e6 20 04 80 	movabs $0x800420e653,%rax
  800420cec7:	00 00 00 
  800420ceca:	ff d0                	callq  *%rax

	low  = _dwarf_attr_find(die, DW_AT_low_pc);
  800420cecc:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420ced3:	be 11 00 00 00       	mov    $0x11,%esi
  800420ced8:	48 89 c7             	mov    %rax,%rdi
  800420cedb:	48 b8 c4 05 21 04 80 	movabs $0x80042105c4,%rax
  800420cee2:	00 00 00 
  800420cee5:	ff d0                	callq  *%rax
  800420cee7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	high = _dwarf_attr_find(die, DW_AT_high_pc);
  800420ceeb:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420cef2:	be 12 00 00 00       	mov    $0x12,%esi
  800420cef7:	48 89 c7             	mov    %rax,%rdi
  800420cefa:	48 b8 c4 05 21 04 80 	movabs $0x80042105c4,%rax
  800420cf01:	00 00 00 
  800420cf04:	ff d0                	callq  *%rax
  800420cf06:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	if((low && (low->u[0].u64 < addr)) && (high && (high->u[0].u64 > addr)))
  800420cf0a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420cf0f:	0f 84 73 04 00 00    	je     800420d388 <list_func_die+0x568>
  800420cf15:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cf19:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420cf1d:	48 3b 85 98 9e ff ff 	cmp    -0x6168(%rbp),%rax
  800420cf24:	0f 83 5e 04 00 00    	jae    800420d388 <list_func_die+0x568>
  800420cf2a:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420cf2f:	0f 84 53 04 00 00    	je     800420d388 <list_func_die+0x568>
  800420cf35:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420cf39:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420cf3d:	48 3b 85 98 9e ff ff 	cmp    -0x6168(%rbp),%rax
  800420cf44:	0f 86 3e 04 00 00    	jbe    800420d388 <list_func_die+0x568>
	{
		info->rip_file = die->cu_die->die_name;
  800420cf4a:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420cf51:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420cf58:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420cf5f:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420cf66:	48 89 10             	mov    %rdx,(%rax)

		info->rip_fn_name = die->die_name;
  800420cf69:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420cf70:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420cf77:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420cf7e:	48 89 50 10          	mov    %rdx,0x10(%rax)
        info->rip_fn_namelen = strlen(die->die_name);
  800420cf82:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420cf89:	48 8b 80 50 03 00 00 	mov    0x350(%rax),%rax
  800420cf90:	48 89 c7             	mov    %rax,%rdi
  800420cf93:	48 b8 50 e3 20 04 80 	movabs $0x800420e350,%rax
  800420cf9a:	00 00 00 
  800420cf9d:	ff d0                	callq  *%rax
  800420cf9f:	48 8b 95 a8 9e ff ff 	mov    -0x6158(%rbp),%rdx
  800420cfa6:	89 42 18             	mov    %eax,0x18(%rdx)

		info->rip_fn_addr = (uintptr_t)low->u[0].u64;
  800420cfa9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420cfad:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420cfb1:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420cfb8:	48 89 50 20          	mov    %rdx,0x20(%rax)

		assert(die->cu_die);	
  800420cfbc:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420cfc3:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420cfca:	48 85 c0             	test   %rax,%rax
  800420cfcd:	75 35                	jne    800420d004 <list_func_die+0x1e4>
  800420cfcf:	48 b9 b8 8b 21 04 80 	movabs $0x8004218bb8,%rcx
  800420cfd6:	00 00 00 
  800420cfd9:	48 ba c4 8b 21 04 80 	movabs $0x8004218bc4,%rdx
  800420cfe0:	00 00 00 
  800420cfe3:	be 72 00 00 00       	mov    $0x72,%esi
  800420cfe8:	48 bf d9 8b 21 04 80 	movabs $0x8004218bd9,%rdi
  800420cfef:	00 00 00 
  800420cff2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cff7:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420cffe:	00 00 00 
  800420d001:	41 ff d0             	callq  *%r8
		dwarf_srclines(die->cu_die, &ln, addr, NULL); 
  800420d004:	48 8b 85 a0 9e ff ff 	mov    -0x6160(%rbp),%rax
  800420d00b:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420d012:	48 8b 95 98 9e ff ff 	mov    -0x6168(%rbp),%rdx
  800420d019:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  800420d01d:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420d022:	48 89 c7             	mov    %rax,%rdi
  800420d025:	48 b8 63 3c 21 04 80 	movabs $0x8004213c63,%rax
  800420d02c:	00 00 00 
  800420d02f:	ff d0                	callq  *%rax

		info->rip_line = ln.ln_lineno;
  800420d031:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420d035:	89 c2                	mov    %eax,%edx
  800420d037:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420d03e:	89 50 08             	mov    %edx,0x8(%rax)
		info->rip_fn_narg = 0;
  800420d041:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420d048:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)

		Dwarf_Attribute* attr;

		if(dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
  800420d04f:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  800420d056:	00 00 00 
  800420d059:	48 8b 00             	mov    (%rax),%rax
  800420d05c:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420d063:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420d06a:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  800420d06e:	48 89 c7             	mov    %rax,%rdi
  800420d071:	48 b8 9b 08 21 04 80 	movabs $0x800421089b,%rax
  800420d078:	00 00 00 
  800420d07b:	ff d0                	callq  *%rax
  800420d07d:	83 f8 04             	cmp    $0x4,%eax
  800420d080:	0f 84 fb 02 00 00    	je     800420d381 <list_func_die+0x561>
		{
			if(ret.die_tag != DW_TAG_formal_parameter)
  800420d086:	48 8b 85 38 cf ff ff 	mov    -0x30c8(%rbp),%rax
  800420d08d:	48 83 f8 05          	cmp    $0x5,%rax
  800420d091:	0f 85 e6 02 00 00    	jne    800420d37d <list_func_die+0x55d>
				goto last;

			attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420d097:	48 8d 85 20 cf ff ff 	lea    -0x30e0(%rbp),%rax
  800420d09e:	be 49 00 00 00       	mov    $0x49,%esi
  800420d0a3:	48 89 c7             	mov    %rax,%rdi
  800420d0a6:	48 b8 c4 05 21 04 80 	movabs $0x80042105c4,%rax
  800420d0ad:	00 00 00 
  800420d0b0:	ff d0                	callq  *%rax
  800420d0b2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	
try_again:
			if(attr != NULL)
  800420d0b6:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420d0bb:	0f 84 d7 00 00 00    	je     800420d198 <list_func_die+0x378>
			{
				offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420d0c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d0c5:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420d0c9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d0cd:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d0d1:	48 01 d0             	add    %rdx,%rax
  800420d0d4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
				dwarf_offdie(dbg, offset, &sib, *cu);
  800420d0d8:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  800420d0df:	00 00 00 
  800420d0e2:	48 8b 08             	mov    (%rax),%rcx
  800420d0e5:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420d0ec:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  800420d0f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d0f4:	48 8b 38             	mov    (%rax),%rdi
  800420d0f7:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420d0fb:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420d0ff:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420d104:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420d108:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420d10d:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420d111:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420d116:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420d11a:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420d11f:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420d123:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420d128:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420d12c:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420d131:	48 89 cf             	mov    %rcx,%rdi
  800420d134:	48 b8 c1 04 21 04 80 	movabs $0x80042104c1,%rax
  800420d13b:	00 00 00 
  800420d13e:	ff d0                	callq  *%rax
				attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420d140:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420d147:	be 0b 00 00 00       	mov    $0xb,%esi
  800420d14c:	48 89 c7             	mov    %rax,%rdi
  800420d14f:	48 b8 c4 05 21 04 80 	movabs $0x80042105c4,%rax
  800420d156:	00 00 00 
  800420d159:	ff d0                	callq  *%rax
  800420d15b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		
				if(attr != NULL)
  800420d15f:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420d164:	74 0e                	je     800420d174 <list_func_die+0x354>
				{
					ret_val = attr->u[0].u64;
  800420d166:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d16a:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d16e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420d172:	eb 24                	jmp    800420d198 <list_func_die+0x378>
				}
				else
				{
					attr = _dwarf_attr_find(&sib, DW_AT_type);
  800420d174:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420d17b:	be 49 00 00 00       	mov    $0x49,%esi
  800420d180:	48 89 c7             	mov    %rax,%rdi
  800420d183:	48 b8 c4 05 21 04 80 	movabs $0x80042105c4,%rax
  800420d18a:	00 00 00 
  800420d18d:	ff d0                	callq  *%rax
  800420d18f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
					goto try_again;
  800420d193:	e9 1e ff ff ff       	jmpq   800420d0b6 <list_func_die+0x296>
				}
			}
			info->size_fn_arg[info->rip_fn_narg] = ret_val;
  800420d198:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420d19f:	8b 48 28             	mov    0x28(%rax),%ecx
  800420d1a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d1a6:	89 c2                	mov    %eax,%edx
  800420d1a8:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420d1af:	48 63 c9             	movslq %ecx,%rcx
  800420d1b2:	48 83 c1 08          	add    $0x8,%rcx
  800420d1b6:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
			info->rip_fn_narg++;
  800420d1ba:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420d1c1:	8b 40 28             	mov    0x28(%rax),%eax
  800420d1c4:	8d 50 01             	lea    0x1(%rax),%edx
  800420d1c7:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420d1ce:	89 50 28             	mov    %edx,0x28(%rax)
			sib = ret; 
  800420d1d1:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420d1d8:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420d1df:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420d1e4:	48 89 ce             	mov    %rcx,%rsi
  800420d1e7:	48 89 c7             	mov    %rax,%rdi
  800420d1ea:	48 b8 f5 e7 20 04 80 	movabs $0x800420e7f5,%rax
  800420d1f1:	00 00 00 
  800420d1f4:	ff d0                	callq  *%rax

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420d1f6:	e9 4a 01 00 00       	jmpq   800420d345 <list_func_die+0x525>
			{
				if(ret.die_tag != DW_TAG_formal_parameter)
  800420d1fb:	48 8b 85 38 cf ff ff 	mov    -0x30c8(%rbp),%rax
  800420d202:	48 83 f8 05          	cmp    $0x5,%rax
  800420d206:	0f 85 74 01 00 00    	jne    800420d380 <list_func_die+0x560>
					break;

				attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420d20c:	48 8d 85 20 cf ff ff 	lea    -0x30e0(%rbp),%rax
  800420d213:	be 49 00 00 00       	mov    $0x49,%esi
  800420d218:	48 89 c7             	mov    %rax,%rdi
  800420d21b:	48 b8 c4 05 21 04 80 	movabs $0x80042105c4,%rax
  800420d222:	00 00 00 
  800420d225:	ff d0                	callq  *%rax
  800420d227:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    
   		        if(attr != NULL)
  800420d22b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420d230:	0f 84 b1 00 00 00    	je     800420d2e7 <list_func_die+0x4c7>
            	{	   
                	offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420d236:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d23a:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420d23e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d242:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d246:	48 01 d0             	add    %rdx,%rax
  800420d249:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                	dwarf_offdie(dbg, offset, &sib, *cu);
  800420d24d:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  800420d254:	00 00 00 
  800420d257:	48 8b 08             	mov    (%rax),%rcx
  800420d25a:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420d261:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  800420d265:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d269:	48 8b 38             	mov    (%rax),%rdi
  800420d26c:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420d270:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420d274:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420d279:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420d27d:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420d282:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420d286:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420d28b:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420d28f:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420d294:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420d298:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420d29d:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420d2a1:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420d2a6:	48 89 cf             	mov    %rcx,%rdi
  800420d2a9:	48 b8 c1 04 21 04 80 	movabs $0x80042104c1,%rax
  800420d2b0:	00 00 00 
  800420d2b3:	ff d0                	callq  *%rax
                	attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420d2b5:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420d2bc:	be 0b 00 00 00       	mov    $0xb,%esi
  800420d2c1:	48 89 c7             	mov    %rax,%rdi
  800420d2c4:	48 b8 c4 05 21 04 80 	movabs $0x80042105c4,%rax
  800420d2cb:	00 00 00 
  800420d2ce:	ff d0                	callq  *%rax
  800420d2d0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        
       		        if(attr != NULL)
  800420d2d4:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420d2d9:	74 0c                	je     800420d2e7 <list_func_die+0x4c7>
                	{
                    	ret_val = attr->u[0].u64;
  800420d2db:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d2df:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420d2e3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                	}
            	}
	
				info->size_fn_arg[info->rip_fn_narg]=ret_val;// _get_arg_size(ret);
  800420d2e7:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420d2ee:	8b 48 28             	mov    0x28(%rax),%ecx
  800420d2f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d2f5:	89 c2                	mov    %eax,%edx
  800420d2f7:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420d2fe:	48 63 c9             	movslq %ecx,%rcx
  800420d301:	48 83 c1 08          	add    $0x8,%rcx
  800420d305:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
				info->rip_fn_narg++;
  800420d309:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420d310:	8b 40 28             	mov    0x28(%rax),%eax
  800420d313:	8d 50 01             	lea    0x1(%rax),%edx
  800420d316:	48 8b 85 a8 9e ff ff 	mov    -0x6158(%rbp),%rax
  800420d31d:	89 50 28             	mov    %edx,0x28(%rax)
				sib = ret; 
  800420d320:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420d327:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420d32e:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420d333:	48 89 ce             	mov    %rcx,%rsi
  800420d336:	48 89 c7             	mov    %rax,%rdi
  800420d339:	48 b8 f5 e7 20 04 80 	movabs $0x800420e7f5,%rax
  800420d340:	00 00 00 
  800420d343:	ff d0                	callq  *%rax
			}
			info->size_fn_arg[info->rip_fn_narg] = ret_val;
			info->rip_fn_narg++;
			sib = ret; 

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420d345:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  800420d34c:	00 00 00 
  800420d34f:	48 8b 00             	mov    (%rax),%rax
  800420d352:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d356:	48 8d 95 20 cf ff ff 	lea    -0x30e0(%rbp),%rdx
  800420d35d:	48 8d b5 b0 9e ff ff 	lea    -0x6150(%rbp),%rsi
  800420d364:	48 89 c7             	mov    %rax,%rdi
  800420d367:	48 b8 57 06 21 04 80 	movabs $0x8004210657,%rax
  800420d36e:	00 00 00 
  800420d371:	ff d0                	callq  *%rax
  800420d373:	85 c0                	test   %eax,%eax
  800420d375:	0f 84 80 fe ff ff    	je     800420d1fb <list_func_die+0x3db>
  800420d37b:	eb 04                	jmp    800420d381 <list_func_die+0x561>
		Dwarf_Attribute* attr;

		if(dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
		{
			if(ret.die_tag != DW_TAG_formal_parameter)
				goto last;
  800420d37d:	90                   	nop
  800420d37e:	eb 01                	jmp    800420d381 <list_func_die+0x561>
			sib = ret; 

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
			{
				if(ret.die_tag != DW_TAG_formal_parameter)
					break;
  800420d380:	90                   	nop
				info->rip_fn_narg++;
				sib = ret; 
			}
		}
last:	
		return 1;
  800420d381:	b8 01 00 00 00       	mov    $0x1,%eax
  800420d386:	eb 05                	jmp    800420d38d <list_func_die+0x56d>
	}

	return 0;
  800420d388:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420d38d:	c9                   	leaveq 
  800420d38e:	c3                   	retq   

000000800420d38f <debuginfo_rip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_rip(uintptr_t addr, struct Ripdebuginfo *info)
{
  800420d38f:	55                   	push   %rbp
  800420d390:	48 89 e5             	mov    %rsp,%rbp
  800420d393:	48 81 ec c0 91 00 00 	sub    $0x91c0,%rsp
  800420d39a:	48 89 bd 48 6e ff ff 	mov    %rdi,-0x91b8(%rbp)
  800420d3a1:	48 89 b5 40 6e ff ff 	mov    %rsi,-0x91c0(%rbp)
    static struct Env* lastenv = NULL;
    void* elf;    
    Dwarf_Section *sect;
    Dwarf_CU cu;
    Dwarf_Die die, cudie, die2;
    Dwarf_Regtable *rt = NULL;
  800420d3a8:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420d3af:	00 
    //Set up initial pc
    uint64_t pc  = (uintptr_t)addr;
  800420d3b0:	48 8b 85 48 6e ff ff 	mov    -0x91b8(%rbp),%rax
  800420d3b7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    
    // Initialize *info
    info->rip_file = "<unknown>";
  800420d3bb:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420d3c2:	48 ba e7 8b 21 04 80 	movabs $0x8004218be7,%rdx
  800420d3c9:	00 00 00 
  800420d3cc:	48 89 10             	mov    %rdx,(%rax)
    info->rip_line = 0;
  800420d3cf:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420d3d6:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
    info->rip_fn_name = "<unknown>";
  800420d3dd:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420d3e4:	48 ba e7 8b 21 04 80 	movabs $0x8004218be7,%rdx
  800420d3eb:	00 00 00 
  800420d3ee:	48 89 50 10          	mov    %rdx,0x10(%rax)
    info->rip_fn_namelen = 9;
  800420d3f2:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420d3f9:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
    info->rip_fn_addr = addr;
  800420d400:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420d407:	48 8b 95 48 6e ff ff 	mov    -0x91b8(%rbp),%rdx
  800420d40e:	48 89 50 20          	mov    %rdx,0x20(%rax)
    info->rip_fn_narg = 0;
  800420d412:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420d419:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
    
    // Find the relevant set of stabs
    if (addr >= ULIM) {
  800420d420:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420d427:	00 00 00 
  800420d42a:	48 39 85 48 6e ff ff 	cmp    %rax,-0x91b8(%rbp)
  800420d431:	76 13                	jbe    800420d446 <debuginfo_rip+0xb7>
	    elf = (void *)0x10000 + KERNBASE;
  800420d433:	c7 45 f8 00 00 01 04 	movl   $0x4010000,-0x8(%rbp)
  800420d43a:	c7 45 fc 80 00 00 00 	movl   $0x80,-0x4(%rbp)
  800420d441:	e9 f4 00 00 00       	jmpq   800420d53a <debuginfo_rip+0x1ab>
    } else {
	    if(curenv != lastenv) {
  800420d446:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420d44d:	00 00 00 
  800420d450:	ff d0                	callq  *%rax
  800420d452:	48 98                	cltq   
  800420d454:	48 c1 e0 03          	shl    $0x3,%rax
  800420d458:	48 89 c2             	mov    %rax,%rdx
  800420d45b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d45f:	48 29 c2             	sub    %rax,%rdx
  800420d462:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420d469:	00 00 00 
  800420d46c:	48 01 d0             	add    %rdx,%rax
  800420d46f:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420d473:	48 b8 10 c3 63 04 80 	movabs $0x800463c310,%rax
  800420d47a:	00 00 00 
  800420d47d:	48 8b 00             	mov    (%rax),%rax
  800420d480:	48 39 c2             	cmp    %rax,%rdx
  800420d483:	74 7d                	je     800420d502 <debuginfo_rip+0x173>
		    find_debug_sections((uintptr_t)curenv->elf);
  800420d485:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420d48c:	00 00 00 
  800420d48f:	ff d0                	callq  *%rax
  800420d491:	48 98                	cltq   
  800420d493:	48 c1 e0 03          	shl    $0x3,%rax
  800420d497:	48 89 c2             	mov    %rax,%rdx
  800420d49a:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d49e:	48 29 c2             	sub    %rax,%rdx
  800420d4a1:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420d4a8:	00 00 00 
  800420d4ab:	48 01 d0             	add    %rdx,%rax
  800420d4ae:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420d4b2:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420d4b9:	48 89 c7             	mov    %rax,%rdi
  800420d4bc:	48 b8 60 3e 21 04 80 	movabs $0x8004213e60,%rax
  800420d4c3:	00 00 00 
  800420d4c6:	ff d0                	callq  *%rax
		    lastenv = curenv;
  800420d4c8:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420d4cf:	00 00 00 
  800420d4d2:	ff d0                	callq  *%rax
  800420d4d4:	48 98                	cltq   
  800420d4d6:	48 c1 e0 03          	shl    $0x3,%rax
  800420d4da:	48 89 c2             	mov    %rax,%rdx
  800420d4dd:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d4e1:	48 29 c2             	sub    %rax,%rdx
  800420d4e4:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420d4eb:	00 00 00 
  800420d4ee:	48 01 d0             	add    %rdx,%rax
  800420d4f1:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420d4f5:	48 b8 10 c3 63 04 80 	movabs $0x800463c310,%rax
  800420d4fc:	00 00 00 
  800420d4ff:	48 89 10             	mov    %rdx,(%rax)
	    }
	    elf = curenv->elf;
  800420d502:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  800420d509:	00 00 00 
  800420d50c:	ff d0                	callq  *%rax
  800420d50e:	48 98                	cltq   
  800420d510:	48 c1 e0 03          	shl    $0x3,%rax
  800420d514:	48 89 c2             	mov    %rax,%rdx
  800420d517:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d51b:	48 29 c2             	sub    %rax,%rdx
  800420d51e:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800420d525:	00 00 00 
  800420d528:	48 01 d0             	add    %rdx,%rax
  800420d52b:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420d52f:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420d536:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    }
    
    
    _dwarf_init(dbg, elf);
  800420d53a:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  800420d541:	00 00 00 
  800420d544:	48 8b 00             	mov    (%rax),%rax
  800420d547:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420d54b:	48 89 d6             	mov    %rdx,%rsi
  800420d54e:	48 89 c7             	mov    %rax,%rdi
  800420d551:	48 b8 96 f4 20 04 80 	movabs $0x800420f496,%rax
  800420d558:	00 00 00 
  800420d55b:	ff d0                	callq  *%rax

    sect = _dwarf_find_section(".debug_info");	
  800420d55d:	48 bf f1 8b 21 04 80 	movabs $0x8004218bf1,%rdi
  800420d564:	00 00 00 
  800420d567:	48 b8 e0 3d 21 04 80 	movabs $0x8004213de0,%rax
  800420d56e:	00 00 00 
  800420d571:	ff d0                	callq  *%rax
  800420d573:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
  800420d577:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  800420d57e:	00 00 00 
  800420d581:	48 8b 00             	mov    (%rax),%rax
  800420d584:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d588:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420d58c:	48 89 50 08          	mov    %rdx,0x8(%rax)
    dbg->dbg_info_size = sect->ds_size;
  800420d590:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  800420d597:	00 00 00 
  800420d59a:	48 8b 00             	mov    (%rax),%rax
  800420d59d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d5a1:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  800420d5a5:	48 89 50 10          	mov    %rdx,0x10(%rax)
    
    assert(dbg->dbg_info_size);
  800420d5a9:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  800420d5b0:	00 00 00 
  800420d5b3:	48 8b 00             	mov    (%rax),%rax
  800420d5b6:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420d5ba:	48 85 c0             	test   %rax,%rax
  800420d5bd:	0f 85 74 01 00 00    	jne    800420d737 <debuginfo_rip+0x3a8>
  800420d5c3:	48 b9 fd 8b 21 04 80 	movabs $0x8004218bfd,%rcx
  800420d5ca:	00 00 00 
  800420d5cd:	48 ba c4 8b 21 04 80 	movabs $0x8004218bc4,%rdx
  800420d5d4:	00 00 00 
  800420d5d7:	be e3 00 00 00       	mov    $0xe3,%esi
  800420d5dc:	48 bf d9 8b 21 04 80 	movabs $0x8004218bd9,%rdi
  800420d5e3:	00 00 00 
  800420d5e6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d5eb:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420d5f2:	00 00 00 
  800420d5f5:	41 ff d0             	callq  *%r8
    while(_get_next_cu(dbg, &cu) == 0)
    {
	    if(dwarf_siblingof(dbg, NULL, &cudie, &cu) == DW_DLE_NO_ENTRY)
  800420d5f8:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  800420d5ff:	00 00 00 
  800420d602:	48 8b 00             	mov    (%rax),%rax
  800420d605:	48 8d 4d a0          	lea    -0x60(%rbp),%rcx
  800420d609:	48 8d 95 c0 9e ff ff 	lea    -0x6140(%rbp),%rdx
  800420d610:	be 00 00 00 00       	mov    $0x0,%esi
  800420d615:	48 89 c7             	mov    %rax,%rdi
  800420d618:	48 b8 57 06 21 04 80 	movabs $0x8004210657,%rax
  800420d61f:	00 00 00 
  800420d622:	ff d0                	callq  *%rax
  800420d624:	83 f8 04             	cmp    $0x4,%eax
  800420d627:	0f 84 0d 01 00 00    	je     800420d73a <debuginfo_rip+0x3ab>
	    {
		    continue;
	    }	
	    cudie.cu_header = &cu;
  800420d62d:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420d631:	48 89 85 20 a2 ff ff 	mov    %rax,-0x5de0(%rbp)
	    cudie.cu_die = NULL;
  800420d638:	48 c7 85 28 a2 ff ff 	movq   $0x0,-0x5dd8(%rbp)
  800420d63f:	00 00 00 00 
	    
	    if(dwarf_child(dbg, &cu, &cudie, &die) == DW_DLE_NO_ENTRY)
  800420d643:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  800420d64a:	00 00 00 
  800420d64d:	48 8b 00             	mov    (%rax),%rax
  800420d650:	48 8d 8d 30 cf ff ff 	lea    -0x30d0(%rbp),%rcx
  800420d657:	48 8d 95 c0 9e ff ff 	lea    -0x6140(%rbp),%rdx
  800420d65e:	48 8d 75 a0          	lea    -0x60(%rbp),%rsi
  800420d662:	48 89 c7             	mov    %rax,%rdi
  800420d665:	48 b8 9b 08 21 04 80 	movabs $0x800421089b,%rax
  800420d66c:	00 00 00 
  800420d66f:	ff d0                	callq  *%rax
  800420d671:	83 f8 04             	cmp    $0x4,%eax
  800420d674:	0f 84 c3 00 00 00    	je     800420d73d <debuginfo_rip+0x3ae>
	    {
		    continue;
	    }	
	    die.cu_header = &cu;
  800420d67a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420d67e:	48 89 85 90 d2 ff ff 	mov    %rax,-0x2d70(%rbp)
	    die.cu_die = &cudie;
  800420d685:	48 8d 85 c0 9e ff ff 	lea    -0x6140(%rbp),%rax
  800420d68c:	48 89 85 98 d2 ff ff 	mov    %rax,-0x2d68(%rbp)
	    while(1)
	    {
		    if(list_func_die(info, &die, addr))
  800420d693:	48 8b 95 48 6e ff ff 	mov    -0x91b8(%rbp),%rdx
  800420d69a:	48 8d 8d 30 cf ff ff 	lea    -0x30d0(%rbp),%rcx
  800420d6a1:	48 8b 85 40 6e ff ff 	mov    -0x91c0(%rbp),%rax
  800420d6a8:	48 89 ce             	mov    %rcx,%rsi
  800420d6ab:	48 89 c7             	mov    %rax,%rdi
  800420d6ae:	48 b8 20 ce 20 04 80 	movabs $0x800420ce20,%rax
  800420d6b5:	00 00 00 
  800420d6b8:	ff d0                	callq  *%rax
  800420d6ba:	85 c0                	test   %eax,%eax
  800420d6bc:	0f 85 b1 00 00 00    	jne    800420d773 <debuginfo_rip+0x3e4>
			    goto find_done;
		    if(dwarf_siblingof(dbg, &die, &die2, &cu) < 0)
  800420d6c2:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  800420d6c9:	00 00 00 
  800420d6cc:	48 8b 00             	mov    (%rax),%rax
  800420d6cf:	48 8d 4d a0          	lea    -0x60(%rbp),%rcx
  800420d6d3:	48 8d 95 50 6e ff ff 	lea    -0x91b0(%rbp),%rdx
  800420d6da:	48 8d b5 30 cf ff ff 	lea    -0x30d0(%rbp),%rsi
  800420d6e1:	48 89 c7             	mov    %rax,%rdi
  800420d6e4:	48 b8 57 06 21 04 80 	movabs $0x8004210657,%rax
  800420d6eb:	00 00 00 
  800420d6ee:	ff d0                	callq  *%rax
  800420d6f0:	85 c0                	test   %eax,%eax
  800420d6f2:	78 4c                	js     800420d740 <debuginfo_rip+0x3b1>
			    break; 
		    die = die2;
  800420d6f4:	48 8d 85 30 cf ff ff 	lea    -0x30d0(%rbp),%rax
  800420d6fb:	48 8d 8d 50 6e ff ff 	lea    -0x91b0(%rbp),%rcx
  800420d702:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420d707:	48 89 ce             	mov    %rcx,%rsi
  800420d70a:	48 89 c7             	mov    %rax,%rdi
  800420d70d:	48 b8 f5 e7 20 04 80 	movabs $0x800420e7f5,%rax
  800420d714:	00 00 00 
  800420d717:	ff d0                	callq  *%rax
		    die.cu_header = &cu;
  800420d719:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800420d71d:	48 89 85 90 d2 ff ff 	mov    %rax,-0x2d70(%rbp)
		    die.cu_die = &cudie;
  800420d724:	48 8d 85 c0 9e ff ff 	lea    -0x6140(%rbp),%rax
  800420d72b:	48 89 85 98 d2 ff ff 	mov    %rax,-0x2d68(%rbp)
	    }
  800420d732:	e9 5c ff ff ff       	jmpq   800420d693 <debuginfo_rip+0x304>
    sect = _dwarf_find_section(".debug_info");	
    dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
    dbg->dbg_info_size = sect->ds_size;
    
    assert(dbg->dbg_info_size);
    while(_get_next_cu(dbg, &cu) == 0)
  800420d737:	90                   	nop
  800420d738:	eb 07                	jmp    800420d741 <debuginfo_rip+0x3b2>
    {
	    if(dwarf_siblingof(dbg, NULL, &cudie, &cu) == DW_DLE_NO_ENTRY)
	    {
		    continue;
  800420d73a:	90                   	nop
  800420d73b:	eb 04                	jmp    800420d741 <debuginfo_rip+0x3b2>
	    cudie.cu_header = &cu;
	    cudie.cu_die = NULL;
	    
	    if(dwarf_child(dbg, &cu, &cudie, &die) == DW_DLE_NO_ENTRY)
	    {
		    continue;
  800420d73d:	90                   	nop
  800420d73e:	eb 01                	jmp    800420d741 <debuginfo_rip+0x3b2>
	    while(1)
	    {
		    if(list_func_die(info, &die, addr))
			    goto find_done;
		    if(dwarf_siblingof(dbg, &die, &die2, &cu) < 0)
			    break; 
  800420d740:	90                   	nop
    sect = _dwarf_find_section(".debug_info");	
    dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
    dbg->dbg_info_size = sect->ds_size;
    
    assert(dbg->dbg_info_size);
    while(_get_next_cu(dbg, &cu) == 0)
  800420d741:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  800420d748:	00 00 00 
  800420d74b:	48 8b 00             	mov    (%rax),%rax
  800420d74e:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  800420d752:	48 89 d6             	mov    %rdx,%rsi
  800420d755:	48 89 c7             	mov    %rax,%rdi
  800420d758:	48 b8 72 f5 20 04 80 	movabs $0x800420f572,%rax
  800420d75f:	00 00 00 
  800420d762:	ff d0                	callq  *%rax
  800420d764:	85 c0                	test   %eax,%eax
  800420d766:	0f 84 8c fe ff ff    	je     800420d5f8 <debuginfo_rip+0x269>
		    die.cu_header = &cu;
		    die.cu_die = &cudie;
	    }
    }
    
    return -1;
  800420d76c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420d771:	eb 06                	jmp    800420d779 <debuginfo_rip+0x3ea>
	    die.cu_header = &cu;
	    die.cu_die = &cudie;
	    while(1)
	    {
		    if(list_func_die(info, &die, addr))
			    goto find_done;
  800420d773:	90                   	nop
    }
    
    return -1;

find_done:
    return 0;
  800420d774:	b8 00 00 00 00       	mov    $0x0,%eax

}
  800420d779:	c9                   	leaveq 
  800420d77a:	c3                   	retq   
	...

000000800420d77c <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800420d77c:	55                   	push   %rbp
  800420d77d:	48 89 e5             	mov    %rsp,%rbp
  800420d780:	48 83 ec 30          	sub    $0x30,%rsp
  800420d784:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420d788:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420d78c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420d790:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
  800420d793:	44 89 45 e0          	mov    %r8d,-0x20(%rbp)
  800420d797:	44 89 4d dc          	mov    %r9d,-0x24(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800420d79b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420d79e:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800420d7a2:	77 52                	ja     800420d7f6 <printnum+0x7a>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800420d7a4:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800420d7a7:	44 8d 40 ff          	lea    -0x1(%rax),%r8d
  800420d7ab:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800420d7ae:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420d7b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d7b6:	ba 00 00 00 00       	mov    $0x0,%edx
  800420d7bb:	48 f7 75 d0          	divq   -0x30(%rbp)
  800420d7bf:	48 89 c2             	mov    %rax,%rdx
  800420d7c2:	8b 7d dc             	mov    -0x24(%rbp),%edi
  800420d7c5:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420d7c8:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420d7cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d7d0:	41 89 f9             	mov    %edi,%r9d
  800420d7d3:	48 89 c7             	mov    %rax,%rdi
  800420d7d6:	48 b8 7c d7 20 04 80 	movabs $0x800420d77c,%rax
  800420d7dd:	00 00 00 
  800420d7e0:	ff d0                	callq  *%rax
  800420d7e2:	eb 1c                	jmp    800420d800 <printnum+0x84>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  800420d7e4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d7e8:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420d7eb:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800420d7ef:	48 89 d6             	mov    %rdx,%rsi
  800420d7f2:	89 c7                	mov    %eax,%edi
  800420d7f4:	ff d1                	callq  *%rcx
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420d7f6:	83 6d e0 01          	subl   $0x1,-0x20(%rbp)
  800420d7fa:	83 7d e0 00          	cmpl   $0x0,-0x20(%rbp)
  800420d7fe:	7f e4                	jg     800420d7e4 <printnum+0x68>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800420d800:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420d803:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d807:	ba 00 00 00 00       	mov    $0x0,%edx
  800420d80c:	48 f7 f1             	div    %rcx
  800420d80f:	48 89 d0             	mov    %rdx,%rax
  800420d812:	48 ba e8 8d 21 04 80 	movabs $0x8004218de8,%rdx
  800420d819:	00 00 00 
  800420d81c:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  800420d820:	0f be c0             	movsbl %al,%eax
  800420d823:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d827:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800420d82b:	48 89 d6             	mov    %rdx,%rsi
  800420d82e:	89 c7                	mov    %eax,%edi
  800420d830:	ff d1                	callq  *%rcx
}
  800420d832:	c9                   	leaveq 
  800420d833:	c3                   	retq   

000000800420d834 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800420d834:	55                   	push   %rbp
  800420d835:	48 89 e5             	mov    %rsp,%rbp
  800420d838:	48 83 ec 20          	sub    $0x20,%rsp
  800420d83c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420d840:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  800420d843:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420d847:	7e 52                	jle    800420d89b <getuint+0x67>
		x= va_arg(*ap, unsigned long long);
  800420d849:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d84d:	8b 00                	mov    (%rax),%eax
  800420d84f:	83 f8 30             	cmp    $0x30,%eax
  800420d852:	73 24                	jae    800420d878 <getuint+0x44>
  800420d854:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d858:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420d85c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d860:	8b 00                	mov    (%rax),%eax
  800420d862:	89 c0                	mov    %eax,%eax
  800420d864:	48 01 d0             	add    %rdx,%rax
  800420d867:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d86b:	8b 12                	mov    (%rdx),%edx
  800420d86d:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420d870:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d874:	89 0a                	mov    %ecx,(%rdx)
  800420d876:	eb 17                	jmp    800420d88f <getuint+0x5b>
  800420d878:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d87c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420d880:	48 89 d0             	mov    %rdx,%rax
  800420d883:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420d887:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d88b:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420d88f:	48 8b 00             	mov    (%rax),%rax
  800420d892:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420d896:	e9 a3 00 00 00       	jmpq   800420d93e <getuint+0x10a>
	else if (lflag)
  800420d89b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420d89f:	74 4f                	je     800420d8f0 <getuint+0xbc>
		x= va_arg(*ap, unsigned long);
  800420d8a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d8a5:	8b 00                	mov    (%rax),%eax
  800420d8a7:	83 f8 30             	cmp    $0x30,%eax
  800420d8aa:	73 24                	jae    800420d8d0 <getuint+0x9c>
  800420d8ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d8b0:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420d8b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d8b8:	8b 00                	mov    (%rax),%eax
  800420d8ba:	89 c0                	mov    %eax,%eax
  800420d8bc:	48 01 d0             	add    %rdx,%rax
  800420d8bf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d8c3:	8b 12                	mov    (%rdx),%edx
  800420d8c5:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420d8c8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d8cc:	89 0a                	mov    %ecx,(%rdx)
  800420d8ce:	eb 17                	jmp    800420d8e7 <getuint+0xb3>
  800420d8d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d8d4:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420d8d8:	48 89 d0             	mov    %rdx,%rax
  800420d8db:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420d8df:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d8e3:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420d8e7:	48 8b 00             	mov    (%rax),%rax
  800420d8ea:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420d8ee:	eb 4e                	jmp    800420d93e <getuint+0x10a>
	else
		x= va_arg(*ap, unsigned int);
  800420d8f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d8f4:	8b 00                	mov    (%rax),%eax
  800420d8f6:	83 f8 30             	cmp    $0x30,%eax
  800420d8f9:	73 24                	jae    800420d91f <getuint+0xeb>
  800420d8fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d8ff:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420d903:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d907:	8b 00                	mov    (%rax),%eax
  800420d909:	89 c0                	mov    %eax,%eax
  800420d90b:	48 01 d0             	add    %rdx,%rax
  800420d90e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d912:	8b 12                	mov    (%rdx),%edx
  800420d914:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420d917:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d91b:	89 0a                	mov    %ecx,(%rdx)
  800420d91d:	eb 17                	jmp    800420d936 <getuint+0x102>
  800420d91f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d923:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420d927:	48 89 d0             	mov    %rdx,%rax
  800420d92a:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420d92e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d932:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420d936:	8b 00                	mov    (%rax),%eax
  800420d938:	89 c0                	mov    %eax,%eax
  800420d93a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420d93e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420d942:	c9                   	leaveq 
  800420d943:	c3                   	retq   

000000800420d944 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  800420d944:	55                   	push   %rbp
  800420d945:	48 89 e5             	mov    %rsp,%rbp
  800420d948:	48 83 ec 20          	sub    $0x20,%rsp
  800420d94c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420d950:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  800420d953:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420d957:	7e 52                	jle    800420d9ab <getint+0x67>
		x=va_arg(*ap, long long);
  800420d959:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d95d:	8b 00                	mov    (%rax),%eax
  800420d95f:	83 f8 30             	cmp    $0x30,%eax
  800420d962:	73 24                	jae    800420d988 <getint+0x44>
  800420d964:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d968:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420d96c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d970:	8b 00                	mov    (%rax),%eax
  800420d972:	89 c0                	mov    %eax,%eax
  800420d974:	48 01 d0             	add    %rdx,%rax
  800420d977:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d97b:	8b 12                	mov    (%rdx),%edx
  800420d97d:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420d980:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d984:	89 0a                	mov    %ecx,(%rdx)
  800420d986:	eb 17                	jmp    800420d99f <getint+0x5b>
  800420d988:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d98c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420d990:	48 89 d0             	mov    %rdx,%rax
  800420d993:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420d997:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d99b:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420d99f:	48 8b 00             	mov    (%rax),%rax
  800420d9a2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420d9a6:	e9 a3 00 00 00       	jmpq   800420da4e <getint+0x10a>
	else if (lflag)
  800420d9ab:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420d9af:	74 4f                	je     800420da00 <getint+0xbc>
		x=va_arg(*ap, long);
  800420d9b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d9b5:	8b 00                	mov    (%rax),%eax
  800420d9b7:	83 f8 30             	cmp    $0x30,%eax
  800420d9ba:	73 24                	jae    800420d9e0 <getint+0x9c>
  800420d9bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d9c0:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420d9c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d9c8:	8b 00                	mov    (%rax),%eax
  800420d9ca:	89 c0                	mov    %eax,%eax
  800420d9cc:	48 01 d0             	add    %rdx,%rax
  800420d9cf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d9d3:	8b 12                	mov    (%rdx),%edx
  800420d9d5:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420d9d8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d9dc:	89 0a                	mov    %ecx,(%rdx)
  800420d9de:	eb 17                	jmp    800420d9f7 <getint+0xb3>
  800420d9e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d9e4:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420d9e8:	48 89 d0             	mov    %rdx,%rax
  800420d9eb:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420d9ef:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d9f3:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420d9f7:	48 8b 00             	mov    (%rax),%rax
  800420d9fa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420d9fe:	eb 4e                	jmp    800420da4e <getint+0x10a>
	else
		x=va_arg(*ap, int);
  800420da00:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420da04:	8b 00                	mov    (%rax),%eax
  800420da06:	83 f8 30             	cmp    $0x30,%eax
  800420da09:	73 24                	jae    800420da2f <getint+0xeb>
  800420da0b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420da0f:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420da13:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420da17:	8b 00                	mov    (%rax),%eax
  800420da19:	89 c0                	mov    %eax,%eax
  800420da1b:	48 01 d0             	add    %rdx,%rax
  800420da1e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420da22:	8b 12                	mov    (%rdx),%edx
  800420da24:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420da27:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420da2b:	89 0a                	mov    %ecx,(%rdx)
  800420da2d:	eb 17                	jmp    800420da46 <getint+0x102>
  800420da2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420da33:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420da37:	48 89 d0             	mov    %rdx,%rax
  800420da3a:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420da3e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420da42:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420da46:	8b 00                	mov    (%rax),%eax
  800420da48:	48 98                	cltq   
  800420da4a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420da4e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420da52:	c9                   	leaveq 
  800420da53:	c3                   	retq   

000000800420da54 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800420da54:	55                   	push   %rbp
  800420da55:	48 89 e5             	mov    %rsp,%rbp
  800420da58:	41 54                	push   %r12
  800420da5a:	53                   	push   %rbx
  800420da5b:	48 83 ec 60          	sub    $0x60,%rsp
  800420da5f:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420da63:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420da67:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420da6b:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  800420da6f:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420da73:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420da77:	48 8b 0a             	mov    (%rdx),%rcx
  800420da7a:	48 89 08             	mov    %rcx,(%rax)
  800420da7d:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420da81:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420da85:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420da89:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420da8d:	eb 17                	jmp    800420daa6 <vprintfmt+0x52>
			if (ch == '\0')
  800420da8f:	85 db                	test   %ebx,%ebx
  800420da91:	0f 84 d7 04 00 00    	je     800420df6e <vprintfmt+0x51a>
				return;
			putch(ch, putdat);
  800420da97:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420da9b:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420da9f:	48 89 c6             	mov    %rax,%rsi
  800420daa2:	89 df                	mov    %ebx,%edi
  800420daa4:	ff d2                	callq  *%rdx
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420daa6:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420daaa:	0f b6 00             	movzbl (%rax),%eax
  800420daad:	0f b6 d8             	movzbl %al,%ebx
  800420dab0:	83 fb 25             	cmp    $0x25,%ebx
  800420dab3:	0f 95 c0             	setne  %al
  800420dab6:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
  800420dabb:	84 c0                	test   %al,%al
  800420dabd:	75 d0                	jne    800420da8f <vprintfmt+0x3b>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
  800420dabf:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  800420dac3:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  800420daca:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  800420dad1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  800420dad8:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  800420dadf:	eb 04                	jmp    800420dae5 <vprintfmt+0x91>
			goto process_precision;

		case '.':
			if (width < 0)
				width = 0;
			goto reswitch;
  800420dae1:	90                   	nop
  800420dae2:	eb 01                	jmp    800420dae5 <vprintfmt+0x91>
			goto reswitch;

		process_precision:
			if (width < 0)
				width = precision, precision = -1;
			goto reswitch;
  800420dae4:	90                   	nop
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800420dae5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420dae9:	0f b6 00             	movzbl (%rax),%eax
  800420daec:	0f b6 d8             	movzbl %al,%ebx
  800420daef:	89 d8                	mov    %ebx,%eax
  800420daf1:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
  800420daf6:	83 e8 23             	sub    $0x23,%eax
  800420daf9:	83 f8 55             	cmp    $0x55,%eax
  800420dafc:	0f 87 38 04 00 00    	ja     800420df3a <vprintfmt+0x4e6>
  800420db02:	89 c0                	mov    %eax,%eax
  800420db04:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420db0b:	00 
  800420db0c:	48 b8 10 8e 21 04 80 	movabs $0x8004218e10,%rax
  800420db13:	00 00 00 
  800420db16:	48 01 d0             	add    %rdx,%rax
  800420db19:	48 8b 00             	mov    (%rax),%rax
  800420db1c:	ff e0                	jmpq   *%rax

		// flag to pad on the right
		case '-':
			padc = '-';
  800420db1e:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  800420db22:	eb c1                	jmp    800420dae5 <vprintfmt+0x91>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  800420db24:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  800420db28:	eb bb                	jmp    800420dae5 <vprintfmt+0x91>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420db2a:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  800420db31:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800420db34:	89 d0                	mov    %edx,%eax
  800420db36:	c1 e0 02             	shl    $0x2,%eax
  800420db39:	01 d0                	add    %edx,%eax
  800420db3b:	01 c0                	add    %eax,%eax
  800420db3d:	01 d8                	add    %ebx,%eax
  800420db3f:	83 e8 30             	sub    $0x30,%eax
  800420db42:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  800420db45:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420db49:	0f b6 00             	movzbl (%rax),%eax
  800420db4c:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  800420db4f:	83 fb 2f             	cmp    $0x2f,%ebx
  800420db52:	7e 63                	jle    800420dbb7 <vprintfmt+0x163>
  800420db54:	83 fb 39             	cmp    $0x39,%ebx
  800420db57:	7f 5e                	jg     800420dbb7 <vprintfmt+0x163>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420db59:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  800420db5e:	eb d1                	jmp    800420db31 <vprintfmt+0xdd>
			goto process_precision;

		case '*':
			precision = va_arg(aq, int);
  800420db60:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420db63:	83 f8 30             	cmp    $0x30,%eax
  800420db66:	73 17                	jae    800420db7f <vprintfmt+0x12b>
  800420db68:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420db6c:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420db6f:	89 c0                	mov    %eax,%eax
  800420db71:	48 01 d0             	add    %rdx,%rax
  800420db74:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420db77:	83 c2 08             	add    $0x8,%edx
  800420db7a:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420db7d:	eb 0f                	jmp    800420db8e <vprintfmt+0x13a>
  800420db7f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420db83:	48 89 d0             	mov    %rdx,%rax
  800420db86:	48 83 c2 08          	add    $0x8,%rdx
  800420db8a:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420db8e:	8b 00                	mov    (%rax),%eax
  800420db90:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  800420db93:	eb 23                	jmp    800420dbb8 <vprintfmt+0x164>

		case '.':
			if (width < 0)
  800420db95:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420db99:	0f 89 42 ff ff ff    	jns    800420dae1 <vprintfmt+0x8d>
				width = 0;
  800420db9f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  800420dba6:	e9 36 ff ff ff       	jmpq   800420dae1 <vprintfmt+0x8d>

		case '#':
			altflag = 1;
  800420dbab:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  800420dbb2:	e9 2e ff ff ff       	jmpq   800420dae5 <vprintfmt+0x91>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
  800420dbb7:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
  800420dbb8:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420dbbc:	0f 89 22 ff ff ff    	jns    800420dae4 <vprintfmt+0x90>
				width = precision, precision = -1;
  800420dbc2:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420dbc5:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800420dbc8:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  800420dbcf:	e9 10 ff ff ff       	jmpq   800420dae4 <vprintfmt+0x90>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  800420dbd4:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  800420dbd8:	e9 08 ff ff ff       	jmpq   800420dae5 <vprintfmt+0x91>

		// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  800420dbdd:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420dbe0:	83 f8 30             	cmp    $0x30,%eax
  800420dbe3:	73 17                	jae    800420dbfc <vprintfmt+0x1a8>
  800420dbe5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420dbe9:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420dbec:	89 c0                	mov    %eax,%eax
  800420dbee:	48 01 d0             	add    %rdx,%rax
  800420dbf1:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420dbf4:	83 c2 08             	add    $0x8,%edx
  800420dbf7:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420dbfa:	eb 0f                	jmp    800420dc0b <vprintfmt+0x1b7>
  800420dbfc:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420dc00:	48 89 d0             	mov    %rdx,%rax
  800420dc03:	48 83 c2 08          	add    $0x8,%rdx
  800420dc07:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420dc0b:	8b 00                	mov    (%rax),%eax
  800420dc0d:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420dc11:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420dc15:	48 89 d6             	mov    %rdx,%rsi
  800420dc18:	89 c7                	mov    %eax,%edi
  800420dc1a:	ff d1                	callq  *%rcx
			break;
  800420dc1c:	e9 47 03 00 00       	jmpq   800420df68 <vprintfmt+0x514>

		// error message
		case 'e':
			err = va_arg(aq, int);
  800420dc21:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420dc24:	83 f8 30             	cmp    $0x30,%eax
  800420dc27:	73 17                	jae    800420dc40 <vprintfmt+0x1ec>
  800420dc29:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420dc2d:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420dc30:	89 c0                	mov    %eax,%eax
  800420dc32:	48 01 d0             	add    %rdx,%rax
  800420dc35:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420dc38:	83 c2 08             	add    $0x8,%edx
  800420dc3b:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420dc3e:	eb 0f                	jmp    800420dc4f <vprintfmt+0x1fb>
  800420dc40:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420dc44:	48 89 d0             	mov    %rdx,%rax
  800420dc47:	48 83 c2 08          	add    $0x8,%rdx
  800420dc4b:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420dc4f:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  800420dc51:	85 db                	test   %ebx,%ebx
  800420dc53:	79 02                	jns    800420dc57 <vprintfmt+0x203>
				err = -err;
  800420dc55:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  800420dc57:	83 fb 10             	cmp    $0x10,%ebx
  800420dc5a:	7f 16                	jg     800420dc72 <vprintfmt+0x21e>
  800420dc5c:	48 b8 60 8d 21 04 80 	movabs $0x8004218d60,%rax
  800420dc63:	00 00 00 
  800420dc66:	48 63 d3             	movslq %ebx,%rdx
  800420dc69:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  800420dc6d:	4d 85 e4             	test   %r12,%r12
  800420dc70:	75 2e                	jne    800420dca0 <vprintfmt+0x24c>
				printfmt(putch, putdat, "error %d", err);
  800420dc72:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420dc76:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420dc7a:	89 d9                	mov    %ebx,%ecx
  800420dc7c:	48 ba f9 8d 21 04 80 	movabs $0x8004218df9,%rdx
  800420dc83:	00 00 00 
  800420dc86:	48 89 c7             	mov    %rax,%rdi
  800420dc89:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dc8e:	49 b8 78 df 20 04 80 	movabs $0x800420df78,%r8
  800420dc95:	00 00 00 
  800420dc98:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  800420dc9b:	e9 c8 02 00 00       	jmpq   800420df68 <vprintfmt+0x514>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  800420dca0:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420dca4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420dca8:	4c 89 e1             	mov    %r12,%rcx
  800420dcab:	48 ba 02 8e 21 04 80 	movabs $0x8004218e02,%rdx
  800420dcb2:	00 00 00 
  800420dcb5:	48 89 c7             	mov    %rax,%rdi
  800420dcb8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dcbd:	49 b8 78 df 20 04 80 	movabs $0x800420df78,%r8
  800420dcc4:	00 00 00 
  800420dcc7:	41 ff d0             	callq  *%r8
			break;
  800420dcca:	e9 99 02 00 00       	jmpq   800420df68 <vprintfmt+0x514>

		// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  800420dccf:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420dcd2:	83 f8 30             	cmp    $0x30,%eax
  800420dcd5:	73 17                	jae    800420dcee <vprintfmt+0x29a>
  800420dcd7:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420dcdb:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420dcde:	89 c0                	mov    %eax,%eax
  800420dce0:	48 01 d0             	add    %rdx,%rax
  800420dce3:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420dce6:	83 c2 08             	add    $0x8,%edx
  800420dce9:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420dcec:	eb 0f                	jmp    800420dcfd <vprintfmt+0x2a9>
  800420dcee:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420dcf2:	48 89 d0             	mov    %rdx,%rax
  800420dcf5:	48 83 c2 08          	add    $0x8,%rdx
  800420dcf9:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420dcfd:	4c 8b 20             	mov    (%rax),%r12
  800420dd00:	4d 85 e4             	test   %r12,%r12
  800420dd03:	75 0a                	jne    800420dd0f <vprintfmt+0x2bb>
				p = "(null)";
  800420dd05:	49 bc 05 8e 21 04 80 	movabs $0x8004218e05,%r12
  800420dd0c:	00 00 00 
			if (width > 0 && padc != '-')
  800420dd0f:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420dd13:	7e 7a                	jle    800420dd8f <vprintfmt+0x33b>
  800420dd15:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  800420dd19:	74 74                	je     800420dd8f <vprintfmt+0x33b>
				for (width -= strnlen(p, precision); width > 0; width--)
  800420dd1b:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420dd1e:	48 98                	cltq   
  800420dd20:	48 89 c6             	mov    %rax,%rsi
  800420dd23:	4c 89 e7             	mov    %r12,%rdi
  800420dd26:	48 b8 7e e3 20 04 80 	movabs $0x800420e37e,%rax
  800420dd2d:	00 00 00 
  800420dd30:	ff d0                	callq  *%rax
  800420dd32:	29 45 dc             	sub    %eax,-0x24(%rbp)
  800420dd35:	eb 17                	jmp    800420dd4e <vprintfmt+0x2fa>
					putch(padc, putdat);
  800420dd37:	0f be 45 d3          	movsbl -0x2d(%rbp),%eax
  800420dd3b:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420dd3f:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420dd43:	48 89 d6             	mov    %rdx,%rsi
  800420dd46:	89 c7                	mov    %eax,%edi
  800420dd48:	ff d1                	callq  *%rcx
		// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800420dd4a:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420dd4e:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420dd52:	7f e3                	jg     800420dd37 <vprintfmt+0x2e3>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420dd54:	eb 39                	jmp    800420dd8f <vprintfmt+0x33b>
				if (altflag && (ch < ' ' || ch > '~'))
  800420dd56:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  800420dd5a:	74 1e                	je     800420dd7a <vprintfmt+0x326>
  800420dd5c:	83 fb 1f             	cmp    $0x1f,%ebx
  800420dd5f:	7e 05                	jle    800420dd66 <vprintfmt+0x312>
  800420dd61:	83 fb 7e             	cmp    $0x7e,%ebx
  800420dd64:	7e 14                	jle    800420dd7a <vprintfmt+0x326>
					putch('?', putdat);
  800420dd66:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420dd6a:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420dd6e:	48 89 c6             	mov    %rax,%rsi
  800420dd71:	bf 3f 00 00 00       	mov    $0x3f,%edi
  800420dd76:	ff d2                	callq  *%rdx
  800420dd78:	eb 0f                	jmp    800420dd89 <vprintfmt+0x335>
				else
					putch(ch, putdat);
  800420dd7a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420dd7e:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420dd82:	48 89 c6             	mov    %rax,%rsi
  800420dd85:	89 df                	mov    %ebx,%edi
  800420dd87:	ff d2                	callq  *%rdx
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420dd89:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420dd8d:	eb 01                	jmp    800420dd90 <vprintfmt+0x33c>
  800420dd8f:	90                   	nop
  800420dd90:	41 0f b6 04 24       	movzbl (%r12),%eax
  800420dd95:	0f be d8             	movsbl %al,%ebx
  800420dd98:	85 db                	test   %ebx,%ebx
  800420dd9a:	0f 95 c0             	setne  %al
  800420dd9d:	49 83 c4 01          	add    $0x1,%r12
  800420dda1:	84 c0                	test   %al,%al
  800420dda3:	74 28                	je     800420ddcd <vprintfmt+0x379>
  800420dda5:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420dda9:	78 ab                	js     800420dd56 <vprintfmt+0x302>
  800420ddab:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  800420ddaf:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420ddb3:	79 a1                	jns    800420dd56 <vprintfmt+0x302>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420ddb5:	eb 16                	jmp    800420ddcd <vprintfmt+0x379>
				putch(' ', putdat);
  800420ddb7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420ddbb:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420ddbf:	48 89 c6             	mov    %rax,%rsi
  800420ddc2:	bf 20 00 00 00       	mov    $0x20,%edi
  800420ddc7:	ff d2                	callq  *%rdx
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420ddc9:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420ddcd:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420ddd1:	7f e4                	jg     800420ddb7 <vprintfmt+0x363>
				putch(' ', putdat);
			break;
  800420ddd3:	e9 90 01 00 00       	jmpq   800420df68 <vprintfmt+0x514>

		// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  800420ddd8:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420dddc:	be 03 00 00 00       	mov    $0x3,%esi
  800420dde1:	48 89 c7             	mov    %rax,%rdi
  800420dde4:	48 b8 44 d9 20 04 80 	movabs $0x800420d944,%rax
  800420ddeb:	00 00 00 
  800420ddee:	ff d0                	callq  *%rax
  800420ddf0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  800420ddf4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ddf8:	48 85 c0             	test   %rax,%rax
  800420ddfb:	79 1d                	jns    800420de1a <vprintfmt+0x3c6>
				putch('-', putdat);
  800420ddfd:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420de01:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420de05:	48 89 c6             	mov    %rax,%rsi
  800420de08:	bf 2d 00 00 00       	mov    $0x2d,%edi
  800420de0d:	ff d2                	callq  *%rdx
				num = -(long long) num;
  800420de0f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420de13:	48 f7 d8             	neg    %rax
  800420de16:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  800420de1a:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420de21:	e9 d5 00 00 00       	jmpq   800420defb <vprintfmt+0x4a7>
                        
			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  800420de26:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420de2a:	be 03 00 00 00       	mov    $0x3,%esi
  800420de2f:	48 89 c7             	mov    %rax,%rdi
  800420de32:	48 b8 34 d8 20 04 80 	movabs $0x800420d834,%rax
  800420de39:	00 00 00 
  800420de3c:	ff d0                	callq  *%rax
  800420de3e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  800420de42:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420de49:	e9 ad 00 00 00       	jmpq   800420defb <vprintfmt+0x4a7>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			num = getuint(&aq, 3);
  800420de4e:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420de52:	be 03 00 00 00       	mov    $0x3,%esi
  800420de57:	48 89 c7             	mov    %rax,%rdi
  800420de5a:	48 b8 34 d8 20 04 80 	movabs $0x800420d834,%rax
  800420de61:	00 00 00 
  800420de64:	ff d0                	callq  *%rax
  800420de66:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                        base = 8;
  800420de6a:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
			goto number;
  800420de71:	e9 85 00 00 00       	jmpq   800420defb <vprintfmt+0x4a7>
			putch('X', putdat);
		*/	break;

		// pointer
		case 'p':
			putch('0', putdat);
  800420de76:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420de7a:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420de7e:	48 89 c6             	mov    %rax,%rsi
  800420de81:	bf 30 00 00 00       	mov    $0x30,%edi
  800420de86:	ff d2                	callq  *%rdx
			putch('x', putdat);
  800420de88:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420de8c:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420de90:	48 89 c6             	mov    %rax,%rsi
  800420de93:	bf 78 00 00 00       	mov    $0x78,%edi
  800420de98:	ff d2                	callq  *%rdx
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  800420de9a:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420de9d:	83 f8 30             	cmp    $0x30,%eax
  800420dea0:	73 17                	jae    800420deb9 <vprintfmt+0x465>
  800420dea2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420dea6:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420dea9:	89 c0                	mov    %eax,%eax
  800420deab:	48 01 d0             	add    %rdx,%rax
  800420deae:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420deb1:	83 c2 08             	add    $0x8,%edx
  800420deb4:	89 55 b8             	mov    %edx,-0x48(%rbp)

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420deb7:	eb 0f                	jmp    800420dec8 <vprintfmt+0x474>
				(uintptr_t) va_arg(aq, void *);
  800420deb9:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420debd:	48 89 d0             	mov    %rdx,%rax
  800420dec0:	48 83 c2 08          	add    $0x8,%rdx
  800420dec4:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420dec8:	48 8b 00             	mov    (%rax),%rax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420decb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  800420decf:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  800420ded6:	eb 23                	jmp    800420defb <vprintfmt+0x4a7>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  800420ded8:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420dedc:	be 03 00 00 00       	mov    $0x3,%esi
  800420dee1:	48 89 c7             	mov    %rax,%rdi
  800420dee4:	48 b8 34 d8 20 04 80 	movabs $0x800420d834,%rax
  800420deeb:	00 00 00 
  800420deee:	ff d0                	callq  *%rax
  800420def0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  800420def4:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  800420defb:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  800420df00:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420df03:	8b 7d dc             	mov    -0x24(%rbp),%edi
  800420df06:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420df0a:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420df0e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420df12:	45 89 c1             	mov    %r8d,%r9d
  800420df15:	41 89 f8             	mov    %edi,%r8d
  800420df18:	48 89 c7             	mov    %rax,%rdi
  800420df1b:	48 b8 7c d7 20 04 80 	movabs $0x800420d77c,%rax
  800420df22:	00 00 00 
  800420df25:	ff d0                	callq  *%rax
			break;
  800420df27:	eb 3f                	jmp    800420df68 <vprintfmt+0x514>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
  800420df29:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420df2d:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420df31:	48 89 c6             	mov    %rax,%rsi
  800420df34:	89 df                	mov    %ebx,%edi
  800420df36:	ff d2                	callq  *%rdx
			break;
  800420df38:	eb 2e                	jmp    800420df68 <vprintfmt+0x514>

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  800420df3a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420df3e:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420df42:	48 89 c6             	mov    %rax,%rsi
  800420df45:	bf 25 00 00 00       	mov    $0x25,%edi
  800420df4a:	ff d2                	callq  *%rdx
			for (fmt--; fmt[-1] != '%'; fmt--)
  800420df4c:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420df51:	eb 05                	jmp    800420df58 <vprintfmt+0x504>
  800420df53:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420df58:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420df5c:	48 83 e8 01          	sub    $0x1,%rax
  800420df60:	0f b6 00             	movzbl (%rax),%eax
  800420df63:	3c 25                	cmp    $0x25,%al
  800420df65:	75 ec                	jne    800420df53 <vprintfmt+0x4ff>
				/* do nothing */;
			break;
  800420df67:	90                   	nop
		}
	}
  800420df68:	90                   	nop
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420df69:	e9 38 fb ff ff       	jmpq   800420daa6 <vprintfmt+0x52>
			if (ch == '\0')
				return;
  800420df6e:	90                   	nop
				/* do nothing */;
			break;
		}
	}
    va_end(aq);
}
  800420df6f:	48 83 c4 60          	add    $0x60,%rsp
  800420df73:	5b                   	pop    %rbx
  800420df74:	41 5c                	pop    %r12
  800420df76:	5d                   	pop    %rbp
  800420df77:	c3                   	retq   

000000800420df78 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  800420df78:	55                   	push   %rbp
  800420df79:	48 89 e5             	mov    %rsp,%rbp
  800420df7c:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420df83:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420df8a:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  800420df91:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420df98:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420df9f:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420dfa6:	84 c0                	test   %al,%al
  800420dfa8:	74 20                	je     800420dfca <printfmt+0x52>
  800420dfaa:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420dfae:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420dfb2:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420dfb6:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420dfba:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420dfbe:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420dfc2:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420dfc6:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420dfca:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800420dfd1:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420dfd8:	00 00 00 
  800420dfdb:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420dfe2:	00 00 00 
  800420dfe5:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420dfe9:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800420dff0:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420dff7:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  800420dffe:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  800420e005:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800420e00c:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  800420e013:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420e01a:	48 89 c7             	mov    %rax,%rdi
  800420e01d:	48 b8 54 da 20 04 80 	movabs $0x800420da54,%rax
  800420e024:	00 00 00 
  800420e027:	ff d0                	callq  *%rax
	va_end(ap);
}
  800420e029:	c9                   	leaveq 
  800420e02a:	c3                   	retq   

000000800420e02b <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  800420e02b:	55                   	push   %rbp
  800420e02c:	48 89 e5             	mov    %rsp,%rbp
  800420e02f:	48 83 ec 10          	sub    $0x10,%rsp
  800420e033:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420e036:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  800420e03a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e03e:	8b 40 10             	mov    0x10(%rax),%eax
  800420e041:	8d 50 01             	lea    0x1(%rax),%edx
  800420e044:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e048:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  800420e04b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e04f:	48 8b 10             	mov    (%rax),%rdx
  800420e052:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e056:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420e05a:	48 39 c2             	cmp    %rax,%rdx
  800420e05d:	73 17                	jae    800420e076 <sprintputch+0x4b>
		*b->buf++ = ch;
  800420e05f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e063:	48 8b 00             	mov    (%rax),%rax
  800420e066:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420e069:	88 10                	mov    %dl,(%rax)
  800420e06b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e06f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e073:	48 89 10             	mov    %rdx,(%rax)
}
  800420e076:	c9                   	leaveq 
  800420e077:	c3                   	retq   

000000800420e078 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  800420e078:	55                   	push   %rbp
  800420e079:	48 89 e5             	mov    %rsp,%rbp
  800420e07c:	48 83 ec 50          	sub    $0x50,%rsp
  800420e080:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420e084:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  800420e087:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420e08b:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  800420e08f:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  800420e093:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420e097:	48 8b 0a             	mov    (%rdx),%rcx
  800420e09a:	48 89 08             	mov    %rcx,(%rax)
  800420e09d:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420e0a1:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420e0a5:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420e0a9:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  800420e0ad:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e0b1:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420e0b5:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420e0b8:	48 98                	cltq   
  800420e0ba:	48 83 e8 01          	sub    $0x1,%rax
  800420e0be:	48 03 45 c8          	add    -0x38(%rbp),%rax
  800420e0c2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420e0c6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  800420e0cd:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420e0d2:	74 06                	je     800420e0da <vsnprintf+0x62>
  800420e0d4:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800420e0d8:	7f 07                	jg     800420e0e1 <vsnprintf+0x69>
		return -E_INVAL;
  800420e0da:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e0df:	eb 2f                	jmp    800420e110 <vsnprintf+0x98>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  800420e0e1:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420e0e5:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420e0e9:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  800420e0ed:	48 89 c6             	mov    %rax,%rsi
  800420e0f0:	48 bf 2b e0 20 04 80 	movabs $0x800420e02b,%rdi
  800420e0f7:	00 00 00 
  800420e0fa:	48 b8 54 da 20 04 80 	movabs $0x800420da54,%rax
  800420e101:	00 00 00 
  800420e104:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  800420e106:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e10a:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  800420e10d:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  800420e110:	c9                   	leaveq 
  800420e111:	c3                   	retq   

000000800420e112 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  800420e112:	55                   	push   %rbp
  800420e113:	48 89 e5             	mov    %rsp,%rbp
  800420e116:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  800420e11d:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  800420e124:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  800420e12a:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420e131:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420e138:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420e13f:	84 c0                	test   %al,%al
  800420e141:	74 20                	je     800420e163 <snprintf+0x51>
  800420e143:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420e147:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420e14b:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420e14f:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420e153:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420e157:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420e15b:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420e15f:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420e163:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  800420e16a:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  800420e171:	00 00 00 
  800420e174:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  800420e17b:	00 00 00 
  800420e17e:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420e182:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  800420e189:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420e190:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  800420e197:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800420e19e:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  800420e1a5:	48 8b 0a             	mov    (%rdx),%rcx
  800420e1a8:	48 89 08             	mov    %rcx,(%rax)
  800420e1ab:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420e1af:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420e1b3:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420e1b7:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  800420e1bb:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  800420e1c2:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  800420e1c9:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  800420e1cf:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800420e1d6:	48 89 c7             	mov    %rax,%rdi
  800420e1d9:	48 b8 78 e0 20 04 80 	movabs $0x800420e078,%rax
  800420e1e0:	00 00 00 
  800420e1e3:	ff d0                	callq  *%rax
  800420e1e5:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  800420e1eb:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  800420e1f1:	c9                   	leaveq 
  800420e1f2:	c3                   	retq   
	...

000000800420e1f4 <readline>:
#define BUFLEN 1024
static char buf[BUFLEN];

char *
readline(const char *prompt)
{
  800420e1f4:	55                   	push   %rbp
  800420e1f5:	48 89 e5             	mov    %rsp,%rbp
  800420e1f8:	48 83 ec 20          	sub    $0x20,%rsp
  800420e1fc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i, c, echoing;

#if JOS_KERNEL
	if (prompt != NULL)
  800420e200:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e205:	74 22                	je     800420e229 <readline+0x35>
		cprintf("%s", prompt);
  800420e207:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e20b:	48 89 c6             	mov    %rax,%rsi
  800420e20e:	48 bf c0 90 21 04 80 	movabs $0x80042190c0,%rdi
  800420e215:	00 00 00 
  800420e218:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e21d:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420e224:	00 00 00 
  800420e227:	ff d2                	callq  *%rdx
#else
	if (prompt != NULL)
		fprintf(1, "%s", prompt);
#endif

	i = 0;
  800420e229:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	echoing = iscons(0);
  800420e230:	bf 00 00 00 00       	mov    $0x0,%edi
  800420e235:	48 b8 ea 12 20 04 80 	movabs $0x80042012ea,%rax
  800420e23c:	00 00 00 
  800420e23f:	ff d0                	callq  *%rax
  800420e241:	89 45 f8             	mov    %eax,-0x8(%rbp)
  800420e244:	eb 01                	jmp    800420e247 <readline+0x53>
			if (echoing)
				cputchar('\n');
			buf[i] = 0;
			return buf;
		}
	}
  800420e246:	90                   	nop
#endif

	i = 0;
	echoing = iscons(0);
	while (1) {
		c = getchar();
  800420e247:	48 b8 c8 12 20 04 80 	movabs $0x80042012c8,%rax
  800420e24e:	00 00 00 
  800420e251:	ff d0                	callq  *%rax
  800420e253:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (c < 0) {
  800420e256:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420e25a:	79 30                	jns    800420e28c <readline+0x98>
			if (c != -E_EOF)
  800420e25c:	83 7d f4 f7          	cmpl   $0xfffffff7,-0xc(%rbp)
  800420e260:	74 20                	je     800420e282 <readline+0x8e>
				cprintf("read error: %e\n", c);
  800420e262:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e265:	89 c6                	mov    %eax,%esi
  800420e267:	48 bf c3 90 21 04 80 	movabs $0x80042190c3,%rdi
  800420e26e:	00 00 00 
  800420e271:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e276:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800420e27d:	00 00 00 
  800420e280:	ff d2                	callq  *%rdx
			return NULL;
  800420e282:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e287:	e9 c0 00 00 00       	jmpq   800420e34c <readline+0x158>
		} else if ((c == '\b' || c == '\x7f') && i > 0) {
  800420e28c:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  800420e290:	74 06                	je     800420e298 <readline+0xa4>
  800420e292:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%rbp)
  800420e296:	75 26                	jne    800420e2be <readline+0xca>
  800420e298:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e29c:	7e 20                	jle    800420e2be <readline+0xca>
			if (echoing)
  800420e29e:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420e2a2:	74 11                	je     800420e2b5 <readline+0xc1>
				cputchar('\b');
  800420e2a4:	bf 08 00 00 00       	mov    $0x8,%edi
  800420e2a9:	48 b8 aa 12 20 04 80 	movabs $0x80042012aa,%rax
  800420e2b0:	00 00 00 
  800420e2b3:	ff d0                	callq  *%rax
			i--;
  800420e2b5:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
  800420e2b9:	e9 89 00 00 00       	jmpq   800420e347 <readline+0x153>
		} else if (c >= ' ' && i < BUFLEN-1) {
  800420e2be:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420e2c2:	7e 3d                	jle    800420e301 <readline+0x10d>
  800420e2c4:	81 7d fc fe 03 00 00 	cmpl   $0x3fe,-0x4(%rbp)
  800420e2cb:	7f 34                	jg     800420e301 <readline+0x10d>
			if (echoing)
  800420e2cd:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420e2d1:	74 11                	je     800420e2e4 <readline+0xf0>
				cputchar(c);
  800420e2d3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e2d6:	89 c7                	mov    %eax,%edi
  800420e2d8:	48 b8 aa 12 20 04 80 	movabs $0x80042012aa,%rax
  800420e2df:	00 00 00 
  800420e2e2:	ff d0                	callq  *%rax
			buf[i++] = c;
  800420e2e4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e2e7:	89 c1                	mov    %eax,%ecx
  800420e2e9:	48 ba 20 c3 63 04 80 	movabs $0x800463c320,%rdx
  800420e2f0:	00 00 00 
  800420e2f3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e2f6:	48 98                	cltq   
  800420e2f8:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
  800420e2fb:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420e2ff:	eb 46                	jmp    800420e347 <readline+0x153>
		} else if (c == '\n' || c == '\r') {
  800420e301:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  800420e305:	74 0a                	je     800420e311 <readline+0x11d>
  800420e307:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  800420e30b:	0f 85 35 ff ff ff    	jne    800420e246 <readline+0x52>
			if (echoing)
  800420e311:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420e315:	74 11                	je     800420e328 <readline+0x134>
				cputchar('\n');
  800420e317:	bf 0a 00 00 00       	mov    $0xa,%edi
  800420e31c:	48 b8 aa 12 20 04 80 	movabs $0x80042012aa,%rax
  800420e323:	00 00 00 
  800420e326:	ff d0                	callq  *%rax
			buf[i] = 0;
  800420e328:	48 ba 20 c3 63 04 80 	movabs $0x800463c320,%rdx
  800420e32f:	00 00 00 
  800420e332:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e335:	48 98                	cltq   
  800420e337:	c6 04 02 00          	movb   $0x0,(%rdx,%rax,1)
			return buf;
  800420e33b:	48 b8 20 c3 63 04 80 	movabs $0x800463c320,%rax
  800420e342:	00 00 00 
  800420e345:	eb 05                	jmp    800420e34c <readline+0x158>
		}
	}
  800420e347:	e9 fa fe ff ff       	jmpq   800420e246 <readline+0x52>
}
  800420e34c:	c9                   	leaveq 
  800420e34d:	c3                   	retq   
	...

000000800420e350 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  800420e350:	55                   	push   %rbp
  800420e351:	48 89 e5             	mov    %rsp,%rbp
  800420e354:	48 83 ec 18          	sub    $0x18,%rsp
  800420e358:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  800420e35c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420e363:	eb 09                	jmp    800420e36e <strlen+0x1e>
		n++;
  800420e365:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  800420e369:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420e36e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e372:	0f b6 00             	movzbl (%rax),%eax
  800420e375:	84 c0                	test   %al,%al
  800420e377:	75 ec                	jne    800420e365 <strlen+0x15>
		n++;
	return n;
  800420e379:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420e37c:	c9                   	leaveq 
  800420e37d:	c3                   	retq   

000000800420e37e <strnlen>:

int
strnlen(const char *s, size_t size)
{
  800420e37e:	55                   	push   %rbp
  800420e37f:	48 89 e5             	mov    %rsp,%rbp
  800420e382:	48 83 ec 20          	sub    $0x20,%rsp
  800420e386:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e38a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420e38e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420e395:	eb 0e                	jmp    800420e3a5 <strnlen+0x27>
		n++;
  800420e397:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420e39b:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420e3a0:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  800420e3a5:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420e3aa:	74 0b                	je     800420e3b7 <strnlen+0x39>
  800420e3ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e3b0:	0f b6 00             	movzbl (%rax),%eax
  800420e3b3:	84 c0                	test   %al,%al
  800420e3b5:	75 e0                	jne    800420e397 <strnlen+0x19>
		n++;
	return n;
  800420e3b7:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420e3ba:	c9                   	leaveq 
  800420e3bb:	c3                   	retq   

000000800420e3bc <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  800420e3bc:	55                   	push   %rbp
  800420e3bd:	48 89 e5             	mov    %rsp,%rbp
  800420e3c0:	48 83 ec 20          	sub    $0x20,%rsp
  800420e3c4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e3c8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  800420e3cc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e3d0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  800420e3d4:	90                   	nop
  800420e3d5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e3d9:	0f b6 10             	movzbl (%rax),%edx
  800420e3dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e3e0:	88 10                	mov    %dl,(%rax)
  800420e3e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e3e6:	0f b6 00             	movzbl (%rax),%eax
  800420e3e9:	84 c0                	test   %al,%al
  800420e3eb:	0f 95 c0             	setne  %al
  800420e3ee:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420e3f3:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
  800420e3f8:	84 c0                	test   %al,%al
  800420e3fa:	75 d9                	jne    800420e3d5 <strcpy+0x19>
		/* do nothing */;
	return ret;
  800420e3fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420e400:	c9                   	leaveq 
  800420e401:	c3                   	retq   

000000800420e402 <strcat>:

char *
strcat(char *dst, const char *src)
{
  800420e402:	55                   	push   %rbp
  800420e403:	48 89 e5             	mov    %rsp,%rbp
  800420e406:	48 83 ec 20          	sub    $0x20,%rsp
  800420e40a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e40e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  800420e412:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e416:	48 89 c7             	mov    %rax,%rdi
  800420e419:	48 b8 50 e3 20 04 80 	movabs $0x800420e350,%rax
  800420e420:	00 00 00 
  800420e423:	ff d0                	callq  *%rax
  800420e425:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  800420e428:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e42b:	48 98                	cltq   
  800420e42d:	48 03 45 e8          	add    -0x18(%rbp),%rax
  800420e431:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420e435:	48 89 d6             	mov    %rdx,%rsi
  800420e438:	48 89 c7             	mov    %rax,%rdi
  800420e43b:	48 b8 bc e3 20 04 80 	movabs $0x800420e3bc,%rax
  800420e442:	00 00 00 
  800420e445:	ff d0                	callq  *%rax
	return dst;
  800420e447:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420e44b:	c9                   	leaveq 
  800420e44c:	c3                   	retq   

000000800420e44d <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  800420e44d:	55                   	push   %rbp
  800420e44e:	48 89 e5             	mov    %rsp,%rbp
  800420e451:	48 83 ec 28          	sub    $0x28,%rsp
  800420e455:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e459:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420e45d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  800420e461:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e465:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  800420e469:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420e470:	00 
  800420e471:	eb 27                	jmp    800420e49a <strncpy+0x4d>
		*dst++ = *src;
  800420e473:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e477:	0f b6 10             	movzbl (%rax),%edx
  800420e47a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e47e:	88 10                	mov    %dl,(%rax)
  800420e480:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  800420e485:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e489:	0f b6 00             	movzbl (%rax),%eax
  800420e48c:	84 c0                	test   %al,%al
  800420e48e:	74 05                	je     800420e495 <strncpy+0x48>
			src++;
  800420e490:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  800420e495:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420e49a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e49e:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420e4a2:	72 cf                	jb     800420e473 <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  800420e4a4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420e4a8:	c9                   	leaveq 
  800420e4a9:	c3                   	retq   

000000800420e4aa <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  800420e4aa:	55                   	push   %rbp
  800420e4ab:	48 89 e5             	mov    %rsp,%rbp
  800420e4ae:	48 83 ec 28          	sub    $0x28,%rsp
  800420e4b2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e4b6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420e4ba:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  800420e4be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e4c2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  800420e4c6:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420e4cb:	74 37                	je     800420e504 <strlcpy+0x5a>
		while (--size > 0 && *src != '\0')
  800420e4cd:	eb 17                	jmp    800420e4e6 <strlcpy+0x3c>
			*dst++ = *src++;
  800420e4cf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e4d3:	0f b6 10             	movzbl (%rax),%edx
  800420e4d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e4da:	88 10                	mov    %dl,(%rax)
  800420e4dc:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420e4e1:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  800420e4e6:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  800420e4eb:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420e4f0:	74 0b                	je     800420e4fd <strlcpy+0x53>
  800420e4f2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e4f6:	0f b6 00             	movzbl (%rax),%eax
  800420e4f9:	84 c0                	test   %al,%al
  800420e4fb:	75 d2                	jne    800420e4cf <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  800420e4fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e501:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  800420e504:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e508:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e50c:	48 89 d1             	mov    %rdx,%rcx
  800420e50f:	48 29 c1             	sub    %rax,%rcx
  800420e512:	48 89 c8             	mov    %rcx,%rax
}
  800420e515:	c9                   	leaveq 
  800420e516:	c3                   	retq   

000000800420e517 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  800420e517:	55                   	push   %rbp
  800420e518:	48 89 e5             	mov    %rsp,%rbp
  800420e51b:	48 83 ec 10          	sub    $0x10,%rsp
  800420e51f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420e523:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  800420e527:	eb 0a                	jmp    800420e533 <strcmp+0x1c>
		p++, q++;
  800420e529:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420e52e:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  800420e533:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e537:	0f b6 00             	movzbl (%rax),%eax
  800420e53a:	84 c0                	test   %al,%al
  800420e53c:	74 12                	je     800420e550 <strcmp+0x39>
  800420e53e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e542:	0f b6 10             	movzbl (%rax),%edx
  800420e545:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e549:	0f b6 00             	movzbl (%rax),%eax
  800420e54c:	38 c2                	cmp    %al,%dl
  800420e54e:	74 d9                	je     800420e529 <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  800420e550:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e554:	0f b6 00             	movzbl (%rax),%eax
  800420e557:	0f b6 d0             	movzbl %al,%edx
  800420e55a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e55e:	0f b6 00             	movzbl (%rax),%eax
  800420e561:	0f b6 c0             	movzbl %al,%eax
  800420e564:	89 d1                	mov    %edx,%ecx
  800420e566:	29 c1                	sub    %eax,%ecx
  800420e568:	89 c8                	mov    %ecx,%eax
}
  800420e56a:	c9                   	leaveq 
  800420e56b:	c3                   	retq   

000000800420e56c <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  800420e56c:	55                   	push   %rbp
  800420e56d:	48 89 e5             	mov    %rsp,%rbp
  800420e570:	48 83 ec 18          	sub    $0x18,%rsp
  800420e574:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420e578:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420e57c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  800420e580:	eb 0f                	jmp    800420e591 <strncmp+0x25>
		n--, p++, q++;
  800420e582:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  800420e587:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420e58c:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  800420e591:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e596:	74 1d                	je     800420e5b5 <strncmp+0x49>
  800420e598:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e59c:	0f b6 00             	movzbl (%rax),%eax
  800420e59f:	84 c0                	test   %al,%al
  800420e5a1:	74 12                	je     800420e5b5 <strncmp+0x49>
  800420e5a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e5a7:	0f b6 10             	movzbl (%rax),%edx
  800420e5aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e5ae:	0f b6 00             	movzbl (%rax),%eax
  800420e5b1:	38 c2                	cmp    %al,%dl
  800420e5b3:	74 cd                	je     800420e582 <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  800420e5b5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e5ba:	75 07                	jne    800420e5c3 <strncmp+0x57>
		return 0;
  800420e5bc:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e5c1:	eb 1a                	jmp    800420e5dd <strncmp+0x71>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  800420e5c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e5c7:	0f b6 00             	movzbl (%rax),%eax
  800420e5ca:	0f b6 d0             	movzbl %al,%edx
  800420e5cd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e5d1:	0f b6 00             	movzbl (%rax),%eax
  800420e5d4:	0f b6 c0             	movzbl %al,%eax
  800420e5d7:	89 d1                	mov    %edx,%ecx
  800420e5d9:	29 c1                	sub    %eax,%ecx
  800420e5db:	89 c8                	mov    %ecx,%eax
}
  800420e5dd:	c9                   	leaveq 
  800420e5de:	c3                   	retq   

000000800420e5df <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  800420e5df:	55                   	push   %rbp
  800420e5e0:	48 89 e5             	mov    %rsp,%rbp
  800420e5e3:	48 83 ec 10          	sub    $0x10,%rsp
  800420e5e7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420e5eb:	89 f0                	mov    %esi,%eax
  800420e5ed:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420e5f0:	eb 17                	jmp    800420e609 <strchr+0x2a>
		if (*s == c)
  800420e5f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e5f6:	0f b6 00             	movzbl (%rax),%eax
  800420e5f9:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420e5fc:	75 06                	jne    800420e604 <strchr+0x25>
			return (char *) s;
  800420e5fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e602:	eb 15                	jmp    800420e619 <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  800420e604:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420e609:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e60d:	0f b6 00             	movzbl (%rax),%eax
  800420e610:	84 c0                	test   %al,%al
  800420e612:	75 de                	jne    800420e5f2 <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  800420e614:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420e619:	c9                   	leaveq 
  800420e61a:	c3                   	retq   

000000800420e61b <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  800420e61b:	55                   	push   %rbp
  800420e61c:	48 89 e5             	mov    %rsp,%rbp
  800420e61f:	48 83 ec 10          	sub    $0x10,%rsp
  800420e623:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420e627:	89 f0                	mov    %esi,%eax
  800420e629:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420e62c:	eb 11                	jmp    800420e63f <strfind+0x24>
		if (*s == c)
  800420e62e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e632:	0f b6 00             	movzbl (%rax),%eax
  800420e635:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420e638:	74 12                	je     800420e64c <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  800420e63a:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420e63f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e643:	0f b6 00             	movzbl (%rax),%eax
  800420e646:	84 c0                	test   %al,%al
  800420e648:	75 e4                	jne    800420e62e <strfind+0x13>
  800420e64a:	eb 01                	jmp    800420e64d <strfind+0x32>
		if (*s == c)
			break;
  800420e64c:	90                   	nop
	return (char *) s;
  800420e64d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420e651:	c9                   	leaveq 
  800420e652:	c3                   	retq   

000000800420e653 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  800420e653:	55                   	push   %rbp
  800420e654:	48 89 e5             	mov    %rsp,%rbp
  800420e657:	48 83 ec 18          	sub    $0x18,%rsp
  800420e65b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420e65f:	89 75 f4             	mov    %esi,-0xc(%rbp)
  800420e662:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  800420e666:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e66b:	75 06                	jne    800420e673 <memset+0x20>
		return v;
  800420e66d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e671:	eb 69                	jmp    800420e6dc <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  800420e673:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e677:	83 e0 03             	and    $0x3,%eax
  800420e67a:	48 85 c0             	test   %rax,%rax
  800420e67d:	75 48                	jne    800420e6c7 <memset+0x74>
  800420e67f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e683:	83 e0 03             	and    $0x3,%eax
  800420e686:	48 85 c0             	test   %rax,%rax
  800420e689:	75 3c                	jne    800420e6c7 <memset+0x74>
		c &= 0xFF;
  800420e68b:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  800420e692:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e695:	89 c2                	mov    %eax,%edx
  800420e697:	c1 e2 18             	shl    $0x18,%edx
  800420e69a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e69d:	c1 e0 10             	shl    $0x10,%eax
  800420e6a0:	09 c2                	or     %eax,%edx
  800420e6a2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e6a5:	c1 e0 08             	shl    $0x8,%eax
  800420e6a8:	09 d0                	or     %edx,%eax
  800420e6aa:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
  800420e6ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e6b1:	48 89 c1             	mov    %rax,%rcx
  800420e6b4:	48 c1 e9 02          	shr    $0x2,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  800420e6b8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420e6bc:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e6bf:	48 89 d7             	mov    %rdx,%rdi
  800420e6c2:	fc                   	cld    
  800420e6c3:	f3 ab                	rep stos %eax,%es:(%rdi)
  800420e6c5:	eb 11                	jmp    800420e6d8 <memset+0x85>
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  800420e6c7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420e6cb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e6ce:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420e6d2:	48 89 d7             	mov    %rdx,%rdi
  800420e6d5:	fc                   	cld    
  800420e6d6:	f3 aa                	rep stos %al,%es:(%rdi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
  800420e6d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420e6dc:	c9                   	leaveq 
  800420e6dd:	c3                   	retq   

000000800420e6de <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  800420e6de:	55                   	push   %rbp
  800420e6df:	48 89 e5             	mov    %rsp,%rbp
  800420e6e2:	48 83 ec 28          	sub    $0x28,%rsp
  800420e6e6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e6ea:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420e6ee:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  800420e6f2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e6f6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  800420e6fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e6fe:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  800420e702:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e706:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420e70a:	0f 83 88 00 00 00    	jae    800420e798 <memmove+0xba>
  800420e710:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e714:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420e718:	48 01 d0             	add    %rdx,%rax
  800420e71b:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420e71f:	76 77                	jbe    800420e798 <memmove+0xba>
		s += n;
  800420e721:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e725:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  800420e729:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e72d:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420e731:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e735:	83 e0 03             	and    $0x3,%eax
  800420e738:	48 85 c0             	test   %rax,%rax
  800420e73b:	75 3b                	jne    800420e778 <memmove+0x9a>
  800420e73d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e741:	83 e0 03             	and    $0x3,%eax
  800420e744:	48 85 c0             	test   %rax,%rax
  800420e747:	75 2f                	jne    800420e778 <memmove+0x9a>
  800420e749:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e74d:	83 e0 03             	and    $0x3,%eax
  800420e750:	48 85 c0             	test   %rax,%rax
  800420e753:	75 23                	jne    800420e778 <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  800420e755:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e759:	48 83 e8 04          	sub    $0x4,%rax
  800420e75d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420e761:	48 83 ea 04          	sub    $0x4,%rdx
  800420e765:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420e769:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  800420e76d:	48 89 c7             	mov    %rax,%rdi
  800420e770:	48 89 d6             	mov    %rdx,%rsi
  800420e773:	fd                   	std    
  800420e774:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420e776:	eb 1d                	jmp    800420e795 <memmove+0xb7>
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  800420e778:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e77c:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420e780:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e784:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  800420e788:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e78c:	48 89 d7             	mov    %rdx,%rdi
  800420e78f:	48 89 c1             	mov    %rax,%rcx
  800420e792:	fd                   	std    
  800420e793:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  800420e795:	fc                   	cld    
  800420e796:	eb 57                	jmp    800420e7ef <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420e798:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e79c:	83 e0 03             	and    $0x3,%eax
  800420e79f:	48 85 c0             	test   %rax,%rax
  800420e7a2:	75 36                	jne    800420e7da <memmove+0xfc>
  800420e7a4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e7a8:	83 e0 03             	and    $0x3,%eax
  800420e7ab:	48 85 c0             	test   %rax,%rax
  800420e7ae:	75 2a                	jne    800420e7da <memmove+0xfc>
  800420e7b0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e7b4:	83 e0 03             	and    $0x3,%eax
  800420e7b7:	48 85 c0             	test   %rax,%rax
  800420e7ba:	75 1e                	jne    800420e7da <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  800420e7bc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e7c0:	48 89 c1             	mov    %rax,%rcx
  800420e7c3:	48 c1 e9 02          	shr    $0x2,%rcx
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  800420e7c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e7cb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420e7cf:	48 89 c7             	mov    %rax,%rdi
  800420e7d2:	48 89 d6             	mov    %rdx,%rsi
  800420e7d5:	fc                   	cld    
  800420e7d6:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420e7d8:	eb 15                	jmp    800420e7ef <memmove+0x111>
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  800420e7da:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e7de:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420e7e2:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420e7e6:	48 89 c7             	mov    %rax,%rdi
  800420e7e9:	48 89 d6             	mov    %rdx,%rsi
  800420e7ec:	fc                   	cld    
  800420e7ed:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  800420e7ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420e7f3:	c9                   	leaveq 
  800420e7f4:	c3                   	retq   

000000800420e7f5 <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  800420e7f5:	55                   	push   %rbp
  800420e7f6:	48 89 e5             	mov    %rsp,%rbp
  800420e7f9:	48 83 ec 18          	sub    $0x18,%rsp
  800420e7fd:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420e801:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420e805:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  800420e809:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e80d:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420e811:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e815:	48 89 ce             	mov    %rcx,%rsi
  800420e818:	48 89 c7             	mov    %rax,%rdi
  800420e81b:	48 b8 de e6 20 04 80 	movabs $0x800420e6de,%rax
  800420e822:	00 00 00 
  800420e825:	ff d0                	callq  *%rax
}
  800420e827:	c9                   	leaveq 
  800420e828:	c3                   	retq   

000000800420e829 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  800420e829:	55                   	push   %rbp
  800420e82a:	48 89 e5             	mov    %rsp,%rbp
  800420e82d:	48 83 ec 28          	sub    $0x28,%rsp
  800420e831:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e835:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420e839:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  800420e83d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e841:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  800420e845:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e849:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  800420e84d:	eb 38                	jmp    800420e887 <memcmp+0x5e>
		if (*s1 != *s2)
  800420e84f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e853:	0f b6 10             	movzbl (%rax),%edx
  800420e856:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e85a:	0f b6 00             	movzbl (%rax),%eax
  800420e85d:	38 c2                	cmp    %al,%dl
  800420e85f:	74 1c                	je     800420e87d <memcmp+0x54>
			return (int) *s1 - (int) *s2;
  800420e861:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e865:	0f b6 00             	movzbl (%rax),%eax
  800420e868:	0f b6 d0             	movzbl %al,%edx
  800420e86b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e86f:	0f b6 00             	movzbl (%rax),%eax
  800420e872:	0f b6 c0             	movzbl %al,%eax
  800420e875:	89 d1                	mov    %edx,%ecx
  800420e877:	29 c1                	sub    %eax,%ecx
  800420e879:	89 c8                	mov    %ecx,%eax
  800420e87b:	eb 20                	jmp    800420e89d <memcmp+0x74>
		s1++, s2++;
  800420e87d:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420e882:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  800420e887:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420e88c:	0f 95 c0             	setne  %al
  800420e88f:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  800420e894:	84 c0                	test   %al,%al
  800420e896:	75 b7                	jne    800420e84f <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  800420e898:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420e89d:	c9                   	leaveq 
  800420e89e:	c3                   	retq   

000000800420e89f <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  800420e89f:	55                   	push   %rbp
  800420e8a0:	48 89 e5             	mov    %rsp,%rbp
  800420e8a3:	48 83 ec 28          	sub    $0x28,%rsp
  800420e8a7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420e8ab:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  800420e8ae:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  800420e8b2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e8b6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e8ba:	48 01 d0             	add    %rdx,%rax
  800420e8bd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  800420e8c1:	eb 13                	jmp    800420e8d6 <memfind+0x37>
		if (*(const unsigned char *) s == (unsigned char) c)
  800420e8c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e8c7:	0f b6 10             	movzbl (%rax),%edx
  800420e8ca:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420e8cd:	38 c2                	cmp    %al,%dl
  800420e8cf:	74 11                	je     800420e8e2 <memfind+0x43>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  800420e8d1:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420e8d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e8da:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420e8de:	72 e3                	jb     800420e8c3 <memfind+0x24>
  800420e8e0:	eb 01                	jmp    800420e8e3 <memfind+0x44>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
  800420e8e2:	90                   	nop
	return (void *) s;
  800420e8e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420e8e7:	c9                   	leaveq 
  800420e8e8:	c3                   	retq   

000000800420e8e9 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  800420e8e9:	55                   	push   %rbp
  800420e8ea:	48 89 e5             	mov    %rsp,%rbp
  800420e8ed:	48 83 ec 38          	sub    $0x38,%rsp
  800420e8f1:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420e8f5:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420e8f9:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  800420e8fc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  800420e903:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420e90a:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420e90b:	eb 05                	jmp    800420e912 <strtol+0x29>
		s++;
  800420e90d:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420e912:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e916:	0f b6 00             	movzbl (%rax),%eax
  800420e919:	3c 20                	cmp    $0x20,%al
  800420e91b:	74 f0                	je     800420e90d <strtol+0x24>
  800420e91d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e921:	0f b6 00             	movzbl (%rax),%eax
  800420e924:	3c 09                	cmp    $0x9,%al
  800420e926:	74 e5                	je     800420e90d <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  800420e928:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e92c:	0f b6 00             	movzbl (%rax),%eax
  800420e92f:	3c 2b                	cmp    $0x2b,%al
  800420e931:	75 07                	jne    800420e93a <strtol+0x51>
		s++;
  800420e933:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420e938:	eb 17                	jmp    800420e951 <strtol+0x68>
	else if (*s == '-')
  800420e93a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e93e:	0f b6 00             	movzbl (%rax),%eax
  800420e941:	3c 2d                	cmp    $0x2d,%al
  800420e943:	75 0c                	jne    800420e951 <strtol+0x68>
		s++, neg = 1;
  800420e945:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420e94a:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  800420e951:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420e955:	74 06                	je     800420e95d <strtol+0x74>
  800420e957:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  800420e95b:	75 28                	jne    800420e985 <strtol+0x9c>
  800420e95d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e961:	0f b6 00             	movzbl (%rax),%eax
  800420e964:	3c 30                	cmp    $0x30,%al
  800420e966:	75 1d                	jne    800420e985 <strtol+0x9c>
  800420e968:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e96c:	48 83 c0 01          	add    $0x1,%rax
  800420e970:	0f b6 00             	movzbl (%rax),%eax
  800420e973:	3c 78                	cmp    $0x78,%al
  800420e975:	75 0e                	jne    800420e985 <strtol+0x9c>
		s += 2, base = 16;
  800420e977:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  800420e97c:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  800420e983:	eb 2c                	jmp    800420e9b1 <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  800420e985:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420e989:	75 19                	jne    800420e9a4 <strtol+0xbb>
  800420e98b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e98f:	0f b6 00             	movzbl (%rax),%eax
  800420e992:	3c 30                	cmp    $0x30,%al
  800420e994:	75 0e                	jne    800420e9a4 <strtol+0xbb>
		s++, base = 8;
  800420e996:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420e99b:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  800420e9a2:	eb 0d                	jmp    800420e9b1 <strtol+0xc8>
	else if (base == 0)
  800420e9a4:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420e9a8:	75 07                	jne    800420e9b1 <strtol+0xc8>
		base = 10;
  800420e9aa:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  800420e9b1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e9b5:	0f b6 00             	movzbl (%rax),%eax
  800420e9b8:	3c 2f                	cmp    $0x2f,%al
  800420e9ba:	7e 1d                	jle    800420e9d9 <strtol+0xf0>
  800420e9bc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e9c0:	0f b6 00             	movzbl (%rax),%eax
  800420e9c3:	3c 39                	cmp    $0x39,%al
  800420e9c5:	7f 12                	jg     800420e9d9 <strtol+0xf0>
			dig = *s - '0';
  800420e9c7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e9cb:	0f b6 00             	movzbl (%rax),%eax
  800420e9ce:	0f be c0             	movsbl %al,%eax
  800420e9d1:	83 e8 30             	sub    $0x30,%eax
  800420e9d4:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420e9d7:	eb 4e                	jmp    800420ea27 <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  800420e9d9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e9dd:	0f b6 00             	movzbl (%rax),%eax
  800420e9e0:	3c 60                	cmp    $0x60,%al
  800420e9e2:	7e 1d                	jle    800420ea01 <strtol+0x118>
  800420e9e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e9e8:	0f b6 00             	movzbl (%rax),%eax
  800420e9eb:	3c 7a                	cmp    $0x7a,%al
  800420e9ed:	7f 12                	jg     800420ea01 <strtol+0x118>
			dig = *s - 'a' + 10;
  800420e9ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e9f3:	0f b6 00             	movzbl (%rax),%eax
  800420e9f6:	0f be c0             	movsbl %al,%eax
  800420e9f9:	83 e8 57             	sub    $0x57,%eax
  800420e9fc:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420e9ff:	eb 26                	jmp    800420ea27 <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  800420ea01:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ea05:	0f b6 00             	movzbl (%rax),%eax
  800420ea08:	3c 40                	cmp    $0x40,%al
  800420ea0a:	7e 47                	jle    800420ea53 <strtol+0x16a>
  800420ea0c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ea10:	0f b6 00             	movzbl (%rax),%eax
  800420ea13:	3c 5a                	cmp    $0x5a,%al
  800420ea15:	7f 3c                	jg     800420ea53 <strtol+0x16a>
			dig = *s - 'A' + 10;
  800420ea17:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ea1b:	0f b6 00             	movzbl (%rax),%eax
  800420ea1e:	0f be c0             	movsbl %al,%eax
  800420ea21:	83 e8 37             	sub    $0x37,%eax
  800420ea24:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  800420ea27:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420ea2a:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  800420ea2d:	7d 23                	jge    800420ea52 <strtol+0x169>
			break;
		s++, val = (val * base) + dig;
  800420ea2f:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420ea34:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420ea37:	48 98                	cltq   
  800420ea39:	48 89 c2             	mov    %rax,%rdx
  800420ea3c:	48 0f af 55 f0       	imul   -0x10(%rbp),%rdx
  800420ea41:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420ea44:	48 98                	cltq   
  800420ea46:	48 01 d0             	add    %rdx,%rax
  800420ea49:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  800420ea4d:	e9 5f ff ff ff       	jmpq   800420e9b1 <strtol+0xc8>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
  800420ea52:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
  800420ea53:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420ea58:	74 0b                	je     800420ea65 <strtol+0x17c>
		*endptr = (char *) s;
  800420ea5a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ea5e:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420ea62:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  800420ea65:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420ea69:	74 09                	je     800420ea74 <strtol+0x18b>
  800420ea6b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ea6f:	48 f7 d8             	neg    %rax
  800420ea72:	eb 04                	jmp    800420ea78 <strtol+0x18f>
  800420ea74:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420ea78:	c9                   	leaveq 
  800420ea79:	c3                   	retq   

000000800420ea7a <strstr>:

char * strstr(const char *in, const char *str)
{
  800420ea7a:	55                   	push   %rbp
  800420ea7b:	48 89 e5             	mov    %rsp,%rbp
  800420ea7e:	48 83 ec 30          	sub    $0x30,%rsp
  800420ea82:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420ea86:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    char c;
    size_t len;

    c = *str++;
  800420ea8a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ea8e:	0f b6 00             	movzbl (%rax),%eax
  800420ea91:	88 45 ff             	mov    %al,-0x1(%rbp)
  800420ea94:	48 83 45 d0 01       	addq   $0x1,-0x30(%rbp)
    if (!c)
  800420ea99:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  800420ea9d:	75 06                	jne    800420eaa5 <strstr+0x2b>
        return (char *) in;	// Trivial empty string case
  800420ea9f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420eaa3:	eb 68                	jmp    800420eb0d <strstr+0x93>

    len = strlen(str);
  800420eaa5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420eaa9:	48 89 c7             	mov    %rax,%rdi
  800420eaac:	48 b8 50 e3 20 04 80 	movabs $0x800420e350,%rax
  800420eab3:	00 00 00 
  800420eab6:	ff d0                	callq  *%rax
  800420eab8:	48 98                	cltq   
  800420eaba:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    do {
        char sc;

        do {
            sc = *in++;
  800420eabe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420eac2:	0f b6 00             	movzbl (%rax),%eax
  800420eac5:	88 45 ef             	mov    %al,-0x11(%rbp)
  800420eac8:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
            if (!sc)
  800420eacd:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  800420ead1:	75 07                	jne    800420eada <strstr+0x60>
                return (char *) 0;
  800420ead3:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ead8:	eb 33                	jmp    800420eb0d <strstr+0x93>
        } while (sc != c);
  800420eada:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800420eade:	3a 45 ff             	cmp    -0x1(%rbp),%al
  800420eae1:	75 db                	jne    800420eabe <strstr+0x44>
    } while (strncmp(in, str, len) != 0);
  800420eae3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420eae7:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800420eaeb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420eaef:	48 89 ce             	mov    %rcx,%rsi
  800420eaf2:	48 89 c7             	mov    %rax,%rdi
  800420eaf5:	48 b8 6c e5 20 04 80 	movabs $0x800420e56c,%rax
  800420eafc:	00 00 00 
  800420eaff:	ff d0                	callq  *%rax
  800420eb01:	85 c0                	test   %eax,%eax
  800420eb03:	75 b9                	jne    800420eabe <strstr+0x44>

    return (char *) (in - 1);
  800420eb05:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420eb09:	48 83 e8 01          	sub    $0x1,%rax
}
  800420eb0d:	c9                   	leaveq 
  800420eb0e:	c3                   	retq   
	...

000000800420eb10 <_dwarf_read_lsb>:

int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

uint64_t
_dwarf_read_lsb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800420eb10:	55                   	push   %rbp
  800420eb11:	48 89 e5             	mov    %rsp,%rbp
  800420eb14:	48 83 ec 28          	sub    $0x28,%rsp
  800420eb18:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420eb1c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420eb20:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800420eb23:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eb27:	48 8b 00             	mov    (%rax),%rax
  800420eb2a:	48 03 45 e8          	add    -0x18(%rbp),%rax
  800420eb2e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420eb32:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420eb39:	00 
	switch (bytes_to_read) {
  800420eb3a:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420eb3d:	83 f8 02             	cmp    $0x2,%eax
  800420eb40:	0f 84 ab 00 00 00    	je     800420ebf1 <_dwarf_read_lsb+0xe1>
  800420eb46:	83 f8 02             	cmp    $0x2,%eax
  800420eb49:	7f 0e                	jg     800420eb59 <_dwarf_read_lsb+0x49>
  800420eb4b:	83 f8 01             	cmp    $0x1,%eax
  800420eb4e:	0f 84 b3 00 00 00    	je     800420ec07 <_dwarf_read_lsb+0xf7>
  800420eb54:	e9 d9 00 00 00       	jmpq   800420ec32 <_dwarf_read_lsb+0x122>
  800420eb59:	83 f8 04             	cmp    $0x4,%eax
  800420eb5c:	74 65                	je     800420ebc3 <_dwarf_read_lsb+0xb3>
  800420eb5e:	83 f8 08             	cmp    $0x8,%eax
  800420eb61:	0f 85 cb 00 00 00    	jne    800420ec32 <_dwarf_read_lsb+0x122>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420eb67:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eb6b:	48 83 c0 04          	add    $0x4,%rax
  800420eb6f:	0f b6 00             	movzbl (%rax),%eax
  800420eb72:	0f b6 c0             	movzbl %al,%eax
  800420eb75:	48 89 c2             	mov    %rax,%rdx
  800420eb78:	48 c1 e2 20          	shl    $0x20,%rdx
  800420eb7c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eb80:	48 83 c0 05          	add    $0x5,%rax
  800420eb84:	0f b6 00             	movzbl (%rax),%eax
  800420eb87:	0f b6 c0             	movzbl %al,%eax
  800420eb8a:	48 c1 e0 28          	shl    $0x28,%rax
  800420eb8e:	48 09 d0             	or     %rdx,%rax
  800420eb91:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420eb95:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eb99:	48 83 c0 06          	add    $0x6,%rax
  800420eb9d:	0f b6 00             	movzbl (%rax),%eax
  800420eba0:	0f b6 c0             	movzbl %al,%eax
  800420eba3:	48 89 c2             	mov    %rax,%rdx
  800420eba6:	48 c1 e2 30          	shl    $0x30,%rdx
  800420ebaa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ebae:	48 83 c0 07          	add    $0x7,%rax
  800420ebb2:	0f b6 00             	movzbl (%rax),%eax
  800420ebb5:	0f b6 c0             	movzbl %al,%eax
  800420ebb8:	48 c1 e0 38          	shl    $0x38,%rax
  800420ebbc:	48 09 d0             	or     %rdx,%rax
  800420ebbf:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800420ebc3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ebc7:	48 83 c0 02          	add    $0x2,%rax
  800420ebcb:	0f b6 00             	movzbl (%rax),%eax
  800420ebce:	0f b6 c0             	movzbl %al,%eax
  800420ebd1:	48 89 c2             	mov    %rax,%rdx
  800420ebd4:	48 c1 e2 10          	shl    $0x10,%rdx
  800420ebd8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ebdc:	48 83 c0 03          	add    $0x3,%rax
  800420ebe0:	0f b6 00             	movzbl (%rax),%eax
  800420ebe3:	0f b6 c0             	movzbl %al,%eax
  800420ebe6:	48 c1 e0 18          	shl    $0x18,%rax
  800420ebea:	48 09 d0             	or     %rdx,%rax
  800420ebed:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800420ebf1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ebf5:	48 83 c0 01          	add    $0x1,%rax
  800420ebf9:	0f b6 00             	movzbl (%rax),%eax
  800420ebfc:	0f b6 c0             	movzbl %al,%eax
  800420ebff:	48 c1 e0 08          	shl    $0x8,%rax
  800420ec03:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800420ec07:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ec0b:	0f b6 00             	movzbl (%rax),%eax
  800420ec0e:	0f b6 c0             	movzbl %al,%eax
  800420ec11:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420ec15:	90                   	nop
	default:
		return (0);
	}

	*offsetp += bytes_to_read;
  800420ec16:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ec1a:	48 8b 10             	mov    (%rax),%rdx
  800420ec1d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420ec20:	48 98                	cltq   
  800420ec22:	48 01 c2             	add    %rax,%rdx
  800420ec25:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ec29:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420ec2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ec30:	eb 05                	jmp    800420ec37 <_dwarf_read_lsb+0x127>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  800420ec32:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*offsetp += bytes_to_read;

	return (ret);
}
  800420ec37:	c9                   	leaveq 
  800420ec38:	c3                   	retq   

000000800420ec39 <_dwarf_decode_lsb>:

uint64_t
_dwarf_decode_lsb(uint8_t **data, int bytes_to_read)
{
  800420ec39:	55                   	push   %rbp
  800420ec3a:	48 89 e5             	mov    %rsp,%rbp
  800420ec3d:	48 83 ec 20          	sub    $0x20,%rsp
  800420ec41:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ec45:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800420ec48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec4c:	48 8b 00             	mov    (%rax),%rax
  800420ec4f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420ec53:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420ec5a:	00 
	switch (bytes_to_read) {
  800420ec5b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420ec5e:	83 f8 02             	cmp    $0x2,%eax
  800420ec61:	0f 84 ab 00 00 00    	je     800420ed12 <_dwarf_decode_lsb+0xd9>
  800420ec67:	83 f8 02             	cmp    $0x2,%eax
  800420ec6a:	7f 0e                	jg     800420ec7a <_dwarf_decode_lsb+0x41>
  800420ec6c:	83 f8 01             	cmp    $0x1,%eax
  800420ec6f:	0f 84 b3 00 00 00    	je     800420ed28 <_dwarf_decode_lsb+0xef>
  800420ec75:	e9 d9 00 00 00       	jmpq   800420ed53 <_dwarf_decode_lsb+0x11a>
  800420ec7a:	83 f8 04             	cmp    $0x4,%eax
  800420ec7d:	74 65                	je     800420ece4 <_dwarf_decode_lsb+0xab>
  800420ec7f:	83 f8 08             	cmp    $0x8,%eax
  800420ec82:	0f 85 cb 00 00 00    	jne    800420ed53 <_dwarf_decode_lsb+0x11a>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420ec88:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ec8c:	48 83 c0 04          	add    $0x4,%rax
  800420ec90:	0f b6 00             	movzbl (%rax),%eax
  800420ec93:	0f b6 c0             	movzbl %al,%eax
  800420ec96:	48 89 c2             	mov    %rax,%rdx
  800420ec99:	48 c1 e2 20          	shl    $0x20,%rdx
  800420ec9d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eca1:	48 83 c0 05          	add    $0x5,%rax
  800420eca5:	0f b6 00             	movzbl (%rax),%eax
  800420eca8:	0f b6 c0             	movzbl %al,%eax
  800420ecab:	48 c1 e0 28          	shl    $0x28,%rax
  800420ecaf:	48 09 d0             	or     %rdx,%rax
  800420ecb2:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420ecb6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ecba:	48 83 c0 06          	add    $0x6,%rax
  800420ecbe:	0f b6 00             	movzbl (%rax),%eax
  800420ecc1:	0f b6 c0             	movzbl %al,%eax
  800420ecc4:	48 89 c2             	mov    %rax,%rdx
  800420ecc7:	48 c1 e2 30          	shl    $0x30,%rdx
  800420eccb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eccf:	48 83 c0 07          	add    $0x7,%rax
  800420ecd3:	0f b6 00             	movzbl (%rax),%eax
  800420ecd6:	0f b6 c0             	movzbl %al,%eax
  800420ecd9:	48 c1 e0 38          	shl    $0x38,%rax
  800420ecdd:	48 09 d0             	or     %rdx,%rax
  800420ece0:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800420ece4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ece8:	48 83 c0 02          	add    $0x2,%rax
  800420ecec:	0f b6 00             	movzbl (%rax),%eax
  800420ecef:	0f b6 c0             	movzbl %al,%eax
  800420ecf2:	48 89 c2             	mov    %rax,%rdx
  800420ecf5:	48 c1 e2 10          	shl    $0x10,%rdx
  800420ecf9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ecfd:	48 83 c0 03          	add    $0x3,%rax
  800420ed01:	0f b6 00             	movzbl (%rax),%eax
  800420ed04:	0f b6 c0             	movzbl %al,%eax
  800420ed07:	48 c1 e0 18          	shl    $0x18,%rax
  800420ed0b:	48 09 d0             	or     %rdx,%rax
  800420ed0e:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  800420ed12:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ed16:	48 83 c0 01          	add    $0x1,%rax
  800420ed1a:	0f b6 00             	movzbl (%rax),%eax
  800420ed1d:	0f b6 c0             	movzbl %al,%eax
  800420ed20:	48 c1 e0 08          	shl    $0x8,%rax
  800420ed24:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  800420ed28:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ed2c:	0f b6 00             	movzbl (%rax),%eax
  800420ed2f:	0f b6 c0             	movzbl %al,%eax
  800420ed32:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420ed36:	90                   	nop
	default:
		return (0);
	}

	*data += bytes_to_read;
  800420ed37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed3b:	48 8b 10             	mov    (%rax),%rdx
  800420ed3e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420ed41:	48 98                	cltq   
  800420ed43:	48 01 c2             	add    %rax,%rdx
  800420ed46:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed4a:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420ed4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ed51:	eb 05                	jmp    800420ed58 <_dwarf_decode_lsb+0x11f>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  800420ed53:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*data += bytes_to_read;

	return (ret);
}
  800420ed58:	c9                   	leaveq 
  800420ed59:	c3                   	retq   

000000800420ed5a <_dwarf_read_msb>:

uint64_t
_dwarf_read_msb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800420ed5a:	55                   	push   %rbp
  800420ed5b:	48 89 e5             	mov    %rsp,%rbp
  800420ed5e:	48 83 ec 28          	sub    $0x28,%rsp
  800420ed62:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ed66:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420ed6a:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800420ed6d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ed71:	48 8b 00             	mov    (%rax),%rax
  800420ed74:	48 03 45 e8          	add    -0x18(%rbp),%rax
  800420ed78:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	switch (bytes_to_read) {
  800420ed7c:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420ed7f:	83 f8 02             	cmp    $0x2,%eax
  800420ed82:	74 35                	je     800420edb9 <_dwarf_read_msb+0x5f>
  800420ed84:	83 f8 02             	cmp    $0x2,%eax
  800420ed87:	7f 0a                	jg     800420ed93 <_dwarf_read_msb+0x39>
  800420ed89:	83 f8 01             	cmp    $0x1,%eax
  800420ed8c:	74 18                	je     800420eda6 <_dwarf_read_msb+0x4c>
  800420ed8e:	e9 53 01 00 00       	jmpq   800420eee6 <_dwarf_read_msb+0x18c>
  800420ed93:	83 f8 04             	cmp    $0x4,%eax
  800420ed96:	74 49                	je     800420ede1 <_dwarf_read_msb+0x87>
  800420ed98:	83 f8 08             	cmp    $0x8,%eax
  800420ed9b:	0f 84 96 00 00 00    	je     800420ee37 <_dwarf_read_msb+0xdd>
  800420eda1:	e9 40 01 00 00       	jmpq   800420eee6 <_dwarf_read_msb+0x18c>
	case 1:
		ret = src[0];
  800420eda6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420edaa:	0f b6 00             	movzbl (%rax),%eax
  800420edad:	0f b6 c0             	movzbl %al,%eax
  800420edb0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420edb4:	e9 34 01 00 00       	jmpq   800420eeed <_dwarf_read_msb+0x193>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  800420edb9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420edbd:	48 83 c0 01          	add    $0x1,%rax
  800420edc1:	0f b6 00             	movzbl (%rax),%eax
  800420edc4:	0f b6 d0             	movzbl %al,%edx
  800420edc7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420edcb:	0f b6 00             	movzbl (%rax),%eax
  800420edce:	0f b6 c0             	movzbl %al,%eax
  800420edd1:	48 c1 e0 08          	shl    $0x8,%rax
  800420edd5:	48 09 d0             	or     %rdx,%rax
  800420edd8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420eddc:	e9 0c 01 00 00       	jmpq   800420eeed <_dwarf_read_msb+0x193>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  800420ede1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ede5:	48 83 c0 03          	add    $0x3,%rax
  800420ede9:	0f b6 00             	movzbl (%rax),%eax
  800420edec:	0f b6 c0             	movzbl %al,%eax
  800420edef:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420edf3:	48 83 c2 02          	add    $0x2,%rdx
  800420edf7:	0f b6 12             	movzbl (%rdx),%edx
  800420edfa:	0f b6 d2             	movzbl %dl,%edx
  800420edfd:	48 c1 e2 08          	shl    $0x8,%rdx
  800420ee01:	48 09 d0             	or     %rdx,%rax
  800420ee04:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  800420ee08:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ee0c:	48 83 c0 01          	add    $0x1,%rax
  800420ee10:	0f b6 00             	movzbl (%rax),%eax
  800420ee13:	0f b6 c0             	movzbl %al,%eax
  800420ee16:	48 89 c2             	mov    %rax,%rdx
  800420ee19:	48 c1 e2 10          	shl    $0x10,%rdx
  800420ee1d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ee21:	0f b6 00             	movzbl (%rax),%eax
  800420ee24:	0f b6 c0             	movzbl %al,%eax
  800420ee27:	48 c1 e0 18          	shl    $0x18,%rax
  800420ee2b:	48 09 d0             	or     %rdx,%rax
  800420ee2e:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420ee32:	e9 b6 00 00 00       	jmpq   800420eeed <_dwarf_read_msb+0x193>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  800420ee37:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ee3b:	48 83 c0 07          	add    $0x7,%rax
  800420ee3f:	0f b6 00             	movzbl (%rax),%eax
  800420ee42:	0f b6 c0             	movzbl %al,%eax
  800420ee45:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420ee49:	48 83 c2 06          	add    $0x6,%rdx
  800420ee4d:	0f b6 12             	movzbl (%rdx),%edx
  800420ee50:	0f b6 d2             	movzbl %dl,%edx
  800420ee53:	48 c1 e2 08          	shl    $0x8,%rdx
  800420ee57:	48 09 d0             	or     %rdx,%rax
  800420ee5a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  800420ee5e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ee62:	48 83 c0 05          	add    $0x5,%rax
  800420ee66:	0f b6 00             	movzbl (%rax),%eax
  800420ee69:	0f b6 c0             	movzbl %al,%eax
  800420ee6c:	48 89 c2             	mov    %rax,%rdx
  800420ee6f:	48 c1 e2 10          	shl    $0x10,%rdx
  800420ee73:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ee77:	48 83 c0 04          	add    $0x4,%rax
  800420ee7b:	0f b6 00             	movzbl (%rax),%eax
  800420ee7e:	0f b6 c0             	movzbl %al,%eax
  800420ee81:	48 c1 e0 18          	shl    $0x18,%rax
  800420ee85:	48 09 d0             	or     %rdx,%rax
  800420ee88:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  800420ee8c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ee90:	48 83 c0 03          	add    $0x3,%rax
  800420ee94:	0f b6 00             	movzbl (%rax),%eax
  800420ee97:	0f b6 c0             	movzbl %al,%eax
  800420ee9a:	48 89 c2             	mov    %rax,%rdx
  800420ee9d:	48 c1 e2 20          	shl    $0x20,%rdx
  800420eea1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eea5:	48 83 c0 02          	add    $0x2,%rax
  800420eea9:	0f b6 00             	movzbl (%rax),%eax
  800420eeac:	0f b6 c0             	movzbl %al,%eax
  800420eeaf:	48 c1 e0 28          	shl    $0x28,%rax
  800420eeb3:	48 09 d0             	or     %rdx,%rax
  800420eeb6:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  800420eeba:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eebe:	48 83 c0 01          	add    $0x1,%rax
  800420eec2:	0f b6 00             	movzbl (%rax),%eax
  800420eec5:	0f b6 c0             	movzbl %al,%eax
  800420eec8:	48 89 c2             	mov    %rax,%rdx
  800420eecb:	48 c1 e2 30          	shl    $0x30,%rdx
  800420eecf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eed3:	0f b6 00             	movzbl (%rax),%eax
  800420eed6:	0f b6 c0             	movzbl %al,%eax
  800420eed9:	48 c1 e0 38          	shl    $0x38,%rax
  800420eedd:	48 09 d0             	or     %rdx,%rax
  800420eee0:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420eee4:	eb 07                	jmp    800420eeed <_dwarf_read_msb+0x193>
	default:
		return (0);
  800420eee6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420eeeb:	eb 1a                	jmp    800420ef07 <_dwarf_read_msb+0x1ad>
	}

	*offsetp += bytes_to_read;
  800420eeed:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eef1:	48 8b 10             	mov    (%rax),%rdx
  800420eef4:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420eef7:	48 98                	cltq   
  800420eef9:	48 01 c2             	add    %rax,%rdx
  800420eefc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ef00:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420ef03:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420ef07:	c9                   	leaveq 
  800420ef08:	c3                   	retq   

000000800420ef09 <_dwarf_decode_msb>:

uint64_t
_dwarf_decode_msb(uint8_t **data, int bytes_to_read)
{
  800420ef09:	55                   	push   %rbp
  800420ef0a:	48 89 e5             	mov    %rsp,%rbp
  800420ef0d:	48 83 ec 20          	sub    $0x20,%rsp
  800420ef11:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ef15:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800420ef18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ef1c:	48 8b 00             	mov    (%rax),%rax
  800420ef1f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420ef23:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420ef2a:	00 
	switch (bytes_to_read) {
  800420ef2b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420ef2e:	83 f8 02             	cmp    $0x2,%eax
  800420ef31:	74 35                	je     800420ef68 <_dwarf_decode_msb+0x5f>
  800420ef33:	83 f8 02             	cmp    $0x2,%eax
  800420ef36:	7f 0a                	jg     800420ef42 <_dwarf_decode_msb+0x39>
  800420ef38:	83 f8 01             	cmp    $0x1,%eax
  800420ef3b:	74 18                	je     800420ef55 <_dwarf_decode_msb+0x4c>
  800420ef3d:	e9 53 01 00 00       	jmpq   800420f095 <_dwarf_decode_msb+0x18c>
  800420ef42:	83 f8 04             	cmp    $0x4,%eax
  800420ef45:	74 49                	je     800420ef90 <_dwarf_decode_msb+0x87>
  800420ef47:	83 f8 08             	cmp    $0x8,%eax
  800420ef4a:	0f 84 96 00 00 00    	je     800420efe6 <_dwarf_decode_msb+0xdd>
  800420ef50:	e9 40 01 00 00       	jmpq   800420f095 <_dwarf_decode_msb+0x18c>
	case 1:
		ret = src[0];
  800420ef55:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ef59:	0f b6 00             	movzbl (%rax),%eax
  800420ef5c:	0f b6 c0             	movzbl %al,%eax
  800420ef5f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420ef63:	e9 34 01 00 00       	jmpq   800420f09c <_dwarf_decode_msb+0x193>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  800420ef68:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ef6c:	48 83 c0 01          	add    $0x1,%rax
  800420ef70:	0f b6 00             	movzbl (%rax),%eax
  800420ef73:	0f b6 d0             	movzbl %al,%edx
  800420ef76:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ef7a:	0f b6 00             	movzbl (%rax),%eax
  800420ef7d:	0f b6 c0             	movzbl %al,%eax
  800420ef80:	48 c1 e0 08          	shl    $0x8,%rax
  800420ef84:	48 09 d0             	or     %rdx,%rax
  800420ef87:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800420ef8b:	e9 0c 01 00 00       	jmpq   800420f09c <_dwarf_decode_msb+0x193>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  800420ef90:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ef94:	48 83 c0 03          	add    $0x3,%rax
  800420ef98:	0f b6 00             	movzbl (%rax),%eax
  800420ef9b:	0f b6 c0             	movzbl %al,%eax
  800420ef9e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420efa2:	48 83 c2 02          	add    $0x2,%rdx
  800420efa6:	0f b6 12             	movzbl (%rdx),%edx
  800420efa9:	0f b6 d2             	movzbl %dl,%edx
  800420efac:	48 c1 e2 08          	shl    $0x8,%rdx
  800420efb0:	48 09 d0             	or     %rdx,%rax
  800420efb3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  800420efb7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420efbb:	48 83 c0 01          	add    $0x1,%rax
  800420efbf:	0f b6 00             	movzbl (%rax),%eax
  800420efc2:	0f b6 c0             	movzbl %al,%eax
  800420efc5:	48 89 c2             	mov    %rax,%rdx
  800420efc8:	48 c1 e2 10          	shl    $0x10,%rdx
  800420efcc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420efd0:	0f b6 00             	movzbl (%rax),%eax
  800420efd3:	0f b6 c0             	movzbl %al,%eax
  800420efd6:	48 c1 e0 18          	shl    $0x18,%rax
  800420efda:	48 09 d0             	or     %rdx,%rax
  800420efdd:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420efe1:	e9 b6 00 00 00       	jmpq   800420f09c <_dwarf_decode_msb+0x193>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  800420efe6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420efea:	48 83 c0 07          	add    $0x7,%rax
  800420efee:	0f b6 00             	movzbl (%rax),%eax
  800420eff1:	0f b6 c0             	movzbl %al,%eax
  800420eff4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420eff8:	48 83 c2 06          	add    $0x6,%rdx
  800420effc:	0f b6 12             	movzbl (%rdx),%edx
  800420efff:	0f b6 d2             	movzbl %dl,%edx
  800420f002:	48 c1 e2 08          	shl    $0x8,%rdx
  800420f006:	48 09 d0             	or     %rdx,%rax
  800420f009:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  800420f00d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f011:	48 83 c0 05          	add    $0x5,%rax
  800420f015:	0f b6 00             	movzbl (%rax),%eax
  800420f018:	0f b6 c0             	movzbl %al,%eax
  800420f01b:	48 89 c2             	mov    %rax,%rdx
  800420f01e:	48 c1 e2 10          	shl    $0x10,%rdx
  800420f022:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f026:	48 83 c0 04          	add    $0x4,%rax
  800420f02a:	0f b6 00             	movzbl (%rax),%eax
  800420f02d:	0f b6 c0             	movzbl %al,%eax
  800420f030:	48 c1 e0 18          	shl    $0x18,%rax
  800420f034:	48 09 d0             	or     %rdx,%rax
  800420f037:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  800420f03b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f03f:	48 83 c0 03          	add    $0x3,%rax
  800420f043:	0f b6 00             	movzbl (%rax),%eax
  800420f046:	0f b6 c0             	movzbl %al,%eax
  800420f049:	48 89 c2             	mov    %rax,%rdx
  800420f04c:	48 c1 e2 20          	shl    $0x20,%rdx
  800420f050:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f054:	48 83 c0 02          	add    $0x2,%rax
  800420f058:	0f b6 00             	movzbl (%rax),%eax
  800420f05b:	0f b6 c0             	movzbl %al,%eax
  800420f05e:	48 c1 e0 28          	shl    $0x28,%rax
  800420f062:	48 09 d0             	or     %rdx,%rax
  800420f065:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  800420f069:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f06d:	48 83 c0 01          	add    $0x1,%rax
  800420f071:	0f b6 00             	movzbl (%rax),%eax
  800420f074:	0f b6 c0             	movzbl %al,%eax
  800420f077:	48 89 c2             	mov    %rax,%rdx
  800420f07a:	48 c1 e2 30          	shl    $0x30,%rdx
  800420f07e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f082:	0f b6 00             	movzbl (%rax),%eax
  800420f085:	0f b6 c0             	movzbl %al,%eax
  800420f088:	48 c1 e0 38          	shl    $0x38,%rax
  800420f08c:	48 09 d0             	or     %rdx,%rax
  800420f08f:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  800420f093:	eb 07                	jmp    800420f09c <_dwarf_decode_msb+0x193>
	default:
		return (0);
  800420f095:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f09a:	eb 1a                	jmp    800420f0b6 <_dwarf_decode_msb+0x1ad>
		break;
	}

	*data += bytes_to_read;
  800420f09c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f0a0:	48 8b 10             	mov    (%rax),%rdx
  800420f0a3:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420f0a6:	48 98                	cltq   
  800420f0a8:	48 01 c2             	add    %rax,%rdx
  800420f0ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f0af:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f0b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f0b6:	c9                   	leaveq 
  800420f0b7:	c3                   	retq   

000000800420f0b8 <_dwarf_read_sleb128>:

int64_t
_dwarf_read_sleb128(uint8_t *data, uint64_t *offsetp)
{
  800420f0b8:	55                   	push   %rbp
  800420f0b9:	48 89 e5             	mov    %rsp,%rbp
  800420f0bc:	53                   	push   %rbx
  800420f0bd:	48 83 ec 30          	sub    $0x30,%rsp
  800420f0c1:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
  800420f0c5:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
	int64_t ret = 0;
  800420f0c9:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420f0d0:	00 
	uint8_t b;
	int shift = 0;
  800420f0d1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  800420f0d8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f0dc:	48 8b 00             	mov    (%rax),%rax
  800420f0df:	48 03 45 d0          	add    -0x30(%rbp),%rax
  800420f0e3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	do {
		b = *src++;
  800420f0e7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f0eb:	0f b6 00             	movzbl (%rax),%eax
  800420f0ee:	88 45 df             	mov    %al,-0x21(%rbp)
  800420f0f1:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420f0f6:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  800420f0fa:	89 c2                	mov    %eax,%edx
  800420f0fc:	83 e2 7f             	and    $0x7f,%edx
  800420f0ff:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420f102:	89 d3                	mov    %edx,%ebx
  800420f104:	89 c1                	mov    %eax,%ecx
  800420f106:	d3 e3                	shl    %cl,%ebx
  800420f108:	89 d8                	mov    %ebx,%eax
  800420f10a:	48 98                	cltq   
  800420f10c:	48 09 45 f0          	or     %rax,-0x10(%rbp)
		(*offsetp)++;
  800420f110:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f114:	48 8b 00             	mov    (%rax),%rax
  800420f117:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f11b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f11f:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  800420f122:	83 45 ec 07          	addl   $0x7,-0x14(%rbp)
	} while ((b & 0x80) != 0);
  800420f126:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  800420f12a:	84 c0                	test   %al,%al
  800420f12c:	78 b9                	js     800420f0e7 <_dwarf_read_sleb128+0x2f>

	if (shift < 32 && (b & 0x40) != 0)
  800420f12e:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  800420f132:	7f 21                	jg     800420f155 <_dwarf_read_sleb128+0x9d>
  800420f134:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  800420f138:	83 e0 40             	and    $0x40,%eax
  800420f13b:	85 c0                	test   %eax,%eax
  800420f13d:	74 16                	je     800420f155 <_dwarf_read_sleb128+0x9d>
		ret |= (-1 << shift);
  800420f13f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420f142:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800420f147:	89 d3                	mov    %edx,%ebx
  800420f149:	89 c1                	mov    %eax,%ecx
  800420f14b:	d3 e3                	shl    %cl,%ebx
  800420f14d:	89 d8                	mov    %ebx,%eax
  800420f14f:	48 98                	cltq   
  800420f151:	48 09 45 f0          	or     %rax,-0x10(%rbp)

	return (ret);
  800420f155:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420f159:	48 83 c4 30          	add    $0x30,%rsp
  800420f15d:	5b                   	pop    %rbx
  800420f15e:	5d                   	pop    %rbp
  800420f15f:	c3                   	retq   

000000800420f160 <_dwarf_read_uleb128>:

uint64_t
_dwarf_read_uleb128(uint8_t *data, uint64_t *offsetp)
{
  800420f160:	55                   	push   %rbp
  800420f161:	48 89 e5             	mov    %rsp,%rbp
  800420f164:	53                   	push   %rbx
  800420f165:	48 83 ec 30          	sub    $0x30,%rsp
  800420f169:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
  800420f16d:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
	uint64_t ret = 0;
  800420f171:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420f178:	00 
	uint8_t b;
	int shift = 0;
  800420f179:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  800420f180:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f184:	48 8b 00             	mov    (%rax),%rax
  800420f187:	48 03 45 d0          	add    -0x30(%rbp),%rax
  800420f18b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	do {
		b = *src++;
  800420f18f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f193:	0f b6 00             	movzbl (%rax),%eax
  800420f196:	88 45 df             	mov    %al,-0x21(%rbp)
  800420f199:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420f19e:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  800420f1a2:	89 c2                	mov    %eax,%edx
  800420f1a4:	83 e2 7f             	and    $0x7f,%edx
  800420f1a7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420f1aa:	89 d3                	mov    %edx,%ebx
  800420f1ac:	89 c1                	mov    %eax,%ecx
  800420f1ae:	d3 e3                	shl    %cl,%ebx
  800420f1b0:	89 d8                	mov    %ebx,%eax
  800420f1b2:	48 98                	cltq   
  800420f1b4:	48 09 45 f0          	or     %rax,-0x10(%rbp)
		(*offsetp)++;
  800420f1b8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f1bc:	48 8b 00             	mov    (%rax),%rax
  800420f1bf:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f1c3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f1c7:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  800420f1ca:	83 45 ec 07          	addl   $0x7,-0x14(%rbp)
	} while ((b & 0x80) != 0);
  800420f1ce:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  800420f1d2:	84 c0                	test   %al,%al
  800420f1d4:	78 b9                	js     800420f18f <_dwarf_read_uleb128+0x2f>

	return (ret);
  800420f1d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420f1da:	48 83 c4 30          	add    $0x30,%rsp
  800420f1de:	5b                   	pop    %rbx
  800420f1df:	5d                   	pop    %rbp
  800420f1e0:	c3                   	retq   

000000800420f1e1 <_dwarf_decode_sleb128>:

int64_t
_dwarf_decode_sleb128(uint8_t **dp)
{
  800420f1e1:	55                   	push   %rbp
  800420f1e2:	48 89 e5             	mov    %rsp,%rbp
  800420f1e5:	53                   	push   %rbx
  800420f1e6:	48 83 ec 28          	sub    $0x28,%rsp
  800420f1ea:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
	int64_t ret = 0;
  800420f1ee:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420f1f5:	00 
	uint8_t b;
	int shift = 0;
  800420f1f6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)

	uint8_t *src = *dp;
  800420f1fd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f201:	48 8b 00             	mov    (%rax),%rax
  800420f204:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	do {
		b = *src++;
  800420f208:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f20c:	0f b6 00             	movzbl (%rax),%eax
  800420f20f:	88 45 df             	mov    %al,-0x21(%rbp)
  800420f212:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420f217:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  800420f21b:	89 c2                	mov    %eax,%edx
  800420f21d:	83 e2 7f             	and    $0x7f,%edx
  800420f220:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420f223:	89 d3                	mov    %edx,%ebx
  800420f225:	89 c1                	mov    %eax,%ecx
  800420f227:	d3 e3                	shl    %cl,%ebx
  800420f229:	89 d8                	mov    %ebx,%eax
  800420f22b:	48 98                	cltq   
  800420f22d:	48 09 45 f0          	or     %rax,-0x10(%rbp)
		shift += 7;
  800420f231:	83 45 ec 07          	addl   $0x7,-0x14(%rbp)
	} while ((b & 0x80) != 0);
  800420f235:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  800420f239:	84 c0                	test   %al,%al
  800420f23b:	78 cb                	js     800420f208 <_dwarf_decode_sleb128+0x27>

	if (shift < 32 && (b & 0x40) != 0)
  800420f23d:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%rbp)
  800420f241:	7f 21                	jg     800420f264 <_dwarf_decode_sleb128+0x83>
  800420f243:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  800420f247:	83 e0 40             	and    $0x40,%eax
  800420f24a:	85 c0                	test   %eax,%eax
  800420f24c:	74 16                	je     800420f264 <_dwarf_decode_sleb128+0x83>
		ret |= (-1 << shift);
  800420f24e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420f251:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800420f256:	89 d3                	mov    %edx,%ebx
  800420f258:	89 c1                	mov    %eax,%ecx
  800420f25a:	d3 e3                	shl    %cl,%ebx
  800420f25c:	89 d8                	mov    %ebx,%eax
  800420f25e:	48 98                	cltq   
  800420f260:	48 09 45 f0          	or     %rax,-0x10(%rbp)

	*dp = src;
  800420f264:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f268:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f26c:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f26f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420f273:	48 83 c4 28          	add    $0x28,%rsp
  800420f277:	5b                   	pop    %rbx
  800420f278:	5d                   	pop    %rbp
  800420f279:	c3                   	retq   

000000800420f27a <_dwarf_decode_uleb128>:

uint64_t
_dwarf_decode_uleb128(uint8_t **dp)
{
  800420f27a:	55                   	push   %rbp
  800420f27b:	48 89 e5             	mov    %rsp,%rbp
  800420f27e:	53                   	push   %rbx
  800420f27f:	48 83 ec 28          	sub    $0x28,%rsp
  800420f283:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
	uint64_t ret = 0;
  800420f287:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420f28e:	00 
	uint8_t b;
	int shift = 0;
  800420f28f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)

	uint8_t *src = *dp;
  800420f296:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f29a:	48 8b 00             	mov    (%rax),%rax
  800420f29d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	do {
		b = *src++;
  800420f2a1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f2a5:	0f b6 00             	movzbl (%rax),%eax
  800420f2a8:	88 45 df             	mov    %al,-0x21(%rbp)
  800420f2ab:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
		ret |= ((b & 0x7f) << shift);
  800420f2b0:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  800420f2b4:	89 c2                	mov    %eax,%edx
  800420f2b6:	83 e2 7f             	and    $0x7f,%edx
  800420f2b9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420f2bc:	89 d3                	mov    %edx,%ebx
  800420f2be:	89 c1                	mov    %eax,%ecx
  800420f2c0:	d3 e3                	shl    %cl,%ebx
  800420f2c2:	89 d8                	mov    %ebx,%eax
  800420f2c4:	48 98                	cltq   
  800420f2c6:	48 09 45 f0          	or     %rax,-0x10(%rbp)
		shift += 7;
  800420f2ca:	83 45 ec 07          	addl   $0x7,-0x14(%rbp)
	} while ((b & 0x80) != 0);
  800420f2ce:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  800420f2d2:	84 c0                	test   %al,%al
  800420f2d4:	78 cb                	js     800420f2a1 <_dwarf_decode_uleb128+0x27>

	*dp = src;
  800420f2d6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f2da:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f2de:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f2e1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420f2e5:	48 83 c4 28          	add    $0x28,%rsp
  800420f2e9:	5b                   	pop    %rbx
  800420f2ea:	5d                   	pop    %rbp
  800420f2eb:	c3                   	retq   

000000800420f2ec <_dwarf_read_string>:

#define Dwarf_Unsigned uint64_t

char *
_dwarf_read_string(void *data, Dwarf_Unsigned size, uint64_t *offsetp)
{
  800420f2ec:	55                   	push   %rbp
  800420f2ed:	48 89 e5             	mov    %rsp,%rbp
  800420f2f0:	48 83 ec 28          	sub    $0x28,%rsp
  800420f2f4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f2f8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f2fc:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *ret, *src;

	ret = src = (char *) data + *offsetp;
  800420f300:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f304:	48 8b 00             	mov    (%rax),%rax
  800420f307:	48 03 45 e8          	add    -0x18(%rbp),%rax
  800420f30b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420f30f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f313:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (*src != '\0' && *offsetp < size) {
  800420f317:	eb 17                	jmp    800420f330 <_dwarf_read_string+0x44>
		src++;
  800420f319:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
		(*offsetp)++;
  800420f31e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f322:	48 8b 00             	mov    (%rax),%rax
  800420f325:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f329:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f32d:	48 89 10             	mov    %rdx,(%rax)
{
	char *ret, *src;

	ret = src = (char *) data + *offsetp;

	while (*src != '\0' && *offsetp < size) {
  800420f330:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f334:	0f b6 00             	movzbl (%rax),%eax
  800420f337:	84 c0                	test   %al,%al
  800420f339:	74 0d                	je     800420f348 <_dwarf_read_string+0x5c>
  800420f33b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f33f:	48 8b 00             	mov    (%rax),%rax
  800420f342:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420f346:	72 d1                	jb     800420f319 <_dwarf_read_string+0x2d>
		src++;
		(*offsetp)++;
	}

	if (*src == '\0' && *offsetp < size)
  800420f348:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f34c:	0f b6 00             	movzbl (%rax),%eax
  800420f34f:	84 c0                	test   %al,%al
  800420f351:	75 1f                	jne    800420f372 <_dwarf_read_string+0x86>
  800420f353:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f357:	48 8b 00             	mov    (%rax),%rax
  800420f35a:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420f35e:	73 12                	jae    800420f372 <_dwarf_read_string+0x86>
		(*offsetp)++;
  800420f360:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f364:	48 8b 00             	mov    (%rax),%rax
  800420f367:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f36b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420f36f:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f372:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420f376:	c9                   	leaveq 
  800420f377:	c3                   	retq   

000000800420f378 <_dwarf_read_block>:

uint8_t *
_dwarf_read_block(void *data, uint64_t *offsetp, uint64_t length)
{
  800420f378:	55                   	push   %rbp
  800420f379:	48 89 e5             	mov    %rsp,%rbp
  800420f37c:	48 83 ec 28          	sub    $0x28,%rsp
  800420f380:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f384:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f388:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	uint8_t *ret, *src;

	ret = src = (uint8_t *) data + *offsetp;
  800420f38c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f390:	48 8b 00             	mov    (%rax),%rax
  800420f393:	48 03 45 e8          	add    -0x18(%rbp),%rax
  800420f397:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420f39b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f39f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	(*offsetp) += length;
  800420f3a3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f3a7:	48 8b 00             	mov    (%rax),%rax
  800420f3aa:	48 89 c2             	mov    %rax,%rdx
  800420f3ad:	48 03 55 d8          	add    -0x28(%rbp),%rdx
  800420f3b1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f3b5:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800420f3b8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420f3bc:	c9                   	leaveq 
  800420f3bd:	c3                   	retq   

000000800420f3be <_dwarf_elf_get_byte_order>:

Dwarf_Endianness
_dwarf_elf_get_byte_order(void *obj)
{
  800420f3be:	55                   	push   %rbp
  800420f3bf:	48 89 e5             	mov    %rsp,%rbp
  800420f3c2:	48 83 ec 20          	sub    $0x20,%rsp
  800420f3c6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    Elf *e;

    e = (Elf *)obj;
  800420f3ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f3ce:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    assert(e != NULL);
  800420f3d2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420f3d7:	75 35                	jne    800420f40e <_dwarf_elf_get_byte_order+0x50>
  800420f3d9:	48 b9 d8 90 21 04 80 	movabs $0x80042190d8,%rcx
  800420f3e0:	00 00 00 
  800420f3e3:	48 ba e2 90 21 04 80 	movabs $0x80042190e2,%rdx
  800420f3ea:	00 00 00 
  800420f3ed:	be 2b 01 00 00       	mov    $0x12b,%esi
  800420f3f2:	48 bf f7 90 21 04 80 	movabs $0x80042190f7,%rdi
  800420f3f9:	00 00 00 
  800420f3fc:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f401:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420f408:	00 00 00 
  800420f40b:	41 ff d0             	callq  *%r8

//TODO: Need to check for 64bit here. Because currently Elf header for
//      64bit doesn't have any memeber e_ident. But need to see what is
//      similar in 64bit.
    switch (e->e_ident[EI_DATA]) {
  800420f40e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f412:	0f b6 40 05          	movzbl 0x5(%rax),%eax
  800420f416:	0f b6 c0             	movzbl %al,%eax
  800420f419:	83 f8 02             	cmp    $0x2,%eax
  800420f41c:	75 07                	jne    800420f425 <_dwarf_elf_get_byte_order+0x67>
    case ELFDATA2MSB:
        return (DW_OBJECT_MSB);
  800420f41e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f423:	eb 05                	jmp    800420f42a <_dwarf_elf_get_byte_order+0x6c>

    case ELFDATA2LSB:
    case ELFDATANONE:
    default:
        return (DW_OBJECT_LSB);
  800420f425:	b8 01 00 00 00       	mov    $0x1,%eax
    }
}
  800420f42a:	c9                   	leaveq 
  800420f42b:	c3                   	retq   

000000800420f42c <_dwarf_elf_get_pointer_size>:

Dwarf_Small
_dwarf_elf_get_pointer_size(void *obj)
{
  800420f42c:	55                   	push   %rbp
  800420f42d:	48 89 e5             	mov    %rsp,%rbp
  800420f430:	48 83 ec 20          	sub    $0x20,%rsp
  800420f434:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    Elf *e;

    e = (Elf *) obj;
  800420f438:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f43c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    assert(e != NULL);
  800420f440:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420f445:	75 35                	jne    800420f47c <_dwarf_elf_get_pointer_size+0x50>
  800420f447:	48 b9 d8 90 21 04 80 	movabs $0x80042190d8,%rcx
  800420f44e:	00 00 00 
  800420f451:	48 ba e2 90 21 04 80 	movabs $0x80042190e2,%rdx
  800420f458:	00 00 00 
  800420f45b:	be 41 01 00 00       	mov    $0x141,%esi
  800420f460:	48 bf f7 90 21 04 80 	movabs $0x80042190f7,%rdi
  800420f467:	00 00 00 
  800420f46a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f46f:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420f476:	00 00 00 
  800420f479:	41 ff d0             	callq  *%r8

    if (e->e_ident[4] == ELFCLASS32)
  800420f47c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f480:	0f b6 40 04          	movzbl 0x4(%rax),%eax
  800420f484:	3c 01                	cmp    $0x1,%al
  800420f486:	75 07                	jne    800420f48f <_dwarf_elf_get_pointer_size+0x63>
        return (4);
  800420f488:	b8 04 00 00 00       	mov    $0x4,%eax
  800420f48d:	eb 05                	jmp    800420f494 <_dwarf_elf_get_pointer_size+0x68>
    else
        return (8);
  800420f48f:	b8 08 00 00 00       	mov    $0x8,%eax
}
  800420f494:	c9                   	leaveq 
  800420f495:	c3                   	retq   

000000800420f496 <_dwarf_init>:

//Return 0 on success
int _dwarf_init(Dwarf_Debug dbg, void *obj)
{
  800420f496:	55                   	push   %rbp
  800420f497:	48 89 e5             	mov    %rsp,%rbp
  800420f49a:	48 83 ec 10          	sub    $0x10,%rsp
  800420f49e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420f4a2:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    memset(dbg, 0, sizeof(struct _Dwarf_Debug));
  800420f4a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f4aa:	ba 58 00 00 00       	mov    $0x58,%edx
  800420f4af:	be 00 00 00 00       	mov    $0x0,%esi
  800420f4b4:	48 89 c7             	mov    %rax,%rdi
  800420f4b7:	48 b8 53 e6 20 04 80 	movabs $0x800420e653,%rax
  800420f4be:	00 00 00 
  800420f4c1:	ff d0                	callq  *%rax
    dbg->curr_off_dbginfo = 0;
  800420f4c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f4c7:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    dbg->dbg_info_size = 0;
  800420f4ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f4d2:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  800420f4d9:	00 
    dbg->dbg_pointer_size = _dwarf_elf_get_pointer_size(obj); 
  800420f4da:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f4de:	48 89 c7             	mov    %rax,%rdi
  800420f4e1:	48 b8 2c f4 20 04 80 	movabs $0x800420f42c,%rax
  800420f4e8:	00 00 00 
  800420f4eb:	ff d0                	callq  *%rax
  800420f4ed:	0f b6 d0             	movzbl %al,%edx
  800420f4f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f4f4:	89 50 28             	mov    %edx,0x28(%rax)

    if (_dwarf_elf_get_byte_order(obj) == DW_OBJECT_MSB) {
  800420f4f7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f4fb:	48 89 c7             	mov    %rax,%rdi
  800420f4fe:	48 b8 be f3 20 04 80 	movabs $0x800420f3be,%rax
  800420f505:	00 00 00 
  800420f508:	ff d0                	callq  *%rax
  800420f50a:	85 c0                	test   %eax,%eax
  800420f50c:	75 26                	jne    800420f534 <_dwarf_init+0x9e>
        dbg->read = _dwarf_read_msb;
  800420f50e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f512:	48 ba 5a ed 20 04 80 	movabs $0x800420ed5a,%rdx
  800420f519:	00 00 00 
  800420f51c:	48 89 50 18          	mov    %rdx,0x18(%rax)
        dbg->decode = _dwarf_decode_msb;
  800420f520:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f524:	48 ba 09 ef 20 04 80 	movabs $0x800420ef09,%rdx
  800420f52b:	00 00 00 
  800420f52e:	48 89 50 20          	mov    %rdx,0x20(%rax)
  800420f532:	eb 24                	jmp    800420f558 <_dwarf_init+0xc2>
    } else {
        dbg->read = _dwarf_read_lsb;
  800420f534:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f538:	48 ba 10 eb 20 04 80 	movabs $0x800420eb10,%rdx
  800420f53f:	00 00 00 
  800420f542:	48 89 50 18          	mov    %rdx,0x18(%rax)
        dbg->decode = _dwarf_decode_lsb;
  800420f546:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f54a:	48 ba 39 ec 20 04 80 	movabs $0x800420ec39,%rdx
  800420f551:	00 00 00 
  800420f554:	48 89 50 20          	mov    %rdx,0x20(%rax)
    }
   _dwarf_frame_params_init(dbg);
  800420f558:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f55c:	48 89 c7             	mov    %rax,%rdi
  800420f55f:	48 b8 9c 0a 21 04 80 	movabs $0x8004210a9c,%rax
  800420f566:	00 00 00 
  800420f569:	ff d0                	callq  *%rax
   return 0;
  800420f56b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420f570:	c9                   	leaveq 
  800420f571:	c3                   	retq   

000000800420f572 <_get_next_cu>:

//Return 0 on success
int _get_next_cu(Dwarf_Debug dbg, Dwarf_CU *cu)
{
  800420f572:	55                   	push   %rbp
  800420f573:	48 89 e5             	mov    %rsp,%rbp
  800420f576:	48 83 ec 20          	sub    $0x20,%rsp
  800420f57a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f57e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    uint32_t length;
    uint64_t offset;
    uint8_t dwarf_size;

    if(dbg->curr_off_dbginfo > dbg->dbg_info_size)
  800420f582:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f586:	48 8b 10             	mov    (%rax),%rdx
  800420f589:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f58d:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420f591:	48 39 c2             	cmp    %rax,%rdx
  800420f594:	76 0a                	jbe    800420f5a0 <_get_next_cu+0x2e>
        return -1;
  800420f596:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420f59b:	e9 73 01 00 00       	jmpq   800420f713 <_get_next_cu+0x1a1>

    offset = dbg->curr_off_dbginfo;
  800420f5a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f5a4:	48 8b 00             	mov    (%rax),%rax
  800420f5a7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	cu->cu_offset = offset;
  800420f5ab:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f5af:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f5b3:	48 89 50 30          	mov    %rdx,0x30(%rax)

    length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset,4);
  800420f5b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f5bb:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800420f5bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f5c3:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420f5c7:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420f5cb:	ba 04 00 00 00       	mov    $0x4,%edx
  800420f5d0:	48 89 ce             	mov    %rcx,%rsi
  800420f5d3:	48 89 c7             	mov    %rax,%rdi
  800420f5d6:	41 ff d0             	callq  *%r8
  800420f5d9:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (length == 0xffffffff) {
  800420f5dc:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  800420f5e0:	75 2b                	jne    800420f60d <_get_next_cu+0x9b>
        length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 8);
  800420f5e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f5e6:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800420f5ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f5ee:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420f5f2:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420f5f6:	ba 08 00 00 00       	mov    $0x8,%edx
  800420f5fb:	48 89 ce             	mov    %rcx,%rsi
  800420f5fe:	48 89 c7             	mov    %rax,%rdi
  800420f601:	41 ff d0             	callq  *%r8
  800420f604:	89 45 fc             	mov    %eax,-0x4(%rbp)
        dwarf_size = 8;
  800420f607:	c6 45 fb 08          	movb   $0x8,-0x5(%rbp)
  800420f60b:	eb 04                	jmp    800420f611 <_get_next_cu+0x9f>
    } else {
        dwarf_size = 4;
  800420f60d:	c6 45 fb 04          	movb   $0x4,-0x5(%rbp)
    }

    cu->cu_dwarf_size = dwarf_size;
  800420f611:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f615:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  800420f619:	88 50 19             	mov    %dl,0x19(%rax)
	if (length > ds->ds_size - offset) {
		return (DW_DLE_CU_LENGTH_ERROR);
	}*/

	/* Compute the offset to the next compilation unit: */
	dbg->curr_off_dbginfo = offset + length;
  800420f61c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420f61f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f623:	48 01 c2             	add    %rax,%rdx
  800420f626:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f62a:	48 89 10             	mov    %rdx,(%rax)
	cu->cu_next_offset   = dbg->curr_off_dbginfo;
  800420f62d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f631:	48 8b 10             	mov    (%rax),%rdx
  800420f634:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f638:	48 89 50 20          	mov    %rdx,0x20(%rax)

	/* Initialise the compilation unit. */
	cu->cu_length = (uint64_t)length;
  800420f63c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420f63f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f643:	48 89 10             	mov    %rdx,(%rax)

	cu->cu_length_size   = (dwarf_size == 4 ? 4 : 12);
  800420f646:	80 7d fb 04          	cmpb   $0x4,-0x5(%rbp)
  800420f64a:	75 07                	jne    800420f653 <_get_next_cu+0xe1>
  800420f64c:	b8 04 00 00 00       	mov    $0x4,%eax
  800420f651:	eb 05                	jmp    800420f658 <_get_next_cu+0xe6>
  800420f653:	b8 0c 00 00 00       	mov    $0xc,%eax
  800420f658:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f65c:	88 42 18             	mov    %al,0x18(%rdx)
	cu->version              = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 2);
  800420f65f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f663:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800420f667:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f66b:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420f66f:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420f673:	ba 02 00 00 00       	mov    $0x2,%edx
  800420f678:	48 89 ce             	mov    %rcx,%rsi
  800420f67b:	48 89 c7             	mov    %rax,%rdi
  800420f67e:	41 ff d0             	callq  *%r8
  800420f681:	89 c2                	mov    %eax,%edx
  800420f683:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f687:	66 89 50 08          	mov    %dx,0x8(%rax)
	cu->debug_abbrev_offset  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, dwarf_size);
  800420f68b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f68f:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800420f693:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  800420f697:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f69b:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420f69f:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420f6a3:	48 89 ce             	mov    %rcx,%rsi
  800420f6a6:	48 89 c7             	mov    %rax,%rdi
  800420f6a9:	41 ff d0             	callq  *%r8
  800420f6ac:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f6b0:	48 89 42 10          	mov    %rax,0x10(%rdx)
	//cu->cu_abbrev_offset_cur = cu->cu_abbrev_offset;
	cu->addr_size  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 1);
  800420f6b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6b8:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800420f6bc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6c0:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420f6c4:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420f6c8:	ba 01 00 00 00       	mov    $0x1,%edx
  800420f6cd:	48 89 ce             	mov    %rcx,%rsi
  800420f6d0:	48 89 c7             	mov    %rax,%rdi
  800420f6d3:	41 ff d0             	callq  *%r8
  800420f6d6:	89 c2                	mov    %eax,%edx
  800420f6d8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f6dc:	88 50 0a             	mov    %dl,0xa(%rax)

	if (cu->version < 2 || cu->version > 4) {
  800420f6df:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f6e3:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420f6e7:	66 83 f8 01          	cmp    $0x1,%ax
  800420f6eb:	76 0e                	jbe    800420f6fb <_get_next_cu+0x189>
  800420f6ed:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f6f1:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420f6f5:	66 83 f8 04          	cmp    $0x4,%ax
  800420f6f9:	76 07                	jbe    800420f702 <_get_next_cu+0x190>
		return -1;
  800420f6fb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420f700:	eb 11                	jmp    800420f713 <_get_next_cu+0x1a1>
	}

	cu->cu_die_offset = offset;
  800420f702:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f706:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f70a:	48 89 50 28          	mov    %rdx,0x28(%rax)

	return 0;
  800420f70e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420f713:	c9                   	leaveq 
  800420f714:	c3                   	retq   

000000800420f715 <print_cu>:

void print_cu(Dwarf_CU cu)
{
  800420f715:	55                   	push   %rbp
  800420f716:	48 89 e5             	mov    %rsp,%rbp
    cprintf("%ld---%du--%d\n",cu.cu_length,cu.version,cu.addr_size);
  800420f719:	0f b6 45 1a          	movzbl 0x1a(%rbp),%eax
  800420f71d:	0f b6 c8             	movzbl %al,%ecx
  800420f720:	0f b7 45 18          	movzwl 0x18(%rbp),%eax
  800420f724:	0f b7 d0             	movzwl %ax,%edx
  800420f727:	48 8b 45 10          	mov    0x10(%rbp),%rax
  800420f72b:	48 89 c6             	mov    %rax,%rsi
  800420f72e:	48 bf 0a 91 21 04 80 	movabs $0x800421910a,%rdi
  800420f735:	00 00 00 
  800420f738:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f73d:	49 b8 f2 89 20 04 80 	movabs $0x80042089f2,%r8
  800420f744:	00 00 00 
  800420f747:	41 ff d0             	callq  *%r8
}
  800420f74a:	5d                   	pop    %rbp
  800420f74b:	c3                   	retq   

000000800420f74c <_dwarf_abbrev_parse>:

//Return 0 on success
int
_dwarf_abbrev_parse(Dwarf_Debug dbg, Dwarf_CU cu, Dwarf_Unsigned *offset,
    Dwarf_Abbrev *abp, Dwarf_Section *ds)
{
  800420f74c:	55                   	push   %rbp
  800420f74d:	48 89 e5             	mov    %rsp,%rbp
  800420f750:	48 83 ec 60          	sub    $0x60,%rsp
  800420f754:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800420f758:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800420f75c:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  800420f760:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    uint64_t tag;
    uint8_t children;
    uint64_t abbr_addr;
    int ret;

    assert(abp != NULL);
  800420f764:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  800420f769:	75 35                	jne    800420f7a0 <_dwarf_abbrev_parse+0x54>
  800420f76b:	48 b9 19 91 21 04 80 	movabs $0x8004219119,%rcx
  800420f772:	00 00 00 
  800420f775:	48 ba e2 90 21 04 80 	movabs $0x80042190e2,%rdx
  800420f77c:	00 00 00 
  800420f77f:	be a6 01 00 00       	mov    $0x1a6,%esi
  800420f784:	48 bf f7 90 21 04 80 	movabs $0x80042190f7,%rdi
  800420f78b:	00 00 00 
  800420f78e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f793:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420f79a:	00 00 00 
  800420f79d:	41 ff d0             	callq  *%r8
    assert(ds != NULL);
  800420f7a0:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  800420f7a5:	75 35                	jne    800420f7dc <_dwarf_abbrev_parse+0x90>
  800420f7a7:	48 b9 25 91 21 04 80 	movabs $0x8004219125,%rcx
  800420f7ae:	00 00 00 
  800420f7b1:	48 ba e2 90 21 04 80 	movabs $0x80042190e2,%rdx
  800420f7b8:	00 00 00 
  800420f7bb:	be a7 01 00 00       	mov    $0x1a7,%esi
  800420f7c0:	48 bf f7 90 21 04 80 	movabs $0x80042190f7,%rdi
  800420f7c7:	00 00 00 
  800420f7ca:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f7cf:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420f7d6:	00 00 00 
  800420f7d9:	41 ff d0             	callq  *%r8

    if (*offset >= ds->ds_size)
  800420f7dc:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420f7e0:	48 8b 10             	mov    (%rax),%rdx
  800420f7e3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420f7e7:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f7eb:	48 39 c2             	cmp    %rax,%rdx
  800420f7ee:	72 0a                	jb     800420f7fa <_dwarf_abbrev_parse+0xae>
        	return (DW_DLE_NO_ENTRY);
  800420f7f0:	b8 04 00 00 00       	mov    $0x4,%eax
  800420f7f5:	e9 d7 01 00 00       	jmpq   800420f9d1 <_dwarf_abbrev_parse+0x285>

    aboff = *offset;
  800420f7fa:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420f7fe:	48 8b 00             	mov    (%rax),%rax
  800420f801:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    abbr_addr = (uint64_t)ds->ds_data; //(uint64_t)((uint8_t *)elf_base_ptr + ds->sh_offset);
  800420f805:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420f809:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420f80d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

    entry = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420f811:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f815:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420f819:	48 89 d6             	mov    %rdx,%rsi
  800420f81c:	48 89 c7             	mov    %rax,%rdi
  800420f81f:	48 b8 60 f1 20 04 80 	movabs $0x800420f160,%rax
  800420f826:	00 00 00 
  800420f829:	ff d0                	callq  *%rax
  800420f82b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    if (entry == 0) {
  800420f82f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f834:	75 15                	jne    800420f84b <_dwarf_abbrev_parse+0xff>
        /* Last entry. */
        //Need to make connection from below function
        abp->ab_entry = 0;
  800420f836:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f83a:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
        return DW_DLE_NONE;
  800420f841:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f846:	e9 86 01 00 00       	jmpq   800420f9d1 <_dwarf_abbrev_parse+0x285>
    }

    tag = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420f84b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f84f:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420f853:	48 89 d6             	mov    %rdx,%rsi
  800420f856:	48 89 c7             	mov    %rax,%rdi
  800420f859:	48 b8 60 f1 20 04 80 	movabs $0x800420f160,%rax
  800420f860:	00 00 00 
  800420f863:	ff d0                	callq  *%rax
  800420f865:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    children = dbg->read((uint8_t *)abbr_addr, offset, 1);
  800420f869:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420f86d:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800420f871:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f875:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800420f879:	ba 01 00 00 00       	mov    $0x1,%edx
  800420f87e:	48 89 ce             	mov    %rcx,%rsi
  800420f881:	48 89 c7             	mov    %rax,%rdi
  800420f884:	41 ff d0             	callq  *%r8
  800420f887:	88 45 df             	mov    %al,-0x21(%rbp)

    abp->ab_entry    = entry;
  800420f88a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f88e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f892:	48 89 10             	mov    %rdx,(%rax)
    abp->ab_tag      = tag;
  800420f895:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f899:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f89d:	48 89 50 08          	mov    %rdx,0x8(%rax)
    abp->ab_children = children;
  800420f8a1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f8a5:	0f b6 55 df          	movzbl -0x21(%rbp),%edx
  800420f8a9:	88 50 10             	mov    %dl,0x10(%rax)
    abp->ab_offset   = aboff;
  800420f8ac:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f8b0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420f8b4:	48 89 50 18          	mov    %rdx,0x18(%rax)
    abp->ab_length   = 0;    /* fill in later. */
  800420f8b8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f8bc:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  800420f8c3:	00 
    abp->ab_atnum    = 0;
  800420f8c4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f8c8:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  800420f8cf:	00 

    /* Parse attribute definitions. */
    do {
        adoff = *offset;
  800420f8d0:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420f8d4:	48 8b 00             	mov    (%rax),%rax
  800420f8d7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
        attr = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420f8db:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f8df:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420f8e3:	48 89 d6             	mov    %rdx,%rsi
  800420f8e6:	48 89 c7             	mov    %rax,%rdi
  800420f8e9:	48 b8 60 f1 20 04 80 	movabs $0x800420f160,%rax
  800420f8f0:	00 00 00 
  800420f8f3:	ff d0                	callq  *%rax
  800420f8f5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        form = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  800420f8f9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f8fd:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420f901:	48 89 d6             	mov    %rdx,%rsi
  800420f904:	48 89 c7             	mov    %rax,%rdi
  800420f907:	48 b8 60 f1 20 04 80 	movabs $0x800420f160,%rax
  800420f90e:	00 00 00 
  800420f911:	ff d0                	callq  *%rax
  800420f913:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        if (attr != 0)
  800420f917:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420f91c:	0f 84 89 00 00 00    	je     800420f9ab <_dwarf_abbrev_parse+0x25f>
        {
            /* Initialise the attribute definition structure. */
            abp->ab_attrdef[abp->ab_atnum].ad_attrib = attr;
  800420f922:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f926:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420f92a:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420f92e:	48 89 d0             	mov    %rdx,%rax
  800420f931:	48 01 c0             	add    %rax,%rax
  800420f934:	48 01 d0             	add    %rdx,%rax
  800420f937:	48 c1 e0 03          	shl    $0x3,%rax
  800420f93b:	48 01 c8             	add    %rcx,%rax
  800420f93e:	48 8d 50 30          	lea    0x30(%rax),%rdx
  800420f942:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f946:	48 89 02             	mov    %rax,(%rdx)
            abp->ab_attrdef[abp->ab_atnum].ad_form   = form;
  800420f949:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f94d:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420f951:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420f955:	48 89 d0             	mov    %rdx,%rax
  800420f958:	48 01 c0             	add    %rax,%rax
  800420f95b:	48 01 d0             	add    %rdx,%rax
  800420f95e:	48 c1 e0 03          	shl    $0x3,%rax
  800420f962:	48 01 c8             	add    %rcx,%rax
  800420f965:	48 8d 50 38          	lea    0x38(%rax),%rdx
  800420f969:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420f96d:	48 89 02             	mov    %rax,(%rdx)
            abp->ab_attrdef[abp->ab_atnum].ad_offset = adoff;
  800420f970:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f974:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420f978:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  800420f97c:	48 89 d0             	mov    %rdx,%rax
  800420f97f:	48 01 c0             	add    %rax,%rax
  800420f982:	48 01 d0             	add    %rdx,%rax
  800420f985:	48 c1 e0 03          	shl    $0x3,%rax
  800420f989:	48 01 c8             	add    %rcx,%rax
  800420f98c:	48 8d 50 40          	lea    0x40(%rax),%rdx
  800420f990:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f994:	48 89 02             	mov    %rax,(%rdx)
            abp->ab_atnum++;
  800420f997:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f99b:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420f99f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f9a3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f9a7:	48 89 50 28          	mov    %rdx,0x28(%rax)
        }
    } while (attr != 0);
  800420f9ab:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420f9b0:	0f 85 1a ff ff ff    	jne    800420f8d0 <_dwarf_abbrev_parse+0x184>

    //(*abp)->ab_length = *offset - aboff;
    abp->ab_length = (uint64_t)(*offset - aboff);
  800420f9b6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420f9ba:	48 8b 00             	mov    (%rax),%rax
  800420f9bd:	48 89 c2             	mov    %rax,%rdx
  800420f9c0:	48 2b 55 f8          	sub    -0x8(%rbp),%rdx
  800420f9c4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f9c8:	48 89 50 20          	mov    %rdx,0x20(%rax)

    return DW_DLV_OK;
  800420f9cc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420f9d1:	c9                   	leaveq 
  800420f9d2:	c3                   	retq   

000000800420f9d3 <_dwarf_abbrev_find>:

//Return 0 on success
int
_dwarf_abbrev_find(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t entry, Dwarf_Abbrev *abp)
{
  800420f9d3:	55                   	push   %rbp
  800420f9d4:	48 89 e5             	mov    %rsp,%rbp
  800420f9d7:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  800420f9db:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420f9df:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420f9e3:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    Dwarf_Section *ds;
    uint64_t offset;
    int ret;

    if (entry == 0)
  800420f9e7:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420f9ec:	75 0a                	jne    800420f9f8 <_dwarf_abbrev_find+0x25>
    {
		return (DW_DLE_NO_ENTRY);
  800420f9ee:	b8 04 00 00 00       	mov    $0x4,%eax
  800420f9f3:	e9 0b 01 00 00       	jmpq   800420fb03 <_dwarf_abbrev_find+0x130>
    }

    /* Load and search the abbrev table. */
    ds = _dwarf_find_section(".debug_abbrev");
  800420f9f8:	48 bf 30 91 21 04 80 	movabs $0x8004219130,%rdi
  800420f9ff:	00 00 00 
  800420fa02:	48 b8 e0 3d 21 04 80 	movabs $0x8004213de0,%rax
  800420fa09:	00 00 00 
  800420fa0c:	ff d0                	callq  *%rax
  800420fa0e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    assert(ds != NULL);
  800420fa12:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420fa17:	75 35                	jne    800420fa4e <_dwarf_abbrev_find+0x7b>
  800420fa19:	48 b9 25 91 21 04 80 	movabs $0x8004219125,%rcx
  800420fa20:	00 00 00 
  800420fa23:	48 ba e2 90 21 04 80 	movabs $0x80042190e2,%rdx
  800420fa2a:	00 00 00 
  800420fa2d:	be e7 01 00 00       	mov    $0x1e7,%esi
  800420fa32:	48 bf f7 90 21 04 80 	movabs $0x80042190f7,%rdi
  800420fa39:	00 00 00 
  800420fa3c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fa41:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800420fa48:	00 00 00 
  800420fa4b:	41 ff d0             	callq  *%r8

    //TODO: We are starting offset from 0, however libdwarf logic
    //      is keeping a counter for current offset. Ok. let use
    //      that. I relent, but this will be done in Phase 2. :)
    //offset = 0; //cu->cu_abbrev_offset_cur;
    offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
  800420fa4e:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800420fa52:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    while (offset < ds->ds_size) {
  800420fa56:	e9 8b 00 00 00       	jmpq   800420fae6 <_dwarf_abbrev_find+0x113>
        ret = _dwarf_abbrev_parse(dbg, cu, &offset, abp, ds);
  800420fa5b:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  800420fa5f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420fa63:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  800420fa67:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fa6b:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  800420fa6f:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420fa73:	48 8b 7d 18          	mov    0x18(%rbp),%rdi
  800420fa77:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420fa7c:	48 8b 7d 20          	mov    0x20(%rbp),%rdi
  800420fa80:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420fa85:	48 8b 7d 28          	mov    0x28(%rbp),%rdi
  800420fa89:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420fa8e:	48 8b 7d 30          	mov    0x30(%rbp),%rdi
  800420fa92:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420fa97:	48 8b 7d 38          	mov    0x38(%rbp),%rdi
  800420fa9b:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420faa0:	48 8b 7d 40          	mov    0x40(%rbp),%rdi
  800420faa4:	48 89 7c 24 30       	mov    %rdi,0x30(%rsp)
  800420faa9:	48 89 c7             	mov    %rax,%rdi
  800420faac:	48 b8 4c f7 20 04 80 	movabs $0x800420f74c,%rax
  800420fab3:	00 00 00 
  800420fab6:	ff d0                	callq  *%rax
  800420fab8:	89 45 f4             	mov    %eax,-0xc(%rbp)
        if (ret != DW_DLE_NONE)
  800420fabb:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420fabf:	74 05                	je     800420fac6 <_dwarf_abbrev_find+0xf3>
            return (ret);
  800420fac1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420fac4:	eb 3d                	jmp    800420fb03 <_dwarf_abbrev_find+0x130>
        if (abp->ab_entry == entry) {
  800420fac6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420faca:	48 8b 00             	mov    (%rax),%rax
  800420facd:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800420fad1:	75 07                	jne    800420fada <_dwarf_abbrev_find+0x107>
            //cu->cu_abbrev_offset_cur = offset;
            return DW_DLE_NONE;
  800420fad3:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fad8:	eb 29                	jmp    800420fb03 <_dwarf_abbrev_find+0x130>
        }
        if (abp->ab_entry == 0) {
  800420fada:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420fade:	48 8b 00             	mov    (%rax),%rax
  800420fae1:	48 85 c0             	test   %rax,%rax
  800420fae4:	74 17                	je     800420fafd <_dwarf_abbrev_find+0x12a>
    //TODO: We are starting offset from 0, however libdwarf logic
    //      is keeping a counter for current offset. Ok. let use
    //      that. I relent, but this will be done in Phase 2. :)
    //offset = 0; //cu->cu_abbrev_offset_cur;
    offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
    while (offset < ds->ds_size) {
  800420fae6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420faea:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800420faee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420faf2:	48 39 c2             	cmp    %rax,%rdx
  800420faf5:	0f 87 60 ff ff ff    	ja     800420fa5b <_dwarf_abbrev_find+0x88>
  800420fafb:	eb 01                	jmp    800420fafe <_dwarf_abbrev_find+0x12b>
            return DW_DLE_NONE;
        }
        if (abp->ab_entry == 0) {
            //cu->cu_abbrev_offset_cur = offset;
            //cu->cu_abbrev_loaded = 1;
            break;
  800420fafd:	90                   	nop
        }
    }

    return DW_DLE_NO_ENTRY;
  800420fafe:	b8 04 00 00 00       	mov    $0x4,%eax
}
  800420fb03:	c9                   	leaveq 
  800420fb04:	c3                   	retq   

000000800420fb05 <_dwarf_attr_init>:

//Return 0 on success
int
_dwarf_attr_init(Dwarf_Debug dbg, uint64_t *offsetp, Dwarf_CU *cu, Dwarf_Die *ret_die, Dwarf_AttrDef *ad,
    uint64_t form, int indirect)
{
  800420fb05:	55                   	push   %rbp
  800420fb06:	48 89 e5             	mov    %rsp,%rbp
  800420fb09:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  800420fb10:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  800420fb17:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  800420fb1e:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  800420fb25:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
  800420fb2c:	4c 89 85 48 ff ff ff 	mov    %r8,-0xb8(%rbp)
  800420fb33:	4c 89 8d 40 ff ff ff 	mov    %r9,-0xc0(%rbp)
    struct _Dwarf_Attribute atref;
    Dwarf_Section *str;
    int ret;
    Dwarf_Section *ds = _dwarf_find_section(".debug_info");
  800420fb3a:	48 bf 3e 91 21 04 80 	movabs $0x800421913e,%rdi
  800420fb41:	00 00 00 
  800420fb44:	48 b8 e0 3d 21 04 80 	movabs $0x8004213de0,%rax
  800420fb4b:	00 00 00 
  800420fb4e:	ff d0                	callq  *%rax
  800420fb50:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    uint8_t *ds_data = (uint8_t *)ds->ds_data; //(uint8_t *)dbg->dbg_info_offset_elf;
  800420fb54:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fb58:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420fb5c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    uint8_t dwarf_size = cu->cu_dwarf_size;
  800420fb60:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420fb67:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  800420fb6b:	88 45 e7             	mov    %al,-0x19(%rbp)

    ret = DW_DLE_NONE;
  800420fb6e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    memset(&atref, 0, sizeof(atref));
  800420fb75:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  800420fb7c:	ba 60 00 00 00       	mov    $0x60,%edx
  800420fb81:	be 00 00 00 00       	mov    $0x0,%esi
  800420fb86:	48 89 c7             	mov    %rax,%rdi
  800420fb89:	48 b8 53 e6 20 04 80 	movabs $0x800420e653,%rax
  800420fb90:	00 00 00 
  800420fb93:	ff d0                	callq  *%rax
    atref.at_die = ret_die;
  800420fb95:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800420fb9c:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
    atref.at_attrib = ad->ad_attrib;
  800420fba3:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420fbaa:	48 8b 00             	mov    (%rax),%rax
  800420fbad:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    atref.at_form = ad->ad_form;
  800420fbb1:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420fbb8:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420fbbc:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    atref.at_indirect = indirect;
  800420fbc0:	8b 45 10             	mov    0x10(%rbp),%eax
  800420fbc3:	89 45 90             	mov    %eax,-0x70(%rbp)
    atref.at_ld = NULL;
  800420fbc6:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  800420fbcd:	00 

    switch (form) {
  800420fbce:	48 83 bd 40 ff ff ff 	cmpq   $0x20,-0xc0(%rbp)
  800420fbd5:	20 
  800420fbd6:	0f 87 b4 04 00 00    	ja     8004210090 <_dwarf_attr_init+0x58b>
  800420fbdc:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  800420fbe3:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420fbea:	00 
  800420fbeb:	48 b8 68 91 21 04 80 	movabs $0x8004219168,%rax
  800420fbf2:	00 00 00 
  800420fbf5:	48 01 d0             	add    %rdx,%rax
  800420fbf8:	48 8b 00             	mov    (%rax),%rax
  800420fbfb:	ff e0                	jmpq   *%rax
    case DW_FORM_addr:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  800420fbfd:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420fc04:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800420fc08:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420fc0f:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  800420fc13:	0f b6 d0             	movzbl %al,%edx
  800420fc16:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420fc1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc21:	48 89 ce             	mov    %rcx,%rsi
  800420fc24:	48 89 c7             	mov    %rax,%rdi
  800420fc27:	41 ff d0             	callq  *%r8
  800420fc2a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  800420fc2e:	e9 67 04 00 00       	jmpq   800421009a <_dwarf_attr_init+0x595>
    case DW_FORM_block:
    case DW_FORM_exprloc:
        atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  800420fc33:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420fc3a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc3e:	48 89 d6             	mov    %rdx,%rsi
  800420fc41:	48 89 c7             	mov    %rax,%rdi
  800420fc44:	48 b8 60 f1 20 04 80 	movabs $0x800420f160,%rax
  800420fc4b:	00 00 00 
  800420fc4e:	ff d0                	callq  *%rax
  800420fc50:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800420fc54:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420fc58:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420fc5f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc63:	48 89 ce             	mov    %rcx,%rsi
  800420fc66:	48 89 c7             	mov    %rax,%rdi
  800420fc69:	48 b8 78 f3 20 04 80 	movabs $0x800420f378,%rax
  800420fc70:	00 00 00 
  800420fc73:	ff d0                	callq  *%rax
  800420fc75:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  800420fc79:	e9 1c 04 00 00       	jmpq   800421009a <_dwarf_attr_init+0x595>
    case DW_FORM_block1:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  800420fc7e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420fc85:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800420fc89:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420fc90:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc94:	ba 01 00 00 00       	mov    $0x1,%edx
  800420fc99:	48 89 ce             	mov    %rcx,%rsi
  800420fc9c:	48 89 c7             	mov    %rax,%rdi
  800420fc9f:	41 ff d0             	callq  *%r8
  800420fca2:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800420fca6:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420fcaa:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420fcb1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fcb5:	48 89 ce             	mov    %rcx,%rsi
  800420fcb8:	48 89 c7             	mov    %rax,%rdi
  800420fcbb:	48 b8 78 f3 20 04 80 	movabs $0x800420f378,%rax
  800420fcc2:	00 00 00 
  800420fcc5:	ff d0                	callq  *%rax
  800420fcc7:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  800420fccb:	e9 ca 03 00 00       	jmpq   800421009a <_dwarf_attr_init+0x595>
    case DW_FORM_block2:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  800420fcd0:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420fcd7:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800420fcdb:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420fce2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fce6:	ba 02 00 00 00       	mov    $0x2,%edx
  800420fceb:	48 89 ce             	mov    %rcx,%rsi
  800420fcee:	48 89 c7             	mov    %rax,%rdi
  800420fcf1:	41 ff d0             	callq  *%r8
  800420fcf4:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800420fcf8:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420fcfc:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420fd03:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd07:	48 89 ce             	mov    %rcx,%rsi
  800420fd0a:	48 89 c7             	mov    %rax,%rdi
  800420fd0d:	48 b8 78 f3 20 04 80 	movabs $0x800420f378,%rax
  800420fd14:	00 00 00 
  800420fd17:	ff d0                	callq  *%rax
  800420fd19:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  800420fd1d:	e9 78 03 00 00       	jmpq   800421009a <_dwarf_attr_init+0x595>
   case DW_FORM_block4:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  800420fd22:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420fd29:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800420fd2d:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420fd34:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd38:	ba 04 00 00 00       	mov    $0x4,%edx
  800420fd3d:	48 89 ce             	mov    %rcx,%rsi
  800420fd40:	48 89 c7             	mov    %rax,%rdi
  800420fd43:	41 ff d0             	callq  *%r8
  800420fd46:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800420fd4a:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800420fd4e:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420fd55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd59:	48 89 ce             	mov    %rcx,%rsi
  800420fd5c:	48 89 c7             	mov    %rax,%rdi
  800420fd5f:	48 b8 78 f3 20 04 80 	movabs $0x800420f378,%rax
  800420fd66:	00 00 00 
  800420fd69:	ff d0                	callq  *%rax
  800420fd6b:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  800420fd6f:	e9 26 03 00 00       	jmpq   800421009a <_dwarf_attr_init+0x595>
    case DW_FORM_data1:
    case DW_FORM_flag:
    case DW_FORM_ref1:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  800420fd74:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420fd7b:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800420fd7f:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420fd86:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd8a:	ba 01 00 00 00       	mov    $0x1,%edx
  800420fd8f:	48 89 ce             	mov    %rcx,%rsi
  800420fd92:	48 89 c7             	mov    %rax,%rdi
  800420fd95:	41 ff d0             	callq  *%r8
  800420fd98:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  800420fd9c:	e9 f9 02 00 00       	jmpq   800421009a <_dwarf_attr_init+0x595>
    case DW_FORM_data2:
    case DW_FORM_ref2:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  800420fda1:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420fda8:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800420fdac:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420fdb3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fdb7:	ba 02 00 00 00       	mov    $0x2,%edx
  800420fdbc:	48 89 ce             	mov    %rcx,%rsi
  800420fdbf:	48 89 c7             	mov    %rax,%rdi
  800420fdc2:	41 ff d0             	callq  *%r8
  800420fdc5:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  800420fdc9:	e9 cc 02 00 00       	jmpq   800421009a <_dwarf_attr_init+0x595>
    case DW_FORM_data4:
    case DW_FORM_ref4:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  800420fdce:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420fdd5:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800420fdd9:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420fde0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fde4:	ba 04 00 00 00       	mov    $0x4,%edx
  800420fde9:	48 89 ce             	mov    %rcx,%rsi
  800420fdec:	48 89 c7             	mov    %rax,%rdi
  800420fdef:	41 ff d0             	callq  *%r8
  800420fdf2:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  800420fdf6:	e9 9f 02 00 00       	jmpq   800421009a <_dwarf_attr_init+0x595>
    case DW_FORM_data8:
    case DW_FORM_ref8:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, 8);
  800420fdfb:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420fe02:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800420fe06:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420fe0d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fe11:	ba 08 00 00 00       	mov    $0x8,%edx
  800420fe16:	48 89 ce             	mov    %rcx,%rsi
  800420fe19:	48 89 c7             	mov    %rax,%rdi
  800420fe1c:	41 ff d0             	callq  *%r8
  800420fe1f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  800420fe23:	e9 72 02 00 00       	jmpq   800421009a <_dwarf_attr_init+0x595>
    case DW_FORM_indirect:
        form = _dwarf_read_uleb128(ds_data, offsetp);
  800420fe28:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420fe2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fe33:	48 89 d6             	mov    %rdx,%rsi
  800420fe36:	48 89 c7             	mov    %rax,%rdi
  800420fe39:	48 b8 60 f1 20 04 80 	movabs $0x800420f160,%rax
  800420fe40:	00 00 00 
  800420fe43:	ff d0                	callq  *%rax
  800420fe45:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
        return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
  800420fe4c:	4c 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%r8
  800420fe53:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
  800420fe5a:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  800420fe61:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  800420fe68:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800420fe6f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420fe76:	c7 04 24 01 00 00 00 	movl   $0x1,(%rsp)
  800420fe7d:	4d 89 c1             	mov    %r8,%r9
  800420fe80:	49 89 f8             	mov    %rdi,%r8
  800420fe83:	48 89 c7             	mov    %rax,%rdi
  800420fe86:	48 b8 05 fb 20 04 80 	movabs $0x800420fb05,%rax
  800420fe8d:	00 00 00 
  800420fe90:	ff d0                	callq  *%rax
  800420fe92:	e9 31 03 00 00       	jmpq   80042101c8 <_dwarf_attr_init+0x6c3>
    case DW_FORM_ref_addr:
        if (cu->version == 2)
  800420fe97:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420fe9e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420fea2:	66 83 f8 02          	cmp    $0x2,%ax
  800420fea6:	75 36                	jne    800420fede <_dwarf_attr_init+0x3d9>
            atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  800420fea8:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420feaf:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800420feb3:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420feba:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  800420febe:	0f b6 d0             	movzbl %al,%edx
  800420fec1:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420fec8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fecc:	48 89 ce             	mov    %rcx,%rsi
  800420fecf:	48 89 c7             	mov    %rax,%rdi
  800420fed2:	41 ff d0             	callq  *%r8
  800420fed5:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        else if (cu->version == 3)
            atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
        break;
  800420fed9:	e9 bb 01 00 00       	jmpq   8004210099 <_dwarf_attr_init+0x594>
        form = _dwarf_read_uleb128(ds_data, offsetp);
        return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
    case DW_FORM_ref_addr:
        if (cu->version == 2)
            atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
        else if (cu->version == 3)
  800420fede:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420fee5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420fee9:	66 83 f8 03          	cmp    $0x3,%ax
  800420feed:	0f 85 a6 01 00 00    	jne    8004210099 <_dwarf_attr_init+0x594>
            atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  800420fef3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420fefa:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800420fefe:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  800420ff02:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420ff09:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ff0d:	48 89 ce             	mov    %rcx,%rsi
  800420ff10:	48 89 c7             	mov    %rax,%rdi
  800420ff13:	41 ff d0             	callq  *%r8
  800420ff16:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  800420ff1a:	e9 7a 01 00 00       	jmpq   8004210099 <_dwarf_attr_init+0x594>
    case DW_FORM_ref_udata:
    case DW_FORM_udata:
        atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  800420ff1f:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420ff26:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ff2a:	48 89 d6             	mov    %rdx,%rsi
  800420ff2d:	48 89 c7             	mov    %rax,%rdi
  800420ff30:	48 b8 60 f1 20 04 80 	movabs $0x800420f160,%rax
  800420ff37:	00 00 00 
  800420ff3a:	ff d0                	callq  *%rax
  800420ff3c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  800420ff40:	e9 55 01 00 00       	jmpq   800421009a <_dwarf_attr_init+0x595>
    case DW_FORM_sdata:
        atref.u[0].s64 = _dwarf_read_sleb128(ds_data, offsetp);
  800420ff45:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420ff4c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ff50:	48 89 d6             	mov    %rdx,%rsi
  800420ff53:	48 89 c7             	mov    %rax,%rdi
  800420ff56:	48 b8 b8 f0 20 04 80 	movabs $0x800420f0b8,%rax
  800420ff5d:	00 00 00 
  800420ff60:	ff d0                	callq  *%rax
  800420ff62:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  800420ff66:	e9 2f 01 00 00       	jmpq   800421009a <_dwarf_attr_init+0x595>
    case DW_FORM_sec_offset:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  800420ff6b:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420ff72:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800420ff76:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  800420ff7a:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420ff81:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ff85:	48 89 ce             	mov    %rcx,%rsi
  800420ff88:	48 89 c7             	mov    %rax,%rdi
  800420ff8b:	41 ff d0             	callq  *%r8
  800420ff8e:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  800420ff92:	e9 03 01 00 00       	jmpq   800421009a <_dwarf_attr_init+0x595>
    case DW_FORM_string:
        atref.u[0].s =(char*) _dwarf_read_string(ds_data, (uint64_t)ds->ds_size, offsetp);
  800420ff97:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ff9b:	48 8b 48 18          	mov    0x18(%rax),%rcx
  800420ff9f:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800420ffa6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ffaa:	48 89 ce             	mov    %rcx,%rsi
  800420ffad:	48 89 c7             	mov    %rax,%rdi
  800420ffb0:	48 b8 ec f2 20 04 80 	movabs $0x800420f2ec,%rax
  800420ffb7:	00 00 00 
  800420ffba:	ff d0                	callq  *%rax
  800420ffbc:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        break;
  800420ffc0:	e9 d5 00 00 00       	jmpq   800421009a <_dwarf_attr_init+0x595>
    case DW_FORM_strp:
        atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  800420ffc5:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420ffcc:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800420ffd0:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  800420ffd4:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800420ffdb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ffdf:	48 89 ce             	mov    %rcx,%rsi
  800420ffe2:	48 89 c7             	mov    %rax,%rdi
  800420ffe5:	41 ff d0             	callq  *%r8
  800420ffe8:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        str = _dwarf_find_section(".debug_str");
  800420ffec:	48 bf 4a 91 21 04 80 	movabs $0x800421914a,%rdi
  800420fff3:	00 00 00 
  800420fff6:	48 b8 e0 3d 21 04 80 	movabs $0x8004213de0,%rax
  800420fffd:	00 00 00 
  8004210000:	ff d0                	callq  *%rax
  8004210002:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        assert(str != NULL);
  8004210006:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421000b:	75 35                	jne    8004210042 <_dwarf_attr_init+0x53d>
  800421000d:	48 b9 55 91 21 04 80 	movabs $0x8004219155,%rcx
  8004210014:	00 00 00 
  8004210017:	48 ba e2 90 21 04 80 	movabs $0x80042190e2,%rdx
  800421001e:	00 00 00 
  8004210021:	be 53 02 00 00       	mov    $0x253,%esi
  8004210026:	48 bf f7 90 21 04 80 	movabs $0x80042190f7,%rdi
  800421002d:	00 00 00 
  8004210030:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210035:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800421003c:	00 00 00 
  800421003f:	41 ff d0             	callq  *%r8
        //atref.u[1].s = (char *)(elf_base_ptr + str->sh_offset) + atref.u[0].u64;
        atref.u[1].s = (char *)str->ds_data + atref.u[0].u64;
  8004210042:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210046:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800421004a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421004e:	48 01 d0             	add    %rdx,%rax
  8004210051:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  8004210055:	eb 43                	jmp    800421009a <_dwarf_attr_init+0x595>
    case DW_FORM_ref_sig8:
        atref.u[0].u64 = 8;
  8004210057:	48 c7 45 98 08 00 00 	movq   $0x8,-0x68(%rbp)
  800421005e:	00 
        atref.u[1].u8p = (uint8_t*)(_dwarf_read_block(ds_data, offsetp, atref.u[0].u64));
  800421005f:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004210063:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800421006a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421006e:	48 89 ce             	mov    %rcx,%rsi
  8004210071:	48 89 c7             	mov    %rax,%rdi
  8004210074:	48 b8 78 f3 20 04 80 	movabs $0x800420f378,%rax
  800421007b:	00 00 00 
  800421007e:	ff d0                	callq  *%rax
  8004210080:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        break;
  8004210084:	eb 14                	jmp    800421009a <_dwarf_attr_init+0x595>
    case DW_FORM_flag_present:
        /* This form has no value encoded in the DIE. */
        atref.u[0].u64 = 1;
  8004210086:	48 c7 45 98 01 00 00 	movq   $0x1,-0x68(%rbp)
  800421008d:	00 
        break;
  800421008e:	eb 0a                	jmp    800421009a <_dwarf_attr_init+0x595>
    default:
        //DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
        ret = DW_DLE_ATTR_FORM_BAD;
  8004210090:	c7 45 fc 0e 00 00 00 	movl   $0xe,-0x4(%rbp)
        break;
  8004210097:	eb 01                	jmp    800421009a <_dwarf_attr_init+0x595>
    case DW_FORM_ref_addr:
        if (cu->version == 2)
            atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
        else if (cu->version == 3)
            atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
        break;
  8004210099:	90                   	nop
        //DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
        ret = DW_DLE_ATTR_FORM_BAD;
        break;
    }

    if (ret == DW_DLE_NONE) {
  800421009a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800421009e:	0f 85 21 01 00 00    	jne    80042101c5 <_dwarf_attr_init+0x6c0>
        if (form == DW_FORM_block || form == DW_FORM_block1 ||
  80042100a4:	48 83 bd 40 ff ff ff 	cmpq   $0x9,-0xc0(%rbp)
  80042100ab:	09 
  80042100ac:	74 1e                	je     80042100cc <_dwarf_attr_init+0x5c7>
  80042100ae:	48 83 bd 40 ff ff ff 	cmpq   $0xa,-0xc0(%rbp)
  80042100b5:	0a 
  80042100b6:	74 14                	je     80042100cc <_dwarf_attr_init+0x5c7>
  80042100b8:	48 83 bd 40 ff ff ff 	cmpq   $0x3,-0xc0(%rbp)
  80042100bf:	03 
  80042100c0:	74 0a                	je     80042100cc <_dwarf_attr_init+0x5c7>
            form == DW_FORM_block2 || form == DW_FORM_block4) {
  80042100c2:	48 83 bd 40 ff ff ff 	cmpq   $0x4,-0xc0(%rbp)
  80042100c9:	04 
  80042100ca:	75 10                	jne    80042100dc <_dwarf_attr_init+0x5d7>
            atref.at_block.bl_len = atref.u[0].u64;
  80042100cc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042100d0:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
            atref.at_block.bl_data = atref.u[1].u8p;
  80042100d4:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042100d8:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        }
        //ret = _dwarf_attr_add(die, &atref, NULL, error);
        if (atref.at_attrib == DW_AT_name) {
  80042100dc:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042100e0:	48 83 f8 03          	cmp    $0x3,%rax
  80042100e4:	75 39                	jne    800421011f <_dwarf_attr_init+0x61a>
                switch (atref.at_form) {
  80042100e6:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042100ea:	48 83 f8 08          	cmp    $0x8,%rax
  80042100ee:	74 1a                	je     800421010a <_dwarf_attr_init+0x605>
  80042100f0:	48 83 f8 0e          	cmp    $0xe,%rax
  80042100f4:	75 28                	jne    800421011e <_dwarf_attr_init+0x619>
                case DW_FORM_strp:
                    ret_die->die_name = atref.u[1].s;
  80042100f6:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042100fa:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004210101:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
                    break;
  8004210108:	eb 15                	jmp    800421011f <_dwarf_attr_init+0x61a>
                case DW_FORM_string:
                    ret_die->die_name = atref.u[0].s;
  800421010a:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421010e:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004210115:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
                    break;
  800421011c:	eb 01                	jmp    800421011f <_dwarf_attr_init+0x61a>
                default:
                    break;
  800421011e:	90                   	nop
                }
        }
        ret_die->die_attr[ret_die->die_attr_count++] = atref;
  800421011f:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004210126:	0f b6 90 58 03 00 00 	movzbl 0x358(%rax),%edx
  800421012d:	0f b6 c2             	movzbl %dl,%eax
  8004210130:	48 8b b5 50 ff ff ff 	mov    -0xb0(%rbp),%rsi
  8004210137:	48 63 c8             	movslq %eax,%rcx
  800421013a:	48 89 c8             	mov    %rcx,%rax
  800421013d:	48 01 c0             	add    %rax,%rax
  8004210140:	48 01 c8             	add    %rcx,%rax
  8004210143:	48 c1 e0 05          	shl    $0x5,%rax
  8004210147:	48 01 f0             	add    %rsi,%rax
  800421014a:	48 05 70 03 00 00    	add    $0x370,%rax
  8004210150:	48 8b 8d 70 ff ff ff 	mov    -0x90(%rbp),%rcx
  8004210157:	48 89 08             	mov    %rcx,(%rax)
  800421015a:	48 8b 8d 78 ff ff ff 	mov    -0x88(%rbp),%rcx
  8004210161:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004210165:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
  8004210169:	48 89 48 10          	mov    %rcx,0x10(%rax)
  800421016d:	48 8b 4d 88          	mov    -0x78(%rbp),%rcx
  8004210171:	48 89 48 18          	mov    %rcx,0x18(%rax)
  8004210175:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
  8004210179:	48 89 48 20          	mov    %rcx,0x20(%rax)
  800421017d:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  8004210181:	48 89 48 28          	mov    %rcx,0x28(%rax)
  8004210185:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004210189:	48 89 48 30          	mov    %rcx,0x30(%rax)
  800421018d:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004210191:	48 89 48 38          	mov    %rcx,0x38(%rax)
  8004210195:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004210199:	48 89 48 40          	mov    %rcx,0x40(%rax)
  800421019d:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  80042101a1:	48 89 48 48          	mov    %rcx,0x48(%rax)
  80042101a5:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  80042101a9:	48 89 48 50          	mov    %rcx,0x50(%rax)
  80042101ad:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  80042101b1:	48 89 48 58          	mov    %rcx,0x58(%rax)
  80042101b5:	83 c2 01             	add    $0x1,%edx
  80042101b8:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042101bf:	88 90 58 03 00 00    	mov    %dl,0x358(%rax)
    }

    return (ret);
  80042101c5:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042101c8:	c9                   	leaveq 
  80042101c9:	c3                   	retq   

00000080042101ca <dwarf_search_die_within_cu>:

int
dwarf_search_die_within_cu(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t offset, Dwarf_Die *ret_die, int search_sibling)
{
  80042101ca:	55                   	push   %rbp
  80042101cb:	48 89 e5             	mov    %rsp,%rbp
  80042101ce:	48 81 ec d0 03 00 00 	sub    $0x3d0,%rsp
  80042101d5:	48 89 bd 88 fc ff ff 	mov    %rdi,-0x378(%rbp)
  80042101dc:	48 89 b5 80 fc ff ff 	mov    %rsi,-0x380(%rbp)
  80042101e3:	48 89 95 78 fc ff ff 	mov    %rdx,-0x388(%rbp)
  80042101ea:	89 8d 74 fc ff ff    	mov    %ecx,-0x38c(%rbp)
    uint64_t abnum;
    uint64_t die_offset;
    int ret, level;
    int i;

    assert(dbg);
  80042101f0:	48 83 bd 88 fc ff ff 	cmpq   $0x0,-0x378(%rbp)
  80042101f7:	00 
  80042101f8:	75 35                	jne    800421022f <dwarf_search_die_within_cu+0x65>
  80042101fa:	48 b9 70 92 21 04 80 	movabs $0x8004219270,%rcx
  8004210201:	00 00 00 
  8004210204:	48 ba e2 90 21 04 80 	movabs $0x80042190e2,%rdx
  800421020b:	00 00 00 
  800421020e:	be 88 02 00 00       	mov    $0x288,%esi
  8004210213:	48 bf f7 90 21 04 80 	movabs $0x80042190f7,%rdi
  800421021a:	00 00 00 
  800421021d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210222:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004210229:	00 00 00 
  800421022c:	41 ff d0             	callq  *%r8
    //assert(cu);
    assert(ret_die);
  800421022f:	48 83 bd 78 fc ff ff 	cmpq   $0x0,-0x388(%rbp)
  8004210236:	00 
  8004210237:	75 35                	jne    800421026e <dwarf_search_die_within_cu+0xa4>
  8004210239:	48 b9 74 92 21 04 80 	movabs $0x8004219274,%rcx
  8004210240:	00 00 00 
  8004210243:	48 ba e2 90 21 04 80 	movabs $0x80042190e2,%rdx
  800421024a:	00 00 00 
  800421024d:	be 8a 02 00 00       	mov    $0x28a,%esi
  8004210252:	48 bf f7 90 21 04 80 	movabs $0x80042190f7,%rdi
  8004210259:	00 00 00 
  800421025c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210261:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004210268:	00 00 00 
  800421026b:	41 ff d0             	callq  *%r8

    level = 1;
  800421026e:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

    while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  8004210275:	e9 15 02 00 00       	jmpq   800421048f <dwarf_search_die_within_cu+0x2c5>

        die_offset = offset;
  800421027a:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004210281:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

        abnum = _dwarf_read_uleb128((uint8_t *)dbg->dbg_info_offset_elf, &offset);
  8004210285:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  800421028c:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210290:	48 8d 95 80 fc ff ff 	lea    -0x380(%rbp),%rdx
  8004210297:	48 89 d6             	mov    %rdx,%rsi
  800421029a:	48 89 c7             	mov    %rax,%rdi
  800421029d:	48 b8 60 f1 20 04 80 	movabs $0x800420f160,%rax
  80042102a4:	00 00 00 
  80042102a7:	ff d0                	callq  *%rax
  80042102a9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

        if (abnum == 0) {
  80042102ad:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042102b2:	75 22                	jne    80042102d6 <dwarf_search_die_within_cu+0x10c>
            if (level == 0 || !search_sibling) {
  80042102b4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042102b8:	74 09                	je     80042102c3 <dwarf_search_die_within_cu+0xf9>
  80042102ba:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  80042102c1:	75 0a                	jne    80042102cd <dwarf_search_die_within_cu+0x103>
                //No more entry
                return (DW_DLE_NO_ENTRY);
  80042102c3:	b8 04 00 00 00       	mov    $0x4,%eax
  80042102c8:	e9 f2 01 00 00       	jmpq   80042104bf <dwarf_search_die_within_cu+0x2f5>
            }
            /*
             * Return to previous DIE level.
             */
            level--;
  80042102cd:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
            continue;
  80042102d1:	e9 b9 01 00 00       	jmpq   800421048f <dwarf_search_die_within_cu+0x2c5>
        }

        if ((ret = _dwarf_abbrev_find(dbg, cu, abnum, &ab)) != DW_DLE_NONE)
  80042102d6:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  80042102dd:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042102e1:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042102e8:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  80042102ec:	48 89 34 24          	mov    %rsi,(%rsp)
  80042102f0:	48 8b 75 18          	mov    0x18(%rbp),%rsi
  80042102f4:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  80042102f9:	48 8b 75 20          	mov    0x20(%rbp),%rsi
  80042102fd:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  8004210302:	48 8b 75 28          	mov    0x28(%rbp),%rsi
  8004210306:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
  800421030b:	48 8b 75 30          	mov    0x30(%rbp),%rsi
  800421030f:	48 89 74 24 20       	mov    %rsi,0x20(%rsp)
  8004210314:	48 8b 75 38          	mov    0x38(%rbp),%rsi
  8004210318:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
  800421031d:	48 8b 75 40          	mov    0x40(%rbp),%rsi
  8004210321:	48 89 74 24 30       	mov    %rsi,0x30(%rsp)
  8004210326:	48 89 ce             	mov    %rcx,%rsi
  8004210329:	48 89 c7             	mov    %rax,%rdi
  800421032c:	48 b8 d3 f9 20 04 80 	movabs $0x800420f9d3,%rax
  8004210333:	00 00 00 
  8004210336:	ff d0                	callq  *%rax
  8004210338:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  800421033b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421033f:	74 08                	je     8004210349 <dwarf_search_die_within_cu+0x17f>
            return (ret);
  8004210341:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210344:	e9 76 01 00 00       	jmpq   80042104bf <dwarf_search_die_within_cu+0x2f5>
        ret_die->die_offset = die_offset;
  8004210349:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004210350:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210354:	48 89 10             	mov    %rdx,(%rax)
        ret_die->die_abnum  = abnum;
  8004210357:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800421035e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210362:	48 89 50 10          	mov    %rdx,0x10(%rax)
        ret_die->die_ab  = ab;
  8004210366:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800421036d:	48 8d 78 20          	lea    0x20(%rax),%rdi
  8004210371:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  8004210378:	b8 66 00 00 00       	mov    $0x66,%eax
  800421037d:	48 89 d6             	mov    %rdx,%rsi
  8004210380:	48 89 c1             	mov    %rax,%rcx
  8004210383:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
        ret_die->die_attr_count = 0;
  8004210386:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800421038d:	c6 80 58 03 00 00 00 	movb   $0x0,0x358(%rax)
        ret_die->die_tag = ab.ab_tag;
  8004210394:	48 8b 95 b8 fc ff ff 	mov    -0x348(%rbp),%rdx
  800421039b:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  80042103a2:	48 89 50 18          	mov    %rdx,0x18(%rax)
        //ret_die->die_cu  = cu;
        //ret_die->die_dbg = cu->cu_dbg;

        for(i=0; i < ab.ab_atnum; i++)
  80042103a6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  80042103ad:	e9 8e 00 00 00       	jmpq   8004210440 <dwarf_search_die_within_cu+0x276>
        {
            if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
  80042103b2:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042103b5:	48 63 d0             	movslq %eax,%rdx
  80042103b8:	48 89 d0             	mov    %rdx,%rax
  80042103bb:	48 01 c0             	add    %rax,%rax
  80042103be:	48 01 d0             	add    %rdx,%rax
  80042103c1:	48 c1 e0 03          	shl    $0x3,%rax
  80042103c5:	48 01 e8             	add    %rbp,%rax
  80042103c8:	48 2d 18 03 00 00    	sub    $0x318,%rax
  80042103ce:	48 8b 08             	mov    (%rax),%rcx
  80042103d1:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042103d4:	48 63 d0             	movslq %eax,%rdx
  80042103d7:	48 89 d0             	mov    %rdx,%rax
  80042103da:	48 01 c0             	add    %rax,%rax
  80042103dd:	48 01 d0             	add    %rdx,%rax
  80042103e0:	48 c1 e0 03          	shl    $0x3,%rax
  80042103e4:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  80042103eb:	48 83 c2 30          	add    $0x30,%rdx
  80042103ef:	48 8d 3c 02          	lea    (%rdx,%rax,1),%rdi
  80042103f3:	48 8b 95 78 fc ff ff 	mov    -0x388(%rbp),%rdx
  80042103fa:	48 8d b5 80 fc ff ff 	lea    -0x380(%rbp),%rsi
  8004210401:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004210408:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  800421040f:	49 89 c9             	mov    %rcx,%r9
  8004210412:	49 89 f8             	mov    %rdi,%r8
  8004210415:	48 89 d1             	mov    %rdx,%rcx
  8004210418:	48 8d 55 10          	lea    0x10(%rbp),%rdx
  800421041c:	48 89 c7             	mov    %rax,%rdi
  800421041f:	48 b8 05 fb 20 04 80 	movabs $0x800420fb05,%rax
  8004210426:	00 00 00 
  8004210429:	ff d0                	callq  *%rax
  800421042b:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  800421042e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004210432:	74 08                	je     800421043c <dwarf_search_die_within_cu+0x272>
                return (ret);
  8004210434:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210437:	e9 83 00 00 00       	jmpq   80042104bf <dwarf_search_die_within_cu+0x2f5>
        ret_die->die_attr_count = 0;
        ret_die->die_tag = ab.ab_tag;
        //ret_die->die_cu  = cu;
        //ret_die->die_dbg = cu->cu_dbg;

        for(i=0; i < ab.ab_atnum; i++)
  800421043c:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004210440:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004210443:	48 63 d0             	movslq %eax,%rdx
  8004210446:	48 8b 85 d8 fc ff ff 	mov    -0x328(%rbp),%rax
  800421044d:	48 39 c2             	cmp    %rax,%rdx
  8004210450:	0f 82 5c ff ff ff    	jb     80042103b2 <dwarf_search_die_within_cu+0x1e8>
        {
            if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
                return (ret);
        }

        ret_die->die_next_off = offset;
  8004210456:	48 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%rdx
  800421045d:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004210464:	48 89 50 08          	mov    %rdx,0x8(%rax)
        if (search_sibling && level > 0) {
  8004210468:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  800421046f:	74 17                	je     8004210488 <dwarf_search_die_within_cu+0x2be>
  8004210471:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004210475:	7e 11                	jle    8004210488 <dwarf_search_die_within_cu+0x2be>
            //dwarf_dealloc(dbg, die, DW_DLA_DIE);
            if (ab.ab_children == DW_CHILDREN_yes) {
  8004210477:	0f b6 85 c0 fc ff ff 	movzbl -0x340(%rbp),%eax
  800421047e:	3c 01                	cmp    $0x1,%al
  8004210480:	75 0d                	jne    800421048f <dwarf_search_die_within_cu+0x2c5>
                /* Advance to next DIE level. */
                level++;
  8004210482:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
        }

        ret_die->die_next_off = offset;
        if (search_sibling && level > 0) {
            //dwarf_dealloc(dbg, die, DW_DLA_DIE);
            if (ab.ab_children == DW_CHILDREN_yes) {
  8004210486:	eb 07                	jmp    800421048f <dwarf_search_die_within_cu+0x2c5>
                /* Advance to next DIE level. */
                level++;
            }
        } else {
            //*ret_die = die;
            return (DW_DLE_NONE);
  8004210488:	b8 00 00 00 00       	mov    $0x0,%eax
  800421048d:	eb 30                	jmp    80042104bf <dwarf_search_die_within_cu+0x2f5>
    //assert(cu);
    assert(ret_die);

    level = 1;

    while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  800421048f:	48 8b 55 30          	mov    0x30(%rbp),%rdx
  8004210493:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  800421049a:	48 39 c2             	cmp    %rax,%rdx
  800421049d:	76 1b                	jbe    80042104ba <dwarf_search_die_within_cu+0x2f0>
  800421049f:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042104a6:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042104aa:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  80042104b1:	48 39 c2             	cmp    %rax,%rdx
  80042104b4:	0f 87 c0 fd ff ff    	ja     800421027a <dwarf_search_die_within_cu+0xb0>
            //*ret_die = die;
            return (DW_DLE_NONE);
        }
    }

    return (DW_DLE_NO_ENTRY);
  80042104ba:	b8 04 00 00 00       	mov    $0x4,%eax
}
  80042104bf:	c9                   	leaveq 
  80042104c0:	c3                   	retq   

00000080042104c1 <dwarf_offdie>:

//Return 0 on success
int
dwarf_offdie(Dwarf_Debug dbg, uint64_t offset, Dwarf_Die *ret_die, Dwarf_CU cu)
{
  80042104c1:	55                   	push   %rbp
  80042104c2:	48 89 e5             	mov    %rsp,%rbp
  80042104c5:	48 83 ec 70          	sub    $0x70,%rsp
  80042104c9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042104cd:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042104d1:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
    int ret;

    assert(dbg);
  80042104d5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042104da:	75 35                	jne    8004210511 <dwarf_offdie+0x50>
  80042104dc:	48 b9 70 92 21 04 80 	movabs $0x8004219270,%rcx
  80042104e3:	00 00 00 
  80042104e6:	48 ba e2 90 21 04 80 	movabs $0x80042190e2,%rdx
  80042104ed:	00 00 00 
  80042104f0:	be c6 02 00 00       	mov    $0x2c6,%esi
  80042104f5:	48 bf f7 90 21 04 80 	movabs $0x80042190f7,%rdi
  80042104fc:	00 00 00 
  80042104ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210504:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800421050b:	00 00 00 
  800421050e:	41 ff d0             	callq  *%r8
    assert(ret_die);
  8004210511:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210516:	75 35                	jne    800421054d <dwarf_offdie+0x8c>
  8004210518:	48 b9 74 92 21 04 80 	movabs $0x8004219274,%rcx
  800421051f:	00 00 00 
  8004210522:	48 ba e2 90 21 04 80 	movabs $0x80042190e2,%rdx
  8004210529:	00 00 00 
  800421052c:	be c7 02 00 00       	mov    $0x2c7,%esi
  8004210531:	48 bf f7 90 21 04 80 	movabs $0x80042190f7,%rdi
  8004210538:	00 00 00 
  800421053b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210540:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004210547:	00 00 00 
  800421054a:	41 ff d0             	callq  *%r8

    /* First search the current CU. */
	if (offset < cu.cu_next_offset) {
  800421054d:	48 8b 45 30          	mov    0x30(%rbp),%rax
  8004210551:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004210555:	76 66                	jbe    80042105bd <dwarf_offdie+0xfc>
		ret = dwarf_search_die_within_cu(dbg, cu, offset, ret_die, 0);
  8004210557:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421055b:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800421055f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210563:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
  8004210567:	48 89 0c 24          	mov    %rcx,(%rsp)
  800421056b:	48 8b 4d 18          	mov    0x18(%rbp),%rcx
  800421056f:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  8004210574:	48 8b 4d 20          	mov    0x20(%rbp),%rcx
  8004210578:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  800421057d:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004210581:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  8004210586:	48 8b 4d 30          	mov    0x30(%rbp),%rcx
  800421058a:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  800421058f:	48 8b 4d 38          	mov    0x38(%rbp),%rcx
  8004210593:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  8004210598:	48 8b 4d 40          	mov    0x40(%rbp),%rcx
  800421059c:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
  80042105a1:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042105a6:	48 89 c7             	mov    %rax,%rdi
  80042105a9:	48 b8 ca 01 21 04 80 	movabs $0x80042101ca,%rax
  80042105b0:	00 00 00 
  80042105b3:	ff d0                	callq  *%rax
  80042105b5:	89 45 fc             	mov    %eax,-0x4(%rbp)
		return ret;
  80042105b8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042105bb:	eb 05                	jmp    80042105c2 <dwarf_offdie+0x101>
	}

    /*TODO: Search other CU*/
    return DW_DLV_OK;
  80042105bd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042105c2:	c9                   	leaveq 
  80042105c3:	c3                   	retq   

00000080042105c4 <_dwarf_attr_find>:

Dwarf_Attribute*
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
  80042105c4:	55                   	push   %rbp
  80042105c5:	48 89 e5             	mov    %rsp,%rbp
  80042105c8:	48 83 ec 20          	sub    $0x20,%rsp
  80042105cc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042105d0:	89 f0                	mov    %esi,%eax
  80042105d2:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
    Dwarf_Attribute *myat = NULL;
  80042105d6:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042105dd:	00 
    int i;
    
    for(i=0; i < die->die_attr_count; i++)
  80042105de:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042105e5:	eb 57                	jmp    800421063e <_dwarf_attr_find+0x7a>
    {
        if (die->die_attr[i].at_attrib == attr)
  80042105e7:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042105eb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042105ee:	48 63 d0             	movslq %eax,%rdx
  80042105f1:	48 89 d0             	mov    %rdx,%rax
  80042105f4:	48 01 c0             	add    %rax,%rax
  80042105f7:	48 01 d0             	add    %rdx,%rax
  80042105fa:	48 c1 e0 05          	shl    $0x5,%rax
  80042105fe:	48 01 c8             	add    %rcx,%rax
  8004210601:	48 05 80 03 00 00    	add    $0x380,%rax
  8004210607:	48 8b 10             	mov    (%rax),%rdx
  800421060a:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  800421060e:	48 39 c2             	cmp    %rax,%rdx
  8004210611:	75 27                	jne    800421063a <_dwarf_attr_find+0x76>
        {
            myat = &(die->die_attr[i]);
  8004210613:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210617:	48 8d 88 70 03 00 00 	lea    0x370(%rax),%rcx
  800421061e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210621:	48 63 d0             	movslq %eax,%rdx
  8004210624:	48 89 d0             	mov    %rdx,%rax
  8004210627:	48 01 c0             	add    %rax,%rax
  800421062a:	48 01 d0             	add    %rdx,%rax
  800421062d:	48 c1 e0 05          	shl    $0x5,%rax
  8004210631:	48 01 c8             	add    %rcx,%rax
  8004210634:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
            break;
  8004210638:	eb 17                	jmp    8004210651 <_dwarf_attr_find+0x8d>
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
    Dwarf_Attribute *myat = NULL;
    int i;
    
    for(i=0; i < die->die_attr_count; i++)
  800421063a:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800421063e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210642:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  8004210649:	0f b6 c0             	movzbl %al,%eax
  800421064c:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  800421064f:	7f 96                	jg     80042105e7 <_dwarf_attr_find+0x23>
            myat = &(die->die_attr[i]);
            break;
        }
    }

    return myat;
  8004210651:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210655:	c9                   	leaveq 
  8004210656:	c3                   	retq   

0000008004210657 <dwarf_siblingof>:

//Return 0 on success
int
dwarf_siblingof(Dwarf_Debug dbg, Dwarf_Die *die, Dwarf_Die *ret_die,
    Dwarf_CU *cu)
{
  8004210657:	55                   	push   %rbp
  8004210658:	48 89 e5             	mov    %rsp,%rbp
  800421065b:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  800421065f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004210663:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004210667:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  800421066b:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
    Dwarf_Attribute *at;
    uint64_t offset;
    int ret, search_sibling;

    assert(dbg);
  800421066f:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210674:	75 35                	jne    80042106ab <dwarf_siblingof+0x54>
  8004210676:	48 b9 70 92 21 04 80 	movabs $0x8004219270,%rcx
  800421067d:	00 00 00 
  8004210680:	48 ba e2 90 21 04 80 	movabs $0x80042190e2,%rdx
  8004210687:	00 00 00 
  800421068a:	be ee 02 00 00       	mov    $0x2ee,%esi
  800421068f:	48 bf f7 90 21 04 80 	movabs $0x80042190f7,%rdi
  8004210696:	00 00 00 
  8004210699:	b8 00 00 00 00       	mov    $0x0,%eax
  800421069e:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042106a5:	00 00 00 
  80042106a8:	41 ff d0             	callq  *%r8
    assert(ret_die);
  80042106ab:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042106b0:	75 35                	jne    80042106e7 <dwarf_siblingof+0x90>
  80042106b2:	48 b9 74 92 21 04 80 	movabs $0x8004219274,%rcx
  80042106b9:	00 00 00 
  80042106bc:	48 ba e2 90 21 04 80 	movabs $0x80042190e2,%rdx
  80042106c3:	00 00 00 
  80042106c6:	be ef 02 00 00       	mov    $0x2ef,%esi
  80042106cb:	48 bf f7 90 21 04 80 	movabs $0x80042190f7,%rdi
  80042106d2:	00 00 00 
  80042106d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042106da:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042106e1:	00 00 00 
  80042106e4:	41 ff d0             	callq  *%r8
    assert(cu);
  80042106e7:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  80042106ec:	75 35                	jne    8004210723 <dwarf_siblingof+0xcc>
  80042106ee:	48 b9 7c 92 21 04 80 	movabs $0x800421927c,%rcx
  80042106f5:	00 00 00 
  80042106f8:	48 ba e2 90 21 04 80 	movabs $0x80042190e2,%rdx
  80042106ff:	00 00 00 
  8004210702:	be f0 02 00 00       	mov    $0x2f0,%esi
  8004210707:	48 bf f7 90 21 04 80 	movabs $0x80042190f7,%rdi
  800421070e:	00 00 00 
  8004210711:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210716:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800421071d:	00 00 00 
  8004210720:	41 ff d0             	callq  *%r8

    /* Application requests the first DIE in this CU. */
    if (die == NULL)
  8004210723:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004210728:	75 65                	jne    800421078f <dwarf_siblingof+0x138>
        return (dwarf_offdie(dbg, cu->cu_die_offset, ret_die, *cu));
  800421072a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421072e:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004210732:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210736:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421073a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421073e:	48 8b 38             	mov    (%rax),%rdi
  8004210741:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004210745:	48 8b 78 08          	mov    0x8(%rax),%rdi
  8004210749:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800421074e:	48 8b 78 10          	mov    0x10(%rax),%rdi
  8004210752:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004210757:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800421075b:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004210760:	48 8b 78 20          	mov    0x20(%rax),%rdi
  8004210764:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  8004210769:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800421076d:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  8004210772:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004210776:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800421077b:	48 89 cf             	mov    %rcx,%rdi
  800421077e:	48 b8 c1 04 21 04 80 	movabs $0x80042104c1,%rax
  8004210785:	00 00 00 
  8004210788:	ff d0                	callq  *%rax
  800421078a:	e9 0a 01 00 00       	jmpq   8004210899 <dwarf_siblingof+0x242>

    /*
     * If the DIE doesn't have any children, its sibling sits next
     * right to it.
     */
    search_sibling = 0;
  800421078f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004210796:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421079a:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  800421079e:	84 c0                	test   %al,%al
  80042107a0:	75 0e                	jne    80042107b0 <dwarf_siblingof+0x159>
        offset = die->die_next_off;
  80042107a2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042107a6:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042107aa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042107ae:	eb 6b                	jmp    800421081b <dwarf_siblingof+0x1c4>
    else {
        /*
         * Look for DW_AT_sibling attribute for the offset of
         * its sibling.
         */
        if ((at = _dwarf_attr_find(die, DW_AT_sibling)) != NULL) {
  80042107b0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042107b4:	be 01 00 00 00       	mov    $0x1,%esi
  80042107b9:	48 89 c7             	mov    %rax,%rdi
  80042107bc:	48 b8 c4 05 21 04 80 	movabs $0x80042105c4,%rax
  80042107c3:	00 00 00 
  80042107c6:	ff d0                	callq  *%rax
  80042107c8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042107cc:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042107d1:	74 35                	je     8004210808 <dwarf_siblingof+0x1b1>
            if (at->at_form != DW_FORM_ref_addr)
  80042107d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042107d7:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042107db:	48 83 f8 10          	cmp    $0x10,%rax
  80042107df:	74 19                	je     80042107fa <dwarf_siblingof+0x1a3>
                offset = at->u[0].u64 + cu->cu_offset;
  80042107e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042107e5:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042107e9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042107ed:	48 8b 40 30          	mov    0x30(%rax),%rax
  80042107f1:	48 01 d0             	add    %rdx,%rax
  80042107f4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042107f8:	eb 21                	jmp    800421081b <dwarf_siblingof+0x1c4>
            else
                offset = at->u[0].u64;
  80042107fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042107fe:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004210802:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004210806:	eb 13                	jmp    800421081b <dwarf_siblingof+0x1c4>
        } else {
            offset = die->die_next_off;
  8004210808:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421080c:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210810:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
            search_sibling = 1;
  8004210814:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
        }
    }

    ret = dwarf_search_die_within_cu(dbg, *cu, offset, ret_die, search_sibling);
  800421081b:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  800421081e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210822:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8004210826:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  800421082a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421082e:	4c 8b 00             	mov    (%rax),%r8
  8004210831:	4c 89 04 24          	mov    %r8,(%rsp)
  8004210835:	4c 8b 40 08          	mov    0x8(%rax),%r8
  8004210839:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  800421083e:	4c 8b 40 10          	mov    0x10(%rax),%r8
  8004210842:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  8004210847:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800421084b:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  8004210850:	4c 8b 40 20          	mov    0x20(%rax),%r8
  8004210854:	4c 89 44 24 20       	mov    %r8,0x20(%rsp)
  8004210859:	4c 8b 40 28          	mov    0x28(%rax),%r8
  800421085d:	4c 89 44 24 28       	mov    %r8,0x28(%rsp)
  8004210862:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004210866:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800421086b:	48 b8 ca 01 21 04 80 	movabs $0x80042101ca,%rax
  8004210872:	00 00 00 
  8004210875:	ff d0                	callq  *%rax
  8004210877:	89 45 e4             	mov    %eax,-0x1c(%rbp)


    if (ret == DW_DLE_NO_ENTRY) {
  800421087a:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  800421087e:	75 07                	jne    8004210887 <dwarf_siblingof+0x230>
        return (DW_DLV_NO_ENTRY);
  8004210880:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210885:	eb 12                	jmp    8004210899 <dwarf_siblingof+0x242>
    } else if (ret != DW_DLE_NONE)
  8004210887:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421088b:	74 07                	je     8004210894 <dwarf_siblingof+0x23d>
        return (DW_DLV_ERROR);
  800421088d:	b8 01 00 00 00       	mov    $0x1,%eax
  8004210892:	eb 05                	jmp    8004210899 <dwarf_siblingof+0x242>


    return (DW_DLV_OK);
  8004210894:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210899:	c9                   	leaveq 
  800421089a:	c3                   	retq   

000000800421089b <dwarf_child>:

int
dwarf_child(Dwarf_Debug dbg, Dwarf_CU *cu, Dwarf_Die *die, Dwarf_Die *ret_die)
{
  800421089b:	55                   	push   %rbp
  800421089c:	48 89 e5             	mov    %rsp,%rbp
  800421089f:	48 83 ec 70          	sub    $0x70,%rsp
  80042108a3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042108a7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042108ab:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80042108af:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
    int ret;

    assert(die);
  80042108b3:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042108b8:	75 35                	jne    80042108ef <dwarf_child+0x54>
  80042108ba:	48 b9 7f 92 21 04 80 	movabs $0x800421927f,%rcx
  80042108c1:	00 00 00 
  80042108c4:	48 ba e2 90 21 04 80 	movabs $0x80042190e2,%rdx
  80042108cb:	00 00 00 
  80042108ce:	be 1e 03 00 00       	mov    $0x31e,%esi
  80042108d3:	48 bf f7 90 21 04 80 	movabs $0x80042190f7,%rdi
  80042108da:	00 00 00 
  80042108dd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042108e2:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042108e9:	00 00 00 
  80042108ec:	41 ff d0             	callq  *%r8
    assert(ret_die);
  80042108ef:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042108f4:	75 35                	jne    800421092b <dwarf_child+0x90>
  80042108f6:	48 b9 74 92 21 04 80 	movabs $0x8004219274,%rcx
  80042108fd:	00 00 00 
  8004210900:	48 ba e2 90 21 04 80 	movabs $0x80042190e2,%rdx
  8004210907:	00 00 00 
  800421090a:	be 1f 03 00 00       	mov    $0x31f,%esi
  800421090f:	48 bf f7 90 21 04 80 	movabs $0x80042190f7,%rdi
  8004210916:	00 00 00 
  8004210919:	b8 00 00 00 00       	mov    $0x0,%eax
  800421091e:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004210925:	00 00 00 
  8004210928:	41 ff d0             	callq  *%r8
    assert(dbg);
  800421092b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210930:	75 35                	jne    8004210967 <dwarf_child+0xcc>
  8004210932:	48 b9 70 92 21 04 80 	movabs $0x8004219270,%rcx
  8004210939:	00 00 00 
  800421093c:	48 ba e2 90 21 04 80 	movabs $0x80042190e2,%rdx
  8004210943:	00 00 00 
  8004210946:	be 20 03 00 00       	mov    $0x320,%esi
  800421094b:	48 bf f7 90 21 04 80 	movabs $0x80042190f7,%rdi
  8004210952:	00 00 00 
  8004210955:	b8 00 00 00 00       	mov    $0x0,%eax
  800421095a:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004210961:	00 00 00 
  8004210964:	41 ff d0             	callq  *%r8
    assert(cu);
  8004210967:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800421096c:	75 35                	jne    80042109a3 <dwarf_child+0x108>
  800421096e:	48 b9 7c 92 21 04 80 	movabs $0x800421927c,%rcx
  8004210975:	00 00 00 
  8004210978:	48 ba e2 90 21 04 80 	movabs $0x80042190e2,%rdx
  800421097f:	00 00 00 
  8004210982:	be 21 03 00 00       	mov    $0x321,%esi
  8004210987:	48 bf f7 90 21 04 80 	movabs $0x80042190f7,%rdi
  800421098e:	00 00 00 
  8004210991:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210996:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800421099d:	00 00 00 
  80042109a0:	41 ff d0             	callq  *%r8

    if (die->die_ab.ab_children == DW_CHILDREN_no)
  80042109a3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042109a7:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  80042109ab:	84 c0                	test   %al,%al
  80042109ad:	75 0a                	jne    80042109b9 <dwarf_child+0x11e>
        return (DW_DLE_NO_ENTRY);
  80042109af:	b8 04 00 00 00       	mov    $0x4,%eax
  80042109b4:	e9 84 00 00 00       	jmpq   8004210a3d <dwarf_child+0x1a2>

    ret = dwarf_search_die_within_cu(dbg, *cu, die->die_next_off, ret_die, 0);
  80042109b9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042109bd:	48 8b 70 08          	mov    0x8(%rax),%rsi
  80042109c1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042109c5:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  80042109c9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042109cd:	48 8b 08             	mov    (%rax),%rcx
  80042109d0:	48 89 0c 24          	mov    %rcx,(%rsp)
  80042109d4:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042109d8:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  80042109dd:	48 8b 48 10          	mov    0x10(%rax),%rcx
  80042109e1:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  80042109e6:	48 8b 48 18          	mov    0x18(%rax),%rcx
  80042109ea:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  80042109ef:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042109f3:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  80042109f8:	48 8b 48 28          	mov    0x28(%rax),%rcx
  80042109fc:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  8004210a01:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004210a05:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004210a0a:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004210a0f:	48 b8 ca 01 21 04 80 	movabs $0x80042101ca,%rax
  8004210a16:	00 00 00 
  8004210a19:	ff d0                	callq  *%rax
  8004210a1b:	89 45 fc             	mov    %eax,-0x4(%rbp)

    if (ret == DW_DLE_NO_ENTRY) {
  8004210a1e:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004210a22:	75 07                	jne    8004210a2b <dwarf_child+0x190>
        DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
        return (DW_DLV_NO_ENTRY);
  8004210a24:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210a29:	eb 12                	jmp    8004210a3d <dwarf_child+0x1a2>
    } else if (ret != DW_DLE_NONE)
  8004210a2b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004210a2f:	74 07                	je     8004210a38 <dwarf_child+0x19d>
        return (DW_DLV_ERROR);
  8004210a31:	b8 01 00 00 00       	mov    $0x1,%eax
  8004210a36:	eb 05                	jmp    8004210a3d <dwarf_child+0x1a2>

    return (DW_DLV_OK);
  8004210a38:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210a3d:	c9                   	leaveq 
  8004210a3e:	c3                   	retq   

0000008004210a3f <_dwarf_find_section_enhanced>:


int  _dwarf_find_section_enhanced(Dwarf_Section *ds)
{
  8004210a3f:	55                   	push   %rbp
  8004210a40:	48 89 e5             	mov    %rsp,%rbp
  8004210a43:	48 83 ec 20          	sub    $0x20,%rsp
  8004210a47:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    Dwarf_Section *secthdr = _dwarf_find_section(ds->ds_name);
  8004210a4b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a4f:	48 8b 00             	mov    (%rax),%rax
  8004210a52:	48 89 c7             	mov    %rax,%rdi
  8004210a55:	48 b8 e0 3d 21 04 80 	movabs $0x8004213de0,%rax
  8004210a5c:	00 00 00 
  8004210a5f:	ff d0                	callq  *%rax
  8004210a61:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    ds->ds_data = secthdr->ds_data;//(Dwarf_Small*)((uint8_t *)elf_base_ptr + secthdr->sh_offset);
  8004210a65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210a69:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004210a6d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a71:	48 89 50 08          	mov    %rdx,0x8(%rax)
    ds->ds_addr = secthdr->ds_addr;
  8004210a75:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210a79:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004210a7d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a81:	48 89 50 10          	mov    %rdx,0x10(%rax)
    ds->ds_size = secthdr->ds_size;
  8004210a85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210a89:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004210a8d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a91:	48 89 50 18          	mov    %rdx,0x18(%rax)
    return 0;
  8004210a95:	b8 00 00 00 00       	mov    $0x0,%eax

}
  8004210a9a:	c9                   	leaveq 
  8004210a9b:	c3                   	retq   

0000008004210a9c <_dwarf_frame_params_init>:
int  _dwarf_find_section_enhanced(Dwarf_Section *ds);


void
_dwarf_frame_params_init(Dwarf_Debug dbg)
{
  8004210a9c:	55                   	push   %rbp
  8004210a9d:	48 89 e5             	mov    %rsp,%rbp
  8004210aa0:	48 83 ec 08          	sub    $0x8,%rsp
  8004210aa4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)

        /* Initialise call frame related parameters. */
        dbg->dbg_frame_rule_table_size = DW_FRAME_LAST_REG_NUM;
  8004210aa8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210aac:	66 c7 40 40 42 00    	movw   $0x42,0x40(%rax)
        dbg->dbg_frame_rule_initial_value = DW_FRAME_REG_INITIAL_VALUE;
  8004210ab2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210ab6:	66 c7 40 42 0b 04    	movw   $0x40b,0x42(%rax)
        dbg->dbg_frame_cfa_value = DW_FRAME_CFA_COL3;
  8004210abc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210ac0:	66 c7 40 44 9c 05    	movw   $0x59c,0x44(%rax)
        dbg->dbg_frame_same_value = DW_FRAME_SAME_VAL;
  8004210ac6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210aca:	66 c7 40 46 0b 04    	movw   $0x40b,0x46(%rax)
        dbg->dbg_frame_undefined_value = DW_FRAME_UNDEFINED_VAL;
  8004210ad0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210ad4:	66 c7 40 48 0a 04    	movw   $0x40a,0x48(%rax)
}
  8004210ada:	c9                   	leaveq 
  8004210adb:	c3                   	retq   

0000008004210adc <dwarf_get_fde_at_pc>:


int
dwarf_get_fde_at_pc(Dwarf_Addr pc,
    Dwarf_Addr *lopc, Dwarf_Addr *hipc, struct _Dwarf_Fde *ret_fde, Dwarf_Cie cie, Dwarf_Error *error)
{
  8004210adc:	55                   	push   %rbp
  8004210add:	48 89 e5             	mov    %rsp,%rbp
  8004210ae0:	48 83 ec 40          	sub    $0x40,%rsp
  8004210ae4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210ae8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210aec:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004210af0:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004210af4:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
  8004210af8:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
    Dwarf_Fde fde = ret_fde;
  8004210afc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210b00:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(fde, 0, sizeof(struct _Dwarf_Fde));
  8004210b04:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210b08:	ba 80 00 00 00       	mov    $0x80,%edx
  8004210b0d:	be 00 00 00 00       	mov    $0x0,%esi
  8004210b12:	48 89 c7             	mov    %rax,%rdi
  8004210b15:	48 b8 53 e6 20 04 80 	movabs $0x800420e653,%rax
  8004210b1c:	00 00 00 
  8004210b1f:	ff d0                	callq  *%rax
	fde->fde_cie = cie;
  8004210b21:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210b25:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210b29:	48 89 50 08          	mov    %rdx,0x8(%rax)
	
        if (ret_fde == NULL || lopc == NULL || hipc == NULL) {
  8004210b2d:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004210b32:	74 12                	je     8004210b46 <dwarf_get_fde_at_pc+0x6a>
  8004210b34:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004210b39:	74 0b                	je     8004210b46 <dwarf_get_fde_at_pc+0x6a>
  8004210b3b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210b40:	0f 85 a3 00 00 00    	jne    8004210be9 <dwarf_get_fde_at_pc+0x10d>
                return (DW_DLV_ERROR);
  8004210b46:	b8 01 00 00 00       	mov    $0x1,%eax
  8004210b4b:	e9 ca 00 00 00       	jmpq   8004210c1a <dwarf_get_fde_at_pc+0x13e>
        }

        while(dbg->dbg_eh_offset < dbg->dbg_eh_size) {
                if (_dwarf_get_next_fde(dbg, is_eh_frame, error, fde) < 0)
  8004210b50:	48 b8 c0 a6 22 04 80 	movabs $0x800422a6c0,%rax
  8004210b57:	00 00 00 
  8004210b5a:	8b 30                	mov    (%rax),%esi
  8004210b5c:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  8004210b63:	00 00 00 
  8004210b66:	48 8b 00             	mov    (%rax),%rax
  8004210b69:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004210b6d:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004210b71:	48 89 c7             	mov    %rax,%rdi
  8004210b74:	48 b8 4a 2d 21 04 80 	movabs $0x8004212d4a,%rax
  8004210b7b:	00 00 00 
  8004210b7e:	ff d0                	callq  *%rax
  8004210b80:	85 c0                	test   %eax,%eax
  8004210b82:	79 0a                	jns    8004210b8e <dwarf_get_fde_at_pc+0xb2>
				{
		    		return DW_DLV_NO_ENTRY;
  8004210b84:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210b89:	e9 8c 00 00 00       	jmpq   8004210c1a <dwarf_get_fde_at_pc+0x13e>
				}
                if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  8004210b8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210b92:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004210b96:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004210b9a:	77 4e                	ja     8004210bea <dwarf_get_fde_at_pc+0x10e>
  8004210b9c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210ba0:	48 8b 50 30          	mov    0x30(%rax),%rdx
                    fde->fde_adrange) {
  8004210ba4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210ba8:	48 8b 40 38          	mov    0x38(%rax),%rax
        while(dbg->dbg_eh_offset < dbg->dbg_eh_size) {
                if (_dwarf_get_next_fde(dbg, is_eh_frame, error, fde) < 0)
				{
		    		return DW_DLV_NO_ENTRY;
				}
                if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  8004210bac:	48 01 d0             	add    %rdx,%rax
  8004210baf:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004210bb3:	76 35                	jbe    8004210bea <dwarf_get_fde_at_pc+0x10e>
                    fde->fde_adrange) {
                        *lopc = fde->fde_initloc;
  8004210bb5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210bb9:	48 8b 50 30          	mov    0x30(%rax),%rdx
  8004210bbd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210bc1:	48 89 10             	mov    %rdx,(%rax)
                        *hipc = fde->fde_initloc + fde->fde_adrange - 1;
  8004210bc4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210bc8:	48 8b 50 30          	mov    0x30(%rax),%rdx
  8004210bcc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210bd0:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004210bd4:	48 01 d0             	add    %rdx,%rax
  8004210bd7:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  8004210bdb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210bdf:	48 89 10             	mov    %rdx,(%rax)

                        return (DW_DLV_OK);
  8004210be2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210be7:	eb 31                	jmp    8004210c1a <dwarf_get_fde_at_pc+0x13e>
	
        if (ret_fde == NULL || lopc == NULL || hipc == NULL) {
                return (DW_DLV_ERROR);
        }

        while(dbg->dbg_eh_offset < dbg->dbg_eh_size) {
  8004210be9:	90                   	nop
  8004210bea:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  8004210bf1:	00 00 00 
  8004210bf4:	48 8b 00             	mov    (%rax),%rax
  8004210bf7:	48 8b 50 30          	mov    0x30(%rax),%rdx
  8004210bfb:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  8004210c02:	00 00 00 
  8004210c05:	48 8b 00             	mov    (%rax),%rax
  8004210c08:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004210c0c:	48 39 c2             	cmp    %rax,%rdx
  8004210c0f:	0f 82 3b ff ff ff    	jb     8004210b50 <dwarf_get_fde_at_pc+0x74>
                        return (DW_DLV_OK);
                }
        }

        DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
        return (DW_DLV_NO_ENTRY);
  8004210c15:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8004210c1a:	c9                   	leaveq 
  8004210c1b:	c3                   	retq   

0000008004210c1c <_dwarf_frame_regtable_copy>:

int
_dwarf_frame_regtable_copy(Dwarf_Debug dbg, Dwarf_Regtable3 **dest,
    Dwarf_Regtable3 *src, Dwarf_Error *error)
{
  8004210c1c:	55                   	push   %rbp
  8004210c1d:	48 89 e5             	mov    %rsp,%rbp
  8004210c20:	48 83 ec 30          	sub    $0x30,%rsp
  8004210c24:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210c28:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210c2c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004210c30:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
        int i;

        assert(dest != NULL);
  8004210c34:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004210c39:	75 35                	jne    8004210c70 <_dwarf_frame_regtable_copy+0x54>
  8004210c3b:	48 b9 92 92 21 04 80 	movabs $0x8004219292,%rcx
  8004210c42:	00 00 00 
  8004210c45:	48 ba 9f 92 21 04 80 	movabs $0x800421929f,%rdx
  8004210c4c:	00 00 00 
  8004210c4f:	be 63 00 00 00       	mov    $0x63,%esi
  8004210c54:	48 bf b4 92 21 04 80 	movabs $0x80042192b4,%rdi
  8004210c5b:	00 00 00 
  8004210c5e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210c63:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004210c6a:	00 00 00 
  8004210c6d:	41 ff d0             	callq  *%r8
        assert(src != NULL);
  8004210c70:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210c75:	75 35                	jne    8004210cac <_dwarf_frame_regtable_copy+0x90>
  8004210c77:	48 b9 ca 92 21 04 80 	movabs $0x80042192ca,%rcx
  8004210c7e:	00 00 00 
  8004210c81:	48 ba 9f 92 21 04 80 	movabs $0x800421929f,%rdx
  8004210c88:	00 00 00 
  8004210c8b:	be 64 00 00 00       	mov    $0x64,%esi
  8004210c90:	48 bf b4 92 21 04 80 	movabs $0x80042192b4,%rdi
  8004210c97:	00 00 00 
  8004210c9a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210c9f:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004210ca6:	00 00 00 
  8004210ca9:	41 ff d0             	callq  *%r8

        if (*dest == NULL) {
  8004210cac:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210cb0:	48 8b 00             	mov    (%rax),%rax
  8004210cb3:	48 85 c0             	test   %rax,%rax
  8004210cb6:	75 39                	jne    8004210cf1 <_dwarf_frame_regtable_copy+0xd5>
		*dest = &global_rt_table_shadow;
  8004210cb8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210cbc:	48 ba 60 c7 63 04 80 	movabs $0x800463c760,%rdx
  8004210cc3:	00 00 00 
  8004210cc6:	48 89 10             	mov    %rdx,(%rax)
                /*if ((*dest = malloc(sizeof(Dwarf_Regtable3))) == NULL) {
                        DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
                        return (DW_DLE_MEMORY);
                }*/
                (*dest)->rt3_reg_table_size = src->rt3_reg_table_size;
  8004210cc9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210ccd:	48 8b 00             	mov    (%rax),%rax
  8004210cd0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004210cd4:	0f b7 52 18          	movzwl 0x18(%rdx),%edx
  8004210cd8:	66 89 50 18          	mov    %dx,0x18(%rax)
		(*dest)->rt3_rules = global_rules_shadow;
  8004210cdc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210ce0:	48 8b 00             	mov    (%rax),%rax
  8004210ce3:	48 ba 60 d0 67 04 80 	movabs $0x800467d060,%rdx
  8004210cea:	00 00 00 
  8004210ced:	48 89 50 20          	mov    %rdx,0x20(%rax)
                        DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
                        return (DW_DLE_MEMORY);
                }*/
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
  8004210cf1:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004210cf5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210cf9:	48 8b 00             	mov    (%rax),%rax
  8004210cfc:	ba 18 00 00 00       	mov    $0x18,%edx
  8004210d01:	48 89 ce             	mov    %rcx,%rsi
  8004210d04:	48 89 c7             	mov    %rax,%rdi
  8004210d07:	48 b8 f5 e7 20 04 80 	movabs $0x800420e7f5,%rax
  8004210d0e:	00 00 00 
  8004210d11:	ff d0                	callq  *%rax
            sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004210d13:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004210d1a:	eb 5a                	jmp    8004210d76 <_dwarf_frame_regtable_copy+0x15a>
             i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
  8004210d1c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210d20:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210d24:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004210d27:	48 63 d0             	movslq %eax,%rdx
  8004210d2a:	48 89 d0             	mov    %rdx,%rax
  8004210d2d:	48 01 c0             	add    %rax,%rax
  8004210d30:	48 01 d0             	add    %rdx,%rax
  8004210d33:	48 c1 e0 03          	shl    $0x3,%rax
  8004210d37:	48 01 c1             	add    %rax,%rcx
  8004210d3a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210d3e:	48 8b 00             	mov    (%rax),%rax
  8004210d41:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004210d45:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004210d48:	48 63 d0             	movslq %eax,%rdx
  8004210d4b:	48 89 d0             	mov    %rdx,%rax
  8004210d4e:	48 01 c0             	add    %rax,%rax
  8004210d51:	48 01 d0             	add    %rdx,%rax
  8004210d54:	48 c1 e0 03          	shl    $0x3,%rax
  8004210d58:	48 01 f0             	add    %rsi,%rax
  8004210d5b:	ba 18 00 00 00       	mov    $0x18,%edx
  8004210d60:	48 89 ce             	mov    %rcx,%rsi
  8004210d63:	48 89 c7             	mov    %rax,%rdi
  8004210d66:	48 b8 f5 e7 20 04 80 	movabs $0x800420e7f5,%rax
  8004210d6d:	00 00 00 
  8004210d70:	ff d0                	callq  *%rax

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
            sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
             i < src->rt3_reg_table_size; i++)
  8004210d72:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
            sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004210d76:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210d7a:	48 8b 00             	mov    (%rax),%rax
  8004210d7d:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004210d81:	0f b7 c0             	movzwl %ax,%eax
  8004210d84:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004210d87:	7e 46                	jle    8004210dcf <_dwarf_frame_regtable_copy+0x1b3>
             i < src->rt3_reg_table_size; i++)
  8004210d89:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210d8d:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004210d91:	0f b7 c0             	movzwl %ax,%eax
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
            sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004210d94:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004210d97:	7f 83                	jg     8004210d1c <_dwarf_frame_regtable_copy+0x100>
             i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
                    sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
  8004210d99:	eb 34                	jmp    8004210dcf <_dwarf_frame_regtable_copy+0x1b3>
                (*dest)->rt3_rules[i].dw_regnum =
  8004210d9b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210d9f:	48 8b 00             	mov    (%rax),%rax
  8004210da2:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210da6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004210da9:	48 63 d0             	movslq %eax,%rdx
  8004210dac:	48 89 d0             	mov    %rdx,%rax
  8004210daf:	48 01 c0             	add    %rax,%rax
  8004210db2:	48 01 d0             	add    %rdx,%rax
  8004210db5:	48 c1 e0 03          	shl    $0x3,%rax
  8004210db9:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
                    dbg->dbg_frame_undefined_value;
  8004210dbd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210dc1:	0f b7 40 48          	movzwl 0x48(%rax),%eax
             i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
                    sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
                (*dest)->rt3_rules[i].dw_regnum =
  8004210dc5:	66 89 42 02          	mov    %ax,0x2(%rdx)
        for (i = 0; i < (*dest)->rt3_reg_table_size &&
             i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
                    sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
  8004210dc9:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004210dcd:	eb 01                	jmp    8004210dd0 <_dwarf_frame_regtable_copy+0x1b4>
  8004210dcf:	90                   	nop
  8004210dd0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210dd4:	48 8b 00             	mov    (%rax),%rax
  8004210dd7:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004210ddb:	0f b7 c0             	movzwl %ax,%eax
  8004210dde:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004210de1:	7f b8                	jg     8004210d9b <_dwarf_frame_regtable_copy+0x17f>
                (*dest)->rt3_rules[i].dw_regnum =
                    dbg->dbg_frame_undefined_value;

        return (DW_DLE_NONE);
  8004210de3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210de8:	c9                   	leaveq 
  8004210de9:	c3                   	retq   

0000008004210dea <_dwarf_frame_run_inst>:

static int
_dwarf_frame_run_inst(Dwarf_Debug dbg, Dwarf_Regtable3 *rt, uint8_t *insts,
    Dwarf_Unsigned len, Dwarf_Unsigned caf, Dwarf_Signed daf, Dwarf_Addr pc,
    Dwarf_Addr pc_req, Dwarf_Addr *row_pc, Dwarf_Error *error)
{
  8004210dea:	55                   	push   %rbp
  8004210deb:	48 89 e5             	mov    %rsp,%rbp
  8004210dee:	53                   	push   %rbx
  8004210def:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  8004210df6:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  8004210dfa:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  8004210dfe:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  8004210e02:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  8004210e06:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  8004210e0d:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)

#ifdef FRAME_DEBUG
        printf("frame_run_inst: (caf=%ju, daf=%jd)\n", caf, daf);
#endif

        ret = DW_DLE_NONE;
  8004210e14:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
        init_rt = saved_rt = NULL;
  8004210e1b:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8004210e22:	00 
  8004210e23:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210e27:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        *row_pc = pc;
  8004210e2b:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004210e2f:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004210e33:	48 89 10             	mov    %rdx,(%rax)

        /* Save a copy of the table as initial state. */
        _dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
  8004210e36:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004210e3a:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004210e3e:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
  8004210e42:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004210e46:	48 89 c7             	mov    %rax,%rdi
  8004210e49:	48 b8 1c 0c 21 04 80 	movabs $0x8004210c1c,%rax
  8004210e50:	00 00 00 
  8004210e53:	ff d0                	callq  *%rax
        p = insts;
  8004210e55:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004210e59:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        pe = p + len;
  8004210e5d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210e61:	48 03 45 80          	add    -0x80(%rbp),%rax
  8004210e65:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

        while (p < pe) {
  8004210e69:	e9 7c 0d 00 00       	jmpq   8004211bea <_dwarf_frame_run_inst+0xe00>

#ifdef FRAME_DEBUG
                printf("p=%p pe=%p pc=%#jx pc_req=%#jx\n", p, pe, pc, pc_req);
#endif

                if (*p == DW_CFA_nop) {
  8004210e6e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210e72:	0f b6 00             	movzbl (%rax),%eax
  8004210e75:	84 c0                	test   %al,%al
  8004210e77:	75 11                	jne    8004210e8a <_dwarf_frame_run_inst+0xa0>
#ifdef FRAME_DEBUG
                        printf("DW_CFA_nop\n");
#endif
                        p++;
  8004210e79:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210e7d:	48 83 c0 01          	add    $0x1,%rax
  8004210e81:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                        continue;
  8004210e85:	e9 60 0d 00 00       	jmpq   8004211bea <_dwarf_frame_run_inst+0xe00>
                }

                high2 = *p & 0xc0;
  8004210e8a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210e8e:	0f b6 00             	movzbl (%rax),%eax
  8004210e91:	83 e0 c0             	and    $0xffffffc0,%eax
  8004210e94:	88 45 df             	mov    %al,-0x21(%rbp)
                low6 = *p & 0x3f;
  8004210e97:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210e9b:	0f b6 00             	movzbl (%rax),%eax
  8004210e9e:	83 e0 3f             	and    $0x3f,%eax
  8004210ea1:	88 45 de             	mov    %al,-0x22(%rbp)
                p++;
  8004210ea4:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210ea8:	48 83 c0 01          	add    $0x1,%rax
  8004210eac:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

                if (high2 > 0) {
  8004210eb0:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  8004210eb4:	0f 84 a1 01 00 00    	je     800421105b <_dwarf_frame_run_inst+0x271>
                        switch (high2) {
  8004210eba:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004210ebe:	3d 80 00 00 00       	cmp    $0x80,%eax
  8004210ec3:	74 37                	je     8004210efc <_dwarf_frame_run_inst+0x112>
  8004210ec5:	3d c0 00 00 00       	cmp    $0xc0,%eax
  8004210eca:	0f 84 00 01 00 00    	je     8004210fd0 <_dwarf_frame_run_inst+0x1e6>
  8004210ed0:	83 f8 40             	cmp    $0x40,%eax
  8004210ed3:	0f 85 70 01 00 00    	jne    8004211049 <_dwarf_frame_run_inst+0x25f>
                        case DW_CFA_advance_loc:
                                pc += low6 * caf;
  8004210ed9:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  8004210edd:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004210ee4:	ff 
  8004210ee5:	48 01 45 10          	add    %rax,0x10(%rbp)
#ifdef FRAME_DEBUG
                                printf("DW_CFA_advance_loc(%#jx(%u))\n", pc,
                                    low6);
#endif
                                if (pc_req < pc)
  8004210ee9:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004210eed:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004210ef1:	0f 83 5e 01 00 00    	jae    8004211055 <_dwarf_frame_run_inst+0x26b>
                                        goto program_done;
  8004210ef7:	e9 ff 0c 00 00       	jmpq   8004211bfb <_dwarf_frame_run_inst+0xe11>
                                break;
                        case DW_CFA_offset:
                                *row_pc = pc;
  8004210efc:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004210f00:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004210f04:	48 89 10             	mov    %rdx,(%rax)
                                CHECK_TABLE_SIZE(low6);
  8004210f07:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004210f0b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210f0f:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004210f13:	66 39 c2             	cmp    %ax,%dx
  8004210f16:	72 0c                	jb     8004210f24 <_dwarf_frame_run_inst+0x13a>
  8004210f18:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004210f1f:	e9 d7 0c 00 00       	jmpq   8004211bfb <_dwarf_frame_run_inst+0xe11>
                                RL[low6].dw_offset_relevant = 1;
  8004210f24:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210f28:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210f2c:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004210f30:	48 89 d0             	mov    %rdx,%rax
  8004210f33:	48 01 c0             	add    %rax,%rax
  8004210f36:	48 01 d0             	add    %rdx,%rax
  8004210f39:	48 c1 e0 03          	shl    $0x3,%rax
  8004210f3d:	48 01 c8             	add    %rcx,%rax
  8004210f40:	c6 00 01             	movb   $0x1,(%rax)
                                RL[low6].dw_value_type = DW_EXPR_OFFSET;
  8004210f43:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210f47:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210f4b:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004210f4f:	48 89 d0             	mov    %rdx,%rax
  8004210f52:	48 01 c0             	add    %rax,%rax
  8004210f55:	48 01 d0             	add    %rdx,%rax
  8004210f58:	48 c1 e0 03          	shl    $0x3,%rax
  8004210f5c:	48 01 c8             	add    %rcx,%rax
  8004210f5f:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                                RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
  8004210f63:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210f67:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210f6b:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004210f6f:	48 89 d0             	mov    %rdx,%rax
  8004210f72:	48 01 c0             	add    %rax,%rax
  8004210f75:	48 01 d0             	add    %rdx,%rax
  8004210f78:	48 c1 e0 03          	shl    $0x3,%rax
  8004210f7c:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004210f80:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004210f84:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  8004210f88:	66 89 42 02          	mov    %ax,0x2(%rdx)
                                RL[low6].dw_offset_or_block_len =
  8004210f8c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210f90:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004210f94:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004210f98:	48 89 d0             	mov    %rdx,%rax
  8004210f9b:	48 01 c0             	add    %rax,%rax
  8004210f9e:	48 01 d0             	add    %rdx,%rax
  8004210fa1:	48 c1 e0 03          	shl    $0x3,%rax
  8004210fa5:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
                                    _dwarf_decode_uleb128(&p) * daf;
  8004210fa9:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004210fad:	48 89 c7             	mov    %rax,%rdi
  8004210fb0:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  8004210fb7:	00 00 00 
  8004210fba:	ff d0                	callq  *%rax
  8004210fbc:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004210fc3:	48 0f af c2          	imul   %rdx,%rax
                                *row_pc = pc;
                                CHECK_TABLE_SIZE(low6);
                                RL[low6].dw_offset_relevant = 1;
                                RL[low6].dw_value_type = DW_EXPR_OFFSET;
                                RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
                                RL[low6].dw_offset_or_block_len =
  8004210fc7:	48 89 43 08          	mov    %rax,0x8(%rbx)
                                    _dwarf_decode_uleb128(&p) * daf;
#ifdef FRAME_DEBUG
                                printf("DW_CFA_offset(%jd)\n",
                                    RL[low6].dw_offset_or_block_len);
#endif
                                break;
  8004210fcb:	e9 86 00 00 00       	jmpq   8004211056 <_dwarf_frame_run_inst+0x26c>
                        case DW_CFA_restore:
                                *row_pc = pc;
  8004210fd0:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004210fd4:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004210fd8:	48 89 10             	mov    %rdx,(%rax)
                                CHECK_TABLE_SIZE(low6);
  8004210fdb:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004210fdf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004210fe3:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004210fe7:	66 39 c2             	cmp    %ax,%dx
  8004210fea:	72 0c                	jb     8004210ff8 <_dwarf_frame_run_inst+0x20e>
  8004210fec:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004210ff3:	e9 03 0c 00 00       	jmpq   8004211bfb <_dwarf_frame_run_inst+0xe11>
                                memcpy(&RL[low6], &INITRL[low6],
  8004210ff8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210ffc:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211000:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004211004:	48 89 d0             	mov    %rdx,%rax
  8004211007:	48 01 c0             	add    %rax,%rax
  800421100a:	48 01 d0             	add    %rdx,%rax
  800421100d:	48 c1 e0 03          	shl    $0x3,%rax
  8004211011:	48 01 c1             	add    %rax,%rcx
  8004211014:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211018:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421101c:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004211020:	48 89 d0             	mov    %rdx,%rax
  8004211023:	48 01 c0             	add    %rax,%rax
  8004211026:	48 01 d0             	add    %rdx,%rax
  8004211029:	48 c1 e0 03          	shl    $0x3,%rax
  800421102d:	48 01 f0             	add    %rsi,%rax
  8004211030:	ba 18 00 00 00       	mov    $0x18,%edx
  8004211035:	48 89 ce             	mov    %rcx,%rsi
  8004211038:	48 89 c7             	mov    %rax,%rdi
  800421103b:	48 b8 f5 e7 20 04 80 	movabs $0x800420e7f5,%rax
  8004211042:	00 00 00 
  8004211045:	ff d0                	callq  *%rax
                                    sizeof(Dwarf_Regtable_Entry3));
#ifdef FRAME_DEBUG
                                printf("DW_CFA_restore(%u)\n", low6);
#endif
                                break;
  8004211047:	eb 0d                	jmp    8004211056 <_dwarf_frame_run_inst+0x26c>
                        default:
                                DWARF_SET_ERROR(dbg, error,
                                    DW_DLE_FRAME_INSTR_EXEC_ERROR);
                                ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  8004211049:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
                                goto program_done;
  8004211050:	e9 a6 0b 00 00       	jmpq   8004211bfb <_dwarf_frame_run_inst+0xe11>
                                printf("DW_CFA_advance_loc(%#jx(%u))\n", pc,
                                    low6);
#endif
                                if (pc_req < pc)
                                        goto program_done;
                                break;
  8004211055:	90                   	nop
                                    DW_DLE_FRAME_INSTR_EXEC_ERROR);
                                ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
                                goto program_done;
                        }

                        continue;
  8004211056:	e9 8f 0b 00 00       	jmpq   8004211bea <_dwarf_frame_run_inst+0xe00>
                }

                switch (low6) {
  800421105b:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  800421105f:	83 f8 16             	cmp    $0x16,%eax
  8004211062:	0f 87 72 0b 00 00    	ja     8004211bda <_dwarf_frame_run_inst+0xdf0>
  8004211068:	89 c0                	mov    %eax,%eax
  800421106a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004211071:	00 
  8004211072:	48 b8 00 93 21 04 80 	movabs $0x8004219300,%rax
  8004211079:	00 00 00 
  800421107c:	48 01 d0             	add    %rdx,%rax
  800421107f:	48 8b 00             	mov    (%rax),%rax
  8004211082:	ff e0                	jmpq   *%rax
                case DW_CFA_set_loc:
			printf("dbg pointersize :%x\n",dbg->dbg_pointer_size);
  8004211084:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211088:	8b 40 28             	mov    0x28(%rax),%eax
  800421108b:	89 c6                	mov    %eax,%esi
  800421108d:	48 bf d6 92 21 04 80 	movabs $0x80042192d6,%rdi
  8004211094:	00 00 00 
  8004211097:	b8 00 00 00 00       	mov    $0x0,%eax
  800421109c:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  80042110a3:	00 00 00 
  80042110a6:	ff d2                	callq  *%rdx
                        pc = dbg->decode(&p, dbg->dbg_pointer_size);
  80042110a8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042110ac:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042110b0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042110b4:	8b 50 28             	mov    0x28(%rax),%edx
  80042110b7:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042110bb:	89 d6                	mov    %edx,%esi
  80042110bd:	48 89 c7             	mov    %rax,%rdi
  80042110c0:	ff d1                	callq  *%rcx
  80042110c2:	48 89 45 10          	mov    %rax,0x10(%rbp)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_set_loc(pc=%#jx)\n", pc);
#endif
                        if (pc_req < pc)
  80042110c6:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042110ca:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042110ce:	0f 83 26 0b 00 00    	jae    8004211bfa <_dwarf_frame_run_inst+0xe10>
				printf("Program done\n");
  80042110d4:	48 bf eb 92 21 04 80 	movabs $0x80042192eb,%rdi
  80042110db:	00 00 00 
  80042110de:	b8 00 00 00 00       	mov    $0x0,%eax
  80042110e3:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  80042110ea:	00 00 00 
  80042110ed:	ff d2                	callq  *%rdx
                                goto program_done;
  80042110ef:	e9 06 0b 00 00       	jmpq   8004211bfa <_dwarf_frame_run_inst+0xe10>
                        break;
                case DW_CFA_advance_loc1:
                        pc += dbg->decode(&p, 1) * caf;
  80042110f4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042110f8:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042110fc:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211100:	be 01 00 00 00       	mov    $0x1,%esi
  8004211105:	48 89 c7             	mov    %rax,%rdi
  8004211108:	ff d2                	callq  *%rdx
  800421110a:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004211111:	ff 
  8004211112:	48 01 45 10          	add    %rax,0x10(%rbp)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_set_loc1(pc=%#jx)\n", pc);
#endif
                        if (pc_req < pc)
  8004211116:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800421111a:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800421111e:	0f 83 bf 0a 00 00    	jae    8004211be3 <_dwarf_frame_run_inst+0xdf9>
                                goto program_done;
  8004211124:	e9 d2 0a 00 00       	jmpq   8004211bfb <_dwarf_frame_run_inst+0xe11>
                        break;
                case DW_CFA_advance_loc2:
                        pc += dbg->decode(&p, 2) * caf;
  8004211129:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421112d:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004211131:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211135:	be 02 00 00 00       	mov    $0x2,%esi
  800421113a:	48 89 c7             	mov    %rax,%rdi
  800421113d:	ff d2                	callq  *%rdx
  800421113f:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  8004211146:	ff 
  8004211147:	48 01 45 10          	add    %rax,0x10(%rbp)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_set_loc2(pc=%#jx)\n", pc);
#endif
                        if (pc_req < pc)
  800421114b:	48 8b 45 18          	mov    0x18(%rbp),%rax
  800421114f:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004211153:	0f 83 8d 0a 00 00    	jae    8004211be6 <_dwarf_frame_run_inst+0xdfc>
                                goto program_done;
  8004211159:	e9 9d 0a 00 00       	jmpq   8004211bfb <_dwarf_frame_run_inst+0xe11>
                        break;
                case DW_CFA_advance_loc4:
                        pc += dbg->decode(&p, 4) * caf;
  800421115e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211162:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004211166:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421116a:	be 04 00 00 00       	mov    $0x4,%esi
  800421116f:	48 89 c7             	mov    %rax,%rdi
  8004211172:	ff d2                	callq  *%rdx
  8004211174:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  800421117b:	ff 
  800421117c:	48 01 45 10          	add    %rax,0x10(%rbp)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_set_loc4(pc=%#jx)\n", pc);
#endif
                        if (pc_req < pc)
  8004211180:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004211184:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004211188:	0f 83 5b 0a 00 00    	jae    8004211be9 <_dwarf_frame_run_inst+0xdff>
                                goto program_done;
  800421118e:	e9 68 0a 00 00       	jmpq   8004211bfb <_dwarf_frame_run_inst+0xe11>
                        break;
                case DW_CFA_offset_extended:
                        *row_pc = pc;
  8004211193:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211197:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421119b:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  800421119e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042111a2:	48 89 c7             	mov    %rax,%rdi
  80042111a5:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  80042111ac:	00 00 00 
  80042111af:	ff d0                	callq  *%rax
  80042111b1:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  80042111b5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042111b9:	48 89 c7             	mov    %rax,%rdi
  80042111bc:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  80042111c3:	00 00 00 
  80042111c6:	ff d0                	callq  *%rax
  80042111c8:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CHECK_TABLE_SIZE(reg);
  80042111cc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042111d0:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042111d4:	0f b7 c0             	movzwl %ax,%eax
  80042111d7:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042111db:	77 0c                	ja     80042111e9 <_dwarf_frame_run_inst+0x3ff>
  80042111dd:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042111e4:	e9 12 0a 00 00       	jmpq   8004211bfb <_dwarf_frame_run_inst+0xe11>
                        RL[reg].dw_offset_relevant = 1;
  80042111e9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042111ed:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042111f1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042111f5:	48 89 d0             	mov    %rdx,%rax
  80042111f8:	48 01 c0             	add    %rax,%rax
  80042111fb:	48 01 d0             	add    %rdx,%rax
  80042111fe:	48 c1 e0 03          	shl    $0x3,%rax
  8004211202:	48 01 c8             	add    %rcx,%rax
  8004211205:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_OFFSET;
  8004211208:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421120c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211210:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211214:	48 89 d0             	mov    %rdx,%rax
  8004211217:	48 01 c0             	add    %rax,%rax
  800421121a:	48 01 d0             	add    %rdx,%rax
  800421121d:	48 c1 e0 03          	shl    $0x3,%rax
  8004211221:	48 01 c8             	add    %rcx,%rax
  8004211224:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004211228:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421122c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211230:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211234:	48 89 d0             	mov    %rdx,%rax
  8004211237:	48 01 c0             	add    %rax,%rax
  800421123a:	48 01 d0             	add    %rdx,%rax
  800421123d:	48 c1 e0 03          	shl    $0x3,%rax
  8004211241:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211245:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211249:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  800421124d:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = uoff * daf;
  8004211251:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211255:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211259:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421125d:	48 89 d0             	mov    %rdx,%rax
  8004211260:	48 01 c0             	add    %rax,%rax
  8004211263:	48 01 d0             	add    %rdx,%rax
  8004211266:	48 c1 e0 03          	shl    $0x3,%rax
  800421126a:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421126e:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004211275:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  800421127a:	48 89 42 08          	mov    %rax,0x8(%rdx)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_offset_extended(reg=%ju,uoff=%ju)\n",
                            reg, uoff);
#endif
                        break;
  800421127e:	e9 67 09 00 00       	jmpq   8004211bea <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_restore_extended:
                        *row_pc = pc;
  8004211283:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211287:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421128b:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  800421128e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211292:	48 89 c7             	mov    %rax,%rdi
  8004211295:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  800421129c:	00 00 00 
  800421129f:	ff d0                	callq  *%rax
  80042112a1:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  80042112a5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042112a9:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042112ad:	0f b7 c0             	movzwl %ax,%eax
  80042112b0:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042112b4:	77 0c                	ja     80042112c2 <_dwarf_frame_run_inst+0x4d8>
  80042112b6:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042112bd:	e9 39 09 00 00       	jmpq   8004211bfb <_dwarf_frame_run_inst+0xe11>
                        memcpy(&RL[reg], &INITRL[reg],
  80042112c2:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042112c6:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042112ca:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042112ce:	48 89 d0             	mov    %rdx,%rax
  80042112d1:	48 01 c0             	add    %rax,%rax
  80042112d4:	48 01 d0             	add    %rdx,%rax
  80042112d7:	48 c1 e0 03          	shl    $0x3,%rax
  80042112db:	48 01 c1             	add    %rax,%rcx
  80042112de:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042112e2:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042112e6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042112ea:	48 89 d0             	mov    %rdx,%rax
  80042112ed:	48 01 c0             	add    %rax,%rax
  80042112f0:	48 01 d0             	add    %rdx,%rax
  80042112f3:	48 c1 e0 03          	shl    $0x3,%rax
  80042112f7:	48 01 f0             	add    %rsi,%rax
  80042112fa:	ba 18 00 00 00       	mov    $0x18,%edx
  80042112ff:	48 89 ce             	mov    %rcx,%rsi
  8004211302:	48 89 c7             	mov    %rax,%rdi
  8004211305:	48 b8 f5 e7 20 04 80 	movabs $0x800420e7f5,%rax
  800421130c:	00 00 00 
  800421130f:	ff d0                	callq  *%rax
                            sizeof(Dwarf_Regtable_Entry3));
#ifdef FRAME_DEBUG
                        printf("DW_CFA_restore_extended(%ju)\n", reg);
#endif
                        break;
  8004211311:	e9 d4 08 00 00       	jmpq   8004211bea <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_undefined:
                        *row_pc = pc;
  8004211316:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421131a:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421131e:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004211321:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211325:	48 89 c7             	mov    %rax,%rdi
  8004211328:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  800421132f:	00 00 00 
  8004211332:	ff d0                	callq  *%rax
  8004211334:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004211338:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421133c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211340:	0f b7 c0             	movzwl %ax,%eax
  8004211343:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211347:	77 0c                	ja     8004211355 <_dwarf_frame_run_inst+0x56b>
  8004211349:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211350:	e9 a6 08 00 00       	jmpq   8004211bfb <_dwarf_frame_run_inst+0xe11>
                        RL[reg].dw_offset_relevant = 0;
  8004211355:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211359:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421135d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211361:	48 89 d0             	mov    %rdx,%rax
  8004211364:	48 01 c0             	add    %rax,%rax
  8004211367:	48 01 d0             	add    %rdx,%rax
  800421136a:	48 c1 e0 03          	shl    $0x3,%rax
  800421136e:	48 01 c8             	add    %rcx,%rax
  8004211371:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_undefined_value;
  8004211374:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211378:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421137c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211380:	48 89 d0             	mov    %rdx,%rax
  8004211383:	48 01 c0             	add    %rax,%rax
  8004211386:	48 01 d0             	add    %rdx,%rax
  8004211389:	48 c1 e0 03          	shl    $0x3,%rax
  800421138d:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211391:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211395:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  8004211399:	66 89 42 02          	mov    %ax,0x2(%rdx)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_undefined(%ju)\n", reg);
#endif
                        break;
  800421139d:	e9 48 08 00 00       	jmpq   8004211bea <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_same_value:
                        reg = _dwarf_decode_uleb128(&p);
  80042113a2:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042113a6:	48 89 c7             	mov    %rax,%rdi
  80042113a9:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  80042113b0:	00 00 00 
  80042113b3:	ff d0                	callq  *%rax
  80042113b5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  80042113b9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042113bd:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042113c1:	0f b7 c0             	movzwl %ax,%eax
  80042113c4:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042113c8:	77 0c                	ja     80042113d6 <_dwarf_frame_run_inst+0x5ec>
  80042113ca:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042113d1:	e9 25 08 00 00       	jmpq   8004211bfb <_dwarf_frame_run_inst+0xe11>
                        RL[reg].dw_offset_relevant = 0;
  80042113d6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042113da:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042113de:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042113e2:	48 89 d0             	mov    %rdx,%rax
  80042113e5:	48 01 c0             	add    %rax,%rax
  80042113e8:	48 01 d0             	add    %rdx,%rax
  80042113eb:	48 c1 e0 03          	shl    $0x3,%rax
  80042113ef:	48 01 c8             	add    %rcx,%rax
  80042113f2:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_same_value;
  80042113f5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042113f9:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042113fd:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211401:	48 89 d0             	mov    %rdx,%rax
  8004211404:	48 01 c0             	add    %rax,%rax
  8004211407:	48 01 d0             	add    %rdx,%rax
  800421140a:	48 c1 e0 03          	shl    $0x3,%rax
  800421140e:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211412:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211416:	0f b7 40 46          	movzwl 0x46(%rax),%eax
  800421141a:	66 89 42 02          	mov    %ax,0x2(%rdx)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_same_value(%ju)\n", reg);
#endif
                        break;
  800421141e:	e9 c7 07 00 00       	jmpq   8004211bea <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_register:
                        *row_pc = pc;
  8004211423:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211427:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421142b:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  800421142e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211432:	48 89 c7             	mov    %rax,%rdi
  8004211435:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  800421143c:	00 00 00 
  800421143f:	ff d0                	callq  *%rax
  8004211441:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        reg2 = _dwarf_decode_uleb128(&p);
  8004211445:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211449:	48 89 c7             	mov    %rax,%rdi
  800421144c:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  8004211453:	00 00 00 
  8004211456:	ff d0                	callq  *%rax
  8004211458:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
                        CHECK_TABLE_SIZE(reg);
  800421145c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211460:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211464:	0f b7 c0             	movzwl %ax,%eax
  8004211467:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421146b:	77 0c                	ja     8004211479 <_dwarf_frame_run_inst+0x68f>
  800421146d:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211474:	e9 82 07 00 00       	jmpq   8004211bfb <_dwarf_frame_run_inst+0xe11>
                        RL[reg].dw_offset_relevant = 0;
  8004211479:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421147d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211481:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211485:	48 89 d0             	mov    %rdx,%rax
  8004211488:	48 01 c0             	add    %rax,%rax
  800421148b:	48 01 d0             	add    %rdx,%rax
  800421148e:	48 c1 e0 03          	shl    $0x3,%rax
  8004211492:	48 01 c8             	add    %rcx,%rax
  8004211495:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = reg2;
  8004211498:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421149c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042114a0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042114a4:	48 89 d0             	mov    %rdx,%rax
  80042114a7:	48 01 c0             	add    %rax,%rax
  80042114aa:	48 01 d0             	add    %rdx,%rax
  80042114ad:	48 c1 e0 03          	shl    $0x3,%rax
  80042114b1:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042114b5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042114b9:	66 89 42 02          	mov    %ax,0x2(%rdx)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_register(reg=%ju,reg2=%ju)\n", reg,
                            reg2);
#endif
                        break;
  80042114bd:	e9 28 07 00 00       	jmpq   8004211bea <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_remember_state:
                        _dwarf_frame_regtable_copy(dbg, &saved_rt, rt, error);
  80042114c2:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80042114c6:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  80042114ca:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
  80042114ce:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042114d2:	48 89 c7             	mov    %rax,%rdi
  80042114d5:	48 b8 1c 0c 21 04 80 	movabs $0x8004210c1c,%rax
  80042114dc:	00 00 00 
  80042114df:	ff d0                	callq  *%rax
#ifdef FRAME_DEBUG
                        printf("DW_CFA_remember_state\n");
#endif
                        break;
  80042114e1:	e9 04 07 00 00       	jmpq   8004211bea <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_restore_state:
                        *row_pc = pc;
  80042114e6:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042114ea:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042114ee:	48 89 10             	mov    %rdx,(%rax)
                        _dwarf_frame_regtable_copy(dbg, &rt, saved_rt, error);
  80042114f1:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80042114f5:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  80042114f9:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  80042114fd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211501:	48 89 c7             	mov    %rax,%rdi
  8004211504:	48 b8 1c 0c 21 04 80 	movabs $0x8004210c1c,%rax
  800421150b:	00 00 00 
  800421150e:	ff d0                	callq  *%rax
#ifdef FRAME_DEBUG
                        printf("DW_CFA_restore_state\n");
#endif
                        break;
  8004211510:	e9 d5 06 00 00       	jmpq   8004211bea <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_def_cfa:
                        *row_pc = pc;
  8004211515:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211519:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421151d:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004211520:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211524:	48 89 c7             	mov    %rax,%rdi
  8004211527:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  800421152e:	00 00 00 
  8004211531:	ff d0                	callq  *%rax
  8004211533:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  8004211537:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421153b:	48 89 c7             	mov    %rax,%rdi
  800421153e:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  8004211545:	00 00 00 
  8004211548:	ff d0                	callq  *%rax
  800421154a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CFA.dw_offset_relevant = 1;
  800421154e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211552:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  8004211555:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211559:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_regnum = reg;
  800421155d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211561:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211565:	66 89 50 02          	mov    %dx,0x2(%rax)
                        CFA.dw_offset_or_block_len = uoff;
  8004211569:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421156d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211571:	48 89 50 08          	mov    %rdx,0x8(%rax)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_def_cfa(reg=%ju,uoff=%ju)\n", reg, uoff);
#endif
                        break;
  8004211575:	e9 70 06 00 00       	jmpq   8004211bea <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_def_cfa_register:
                        *row_pc = pc;
  800421157a:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421157e:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211582:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004211585:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211589:	48 89 c7             	mov    %rax,%rdi
  800421158c:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  8004211593:	00 00 00 
  8004211596:	ff d0                	callq  *%rax
  8004211598:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CFA.dw_regnum = reg;
  800421159c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042115a0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042115a4:	66 89 50 02          	mov    %dx,0x2(%rax)
                         * here.
                         */
#ifdef FRAME_DEBUG
                        printf("DW_CFA_def_cfa_register(%ju)\n", reg);
#endif
                        break;
  80042115a8:	e9 3d 06 00 00       	jmpq   8004211bea <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_def_cfa_offset:
                        *row_pc = pc;
  80042115ad:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042115b1:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042115b5:	48 89 10             	mov    %rdx,(%rax)
                        uoff = _dwarf_decode_uleb128(&p);
  80042115b8:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042115bc:	48 89 c7             	mov    %rax,%rdi
  80042115bf:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  80042115c6:	00 00 00 
  80042115c9:	ff d0                	callq  *%rax
  80042115cb:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CFA.dw_offset_relevant = 1;
  80042115cf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042115d3:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  80042115d6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042115da:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_offset_or_block_len = uoff;
  80042115de:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042115e2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042115e6:	48 89 50 08          	mov    %rdx,0x8(%rax)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_def_cfa_offset(%ju)\n", uoff);
#endif
                        break;
  80042115ea:	e9 fb 05 00 00       	jmpq   8004211bea <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_def_cfa_expression:
                        *row_pc = pc;
  80042115ef:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042115f3:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042115f7:	48 89 10             	mov    %rdx,(%rax)
                        CFA.dw_offset_relevant = 0;
  80042115fa:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042115fe:	c6 00 00             	movb   $0x0,(%rax)
                        CFA.dw_value_type = DW_EXPR_EXPRESSION;
  8004211601:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211605:	c6 40 01 02          	movb   $0x2,0x1(%rax)
                        CFA.dw_offset_or_block_len = _dwarf_decode_uleb128(&p);
  8004211609:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  800421160d:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211611:	48 89 c7             	mov    %rax,%rdi
  8004211614:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  800421161b:	00 00 00 
  800421161e:	ff d0                	callq  *%rax
  8004211620:	48 89 43 08          	mov    %rax,0x8(%rbx)
                        CFA.dw_block_ptr = p;
  8004211624:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211628:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800421162c:	48 89 50 10          	mov    %rdx,0x10(%rax)
                        p += CFA.dw_offset_or_block_len;
  8004211630:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004211634:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211638:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421163c:	48 01 d0             	add    %rdx,%rax
  800421163f:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_def_cfa_expression\n");
#endif
                        break;
  8004211643:	e9 a2 05 00 00       	jmpq   8004211bea <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_expression:
                        *row_pc = pc;
  8004211648:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421164c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211650:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004211653:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211657:	48 89 c7             	mov    %rax,%rdi
  800421165a:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  8004211661:	00 00 00 
  8004211664:	ff d0                	callq  *%rax
  8004211666:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  800421166a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421166e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211672:	0f b7 c0             	movzwl %ax,%eax
  8004211675:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211679:	77 0c                	ja     8004211687 <_dwarf_frame_run_inst+0x89d>
  800421167b:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211682:	e9 74 05 00 00       	jmpq   8004211bfb <_dwarf_frame_run_inst+0xe11>
                        RL[reg].dw_offset_relevant = 0;
  8004211687:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421168b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421168f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211693:	48 89 d0             	mov    %rdx,%rax
  8004211696:	48 01 c0             	add    %rax,%rax
  8004211699:	48 01 d0             	add    %rdx,%rax
  800421169c:	48 c1 e0 03          	shl    $0x3,%rax
  80042116a0:	48 01 c8             	add    %rcx,%rax
  80042116a3:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
  80042116a6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042116aa:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042116ae:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042116b2:	48 89 d0             	mov    %rdx,%rax
  80042116b5:	48 01 c0             	add    %rax,%rax
  80042116b8:	48 01 d0             	add    %rdx,%rax
  80042116bb:	48 c1 e0 03          	shl    $0x3,%rax
  80042116bf:	48 01 c8             	add    %rcx,%rax
  80042116c2:	c6 40 01 02          	movb   $0x2,0x1(%rax)
                        RL[reg].dw_offset_or_block_len =
  80042116c6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042116ca:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042116ce:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042116d2:	48 89 d0             	mov    %rdx,%rax
  80042116d5:	48 01 c0             	add    %rax,%rax
  80042116d8:	48 01 d0             	add    %rdx,%rax
  80042116db:	48 c1 e0 03          	shl    $0x3,%rax
  80042116df:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
                            _dwarf_decode_uleb128(&p);
  80042116e3:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042116e7:	48 89 c7             	mov    %rax,%rdi
  80042116ea:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  80042116f1:	00 00 00 
  80042116f4:	ff d0                	callq  *%rax
                        *row_pc = pc;
                        reg = _dwarf_decode_uleb128(&p);
                        CHECK_TABLE_SIZE(reg);
                        RL[reg].dw_offset_relevant = 0;
                        RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
                        RL[reg].dw_offset_or_block_len =
  80042116f6:	48 89 43 08          	mov    %rax,0x8(%rbx)
                            _dwarf_decode_uleb128(&p);
                        RL[reg].dw_block_ptr = p;
  80042116fa:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042116fe:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211702:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211706:	48 89 d0             	mov    %rdx,%rax
  8004211709:	48 01 c0             	add    %rax,%rax
  800421170c:	48 01 d0             	add    %rdx,%rax
  800421170f:	48 c1 e0 03          	shl    $0x3,%rax
  8004211713:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211717:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421171b:	48 89 42 10          	mov    %rax,0x10(%rdx)
                        p += RL[reg].dw_offset_or_block_len;
  800421171f:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004211723:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211727:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421172b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421172f:	48 89 d0             	mov    %rdx,%rax
  8004211732:	48 01 c0             	add    %rax,%rax
  8004211735:	48 01 d0             	add    %rdx,%rax
  8004211738:	48 c1 e0 03          	shl    $0x3,%rax
  800421173c:	48 01 f0             	add    %rsi,%rax
  800421173f:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211743:	48 01 c8             	add    %rcx,%rax
  8004211746:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_expression\n");
#endif
                        break;
  800421174a:	e9 9b 04 00 00       	jmpq   8004211bea <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_offset_extended_sf:
                        *row_pc = pc;
  800421174f:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211753:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211757:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  800421175a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421175e:	48 89 c7             	mov    %rax,%rdi
  8004211761:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  8004211768:	00 00 00 
  800421176b:	ff d0                	callq  *%rax
  800421176d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  8004211771:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211775:	48 89 c7             	mov    %rax,%rdi
  8004211778:	48 b8 e1 f1 20 04 80 	movabs $0x800420f1e1,%rax
  800421177f:	00 00 00 
  8004211782:	ff d0                	callq  *%rax
  8004211784:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004211788:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421178c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211790:	0f b7 c0             	movzwl %ax,%eax
  8004211793:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211797:	77 0c                	ja     80042117a5 <_dwarf_frame_run_inst+0x9bb>
  8004211799:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042117a0:	e9 56 04 00 00       	jmpq   8004211bfb <_dwarf_frame_run_inst+0xe11>
                        RL[reg].dw_offset_relevant = 1;
  80042117a5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042117a9:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042117ad:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042117b1:	48 89 d0             	mov    %rdx,%rax
  80042117b4:	48 01 c0             	add    %rax,%rax
  80042117b7:	48 01 d0             	add    %rdx,%rax
  80042117ba:	48 c1 e0 03          	shl    $0x3,%rax
  80042117be:	48 01 c8             	add    %rcx,%rax
  80042117c1:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_OFFSET;
  80042117c4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042117c8:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042117cc:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042117d0:	48 89 d0             	mov    %rdx,%rax
  80042117d3:	48 01 c0             	add    %rax,%rax
  80042117d6:	48 01 d0             	add    %rdx,%rax
  80042117d9:	48 c1 e0 03          	shl    $0x3,%rax
  80042117dd:	48 01 c8             	add    %rcx,%rax
  80042117e0:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  80042117e4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042117e8:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042117ec:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042117f0:	48 89 d0             	mov    %rdx,%rax
  80042117f3:	48 01 c0             	add    %rax,%rax
  80042117f6:	48 01 d0             	add    %rdx,%rax
  80042117f9:	48 c1 e0 03          	shl    $0x3,%rax
  80042117fd:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211801:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211805:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  8004211809:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = soff * daf;
  800421180d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211811:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211815:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211819:	48 89 d0             	mov    %rdx,%rax
  800421181c:	48 01 c0             	add    %rax,%rax
  800421181f:	48 01 d0             	add    %rdx,%rax
  8004211822:	48 c1 e0 03          	shl    $0x3,%rax
  8004211826:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421182a:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004211831:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004211836:	48 89 42 08          	mov    %rax,0x8(%rdx)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_offset_extended_sf(reg=%ju,soff=%jd)\n",
                            reg, soff);
#endif
                        break;
  800421183a:	e9 ab 03 00 00       	jmpq   8004211bea <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_def_cfa_sf:
                        *row_pc = pc;
  800421183f:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211843:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211847:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  800421184a:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421184e:	48 89 c7             	mov    %rax,%rdi
  8004211851:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  8004211858:	00 00 00 
  800421185b:	ff d0                	callq  *%rax
  800421185d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  8004211861:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211865:	48 89 c7             	mov    %rax,%rdi
  8004211868:	48 b8 e1 f1 20 04 80 	movabs $0x800420f1e1,%rax
  800421186f:	00 00 00 
  8004211872:	ff d0                	callq  *%rax
  8004211874:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CFA.dw_offset_relevant = 1;
  8004211878:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421187c:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  800421187f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211883:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_regnum = reg;
  8004211887:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421188b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421188f:	66 89 50 02          	mov    %dx,0x2(%rax)
                        CFA.dw_offset_or_block_len = soff * daf;
  8004211893:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211897:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800421189e:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  80042118a3:	48 89 50 08          	mov    %rdx,0x8(%rax)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_def_cfa_sf(reg=%ju,soff=%jd)\n", reg,
                            soff);
#endif
                        break;
  80042118a7:	e9 3e 03 00 00       	jmpq   8004211bea <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_def_cfa_offset_sf:
                        *row_pc = pc;
  80042118ac:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042118b0:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042118b4:	48 89 10             	mov    %rdx,(%rax)
                        soff = _dwarf_decode_sleb128(&p);
  80042118b7:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042118bb:	48 89 c7             	mov    %rax,%rdi
  80042118be:	48 b8 e1 f1 20 04 80 	movabs $0x800420f1e1,%rax
  80042118c5:	00 00 00 
  80042118c8:	ff d0                	callq  *%rax
  80042118ca:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CFA.dw_offset_relevant = 1;
  80042118ce:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042118d2:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  80042118d5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042118d9:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_offset_or_block_len = soff * daf;
  80042118dd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042118e1:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  80042118e8:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  80042118ed:	48 89 50 08          	mov    %rdx,0x8(%rax)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_def_cfa_offset_sf(soff=%jd)\n", soff);
#endif
                        break;
  80042118f1:	e9 f4 02 00 00       	jmpq   8004211bea <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_val_offset:
                        *row_pc = pc;
  80042118f6:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042118fa:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042118fe:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004211901:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211905:	48 89 c7             	mov    %rax,%rdi
  8004211908:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  800421190f:	00 00 00 
  8004211912:	ff d0                	callq  *%rax
  8004211914:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  8004211918:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421191c:	48 89 c7             	mov    %rax,%rdi
  800421191f:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  8004211926:	00 00 00 
  8004211929:	ff d0                	callq  *%rax
  800421192b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CHECK_TABLE_SIZE(reg);
  800421192f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211933:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211937:	0f b7 c0             	movzwl %ax,%eax
  800421193a:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421193e:	77 0c                	ja     800421194c <_dwarf_frame_run_inst+0xb62>
  8004211940:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211947:	e9 af 02 00 00       	jmpq   8004211bfb <_dwarf_frame_run_inst+0xe11>
                        RL[reg].dw_offset_relevant = 1;
  800421194c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211950:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211954:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211958:	48 89 d0             	mov    %rdx,%rax
  800421195b:	48 01 c0             	add    %rax,%rax
  800421195e:	48 01 d0             	add    %rdx,%rax
  8004211961:	48 c1 e0 03          	shl    $0x3,%rax
  8004211965:	48 01 c8             	add    %rcx,%rax
  8004211968:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  800421196b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421196f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211973:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211977:	48 89 d0             	mov    %rdx,%rax
  800421197a:	48 01 c0             	add    %rax,%rax
  800421197d:	48 01 d0             	add    %rdx,%rax
  8004211980:	48 c1 e0 03          	shl    $0x3,%rax
  8004211984:	48 01 c8             	add    %rcx,%rax
  8004211987:	c6 40 01 01          	movb   $0x1,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  800421198b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421198f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211993:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211997:	48 89 d0             	mov    %rdx,%rax
  800421199a:	48 01 c0             	add    %rax,%rax
  800421199d:	48 01 d0             	add    %rdx,%rax
  80042119a0:	48 c1 e0 03          	shl    $0x3,%rax
  80042119a4:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042119a8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042119ac:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  80042119b0:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = uoff * daf;
  80042119b4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042119b8:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042119bc:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042119c0:	48 89 d0             	mov    %rdx,%rax
  80042119c3:	48 01 c0             	add    %rax,%rax
  80042119c6:	48 01 d0             	add    %rdx,%rax
  80042119c9:	48 c1 e0 03          	shl    $0x3,%rax
  80042119cd:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042119d1:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042119d8:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  80042119dd:	48 89 42 08          	mov    %rax,0x8(%rdx)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_val_offset(reg=%ju,uoff=%ju)\n", reg,
                            uoff);
#endif
                        break;
  80042119e1:	e9 04 02 00 00       	jmpq   8004211bea <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_val_offset_sf:
                        *row_pc = pc;
  80042119e6:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042119ea:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042119ee:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042119f1:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042119f5:	48 89 c7             	mov    %rax,%rdi
  80042119f8:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  80042119ff:	00 00 00 
  8004211a02:	ff d0                	callq  *%rax
  8004211a04:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  8004211a08:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211a0c:	48 89 c7             	mov    %rax,%rdi
  8004211a0f:	48 b8 e1 f1 20 04 80 	movabs $0x800420f1e1,%rax
  8004211a16:	00 00 00 
  8004211a19:	ff d0                	callq  *%rax
  8004211a1b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004211a1f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a23:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211a27:	0f b7 c0             	movzwl %ax,%eax
  8004211a2a:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211a2e:	77 0c                	ja     8004211a3c <_dwarf_frame_run_inst+0xc52>
  8004211a30:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211a37:	e9 bf 01 00 00       	jmpq   8004211bfb <_dwarf_frame_run_inst+0xe11>
                        RL[reg].dw_offset_relevant = 1;
  8004211a3c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a40:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211a44:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211a48:	48 89 d0             	mov    %rdx,%rax
  8004211a4b:	48 01 c0             	add    %rax,%rax
  8004211a4e:	48 01 d0             	add    %rdx,%rax
  8004211a51:	48 c1 e0 03          	shl    $0x3,%rax
  8004211a55:	48 01 c8             	add    %rcx,%rax
  8004211a58:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004211a5b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a5f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211a63:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211a67:	48 89 d0             	mov    %rdx,%rax
  8004211a6a:	48 01 c0             	add    %rax,%rax
  8004211a6d:	48 01 d0             	add    %rdx,%rax
  8004211a70:	48 c1 e0 03          	shl    $0x3,%rax
  8004211a74:	48 01 c8             	add    %rcx,%rax
  8004211a77:	c6 40 01 01          	movb   $0x1,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004211a7b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211a7f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211a83:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211a87:	48 89 d0             	mov    %rdx,%rax
  8004211a8a:	48 01 c0             	add    %rax,%rax
  8004211a8d:	48 01 d0             	add    %rdx,%rax
  8004211a90:	48 c1 e0 03          	shl    $0x3,%rax
  8004211a94:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211a98:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004211a9c:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  8004211aa0:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = soff * daf;
  8004211aa4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211aa8:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211aac:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211ab0:	48 89 d0             	mov    %rdx,%rax
  8004211ab3:	48 01 c0             	add    %rax,%rax
  8004211ab6:	48 01 d0             	add    %rdx,%rax
  8004211ab9:	48 c1 e0 03          	shl    $0x3,%rax
  8004211abd:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211ac1:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004211ac8:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004211acd:	48 89 42 08          	mov    %rax,0x8(%rdx)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_val_offset_sf(reg=%ju,soff=%jd)\n", reg,
                            soff);
#endif
                        break;
  8004211ad1:	e9 14 01 00 00       	jmpq   8004211bea <_dwarf_frame_run_inst+0xe00>
                case DW_CFA_val_expression:
                        *row_pc = pc;
  8004211ad6:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211ada:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211ade:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004211ae1:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211ae5:	48 89 c7             	mov    %rax,%rdi
  8004211ae8:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  8004211aef:	00 00 00 
  8004211af2:	ff d0                	callq  *%rax
  8004211af4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004211af8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211afc:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211b00:	0f b7 c0             	movzwl %ax,%eax
  8004211b03:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211b07:	77 0c                	ja     8004211b15 <_dwarf_frame_run_inst+0xd2b>
  8004211b09:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004211b10:	e9 e6 00 00 00       	jmpq   8004211bfb <_dwarf_frame_run_inst+0xe11>
                        RL[reg].dw_offset_relevant = 0;
  8004211b15:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211b19:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211b1d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211b21:	48 89 d0             	mov    %rdx,%rax
  8004211b24:	48 01 c0             	add    %rax,%rax
  8004211b27:	48 01 d0             	add    %rdx,%rax
  8004211b2a:	48 c1 e0 03          	shl    $0x3,%rax
  8004211b2e:	48 01 c8             	add    %rcx,%rax
  8004211b31:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
  8004211b34:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211b38:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211b3c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211b40:	48 89 d0             	mov    %rdx,%rax
  8004211b43:	48 01 c0             	add    %rax,%rax
  8004211b46:	48 01 d0             	add    %rdx,%rax
  8004211b49:	48 c1 e0 03          	shl    $0x3,%rax
  8004211b4d:	48 01 c8             	add    %rcx,%rax
  8004211b50:	c6 40 01 03          	movb   $0x3,0x1(%rax)
                        RL[reg].dw_offset_or_block_len =
  8004211b54:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211b58:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211b5c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211b60:	48 89 d0             	mov    %rdx,%rax
  8004211b63:	48 01 c0             	add    %rax,%rax
  8004211b66:	48 01 d0             	add    %rdx,%rax
  8004211b69:	48 c1 e0 03          	shl    $0x3,%rax
  8004211b6d:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
                            _dwarf_decode_uleb128(&p);
  8004211b71:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004211b75:	48 89 c7             	mov    %rax,%rdi
  8004211b78:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  8004211b7f:	00 00 00 
  8004211b82:	ff d0                	callq  *%rax
                        *row_pc = pc;
                        reg = _dwarf_decode_uleb128(&p);
                        CHECK_TABLE_SIZE(reg);
                        RL[reg].dw_offset_relevant = 0;
                        RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
                        RL[reg].dw_offset_or_block_len =
  8004211b84:	48 89 43 08          	mov    %rax,0x8(%rbx)
                            _dwarf_decode_uleb128(&p);
                        RL[reg].dw_block_ptr = p;
  8004211b88:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211b8c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211b90:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211b94:	48 89 d0             	mov    %rdx,%rax
  8004211b97:	48 01 c0             	add    %rax,%rax
  8004211b9a:	48 01 d0             	add    %rdx,%rax
  8004211b9d:	48 c1 e0 03          	shl    $0x3,%rax
  8004211ba1:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211ba5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211ba9:	48 89 42 10          	mov    %rax,0x10(%rdx)
                        p += RL[reg].dw_offset_or_block_len;
  8004211bad:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004211bb1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004211bb5:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004211bb9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211bbd:	48 89 d0             	mov    %rdx,%rax
  8004211bc0:	48 01 c0             	add    %rax,%rax
  8004211bc3:	48 01 d0             	add    %rdx,%rax
  8004211bc6:	48 c1 e0 03          	shl    $0x3,%rax
  8004211bca:	48 01 f0             	add    %rsi,%rax
  8004211bcd:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211bd1:	48 01 c8             	add    %rcx,%rax
  8004211bd4:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef FRAME_DEBUG
                        printf("DW_CFA_val_expression\n");
#endif
                        break;
  8004211bd8:	eb 10                	jmp    8004211bea <_dwarf_frame_run_inst+0xe00>
                default:
                        DWARF_SET_ERROR(dbg, error,
                            DW_DLE_FRAME_INSTR_EXEC_ERROR);
                        ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  8004211bda:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
                        goto program_done;
  8004211be1:	eb 18                	jmp    8004211bfb <_dwarf_frame_run_inst+0xe11>
#ifdef FRAME_DEBUG
                        printf("DW_CFA_set_loc1(pc=%#jx)\n", pc);
#endif
                        if (pc_req < pc)
                                goto program_done;
                        break;
  8004211be3:	90                   	nop
  8004211be4:	eb 04                	jmp    8004211bea <_dwarf_frame_run_inst+0xe00>
#ifdef FRAME_DEBUG
                        printf("DW_CFA_set_loc2(pc=%#jx)\n", pc);
#endif
                        if (pc_req < pc)
                                goto program_done;
                        break;
  8004211be6:	90                   	nop
  8004211be7:	eb 01                	jmp    8004211bea <_dwarf_frame_run_inst+0xe00>
#ifdef FRAME_DEBUG
                        printf("DW_CFA_set_loc4(pc=%#jx)\n", pc);
#endif
                        if (pc_req < pc)
                                goto program_done;
                        break;
  8004211be9:	90                   	nop
        /* Save a copy of the table as initial state. */
        _dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
        p = insts;
        pe = p + len;

        while (p < pe) {
  8004211bea:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211bee:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004211bf2:	0f 82 76 f2 ff ff    	jb     8004210e6e <_dwarf_frame_run_inst+0x84>
  8004211bf8:	eb 01                	jmp    8004211bfb <_dwarf_frame_run_inst+0xe11>
#ifdef FRAME_DEBUG
                        printf("DW_CFA_set_loc(pc=%#jx)\n", pc);
#endif
                        if (pc_req < pc)
				printf("Program done\n");
                                goto program_done;
  8004211bfa:	90                   	nop
        free(init_rt);
        if (saved_rt) {
                free(saved_rt->rt3_rules);
                free(saved_rt);
        }*/
        return (ret);
  8004211bfb:	8b 45 ec             	mov    -0x14(%rbp),%eax
#undef  CFA
#undef  INITCFA
#undef  RL
#undef  INITRL
#undef  CHECK_TABLE_SIZE
}
  8004211bfe:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  8004211c05:	5b                   	pop    %rbx
  8004211c06:	5d                   	pop    %rbp
  8004211c07:	c3                   	retq   

0000008004211c08 <_dwarf_frame_get_internal_table>:


int
_dwarf_frame_get_internal_table(Dwarf_Fde fde, Dwarf_Addr pc_req,
    Dwarf_Regtable3 **ret_rt, Dwarf_Addr *ret_row_pc, Dwarf_Error *error)
{
  8004211c08:	55                   	push   %rbp
  8004211c09:	48 89 e5             	mov    %rsp,%rbp
  8004211c0c:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004211c10:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004211c14:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004211c18:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004211c1c:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004211c20:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
        Dwarf_Cie cie;
        Dwarf_Regtable3 *rt;
        Dwarf_Addr row_pc;
        int i, ret;

        assert(ret_rt != NULL);
  8004211c24:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004211c29:	75 35                	jne    8004211c60 <_dwarf_frame_get_internal_table+0x58>
  8004211c2b:	48 b9 b8 93 21 04 80 	movabs $0x80042193b8,%rcx
  8004211c32:	00 00 00 
  8004211c35:	48 ba 9f 92 21 04 80 	movabs $0x800421929f,%rdx
  8004211c3c:	00 00 00 
  8004211c3f:	be 01 02 00 00       	mov    $0x201,%esi
  8004211c44:	48 bf b4 92 21 04 80 	movabs $0x80042192b4,%rdi
  8004211c4b:	00 00 00 
  8004211c4e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211c53:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004211c5a:	00 00 00 
  8004211c5d:	41 ff d0             	callq  *%r8

        //dbg = fde->fde_dbg;
        assert(dbg != NULL);
  8004211c60:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  8004211c67:	00 00 00 
  8004211c6a:	48 8b 00             	mov    (%rax),%rax
  8004211c6d:	48 85 c0             	test   %rax,%rax
  8004211c70:	75 35                	jne    8004211ca7 <_dwarf_frame_get_internal_table+0x9f>
  8004211c72:	48 b9 c7 93 21 04 80 	movabs $0x80042193c7,%rcx
  8004211c79:	00 00 00 
  8004211c7c:	48 ba 9f 92 21 04 80 	movabs $0x800421929f,%rdx
  8004211c83:	00 00 00 
  8004211c86:	be 04 02 00 00       	mov    $0x204,%esi
  8004211c8b:	48 bf b4 92 21 04 80 	movabs $0x80042192b4,%rdi
  8004211c92:	00 00 00 
  8004211c95:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211c9a:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004211ca1:	00 00 00 
  8004211ca4:	41 ff d0             	callq  *%r8

        rt = dbg->dbg_internal_reg_table;
  8004211ca7:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  8004211cae:	00 00 00 
  8004211cb1:	48 8b 00             	mov    (%rax),%rax
  8004211cb4:	48 8b 40 50          	mov    0x50(%rax),%rax
  8004211cb8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

        /* Clear the content of regtable from previous run. */
        memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
  8004211cbc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211cc0:	ba 18 00 00 00       	mov    $0x18,%edx
  8004211cc5:	be 00 00 00 00       	mov    $0x0,%esi
  8004211cca:	48 89 c7             	mov    %rax,%rdi
  8004211ccd:	48 b8 53 e6 20 04 80 	movabs $0x800420e653,%rax
  8004211cd4:	00 00 00 
  8004211cd7:	ff d0                	callq  *%rax
        memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
  8004211cd9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211cdd:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211ce1:	0f b7 d0             	movzwl %ax,%edx
  8004211ce4:	48 89 d0             	mov    %rdx,%rax
  8004211ce7:	48 01 c0             	add    %rax,%rax
  8004211cea:	48 01 d0             	add    %rdx,%rax
  8004211ced:	48 c1 e0 03          	shl    $0x3,%rax
  8004211cf1:	48 89 c2             	mov    %rax,%rdx
  8004211cf4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211cf8:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004211cfc:	be 00 00 00 00       	mov    $0x0,%esi
  8004211d01:	48 89 c7             	mov    %rax,%rdi
  8004211d04:	48 b8 53 e6 20 04 80 	movabs $0x800420e653,%rax
  8004211d0b:	00 00 00 
  8004211d0e:	ff d0                	callq  *%rax
            sizeof(Dwarf_Regtable_Entry3));

        /* Set rules to initial values. */
        for (i = 0; i < rt->rt3_reg_table_size; i++)
  8004211d10:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004211d17:	eb 38                	jmp    8004211d51 <_dwarf_frame_get_internal_table+0x149>
                rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;
  8004211d19:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211d1d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211d21:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004211d24:	48 63 d0             	movslq %eax,%rdx
  8004211d27:	48 89 d0             	mov    %rdx,%rax
  8004211d2a:	48 01 c0             	add    %rax,%rax
  8004211d2d:	48 01 d0             	add    %rdx,%rax
  8004211d30:	48 c1 e0 03          	shl    $0x3,%rax
  8004211d34:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004211d38:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  8004211d3f:	00 00 00 
  8004211d42:	48 8b 00             	mov    (%rax),%rax
  8004211d45:	0f b7 40 42          	movzwl 0x42(%rax),%eax
  8004211d49:	66 89 42 02          	mov    %ax,0x2(%rdx)
        memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
        memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
            sizeof(Dwarf_Regtable_Entry3));

        /* Set rules to initial values. */
        for (i = 0; i < rt->rt3_reg_table_size; i++)
  8004211d4d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004211d51:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211d55:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004211d59:	0f b7 c0             	movzwl %ax,%eax
  8004211d5c:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004211d5f:	7f b8                	jg     8004211d19 <_dwarf_frame_get_internal_table+0x111>
                rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

        /* Run initial instructions in CIE. */
        cie = fde->fde_cie;
  8004211d61:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211d65:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211d69:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        assert(cie != NULL);
  8004211d6d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004211d72:	75 35                	jne    8004211da9 <_dwarf_frame_get_internal_table+0x1a1>
  8004211d74:	48 b9 d3 93 21 04 80 	movabs $0x80042193d3,%rcx
  8004211d7b:	00 00 00 
  8004211d7e:	48 ba 9f 92 21 04 80 	movabs $0x800421929f,%rdx
  8004211d85:	00 00 00 
  8004211d88:	be 13 02 00 00       	mov    $0x213,%esi
  8004211d8d:	48 bf b4 92 21 04 80 	movabs $0x80042192b4,%rdi
  8004211d94:	00 00 00 
  8004211d97:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211d9c:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004211da3:	00 00 00 
  8004211da6:	41 ff d0             	callq  *%r8
        ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
            cie->cie_instlen, cie->cie_caf, cie->cie_daf, 0, ~0ULL,
  8004211da9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
                rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

        /* Run initial instructions in CIE. */
        cie = fde->fde_cie;
        assert(cie != NULL);
        ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
  8004211dad:	4c 8b 48 40          	mov    0x40(%rax),%r9
            cie->cie_instlen, cie->cie_caf, cie->cie_daf, 0, ~0ULL,
  8004211db1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
                rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

        /* Run initial instructions in CIE. */
        cie = fde->fde_cie;
        assert(cie != NULL);
        ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
  8004211db5:	4c 8b 40 38          	mov    0x38(%rax),%r8
            cie->cie_instlen, cie->cie_caf, cie->cie_daf, 0, ~0ULL,
  8004211db9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
                rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

        /* Run initial instructions in CIE. */
        cie = fde->fde_cie;
        assert(cie != NULL);
        ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
  8004211dbd:	48 8b 48 70          	mov    0x70(%rax),%rcx
  8004211dc1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211dc5:	48 8b 50 68          	mov    0x68(%rax),%rdx
  8004211dc9:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  8004211dd0:	00 00 00 
  8004211dd3:	48 8b 00             	mov    (%rax),%rax
  8004211dd6:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004211dda:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
  8004211dde:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004211de3:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  8004211de7:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004211dec:	48 c7 44 24 08 ff ff 	movq   $0xffffffffffffffff,0x8(%rsp)
  8004211df3:	ff ff 
  8004211df5:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8004211dfc:	00 
  8004211dfd:	48 89 c7             	mov    %rax,%rdi
  8004211e00:	48 b8 ea 0d 21 04 80 	movabs $0x8004210dea,%rax
  8004211e07:	00 00 00 
  8004211e0a:	ff d0                	callq  *%rax
  8004211e0c:	89 45 e4             	mov    %eax,-0x1c(%rbp)
            cie->cie_instlen, cie->cie_caf, cie->cie_daf, 0, ~0ULL,
            &row_pc, error);
        if (ret != DW_DLE_NONE)
  8004211e0f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004211e13:	74 08                	je     8004211e1d <_dwarf_frame_get_internal_table+0x215>
                return (ret);
  8004211e15:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004211e18:	e9 a1 00 00 00       	jmpq   8004211ebe <_dwarf_frame_get_internal_table+0x2b6>
        /* Run instructions in FDE. */
        if (pc_req >= fde->fde_initloc) {
  8004211e1d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211e21:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211e25:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004211e29:	77 78                	ja     8004211ea3 <_dwarf_frame_get_internal_table+0x29b>
                ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
                    fde->fde_instlen, cie->cie_caf, cie->cie_daf,
                    fde->fde_initloc, pc_req, &row_pc, error);
  8004211e2b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
            &row_pc, error);
        if (ret != DW_DLE_NONE)
                return (ret);
        /* Run instructions in FDE. */
        if (pc_req >= fde->fde_initloc) {
                ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  8004211e2f:	48 8b 78 30          	mov    0x30(%rax),%rdi
                    fde->fde_instlen, cie->cie_caf, cie->cie_daf,
  8004211e33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
            &row_pc, error);
        if (ret != DW_DLE_NONE)
                return (ret);
        /* Run instructions in FDE. */
        if (pc_req >= fde->fde_initloc) {
                ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  8004211e37:	4c 8b 48 40          	mov    0x40(%rax),%r9
                    fde->fde_instlen, cie->cie_caf, cie->cie_daf,
  8004211e3b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
            &row_pc, error);
        if (ret != DW_DLE_NONE)
                return (ret);
        /* Run instructions in FDE. */
        if (pc_req >= fde->fde_initloc) {
                ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  8004211e3f:	4c 8b 50 38          	mov    0x38(%rax),%r10
                    fde->fde_instlen, cie->cie_caf, cie->cie_daf,
  8004211e43:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
            &row_pc, error);
        if (ret != DW_DLE_NONE)
                return (ret);
        /* Run instructions in FDE. */
        if (pc_req >= fde->fde_initloc) {
                ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  8004211e47:	48 8b 48 58          	mov    0x58(%rax),%rcx
  8004211e4b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211e4f:	48 8b 50 50          	mov    0x50(%rax),%rdx
  8004211e53:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  8004211e5a:	00 00 00 
  8004211e5d:	48 8b 00             	mov    (%rax),%rax
  8004211e60:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004211e64:	4c 8b 45 a8          	mov    -0x58(%rbp),%r8
  8004211e68:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  8004211e6d:	4c 8d 45 d8          	lea    -0x28(%rbp),%r8
  8004211e71:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  8004211e76:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
  8004211e7a:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  8004211e7f:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004211e83:	4d 89 d0             	mov    %r10,%r8
  8004211e86:	48 89 c7             	mov    %rax,%rdi
  8004211e89:	48 b8 ea 0d 21 04 80 	movabs $0x8004210dea,%rax
  8004211e90:	00 00 00 
  8004211e93:	ff d0                	callq  *%rax
  8004211e95:	89 45 e4             	mov    %eax,-0x1c(%rbp)
                    fde->fde_instlen, cie->cie_caf, cie->cie_daf,
                    fde->fde_initloc, pc_req, &row_pc, error);
                if (ret != DW_DLE_NONE)
  8004211e98:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004211e9c:	74 05                	je     8004211ea3 <_dwarf_frame_get_internal_table+0x29b>
                        return (ret);
  8004211e9e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004211ea1:	eb 1b                	jmp    8004211ebe <_dwarf_frame_get_internal_table+0x2b6>
        }

        *ret_rt = rt;
  8004211ea3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004211ea7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004211eab:	48 89 10             	mov    %rdx,(%rax)
        *ret_row_pc = row_pc;
  8004211eae:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004211eb2:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004211eb6:	48 89 10             	mov    %rdx,(%rax)

        return (DW_DLE_NONE);
  8004211eb9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211ebe:	c9                   	leaveq 
  8004211ebf:	c3                   	retq   

0000008004211ec0 <dwarf_get_fde_info_for_all_regs>:


int
dwarf_get_fde_info_for_all_regs(Dwarf_Fde fde, Dwarf_Addr pc_requested,
    Dwarf_Regtable *reg_table, Dwarf_Addr *row_pc, Dwarf_Error *error)
{
  8004211ec0:	55                   	push   %rbp
  8004211ec1:	48 89 e5             	mov    %rsp,%rbp
  8004211ec4:	48 83 ec 50          	sub    $0x50,%rsp
  8004211ec8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004211ecc:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004211ed0:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004211ed4:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8004211ed8:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
        Dwarf_Regtable3 *rt;
        Dwarf_Addr pc;
        Dwarf_Half cfa;
        int i, ret;

        if (fde == NULL || reg_table == NULL || row_pc == NULL) {
  8004211edc:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004211ee1:	74 0e                	je     8004211ef1 <dwarf_get_fde_info_for_all_regs+0x31>
  8004211ee3:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004211ee8:	74 07                	je     8004211ef1 <dwarf_get_fde_info_for_all_regs+0x31>
  8004211eea:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004211eef:	75 15                	jne    8004211f06 <dwarf_get_fde_info_for_all_regs+0x46>
                DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
				*(int*) 0 =0;
  8004211ef1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211ef6:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
                return (DW_DLV_ERROR);
  8004211efc:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211f01:	e9 35 02 00 00       	jmpq   800421213b <dwarf_get_fde_info_for_all_regs+0x27b>
        }

        assert(dbg != NULL);
  8004211f06:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  8004211f0d:	00 00 00 
  8004211f10:	48 8b 00             	mov    (%rax),%rax
  8004211f13:	48 85 c0             	test   %rax,%rax
  8004211f16:	75 35                	jne    8004211f4d <dwarf_get_fde_info_for_all_regs+0x8d>
  8004211f18:	48 b9 c7 93 21 04 80 	movabs $0x80042193c7,%rcx
  8004211f1f:	00 00 00 
  8004211f22:	48 ba 9f 92 21 04 80 	movabs $0x800421929f,%rdx
  8004211f29:	00 00 00 
  8004211f2c:	be 39 02 00 00       	mov    $0x239,%esi
  8004211f31:	48 bf b4 92 21 04 80 	movabs $0x80042192b4,%rdi
  8004211f38:	00 00 00 
  8004211f3b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211f40:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004211f47:	00 00 00 
  8004211f4a:	41 ff d0             	callq  *%r8

        if (pc_requested < fde->fde_initloc ||
  8004211f4d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211f51:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211f55:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211f59:	77 19                	ja     8004211f74 <dwarf_get_fde_info_for_all_regs+0xb4>
            pc_requested >= fde->fde_initloc + fde->fde_adrange) {
  8004211f5b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211f5f:	48 8b 50 30          	mov    0x30(%rax),%rdx
  8004211f63:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211f67:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004211f6b:	48 01 d0             	add    %rdx,%rax
                return (DW_DLV_ERROR);
        }

        assert(dbg != NULL);

        if (pc_requested < fde->fde_initloc ||
  8004211f6e:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004211f72:	77 15                	ja     8004211f89 <dwarf_get_fde_info_for_all_regs+0xc9>
            pc_requested >= fde->fde_initloc + fde->fde_adrange) {
                DWARF_SET_ERROR(dbg, error, DW_DLE_PC_NOT_IN_FDE_RANGE);
				*(int*) 0 =0;
  8004211f74:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211f79:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
                return (DW_DLV_ERROR);
  8004211f7f:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211f84:	e9 b2 01 00 00       	jmpq   800421213b <dwarf_get_fde_info_for_all_regs+0x27b>
        }

        ret = _dwarf_frame_get_internal_table(fde, pc_requested, &rt, &pc,
  8004211f89:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004211f8d:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  8004211f91:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  8004211f95:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004211f99:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211f9d:	49 89 f8             	mov    %rdi,%r8
  8004211fa0:	48 89 c7             	mov    %rax,%rdi
  8004211fa3:	48 b8 08 1c 21 04 80 	movabs $0x8004211c08,%rax
  8004211faa:	00 00 00 
  8004211fad:	ff d0                	callq  *%rax
  8004211faf:	89 45 f8             	mov    %eax,-0x8(%rbp)
            error);
        if (ret != DW_DLE_NONE)
  8004211fb2:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004211fb6:	74 15                	je     8004211fcd <dwarf_get_fde_info_for_all_regs+0x10d>
		{

				*(int*)0 = 0;
  8004211fb8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211fbd:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
                return (DW_DLV_ERROR);
  8004211fc3:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211fc8:	e9 6e 01 00 00       	jmpq   800421213b <dwarf_get_fde_info_for_all_regs+0x27b>
        /*
         * Copy the CFA rule to the column intended for holding the CFA,
         * if it's within the range of regtable.
         */
#define CFA rt->rt3_cfa_rule
        cfa = dbg->dbg_frame_cfa_value;
  8004211fcd:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  8004211fd4:	00 00 00 
  8004211fd7:	48 8b 00             	mov    (%rax),%rax
  8004211fda:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  8004211fde:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
        if (cfa < DW_REG_TABLE_SIZE) {
  8004211fe2:	66 83 7d f6 41       	cmpw   $0x41,-0xa(%rbp)
  8004211fe7:	77 5a                	ja     8004212043 <dwarf_get_fde_info_for_all_regs+0x183>
                reg_table->rules[cfa].dw_offset_relevant =
  8004211fe9:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
                   CFA.dw_offset_relevant;
  8004211fed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211ff1:	0f b6 00             	movzbl (%rax),%eax
         * if it's within the range of regtable.
         */
#define CFA rt->rt3_cfa_rule
        cfa = dbg->dbg_frame_cfa_value;
        if (cfa < DW_REG_TABLE_SIZE) {
                reg_table->rules[cfa].dw_offset_relevant =
  8004211ff4:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211ff8:	48 63 c9             	movslq %ecx,%rcx
  8004211ffb:	48 c1 e1 04          	shl    $0x4,%rcx
  8004211fff:	48 01 ca             	add    %rcx,%rdx
  8004212002:	88 02                	mov    %al,(%rdx)
                   CFA.dw_offset_relevant;
                reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
  8004212004:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004212008:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421200c:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004212010:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212014:	48 63 c9             	movslq %ecx,%rcx
  8004212017:	48 c1 e1 04          	shl    $0x4,%rcx
  800421201b:	48 01 ca             	add    %rcx,%rdx
  800421201e:	66 89 42 02          	mov    %ax,0x2(%rdx)
                reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
  8004212022:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004212026:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421202a:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421202e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212032:	48 63 c9             	movslq %ecx,%rcx
  8004212035:	48 c1 e1 04          	shl    $0x4,%rcx
  8004212039:	48 01 ca             	add    %rcx,%rdx
  800421203c:	48 83 c2 08          	add    $0x8,%rdx
  8004212040:	48 89 02             	mov    %rax,(%rdx)
        }

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  8004212043:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421204a:	e9 b9 00 00 00       	jmpq   8004212108 <dwarf_get_fde_info_for_all_regs+0x248>
             i++) {

                /* Do not overwrite CFA column */
                if (i == cfa)
  800421204f:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  8004212053:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004212056:	0f 84 a7 00 00 00    	je     8004212103 <dwarf_get_fde_info_for_all_regs+0x243>
                        continue;

                reg_table->rules[i].dw_offset_relevant =
                    rt->rt3_rules[i].dw_offset_relevant;
  800421205c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212060:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212064:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004212067:	48 63 d0             	movslq %eax,%rdx
  800421206a:	48 89 d0             	mov    %rdx,%rax
  800421206d:	48 01 c0             	add    %rax,%rax
  8004212070:	48 01 d0             	add    %rdx,%rax
  8004212073:	48 c1 e0 03          	shl    $0x3,%rax
  8004212077:	48 01 c8             	add    %rcx,%rax
  800421207a:	0f b6 00             	movzbl (%rax),%eax

                /* Do not overwrite CFA column */
                if (i == cfa)
                        continue;

                reg_table->rules[i].dw_offset_relevant =
  800421207d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212081:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004212084:	48 63 c9             	movslq %ecx,%rcx
  8004212087:	48 c1 e1 04          	shl    $0x4,%rcx
  800421208b:	48 01 ca             	add    %rcx,%rdx
  800421208e:	88 02                	mov    %al,(%rdx)
                    rt->rt3_rules[i].dw_offset_relevant;
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
  8004212090:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212094:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212098:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421209b:	48 63 d0             	movslq %eax,%rdx
  800421209e:	48 89 d0             	mov    %rdx,%rax
  80042120a1:	48 01 c0             	add    %rax,%rax
  80042120a4:	48 01 d0             	add    %rdx,%rax
  80042120a7:	48 c1 e0 03          	shl    $0x3,%rax
  80042120ab:	48 01 c8             	add    %rcx,%rax
  80042120ae:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  80042120b2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042120b6:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042120b9:	48 63 c9             	movslq %ecx,%rcx
  80042120bc:	48 c1 e1 04          	shl    $0x4,%rcx
  80042120c0:	48 01 ca             	add    %rcx,%rdx
  80042120c3:	66 89 42 02          	mov    %ax,0x2(%rdx)
                reg_table->rules[i].dw_offset =
                    rt->rt3_rules[i].dw_offset_or_block_len;
  80042120c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042120cb:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042120cf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042120d2:	48 63 d0             	movslq %eax,%rdx
  80042120d5:	48 89 d0             	mov    %rdx,%rax
  80042120d8:	48 01 c0             	add    %rax,%rax
  80042120db:	48 01 d0             	add    %rdx,%rax
  80042120de:	48 c1 e0 03          	shl    $0x3,%rax
  80042120e2:	48 01 c8             	add    %rcx,%rax
  80042120e5:	48 8b 40 08          	mov    0x8(%rax),%rax
                        continue;

                reg_table->rules[i].dw_offset_relevant =
                    rt->rt3_rules[i].dw_offset_relevant;
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
                reg_table->rules[i].dw_offset =
  80042120e9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042120ed:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042120f0:	48 63 c9             	movslq %ecx,%rcx
  80042120f3:	48 c1 e1 04          	shl    $0x4,%rcx
  80042120f7:	48 01 ca             	add    %rcx,%rdx
  80042120fa:	48 83 c2 08          	add    $0x8,%rdx
  80042120fe:	48 89 02             	mov    %rax,(%rdx)
  8004212101:	eb 01                	jmp    8004212104 <dwarf_get_fde_info_for_all_regs+0x244>
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
             i++) {

                /* Do not overwrite CFA column */
                if (i == cfa)
                        continue;
  8004212103:	90                   	nop

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
             i++) {
  8004212104:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
        }

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  8004212108:	83 7d fc 41          	cmpl   $0x41,-0x4(%rbp)
  800421210c:	7f 1d                	jg     800421212b <dwarf_get_fde_info_for_all_regs+0x26b>
  800421210e:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  8004212115:	00 00 00 
  8004212118:	48 8b 00             	mov    (%rax),%rax
  800421211b:	0f b7 40 40          	movzwl 0x40(%rax),%eax
  800421211f:	0f b7 c0             	movzwl %ax,%eax
  8004212122:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004212125:	0f 8f 24 ff ff ff    	jg     800421204f <dwarf_get_fde_info_for_all_regs+0x18f>
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
                reg_table->rules[i].dw_offset =
                    rt->rt3_rules[i].dw_offset_or_block_len;
        }

        *row_pc = pc;
  800421212b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421212f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212133:	48 89 10             	mov    %rdx,(%rax)

        return (DW_DLV_OK);
  8004212136:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421213b:	c9                   	leaveq 
  800421213c:	c3                   	retq   

000000800421213d <_dwarf_frame_read_lsb_encoded>:

static int
_dwarf_frame_read_lsb_encoded(Dwarf_Debug dbg, uint64_t *val, uint8_t *data,
    uint64_t *offsetp, uint8_t encode, Dwarf_Addr pc, Dwarf_Error *error)
{
  800421213d:	55                   	push   %rbp
  800421213e:	48 89 e5             	mov    %rsp,%rbp
  8004212141:	48 83 ec 40          	sub    $0x40,%rsp
  8004212145:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004212149:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421214d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004212151:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004212155:	44 89 c0             	mov    %r8d,%eax
  8004212158:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
  800421215c:	88 45 cc             	mov    %al,-0x34(%rbp)
	uint8_t application;

	if (encode == DW_EH_PE_omit)
  800421215f:	80 7d cc ff          	cmpb   $0xff,-0x34(%rbp)
  8004212163:	75 0a                	jne    800421216f <_dwarf_frame_read_lsb_encoded+0x32>
		return (DW_DLE_NONE);
  8004212165:	b8 00 00 00 00       	mov    $0x0,%eax
  800421216a:	e9 05 02 00 00       	jmpq   8004212374 <_dwarf_frame_read_lsb_encoded+0x237>

	application = encode & 0xf0;
  800421216f:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004212173:	83 e0 f0             	and    $0xfffffff0,%eax
  8004212176:	88 45 ff             	mov    %al,-0x1(%rbp)
	encode &= 0x0f;
  8004212179:	80 65 cc 0f          	andb   $0xf,-0x34(%rbp)

	switch (encode) {
  800421217d:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004212181:	83 f8 0c             	cmp    $0xc,%eax
  8004212184:	0f 87 91 01 00 00    	ja     800421231b <_dwarf_frame_read_lsb_encoded+0x1de>
  800421218a:	89 c0                	mov    %eax,%eax
  800421218c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004212193:	00 
  8004212194:	48 b8 e0 93 21 04 80 	movabs $0x80042193e0,%rax
  800421219b:	00 00 00 
  800421219e:	48 01 d0             	add    %rdx,%rax
  80042121a1:	48 8b 00             	mov    (%rax),%rax
  80042121a4:	ff e0                	jmpq   *%rax
	case DW_EH_PE_absptr:
		*val = dbg->read(data, offsetp, dbg->dbg_pointer_size);
  80042121a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042121aa:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042121ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042121b2:	8b 50 28             	mov    0x28(%rax),%edx
  80042121b5:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  80042121b9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042121bd:	48 89 ce             	mov    %rcx,%rsi
  80042121c0:	48 89 c7             	mov    %rax,%rdi
  80042121c3:	41 ff d0             	callq  *%r8
  80042121c6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042121ca:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042121cd:	e9 50 01 00 00       	jmpq   8004212322 <_dwarf_frame_read_lsb_encoded+0x1e5>
	case DW_EH_PE_uleb128:
		*val = _dwarf_read_uleb128(data, offsetp);
  80042121d2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042121d6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042121da:	48 89 d6             	mov    %rdx,%rsi
  80042121dd:	48 89 c7             	mov    %rax,%rdi
  80042121e0:	48 b8 60 f1 20 04 80 	movabs $0x800420f160,%rax
  80042121e7:	00 00 00 
  80042121ea:	ff d0                	callq  *%rax
  80042121ec:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042121f0:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042121f3:	e9 2a 01 00 00       	jmpq   8004212322 <_dwarf_frame_read_lsb_encoded+0x1e5>
	case DW_EH_PE_udata2:
		*val = dbg->read(data, offsetp, 2);
  80042121f8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042121fc:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004212200:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8004212204:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212208:	ba 02 00 00 00       	mov    $0x2,%edx
  800421220d:	48 89 ce             	mov    %rcx,%rsi
  8004212210:	48 89 c7             	mov    %rax,%rdi
  8004212213:	41 ff d0             	callq  *%r8
  8004212216:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421221a:	48 89 02             	mov    %rax,(%rdx)
		break;
  800421221d:	e9 00 01 00 00       	jmpq   8004212322 <_dwarf_frame_read_lsb_encoded+0x1e5>
	case DW_EH_PE_udata4:
		*val = dbg->read(data, offsetp, 4);
  8004212222:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212226:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800421222a:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800421222e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212232:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212237:	48 89 ce             	mov    %rcx,%rsi
  800421223a:	48 89 c7             	mov    %rax,%rdi
  800421223d:	41 ff d0             	callq  *%r8
  8004212240:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212244:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004212247:	e9 d6 00 00 00       	jmpq   8004212322 <_dwarf_frame_read_lsb_encoded+0x1e5>
	case DW_EH_PE_udata8:
		*val = dbg->read(data, offsetp, 8);
  800421224c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212250:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004212254:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8004212258:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421225c:	ba 08 00 00 00       	mov    $0x8,%edx
  8004212261:	48 89 ce             	mov    %rcx,%rsi
  8004212264:	48 89 c7             	mov    %rax,%rdi
  8004212267:	41 ff d0             	callq  *%r8
  800421226a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421226e:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004212271:	e9 ac 00 00 00       	jmpq   8004212322 <_dwarf_frame_read_lsb_encoded+0x1e5>
	case DW_EH_PE_sleb128:
		*val = _dwarf_read_sleb128(data, offsetp);
  8004212276:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421227a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421227e:	48 89 d6             	mov    %rdx,%rsi
  8004212281:	48 89 c7             	mov    %rax,%rdi
  8004212284:	48 b8 b8 f0 20 04 80 	movabs $0x800420f0b8,%rax
  800421228b:	00 00 00 
  800421228e:	ff d0                	callq  *%rax
  8004212290:	48 89 c2             	mov    %rax,%rdx
  8004212293:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212297:	48 89 10             	mov    %rdx,(%rax)
		break;
  800421229a:	e9 83 00 00 00       	jmpq   8004212322 <_dwarf_frame_read_lsb_encoded+0x1e5>
	case DW_EH_PE_sdata2:
		*val = (int16_t) dbg->read(data, offsetp, 2);
  800421229f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042122a3:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042122a7:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  80042122ab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042122af:	ba 02 00 00 00       	mov    $0x2,%edx
  80042122b4:	48 89 ce             	mov    %rcx,%rsi
  80042122b7:	48 89 c7             	mov    %rax,%rdi
  80042122ba:	41 ff d0             	callq  *%r8
  80042122bd:	48 0f bf d0          	movswq %ax,%rdx
  80042122c1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042122c5:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042122c8:	eb 58                	jmp    8004212322 <_dwarf_frame_read_lsb_encoded+0x1e5>
	case DW_EH_PE_sdata4:
		*val = (int32_t) dbg->read(data, offsetp, 4);
  80042122ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042122ce:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042122d2:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  80042122d6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042122da:	ba 04 00 00 00       	mov    $0x4,%edx
  80042122df:	48 89 ce             	mov    %rcx,%rsi
  80042122e2:	48 89 c7             	mov    %rax,%rdi
  80042122e5:	41 ff d0             	callq  *%r8
  80042122e8:	48 63 d0             	movslq %eax,%rdx
  80042122eb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042122ef:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042122f2:	eb 2e                	jmp    8004212322 <_dwarf_frame_read_lsb_encoded+0x1e5>
	case DW_EH_PE_sdata8:
		*val = dbg->read(data, offsetp, 8);
  80042122f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042122f8:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042122fc:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8004212300:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212304:	ba 08 00 00 00       	mov    $0x8,%edx
  8004212309:	48 89 ce             	mov    %rcx,%rsi
  800421230c:	48 89 c7             	mov    %rax,%rdi
  800421230f:	41 ff d0             	callq  *%r8
  8004212312:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004212316:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004212319:	eb 07                	jmp    8004212322 <_dwarf_frame_read_lsb_encoded+0x1e5>
	default:
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  800421231b:	b8 14 00 00 00       	mov    $0x14,%eax
  8004212320:	eb 52                	jmp    8004212374 <_dwarf_frame_read_lsb_encoded+0x237>
	}

	if (application == DW_EH_PE_pcrel) {
  8004212322:	80 7d ff 10          	cmpb   $0x10,-0x1(%rbp)
  8004212326:	75 47                	jne    800421236f <_dwarf_frame_read_lsb_encoded+0x232>
		/*
		 * Value is relative to .eh_frame section virtual addr.
		 */
		switch (encode) {
  8004212328:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  800421232c:	83 f8 01             	cmp    $0x1,%eax
  800421232f:	7c 3d                	jl     800421236e <_dwarf_frame_read_lsb_encoded+0x231>
  8004212331:	83 f8 04             	cmp    $0x4,%eax
  8004212334:	7e 0a                	jle    8004212340 <_dwarf_frame_read_lsb_encoded+0x203>
  8004212336:	83 e8 09             	sub    $0x9,%eax
  8004212339:	83 f8 03             	cmp    $0x3,%eax
  800421233c:	77 30                	ja     800421236e <_dwarf_frame_read_lsb_encoded+0x231>
  800421233e:	eb 17                	jmp    8004212357 <_dwarf_frame_read_lsb_encoded+0x21a>
		case DW_EH_PE_uleb128:
		case DW_EH_PE_udata2:
		case DW_EH_PE_udata4:
		case DW_EH_PE_udata8:
			*val += pc;
  8004212340:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212344:	48 8b 00             	mov    (%rax),%rax
  8004212347:	48 89 c2             	mov    %rax,%rdx
  800421234a:	48 03 55 c0          	add    -0x40(%rbp),%rdx
  800421234e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212352:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004212355:	eb 18                	jmp    800421236f <_dwarf_frame_read_lsb_encoded+0x232>
		case DW_EH_PE_sleb128:
		case DW_EH_PE_sdata2:
		case DW_EH_PE_sdata4:
		case DW_EH_PE_sdata8:
			*val = pc + (int64_t) *val;
  8004212357:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421235b:	48 8b 00             	mov    (%rax),%rax
  800421235e:	48 89 c2             	mov    %rax,%rdx
  8004212361:	48 03 55 c0          	add    -0x40(%rbp),%rdx
  8004212365:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212369:	48 89 10             	mov    %rdx,(%rax)
			break;
  800421236c:	eb 01                	jmp    800421236f <_dwarf_frame_read_lsb_encoded+0x232>
		default:
			/* DW_EH_PE_absptr is absolute value. */
			break;
  800421236e:	90                   	nop
		}
	}

	/* XXX Applications other than DW_EH_PE_pcrel are not handled. */

	return (DW_DLE_NONE);
  800421236f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212374:	c9                   	leaveq 
  8004212375:	c3                   	retq   

0000008004212376 <_dwarf_frame_parse_lsb_cie_augment>:

static int
_dwarf_frame_parse_lsb_cie_augment(Dwarf_Debug dbg, Dwarf_Cie cie,
    Dwarf_Error *error)
{
  8004212376:	55                   	push   %rbp
  8004212377:	48 89 e5             	mov    %rsp,%rbp
  800421237a:	48 83 ec 60          	sub    $0x60,%rsp
  800421237e:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004212382:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004212386:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	uint8_t *aug_p, *augdata_p;
	uint64_t val, offset;
	uint8_t encode;
	int ret;

	assert(cie->cie_augment != NULL && *cie->cie_augment == 'z');
  800421238a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421238e:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212392:	48 85 c0             	test   %rax,%rax
  8004212395:	74 0f                	je     80042123a6 <_dwarf_frame_parse_lsb_cie_augment+0x30>
  8004212397:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421239b:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421239f:	0f b6 00             	movzbl (%rax),%eax
  80042123a2:	3c 7a                	cmp    $0x7a,%al
  80042123a4:	74 35                	je     80042123db <_dwarf_frame_parse_lsb_cie_augment+0x65>
  80042123a6:	48 b9 48 94 21 04 80 	movabs $0x8004219448,%rcx
  80042123ad:	00 00 00 
  80042123b0:	48 ba 9f 92 21 04 80 	movabs $0x800421929f,%rdx
  80042123b7:	00 00 00 
  80042123ba:	be c0 02 00 00       	mov    $0x2c0,%esi
  80042123bf:	48 bf b4 92 21 04 80 	movabs $0x80042192b4,%rdi
  80042123c6:	00 00 00 
  80042123c9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042123ce:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042123d5:	00 00 00 
  80042123d8:	41 ff d0             	callq  *%r8
	/*
	 * Here we're only interested in the presence of augment 'R'
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
  80042123db:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042123df:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042123e3:	48 83 c0 01          	add    $0x1,%rax
  80042123e7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	augdata_p = cie->cie_augdata;
  80042123eb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042123ef:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042123f3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	while (*aug_p != '\0') {
  80042123f7:	e9 a2 00 00 00       	jmpq   800421249e <_dwarf_frame_parse_lsb_cie_augment+0x128>
		switch (*aug_p) {
  80042123fc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212400:	0f b6 00             	movzbl (%rax),%eax
  8004212403:	0f b6 c0             	movzbl %al,%eax
  8004212406:	83 f8 50             	cmp    $0x50,%eax
  8004212409:	74 11                	je     800421241c <_dwarf_frame_parse_lsb_cie_augment+0xa6>
  800421240b:	83 f8 52             	cmp    $0x52,%eax
  800421240e:	74 6d                	je     800421247d <_dwarf_frame_parse_lsb_cie_augment+0x107>
  8004212410:	83 f8 4c             	cmp    $0x4c,%eax
  8004212413:	75 7d                	jne    8004212492 <_dwarf_frame_parse_lsb_cie_augment+0x11c>
		case 'L':
			/* Skip one augment in augment data. */
			augdata_p++;
  8004212415:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
			break;
  800421241a:	eb 7d                	jmp    8004212499 <_dwarf_frame_parse_lsb_cie_augment+0x123>
		case 'P':
			/* Skip two augments in augment data. */
			encode = *augdata_p++;
  800421241c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212420:	0f b6 00             	movzbl (%rax),%eax
  8004212423:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004212426:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
			offset = 0;
  800421242b:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004212432:	00 
			ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004212433:	44 0f b6 45 ef       	movzbl -0x11(%rbp),%r8d
  8004212438:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  800421243c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004212440:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8004212444:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212448:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  800421244c:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004212450:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004212456:	48 89 c7             	mov    %rax,%rdi
  8004212459:	48 b8 3d 21 21 04 80 	movabs $0x800421213d,%rax
  8004212460:	00 00 00 
  8004212463:	ff d0                	callq  *%rax
  8004212465:	89 45 e8             	mov    %eax,-0x18(%rbp)
			    augdata_p, &offset, encode, 0, error);
			if (ret != DW_DLE_NONE)
  8004212468:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  800421246c:	74 05                	je     8004212473 <_dwarf_frame_parse_lsb_cie_augment+0xfd>
				return (ret);
  800421246e:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004212471:	eb 3f                	jmp    80042124b2 <_dwarf_frame_parse_lsb_cie_augment+0x13c>
			augdata_p += offset;
  8004212473:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212477:	48 01 45 f0          	add    %rax,-0x10(%rbp)
			break;
  800421247b:	eb 1c                	jmp    8004212499 <_dwarf_frame_parse_lsb_cie_augment+0x123>
		case 'R':
			cie->cie_fde_encode = *augdata_p++;
  800421247d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212481:	0f b6 10             	movzbl (%rax),%edx
  8004212484:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212488:	88 50 60             	mov    %dl,0x60(%rax)
  800421248b:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
			break;
  8004212490:	eb 07                	jmp    8004212499 <_dwarf_frame_parse_lsb_cie_augment+0x123>
		default:
			DWARF_SET_ERROR(dbg, error,
			    DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004212492:	b8 14 00 00 00       	mov    $0x14,%eax
  8004212497:	eb 19                	jmp    80042124b2 <_dwarf_frame_parse_lsb_cie_augment+0x13c>
		}
		aug_p++;
  8004212499:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
	augdata_p = cie->cie_augdata;
	while (*aug_p != '\0') {
  800421249e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042124a2:	0f b6 00             	movzbl (%rax),%eax
  80042124a5:	84 c0                	test   %al,%al
  80042124a7:	0f 85 4f ff ff ff    	jne    80042123fc <_dwarf_frame_parse_lsb_cie_augment+0x86>
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		}
		aug_p++;
	}

	return (DW_DLE_NONE);
  80042124ad:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042124b2:	c9                   	leaveq 
  80042124b3:	c3                   	retq   

00000080042124b4 <_dwarf_frame_set_cie>:


static int
_dwarf_frame_set_cie(Dwarf_Debug dbg, Dwarf_Section *ds,
    Dwarf_Unsigned *off, Dwarf_Cie ret_cie, Dwarf_Error *error)
{
  80042124b4:	55                   	push   %rbp
  80042124b5:	48 89 e5             	mov    %rsp,%rbp
  80042124b8:	48 83 ec 60          	sub    $0x60,%rsp
  80042124bc:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042124c0:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  80042124c4:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80042124c8:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  80042124cc:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
	Dwarf_Cie cie;
	uint64_t length;
	int dwarf_size, ret;
	char *p;

	assert(ret_cie);
  80042124d0:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  80042124d5:	75 35                	jne    800421250c <_dwarf_frame_set_cie+0x58>
  80042124d7:	48 b9 7d 94 21 04 80 	movabs $0x800421947d,%rcx
  80042124de:	00 00 00 
  80042124e1:	48 ba 9f 92 21 04 80 	movabs $0x800421929f,%rdx
  80042124e8:	00 00 00 
  80042124eb:	be f1 02 00 00       	mov    $0x2f1,%esi
  80042124f0:	48 bf b4 92 21 04 80 	movabs $0x80042192b4,%rdi
  80042124f7:	00 00 00 
  80042124fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042124ff:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004212506:	00 00 00 
  8004212509:	41 ff d0             	callq  *%r8
	cie = ret_cie;
  800421250c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212510:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	cie->cie_dbg = dbg;
  8004212514:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212518:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421251c:	48 89 10             	mov    %rdx,(%rax)
	cie->cie_offset = *off;
  800421251f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212523:	48 8b 10             	mov    (%rax),%rdx
  8004212526:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421252a:	48 89 50 10          	mov    %rdx,0x10(%rax)

	length = dbg->read(ds->ds_data, off, 4);
  800421252e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212532:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004212536:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421253a:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421253e:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004212542:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212547:	48 89 ce             	mov    %rcx,%rsi
  800421254a:	48 89 c7             	mov    %rax,%rdi
  800421254d:	41 ff d0             	callq  *%r8
  8004212550:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004212554:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004212559:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800421255d:	75 2f                	jne    800421258e <_dwarf_frame_set_cie+0xda>
		dwarf_size = 8;
  800421255f:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read(ds->ds_data, off, 8);
  8004212566:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421256a:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800421256e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212572:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212576:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  800421257a:	ba 08 00 00 00       	mov    $0x8,%edx
  800421257f:	48 89 ce             	mov    %rcx,%rsi
  8004212582:	48 89 c7             	mov    %rax,%rdi
  8004212585:	41 ff d0             	callq  *%r8
  8004212588:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421258c:	eb 07                	jmp    8004212595 <_dwarf_frame_set_cie+0xe1>
	} else
		dwarf_size = 4;
  800421258e:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > ds->ds_size - *off) {
  8004212595:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212599:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421259d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042125a1:	48 8b 00             	mov    (%rax),%rax
  80042125a4:	48 89 d1             	mov    %rdx,%rcx
  80042125a7:	48 29 c1             	sub    %rax,%rcx
  80042125aa:	48 89 c8             	mov    %rcx,%rax
  80042125ad:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042125b1:	73 0a                	jae    80042125bd <_dwarf_frame_set_cie+0x109>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  80042125b3:	b8 12 00 00 00       	mov    $0x12,%eax
  80042125b8:	e9 66 03 00 00       	jmpq   8004212923 <_dwarf_frame_set_cie+0x46f>
	}

	(void) dbg->read(ds->ds_data, off, dwarf_size); /* Skip CIE id. */
  80042125bd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042125c1:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042125c5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042125c9:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042125cd:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042125d0:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  80042125d4:	48 89 ce             	mov    %rcx,%rsi
  80042125d7:	48 89 c7             	mov    %rax,%rdi
  80042125da:	41 ff d0             	callq  *%r8
	cie->cie_length = length;
  80042125dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042125e1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042125e5:	48 89 50 18          	mov    %rdx,0x18(%rax)

	cie->cie_version = dbg->read(ds->ds_data, off, 1);
  80042125e9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042125ed:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042125f1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042125f5:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042125f9:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  80042125fd:	ba 01 00 00 00       	mov    $0x1,%edx
  8004212602:	48 89 ce             	mov    %rcx,%rsi
  8004212605:	48 89 c7             	mov    %rax,%rdi
  8004212608:	41 ff d0             	callq  *%r8
  800421260b:	89 c2                	mov    %eax,%edx
  800421260d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212611:	66 89 50 20          	mov    %dx,0x20(%rax)
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004212615:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212619:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  800421261d:	66 83 f8 01          	cmp    $0x1,%ax
  8004212621:	74 26                	je     8004212649 <_dwarf_frame_set_cie+0x195>
  8004212623:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212627:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  800421262b:	66 83 f8 03          	cmp    $0x3,%ax
  800421262f:	74 18                	je     8004212649 <_dwarf_frame_set_cie+0x195>
	    cie->cie_version != 4) {
  8004212631:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212635:	0f b7 40 20          	movzwl 0x20(%rax),%eax

	(void) dbg->read(ds->ds_data, off, dwarf_size); /* Skip CIE id. */
	cie->cie_length = length;

	cie->cie_version = dbg->read(ds->ds_data, off, 1);
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004212639:	66 83 f8 04          	cmp    $0x4,%ax
  800421263d:	74 0a                	je     8004212649 <_dwarf_frame_set_cie+0x195>
	    cie->cie_version != 4) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_VERSION_BAD);
		return (DW_DLE_FRAME_VERSION_BAD);
  800421263f:	b8 16 00 00 00       	mov    $0x16,%eax
  8004212644:	e9 da 02 00 00       	jmpq   8004212923 <_dwarf_frame_set_cie+0x46f>
	}

	cie->cie_augment = ds->ds_data + *off;
  8004212649:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421264d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004212651:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212655:	48 8b 00             	mov    (%rax),%rax
  8004212658:	48 01 c2             	add    %rax,%rdx
  800421265b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421265f:	48 89 50 28          	mov    %rdx,0x28(%rax)
	p = (char *) ds->ds_data;
  8004212663:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212667:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421266b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	while (p[(*off)++] != '\0')
  800421266f:	90                   	nop
  8004212670:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212674:	48 8b 00             	mov    (%rax),%rax
  8004212677:	48 89 c2             	mov    %rax,%rdx
  800421267a:	48 03 55 e0          	add    -0x20(%rbp),%rdx
  800421267e:	0f b6 12             	movzbl (%rdx),%edx
  8004212681:	84 d2                	test   %dl,%dl
  8004212683:	0f 95 c2             	setne  %dl
  8004212686:	48 8d 48 01          	lea    0x1(%rax),%rcx
  800421268a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421268e:	48 89 08             	mov    %rcx,(%rax)
  8004212691:	84 d2                	test   %dl,%dl
  8004212693:	75 db                	jne    8004212670 <_dwarf_frame_set_cie+0x1bc>
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
  8004212695:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212699:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421269d:	0f b6 00             	movzbl (%rax),%eax
  80042126a0:	84 c0                	test   %al,%al
  80042126a2:	74 48                	je     80042126ec <_dwarf_frame_set_cie+0x238>
  80042126a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042126a8:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042126ac:	0f b6 00             	movzbl (%rax),%eax
  80042126af:	3c 7a                	cmp    $0x7a,%al
  80042126b1:	74 39                	je     80042126ec <_dwarf_frame_set_cie+0x238>
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  80042126b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042126b7:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042126bb:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042126bf:	75 07                	jne    80042126c8 <_dwarf_frame_set_cie+0x214>
  80042126c1:	b8 04 00 00 00       	mov    $0x4,%eax
  80042126c6:	eb 05                	jmp    80042126cd <_dwarf_frame_set_cie+0x219>
  80042126c8:	b8 0c 00 00 00       	mov    $0xc,%eax
  80042126cd:	48 01 c2             	add    %rax,%rdx
		    cie->cie_length;
  80042126d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042126d4:	48 8b 40 18          	mov    0x18(%rax),%rax
	while (p[(*off)++] != '\0')
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  80042126d8:	48 01 c2             	add    %rax,%rdx
  80042126db:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042126df:	48 89 10             	mov    %rdx,(%rax)
		    cie->cie_length;
		return (DW_DLE_NONE);
  80042126e2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042126e7:	e9 37 02 00 00       	jmpq   8004212923 <_dwarf_frame_set_cie+0x46f>
	}

	/* Optional EH Data field for .eh_frame section. */
	if (strstr((char *)cie->cie_augment, "eh") != NULL)
  80042126ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042126f0:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042126f4:	48 be 85 94 21 04 80 	movabs $0x8004219485,%rsi
  80042126fb:	00 00 00 
  80042126fe:	48 89 c7             	mov    %rax,%rdi
  8004212701:	48 b8 7a ea 20 04 80 	movabs $0x800420ea7a,%rax
  8004212708:	00 00 00 
  800421270b:	ff d0                	callq  *%rax
  800421270d:	48 85 c0             	test   %rax,%rax
  8004212710:	74 2c                	je     800421273e <_dwarf_frame_set_cie+0x28a>
		cie->cie_ehdata = dbg->read(ds->ds_data, off,
  8004212712:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212716:	4c 8b 40 18          	mov    0x18(%rax),%r8
	    dbg->dbg_pointer_size);
  800421271a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
		return (DW_DLE_NONE);
	}

	/* Optional EH Data field for .eh_frame section. */
	if (strstr((char *)cie->cie_augment, "eh") != NULL)
		cie->cie_ehdata = dbg->read(ds->ds_data, off,
  800421271e:	8b 50 28             	mov    0x28(%rax),%edx
  8004212721:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212725:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212729:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  800421272d:	48 89 ce             	mov    %rcx,%rsi
  8004212730:	48 89 c7             	mov    %rax,%rdi
  8004212733:	41 ff d0             	callq  *%r8
  8004212736:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421273a:	48 89 42 30          	mov    %rax,0x30(%rdx)
	    dbg->dbg_pointer_size);

	cie->cie_caf = _dwarf_read_uleb128(ds->ds_data, off);
  800421273e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212742:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212746:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800421274a:	48 89 d6             	mov    %rdx,%rsi
  800421274d:	48 89 c7             	mov    %rax,%rdi
  8004212750:	48 b8 60 f1 20 04 80 	movabs $0x800420f160,%rax
  8004212757:	00 00 00 
  800421275a:	ff d0                	callq  *%rax
  800421275c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212760:	48 89 42 38          	mov    %rax,0x38(%rdx)
	cie->cie_daf = _dwarf_read_sleb128(ds->ds_data, off);
  8004212764:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212768:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421276c:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004212770:	48 89 d6             	mov    %rdx,%rsi
  8004212773:	48 89 c7             	mov    %rax,%rdi
  8004212776:	48 b8 b8 f0 20 04 80 	movabs $0x800420f0b8,%rax
  800421277d:	00 00 00 
  8004212780:	ff d0                	callq  *%rax
  8004212782:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212786:	48 89 42 40          	mov    %rax,0x40(%rdx)

	/* Return address register. */
	if (cie->cie_version == 1)
  800421278a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421278e:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004212792:	66 83 f8 01          	cmp    $0x1,%ax
  8004212796:	75 2c                	jne    80042127c4 <_dwarf_frame_set_cie+0x310>
		cie->cie_ra = dbg->read(ds->ds_data, off, 1);
  8004212798:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421279c:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042127a0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042127a4:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042127a8:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  80042127ac:	ba 01 00 00 00       	mov    $0x1,%edx
  80042127b1:	48 89 ce             	mov    %rcx,%rsi
  80042127b4:	48 89 c7             	mov    %rax,%rdi
  80042127b7:	41 ff d0             	callq  *%r8
  80042127ba:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042127be:	48 89 42 48          	mov    %rax,0x48(%rdx)
  80042127c2:	eb 26                	jmp    80042127ea <_dwarf_frame_set_cie+0x336>
	else
		cie->cie_ra = _dwarf_read_uleb128(ds->ds_data, off);
  80042127c4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042127c8:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042127cc:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042127d0:	48 89 d6             	mov    %rdx,%rsi
  80042127d3:	48 89 c7             	mov    %rax,%rdi
  80042127d6:	48 b8 60 f1 20 04 80 	movabs $0x800420f160,%rax
  80042127dd:	00 00 00 
  80042127e0:	ff d0                	callq  *%rax
  80042127e2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042127e6:	48 89 42 48          	mov    %rax,0x48(%rdx)

	/* Optional CIE augmentation data for .eh_frame section. */
	if (*cie->cie_augment == 'z') {
  80042127ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042127ee:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042127f2:	0f b6 00             	movzbl (%rax),%eax
  80042127f5:	3c 7a                	cmp    $0x7a,%al
  80042127f7:	0f 85 90 00 00 00    	jne    800421288d <_dwarf_frame_set_cie+0x3d9>
		cie->cie_auglen = _dwarf_read_uleb128(ds->ds_data, off);
  80042127fd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212801:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212805:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004212809:	48 89 d6             	mov    %rdx,%rsi
  800421280c:	48 89 c7             	mov    %rax,%rdi
  800421280f:	48 b8 60 f1 20 04 80 	movabs $0x800420f160,%rax
  8004212816:	00 00 00 
  8004212819:	ff d0                	callq  *%rax
  800421281b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421281f:	48 89 42 50          	mov    %rax,0x50(%rdx)
		cie->cie_augdata = ds->ds_data + *off;
  8004212823:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212827:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800421282b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421282f:	48 8b 00             	mov    (%rax),%rax
  8004212832:	48 01 c2             	add    %rax,%rdx
  8004212835:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212839:	48 89 50 58          	mov    %rdx,0x58(%rax)
		*off += cie->cie_auglen;
  800421283d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212841:	48 8b 10             	mov    (%rax),%rdx
  8004212844:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212848:	48 8b 40 50          	mov    0x50(%rax),%rax
  800421284c:	48 01 c2             	add    %rax,%rdx
  800421284f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212853:	48 89 10             	mov    %rdx,(%rax)
		/*
		 * XXX Use DW_EH_PE_absptr for default FDE PC start/range,
		 * in case _dwarf_frame_parse_lsb_cie_augment fails to
		 * find out the real encode.
		 */
		cie->cie_fde_encode = DW_EH_PE_absptr;
  8004212856:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421285a:	c6 40 60 00          	movb   $0x0,0x60(%rax)
		ret = _dwarf_frame_parse_lsb_cie_augment(dbg, cie, error);
  800421285e:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004212862:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212866:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421286a:	48 89 ce             	mov    %rcx,%rsi
  800421286d:	48 89 c7             	mov    %rax,%rdi
  8004212870:	48 b8 76 23 21 04 80 	movabs $0x8004212376,%rax
  8004212877:	00 00 00 
  800421287a:	ff d0                	callq  *%rax
  800421287c:	89 45 dc             	mov    %eax,-0x24(%rbp)
		if (ret != DW_DLE_NONE)
  800421287f:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004212883:	74 08                	je     800421288d <_dwarf_frame_set_cie+0x3d9>
			return (ret);
  8004212885:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004212888:	e9 96 00 00 00       	jmpq   8004212923 <_dwarf_frame_set_cie+0x46f>
	}

	/* CIE Initial instructions. */
	cie->cie_initinst = ds->ds_data + *off;
  800421288d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212891:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004212895:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212899:	48 8b 00             	mov    (%rax),%rax
  800421289c:	48 01 c2             	add    %rax,%rdx
  800421289f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042128a3:	48 89 50 68          	mov    %rdx,0x68(%rax)
	if (dwarf_size == 4)
  80042128a7:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042128ab:	75 2d                	jne    80042128da <_dwarf_frame_set_cie+0x426>
		cie->cie_instlen = cie->cie_offset + 4 + length - *off;
  80042128ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042128b1:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042128b5:	48 89 c2             	mov    %rax,%rdx
  80042128b8:	48 03 55 f8          	add    -0x8(%rbp),%rdx
  80042128bc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042128c0:	48 8b 00             	mov    (%rax),%rax
  80042128c3:	48 89 d1             	mov    %rdx,%rcx
  80042128c6:	48 29 c1             	sub    %rax,%rcx
  80042128c9:	48 89 c8             	mov    %rcx,%rax
  80042128cc:	48 8d 50 04          	lea    0x4(%rax),%rdx
  80042128d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042128d4:	48 89 50 70          	mov    %rdx,0x70(%rax)
  80042128d8:	eb 2b                	jmp    8004212905 <_dwarf_frame_set_cie+0x451>
	else
		cie->cie_instlen = cie->cie_offset + 12 + length - *off;
  80042128da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042128de:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042128e2:	48 89 c2             	mov    %rax,%rdx
  80042128e5:	48 03 55 f8          	add    -0x8(%rbp),%rdx
  80042128e9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042128ed:	48 8b 00             	mov    (%rax),%rax
  80042128f0:	48 89 d1             	mov    %rdx,%rcx
  80042128f3:	48 29 c1             	sub    %rax,%rcx
  80042128f6:	48 89 c8             	mov    %rcx,%rax
  80042128f9:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  80042128fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212901:	48 89 50 70          	mov    %rdx,0x70(%rax)

	*off += cie->cie_instlen;
  8004212905:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212909:	48 8b 10             	mov    (%rax),%rdx
  800421290c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212910:	48 8b 40 70          	mov    0x70(%rax),%rax
  8004212914:	48 01 c2             	add    %rax,%rdx
  8004212917:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421291b:	48 89 10             	mov    %rdx,(%rax)
	    cie->cie_daf, *off);

	printf("%x %lx\n", (unsigned int)cie->cie_ra, (unsigned long)cie->cie_initinst);
#endif

	return (DW_DLE_NONE);
  800421291e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212923:	c9                   	leaveq 
  8004212924:	c3                   	retq   

0000008004212925 <_dwarf_frame_set_fde>:

static int
_dwarf_frame_set_fde(Dwarf_Debug dbg, Dwarf_Fde retfde, Dwarf_Section *ds,
    Dwarf_Unsigned *off, int eh_frame, Dwarf_Cie cie, Dwarf_Error *error)
{
  8004212925:	55                   	push   %rbp
  8004212926:	48 89 e5             	mov    %rsp,%rbp
  8004212929:	48 83 ec 70          	sub    $0x70,%rsp
  800421292d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004212931:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004212935:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004212939:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  800421293d:	44 89 45 ac          	mov    %r8d,-0x54(%rbp)
  8004212941:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Fde fde;
	Dwarf_Unsigned cieoff;
	uint64_t length, val;
	int dwarf_size, ret;

	fde = retfde;
  8004212945:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212949:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	fde->fde_dbg = dbg;
  800421294d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212951:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212955:	48 89 10             	mov    %rdx,(%rax)
	fde->fde_addr = ds->ds_data + *off;
  8004212958:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421295c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004212960:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212964:	48 8b 00             	mov    (%rax),%rax
  8004212967:	48 01 c2             	add    %rax,%rdx
  800421296a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421296e:	48 89 50 10          	mov    %rdx,0x10(%rax)
	fde->fde_offset = *off;
  8004212972:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212976:	48 8b 10             	mov    (%rax),%rdx
  8004212979:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421297d:	48 89 50 18          	mov    %rdx,0x18(%rax)

	length = dbg->read(ds->ds_data, off, 4);
  8004212981:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212985:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004212989:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421298d:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212991:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004212995:	ba 04 00 00 00       	mov    $0x4,%edx
  800421299a:	48 89 ce             	mov    %rcx,%rsi
  800421299d:	48 89 c7             	mov    %rax,%rdi
  80042129a0:	41 ff d0             	callq  *%r8
  80042129a3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  80042129a7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042129ac:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042129b0:	75 2f                	jne    80042129e1 <_dwarf_frame_set_fde+0xbc>
		dwarf_size = 8;
  80042129b2:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read(ds->ds_data, off, 8);
  80042129b9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042129bd:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042129c1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042129c5:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042129c9:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042129cd:	ba 08 00 00 00       	mov    $0x8,%edx
  80042129d2:	48 89 ce             	mov    %rcx,%rsi
  80042129d5:	48 89 c7             	mov    %rax,%rdi
  80042129d8:	41 ff d0             	callq  *%r8
  80042129db:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042129df:	eb 07                	jmp    80042129e8 <_dwarf_frame_set_fde+0xc3>
	} else
		dwarf_size = 4;
  80042129e1:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > ds->ds_size - *off) {
  80042129e8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042129ec:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042129f0:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042129f4:	48 8b 00             	mov    (%rax),%rax
  80042129f7:	48 89 d1             	mov    %rdx,%rcx
  80042129fa:	48 29 c1             	sub    %rax,%rcx
  80042129fd:	48 89 c8             	mov    %rcx,%rax
  8004212a00:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004212a04:	73 0a                	jae    8004212a10 <_dwarf_frame_set_fde+0xeb>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004212a06:	b8 12 00 00 00       	mov    $0x12,%eax
  8004212a0b:	e9 d1 02 00 00       	jmpq   8004212ce1 <_dwarf_frame_set_fde+0x3bc>
	}

	fde->fde_length = length;
  8004212a10:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212a14:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004212a18:	48 89 50 20          	mov    %rdx,0x20(%rax)

	if (eh_frame) {
  8004212a1c:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004212a20:	74 62                	je     8004212a84 <_dwarf_frame_set_fde+0x15f>
		fde->fde_cieoff = dbg->read(ds->ds_data, off, 4);
  8004212a22:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212a26:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004212a2a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212a2e:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212a32:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004212a36:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212a3b:	48 89 ce             	mov    %rcx,%rsi
  8004212a3e:	48 89 c7             	mov    %rax,%rdi
  8004212a41:	41 ff d0             	callq  *%r8
  8004212a44:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212a48:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = *off - (4 + fde->fde_cieoff);
  8004212a4c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212a50:	48 8b 10             	mov    (%rax),%rdx
  8004212a53:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212a57:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212a5b:	48 89 d1             	mov    %rdx,%rcx
  8004212a5e:	48 29 c1             	sub    %rax,%rcx
  8004212a61:	48 89 c8             	mov    %rcx,%rax
  8004212a64:	48 83 e8 04          	sub    $0x4,%rax
  8004212a68:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		/* This delta should never be 0. */
		if (cieoff == fde->fde_offset) {
  8004212a6c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212a70:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212a74:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004212a78:	75 3e                	jne    8004212ab8 <_dwarf_frame_set_fde+0x193>
			DWARF_SET_ERROR(dbg, error, DW_DLE_NO_CIE_FOR_FDE);
			return (DW_DLE_NO_CIE_FOR_FDE);
  8004212a7a:	b8 13 00 00 00       	mov    $0x13,%eax
  8004212a7f:	e9 5d 02 00 00       	jmpq   8004212ce1 <_dwarf_frame_set_fde+0x3bc>
		}
	} else {
		fde->fde_cieoff = dbg->read(ds->ds_data, off, dwarf_size);
  8004212a84:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212a88:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004212a8c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212a90:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212a94:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004212a97:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004212a9b:	48 89 ce             	mov    %rcx,%rsi
  8004212a9e:	48 89 c7             	mov    %rax,%rdi
  8004212aa1:	41 ff d0             	callq  *%r8
  8004212aa4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212aa8:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = fde->fde_cieoff;
  8004212aac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212ab0:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212ab4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	}

	if (eh_frame) {
  8004212ab8:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004212abc:	0f 84 c3 00 00 00    	je     8004212b85 <_dwarf_frame_set_fde+0x260>
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
		    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  8004212ac2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212ac6:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004212aca:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212ace:	48 8b 00             	mov    (%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
  8004212ad1:	4c 8d 0c 02          	lea    (%rdx,%rax,1),%r9
		    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  8004212ad5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212ad9:	0f b6 40 60          	movzbl 0x60(%rax),%eax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
  8004212add:	44 0f b6 c0          	movzbl %al,%r8d
  8004212ae1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212ae5:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004212ae9:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004212aed:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004212af1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212af5:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004212af9:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004212afd:	48 89 c7             	mov    %rax,%rdi
  8004212b00:	48 b8 3d 21 21 04 80 	movabs $0x800421213d,%rax
  8004212b07:	00 00 00 
  8004212b0a:	ff d0                	callq  *%rax
  8004212b0c:	89 45 dc             	mov    %eax,-0x24(%rbp)
		    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
		if (ret != DW_DLE_NONE)
  8004212b0f:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004212b13:	74 08                	je     8004212b1d <_dwarf_frame_set_fde+0x1f8>
			return (ret);
  8004212b15:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004212b18:	e9 c4 01 00 00       	jmpq   8004212ce1 <_dwarf_frame_set_fde+0x3bc>
		fde->fde_initloc = val;
  8004212b1d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212b21:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212b25:	48 89 50 30          	mov    %rdx,0x30(%rax)
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
		    off, cie->cie_fde_encode, 0, error);
  8004212b29:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212b2d:	0f b6 40 60          	movzbl 0x60(%rax),%eax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
  8004212b31:	44 0f b6 c0          	movzbl %al,%r8d
  8004212b35:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212b39:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004212b3d:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004212b41:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004212b45:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212b49:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004212b4d:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004212b51:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004212b57:	48 89 c7             	mov    %rax,%rdi
  8004212b5a:	48 b8 3d 21 21 04 80 	movabs $0x800421213d,%rax
  8004212b61:	00 00 00 
  8004212b64:	ff d0                	callq  *%rax
  8004212b66:	89 45 dc             	mov    %eax,-0x24(%rbp)
		    off, cie->cie_fde_encode, 0, error);
		if (ret != DW_DLE_NONE)
  8004212b69:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004212b6d:	74 08                	je     8004212b77 <_dwarf_frame_set_fde+0x252>
			return (ret);
  8004212b6f:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004212b72:	e9 6a 01 00 00       	jmpq   8004212ce1 <_dwarf_frame_set_fde+0x3bc>
		fde->fde_adrange = val;
  8004212b77:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212b7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212b7f:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004212b83:	eb 58                	jmp    8004212bdd <_dwarf_frame_set_fde+0x2b8>
	} else {
		fde->fde_initloc = dbg->read(ds->ds_data, off,
  8004212b85:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212b89:	4c 8b 40 18          	mov    0x18(%rax),%r8
		    dbg->dbg_pointer_size);
  8004212b8d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
		    off, cie->cie_fde_encode, 0, error);
		if (ret != DW_DLE_NONE)
			return (ret);
		fde->fde_adrange = val;
	} else {
		fde->fde_initloc = dbg->read(ds->ds_data, off,
  8004212b91:	8b 50 28             	mov    0x28(%rax),%edx
  8004212b94:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212b98:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212b9c:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004212ba0:	48 89 ce             	mov    %rcx,%rsi
  8004212ba3:	48 89 c7             	mov    %rax,%rdi
  8004212ba6:	41 ff d0             	callq  *%r8
  8004212ba9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212bad:	48 89 42 30          	mov    %rax,0x30(%rdx)
		    dbg->dbg_pointer_size);
		fde->fde_adrange = dbg->read(ds->ds_data, off,
  8004212bb1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212bb5:	4c 8b 40 18          	mov    0x18(%rax),%r8
		    dbg->dbg_pointer_size);
  8004212bb9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
			return (ret);
		fde->fde_adrange = val;
	} else {
		fde->fde_initloc = dbg->read(ds->ds_data, off,
		    dbg->dbg_pointer_size);
		fde->fde_adrange = dbg->read(ds->ds_data, off,
  8004212bbd:	8b 50 28             	mov    0x28(%rax),%edx
  8004212bc0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212bc4:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212bc8:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004212bcc:	48 89 ce             	mov    %rcx,%rsi
  8004212bcf:	48 89 c7             	mov    %rax,%rdi
  8004212bd2:	41 ff d0             	callq  *%r8
  8004212bd5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212bd9:	48 89 42 38          	mov    %rax,0x38(%rdx)
		    dbg->dbg_pointer_size);
	}

	/* Optional FDE augmentation data for .eh_frame section. (ignored) */
	if (eh_frame && *cie->cie_augment == 'z') {
  8004212bdd:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004212be1:	74 68                	je     8004212c4b <_dwarf_frame_set_fde+0x326>
  8004212be3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212be7:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212beb:	0f b6 00             	movzbl (%rax),%eax
  8004212bee:	3c 7a                	cmp    $0x7a,%al
  8004212bf0:	75 59                	jne    8004212c4b <_dwarf_frame_set_fde+0x326>
		fde->fde_auglen = _dwarf_read_uleb128(ds->ds_data, off);
  8004212bf2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212bf6:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212bfa:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004212bfe:	48 89 d6             	mov    %rdx,%rsi
  8004212c01:	48 89 c7             	mov    %rax,%rdi
  8004212c04:	48 b8 60 f1 20 04 80 	movabs $0x800420f160,%rax
  8004212c0b:	00 00 00 
  8004212c0e:	ff d0                	callq  *%rax
  8004212c10:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212c14:	48 89 42 40          	mov    %rax,0x40(%rdx)
		fde->fde_augdata = ds->ds_data + *off;
  8004212c18:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212c1c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004212c20:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212c24:	48 8b 00             	mov    (%rax),%rax
  8004212c27:	48 01 c2             	add    %rax,%rdx
  8004212c2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212c2e:	48 89 50 48          	mov    %rdx,0x48(%rax)
		*off += fde->fde_auglen;
  8004212c32:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212c36:	48 8b 10             	mov    (%rax),%rdx
  8004212c39:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212c3d:	48 8b 40 40          	mov    0x40(%rax),%rax
  8004212c41:	48 01 c2             	add    %rax,%rdx
  8004212c44:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212c48:	48 89 10             	mov    %rdx,(%rax)
	}

	fde->fde_inst = ds->ds_data + *off;
  8004212c4b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004212c4f:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004212c53:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212c57:	48 8b 00             	mov    (%rax),%rax
  8004212c5a:	48 01 c2             	add    %rax,%rdx
  8004212c5d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212c61:	48 89 50 50          	mov    %rdx,0x50(%rax)
	if (dwarf_size == 4)
  8004212c65:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004212c69:	75 2d                	jne    8004212c98 <_dwarf_frame_set_fde+0x373>
		fde->fde_instlen = fde->fde_offset + 4 + length - *off;
  8004212c6b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212c6f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212c73:	48 89 c2             	mov    %rax,%rdx
  8004212c76:	48 03 55 f8          	add    -0x8(%rbp),%rdx
  8004212c7a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212c7e:	48 8b 00             	mov    (%rax),%rax
  8004212c81:	48 89 d1             	mov    %rdx,%rcx
  8004212c84:	48 29 c1             	sub    %rax,%rcx
  8004212c87:	48 89 c8             	mov    %rcx,%rax
  8004212c8a:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004212c8e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212c92:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004212c96:	eb 2b                	jmp    8004212cc3 <_dwarf_frame_set_fde+0x39e>
	else
		fde->fde_instlen = fde->fde_offset + 12 + length - *off;
  8004212c98:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212c9c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212ca0:	48 89 c2             	mov    %rax,%rdx
  8004212ca3:	48 03 55 f8          	add    -0x8(%rbp),%rdx
  8004212ca7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212cab:	48 8b 00             	mov    (%rax),%rax
  8004212cae:	48 89 d1             	mov    %rdx,%rcx
  8004212cb1:	48 29 c1             	sub    %rax,%rcx
  8004212cb4:	48 89 c8             	mov    %rcx,%rax
  8004212cb7:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8004212cbb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212cbf:	48 89 50 58          	mov    %rdx,0x58(%rax)

	*off += fde->fde_instlen;
  8004212cc3:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212cc7:	48 8b 10             	mov    (%rax),%rdx
  8004212cca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212cce:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004212cd2:	48 01 c2             	add    %rax,%rdx
  8004212cd5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212cd9:	48 89 10             	mov    %rdx,(%rax)
	printf("\tfde_offset=%ju fde_length=%ju fde_cieoff=%ju"
	    " fde_instlen=%ju off=%ju\n", fde->fde_offset, fde->fde_length,
	    fde->fde_cieoff, fde->fde_instlen, *off);
#endif

	return (DW_DLE_NONE);
  8004212cdc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212ce1:	c9                   	leaveq 
  8004212ce2:	c3                   	retq   

0000008004212ce3 <_dwarf_frame_interal_table_init>:


int
_dwarf_frame_interal_table_init(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004212ce3:	55                   	push   %rbp
  8004212ce4:	48 89 e5             	mov    %rsp,%rbp
  8004212ce7:	48 83 ec 20          	sub    $0x20,%rsp
  8004212ceb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004212cef:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
        Dwarf_Regtable3 *rt = &global_rt_table;
  8004212cf3:	48 b8 20 c7 63 04 80 	movabs $0x800463c720,%rax
  8004212cfa:	00 00 00 
  8004212cfd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

        if (dbg->dbg_internal_reg_table != NULL)
  8004212d01:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212d05:	48 8b 40 50          	mov    0x50(%rax),%rax
  8004212d09:	48 85 c0             	test   %rax,%rax
  8004212d0c:	74 07                	je     8004212d15 <_dwarf_frame_interal_table_init+0x32>
                return (DW_DLE_NONE);
  8004212d0e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212d13:	eb 33                	jmp    8004212d48 <_dwarf_frame_interal_table_init+0x65>
        /*if ((rt = calloc(1, sizeof(Dwarf_Regtable3))) == NULL) {
                DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
                return (DW_DLE_MEMORY);
        }*/

        rt->rt3_reg_table_size = dbg->dbg_frame_rule_table_size;
  8004212d15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212d19:	0f b7 50 40          	movzwl 0x40(%rax),%edx
  8004212d1d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212d21:	66 89 50 18          	mov    %dx,0x18(%rax)

	//assert(!strcmp(section_info[0].ds_name,".debug_info"));
	//cprintf("Table size:%x\n", rt->rt3_reg_table_size);

	rt->rt3_rules = global_rules;
  8004212d25:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212d29:	48 ba a0 d6 67 04 80 	movabs $0x800467d6a0,%rdx
  8004212d30:	00 00 00 
  8004212d33:	48 89 50 20          	mov    %rdx,0x20(%rax)
                free(rt);
                DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
                return (DW_DLE_MEMORY);
        }*/

        dbg->dbg_internal_reg_table = rt;
  8004212d37:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212d3b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004212d3f:	48 89 50 50          	mov    %rdx,0x50(%rax)

        return (DW_DLE_NONE);
  8004212d43:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212d48:	c9                   	leaveq 
  8004212d49:	c3                   	retq   

0000008004212d4a <_dwarf_get_next_fde>:


static int
_dwarf_get_next_fde(Dwarf_Debug dbg,
                    int eh_frame, Dwarf_Error *error, Dwarf_Fde ret_fde)
{
  8004212d4a:	55                   	push   %rbp
  8004212d4b:	48 89 e5             	mov    %rsp,%rbp
  8004212d4e:	48 83 ec 60          	sub    $0x60,%rsp
  8004212d52:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004212d56:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  8004212d59:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004212d5d:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	Dwarf_Section *ds = &debug_frame_sec; 
  8004212d61:	48 b8 a0 a6 22 04 80 	movabs $0x800422a6a0,%rax
  8004212d68:	00 00 00 
  8004212d6b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint64_t length, offset, cie_id, entry_off;
	int dwarf_size, i, ret=-1;
  8004212d6f:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%rbp)

	offset = dbg->dbg_eh_offset;
  8004212d76:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212d7a:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004212d7e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	if (offset < ds->ds_size) {
  8004212d82:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212d86:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004212d8a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212d8e:	48 39 c2             	cmp    %rax,%rdx
  8004212d91:	0f 86 04 02 00 00    	jbe    8004212f9b <_dwarf_get_next_fde+0x251>
		entry_off = offset;
  8004212d97:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212d9b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		length = dbg->read(ds->ds_data, &offset, 4);
  8004212d9f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212da3:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004212da7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212dab:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212daf:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  8004212db3:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212db8:	48 89 ce             	mov    %rcx,%rsi
  8004212dbb:	48 89 c7             	mov    %rax,%rdi
  8004212dbe:	41 ff d0             	callq  *%r8
  8004212dc1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (length == 0xffffffff) {
  8004212dc5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004212dca:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004212dce:	75 2f                	jne    8004212dff <_dwarf_get_next_fde+0xb5>
			dwarf_size = 8;
  8004212dd0:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
			length = dbg->read(ds->ds_data, &offset, 8);
  8004212dd7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212ddb:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004212ddf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212de3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212de7:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  8004212deb:	ba 08 00 00 00       	mov    $0x8,%edx
  8004212df0:	48 89 ce             	mov    %rcx,%rsi
  8004212df3:	48 89 c7             	mov    %rax,%rdi
  8004212df6:	41 ff d0             	callq  *%r8
  8004212df9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004212dfd:	eb 07                	jmp    8004212e06 <_dwarf_get_next_fde+0xbc>
		} else
			dwarf_size = 4;
  8004212dff:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

		if (length > ds->ds_size - offset ||
  8004212e06:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e0a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004212e0e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212e12:	48 89 d1             	mov    %rdx,%rcx
  8004212e15:	48 29 c1             	sub    %rax,%rcx
  8004212e18:	48 89 c8             	mov    %rcx,%rax
  8004212e1b:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004212e1f:	72 0d                	jb     8004212e2e <_dwarf_get_next_fde+0xe4>
  8004212e21:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004212e26:	75 10                	jne    8004212e38 <_dwarf_get_next_fde+0xee>
		    (length == 0 && !eh_frame)) {
  8004212e28:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004212e2c:	75 0a                	jne    8004212e38 <_dwarf_get_next_fde+0xee>
			DWARF_SET_ERROR(dbg, error,
			    DW_DLE_DEBUG_FRAME_LENGTH_BAD);
			return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004212e2e:	b8 12 00 00 00       	mov    $0x12,%eax
  8004212e33:	e9 68 01 00 00       	jmpq   8004212fa0 <_dwarf_get_next_fde+0x256>
		}

		/* Check terminator for .eh_frame */
		if (eh_frame && length == 0)
  8004212e38:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004212e3c:	74 11                	je     8004212e4f <_dwarf_get_next_fde+0x105>
  8004212e3e:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004212e43:	75 0a                	jne    8004212e4f <_dwarf_get_next_fde+0x105>
			return(-1);
  8004212e45:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004212e4a:	e9 51 01 00 00       	jmpq   8004212fa0 <_dwarf_get_next_fde+0x256>

		cie_id = dbg->read(ds->ds_data, &offset, dwarf_size);
  8004212e4f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212e53:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004212e57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212e5b:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212e5f:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004212e62:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  8004212e66:	48 89 ce             	mov    %rcx,%rsi
  8004212e69:	48 89 c7             	mov    %rax,%rdi
  8004212e6c:	41 ff d0             	callq  *%r8
  8004212e6f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

		if (eh_frame) {
  8004212e73:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004212e77:	74 79                	je     8004212ef2 <_dwarf_get_next_fde+0x1a8>
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
  8004212e79:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004212e7e:	75 32                	jne    8004212eb2 <_dwarf_get_next_fde+0x168>
				ret = _dwarf_frame_set_cie(dbg, ds,
				    &entry_off, ret_fde->fde_cie, error);
  8004212e80:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
		cie_id = dbg->read(ds->ds_data, &offset, dwarf_size);

		if (eh_frame) {
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
				ret = _dwarf_frame_set_cie(dbg, ds,
  8004212e84:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004212e88:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
				    &entry_off, ret_fde->fde_cie, error);
  8004212e8c:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
		cie_id = dbg->read(ds->ds_data, &offset, dwarf_size);

		if (eh_frame) {
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
				ret = _dwarf_frame_set_cie(dbg, ds,
  8004212e90:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8004212e94:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212e98:	49 89 f8             	mov    %rdi,%r8
  8004212e9b:	48 89 c7             	mov    %rax,%rdi
  8004212e9e:	48 b8 b4 24 21 04 80 	movabs $0x80042124b4,%rax
  8004212ea5:	00 00 00 
  8004212ea8:	ff d0                	callq  *%rax
  8004212eaa:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004212ead:	e9 c8 00 00 00       	jmpq   8004212f7a <_dwarf_get_next_fde+0x230>
				    &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg,ret_fde, ds,
				    &entry_off, 1, ret_fde->fde_cie, error);
  8004212eb2:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
				ret = _dwarf_frame_set_cie(dbg, ds,
				    &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg,ret_fde, ds,
  8004212eb6:	4c 8b 40 08          	mov    0x8(%rax),%r8
				    &entry_off, 1, ret_fde->fde_cie, error);
  8004212eba:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
				ret = _dwarf_frame_set_cie(dbg, ds,
				    &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg,ret_fde, ds,
  8004212ebe:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212ec2:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004212ec6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212eca:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004212ece:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004212ed2:	4d 89 c1             	mov    %r8,%r9
  8004212ed5:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8004212edb:	48 89 c7             	mov    %rax,%rdi
  8004212ede:	48 b8 25 29 21 04 80 	movabs $0x8004212925,%rax
  8004212ee5:	00 00 00 
  8004212ee8:	ff d0                	callq  *%rax
  8004212eea:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004212eed:	e9 88 00 00 00       	jmpq   8004212f7a <_dwarf_get_next_fde+0x230>
				    &entry_off, 1, ret_fde->fde_cie, error);
		} else {
			/* .dwarf_frame use CIE id ~0 */
			if ((dwarf_size == 4 && cie_id == ~0U) ||
  8004212ef2:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004212ef6:	75 0b                	jne    8004212f03 <_dwarf_get_next_fde+0x1b9>
  8004212ef8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004212efd:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004212f01:	74 0d                	je     8004212f10 <_dwarf_get_next_fde+0x1c6>
  8004212f03:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  8004212f07:	75 36                	jne    8004212f3f <_dwarf_get_next_fde+0x1f5>
			    (dwarf_size == 8 && cie_id == ~0ULL))
  8004212f09:	48 83 7d e0 ff       	cmpq   $0xffffffffffffffff,-0x20(%rbp)
  8004212f0e:	75 2f                	jne    8004212f3f <_dwarf_get_next_fde+0x1f5>
				ret = _dwarf_frame_set_cie(dbg, ds,
				    &entry_off, ret_fde->fde_cie, error);
  8004212f10:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
				    &entry_off, 1, ret_fde->fde_cie, error);
		} else {
			/* .dwarf_frame use CIE id ~0 */
			if ((dwarf_size == 4 && cie_id == ~0U) ||
			    (dwarf_size == 8 && cie_id == ~0ULL))
				ret = _dwarf_frame_set_cie(dbg, ds,
  8004212f14:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004212f18:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
				    &entry_off, ret_fde->fde_cie, error);
  8004212f1c:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
				    &entry_off, 1, ret_fde->fde_cie, error);
		} else {
			/* .dwarf_frame use CIE id ~0 */
			if ((dwarf_size == 4 && cie_id == ~0U) ||
			    (dwarf_size == 8 && cie_id == ~0ULL))
				ret = _dwarf_frame_set_cie(dbg, ds,
  8004212f20:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8004212f24:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212f28:	49 89 f8             	mov    %rdi,%r8
  8004212f2b:	48 89 c7             	mov    %rax,%rdi
  8004212f2e:	48 b8 b4 24 21 04 80 	movabs $0x80042124b4,%rax
  8004212f35:	00 00 00 
  8004212f38:	ff d0                	callq  *%rax
  8004212f3a:	89 45 f0             	mov    %eax,-0x10(%rbp)
  8004212f3d:	eb 3b                	jmp    8004212f7a <_dwarf_get_next_fde+0x230>
				    &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde, ds,
				    &entry_off, 0, ret_fde->fde_cie, error);
  8004212f3f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
			if ((dwarf_size == 4 && cie_id == ~0U) ||
			    (dwarf_size == 8 && cie_id == ~0ULL))
				ret = _dwarf_frame_set_cie(dbg, ds,
				    &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde, ds,
  8004212f43:	4c 8b 40 08          	mov    0x8(%rax),%r8
				    &entry_off, 0, ret_fde->fde_cie, error);
  8004212f47:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
			if ((dwarf_size == 4 && cie_id == ~0U) ||
			    (dwarf_size == 8 && cie_id == ~0ULL))
				ret = _dwarf_frame_set_cie(dbg, ds,
				    &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde, ds,
  8004212f4b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004212f4f:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004212f53:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212f57:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004212f5b:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004212f5f:	4d 89 c1             	mov    %r8,%r9
  8004212f62:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8004212f68:	48 89 c7             	mov    %rax,%rdi
  8004212f6b:	48 b8 25 29 21 04 80 	movabs $0x8004212925,%rax
  8004212f72:	00 00 00 
  8004212f75:	ff d0                	callq  *%rax
  8004212f77:	89 45 f0             	mov    %eax,-0x10(%rbp)
				    &entry_off, 0, ret_fde->fde_cie, error);
		}

		if (ret != DW_DLE_NONE)
  8004212f7a:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  8004212f7e:	74 07                	je     8004212f87 <_dwarf_get_next_fde+0x23d>
			return(-1);
  8004212f80:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004212f85:	eb 19                	jmp    8004212fa0 <_dwarf_get_next_fde+0x256>

		offset = entry_off;
  8004212f87:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212f8b:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		dbg->dbg_eh_offset = offset;
  8004212f8f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004212f93:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212f97:	48 89 50 30          	mov    %rdx,0x30(%rax)
	}

	return (0);
  8004212f9b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212fa0:	c9                   	leaveq 
  8004212fa1:	c3                   	retq   

0000008004212fa2 <dwarf_set_frame_cfa_value>:


Dwarf_Half
dwarf_set_frame_cfa_value(Dwarf_Debug dbg, Dwarf_Half value)
{
  8004212fa2:	55                   	push   %rbp
  8004212fa3:	48 89 e5             	mov    %rsp,%rbp
  8004212fa6:	48 83 ec 20          	sub    $0x20,%rsp
  8004212faa:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004212fae:	89 f0                	mov    %esi,%eax
  8004212fb0:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
        Dwarf_Half old_value;

        old_value = dbg->dbg_frame_cfa_value;
  8004212fb4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212fb8:	0f b7 40 44          	movzwl 0x44(%rax),%eax
  8004212fbc:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
        dbg->dbg_frame_cfa_value = value;
  8004212fc0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212fc4:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  8004212fc8:	66 89 50 44          	mov    %dx,0x44(%rax)

        return (old_value);
  8004212fcc:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
}
  8004212fd0:	c9                   	leaveq 
  8004212fd1:	c3                   	retq   

0000008004212fd2 <_dwarf_frame_section_load_eh>:

int
_dwarf_frame_section_load_eh(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004212fd2:	55                   	push   %rbp
  8004212fd3:	48 89 e5             	mov    %rsp,%rbp
  8004212fd6:	48 83 ec 20          	sub    $0x20,%rsp
  8004212fda:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004212fde:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int status;
	Dwarf_Section *ds = &debug_frame_sec;
  8004212fe2:	48 b8 a0 a6 22 04 80 	movabs $0x800422a6a0,%rax
  8004212fe9:	00 00 00 
  8004212fec:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        status  = _dwarf_find_section_enhanced(&debug_frame_sec);
  8004212ff0:	48 bf a0 a6 22 04 80 	movabs $0x800422a6a0,%rdi
  8004212ff7:	00 00 00 
  8004212ffa:	48 b8 3f 0a 21 04 80 	movabs $0x8004210a3f,%rax
  8004213001:	00 00 00 
  8004213004:	ff d0                	callq  *%rax
  8004213006:	89 45 f4             	mov    %eax,-0xc(%rbp)
        return (DW_DLE_NONE);
  8004213009:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421300e:	c9                   	leaveq 
  800421300f:	c3                   	retq   

0000008004213010 <dwarf_init_eh_section>:


int
dwarf_init_eh_section(Dwarf_Debug dbg,
                      Dwarf_Error *error)
{
  8004213010:	55                   	push   %rbp
  8004213011:	48 89 e5             	mov    %rsp,%rbp
  8004213014:	48 83 ec 10          	sub    $0x10,%rsp
  8004213018:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800421301c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)

        if (dbg == NULL) {
  8004213020:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004213025:	75 07                	jne    800421302e <dwarf_init_eh_section+0x1e>
                DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
                return (DW_DLV_ERROR);
  8004213027:	b8 01 00 00 00       	mov    $0x1,%eax
  800421302c:	eb 7e                	jmp    80042130ac <dwarf_init_eh_section+0x9c>
        }

        if (dbg->dbg_internal_reg_table == NULL) {
  800421302e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213032:	48 8b 40 50          	mov    0x50(%rax),%rax
  8004213036:	48 85 c0             	test   %rax,%rax
  8004213039:	75 25                	jne    8004213060 <dwarf_init_eh_section+0x50>
                if (_dwarf_frame_interal_table_init(dbg, error) != DW_DLE_NONE)
  800421303b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421303f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213043:	48 89 d6             	mov    %rdx,%rsi
  8004213046:	48 89 c7             	mov    %rax,%rdi
  8004213049:	48 b8 e3 2c 21 04 80 	movabs $0x8004212ce3,%rax
  8004213050:	00 00 00 
  8004213053:	ff d0                	callq  *%rax
  8004213055:	85 c0                	test   %eax,%eax
  8004213057:	74 07                	je     8004213060 <dwarf_init_eh_section+0x50>
                        return (DW_DLV_ERROR);
  8004213059:	b8 01 00 00 00       	mov    $0x1,%eax
  800421305e:	eb 4c                	jmp    80042130ac <dwarf_init_eh_section+0x9c>
	}

	if (_dwarf_frame_section_load_eh(dbg, error) != DW_DLE_NONE)
  8004213060:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004213064:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213068:	48 89 d6             	mov    %rdx,%rsi
  800421306b:	48 89 c7             	mov    %rax,%rdi
  800421306e:	48 b8 d2 2f 21 04 80 	movabs $0x8004212fd2,%rax
  8004213075:	00 00 00 
  8004213078:	ff d0                	callq  *%rax
  800421307a:	85 c0                	test   %eax,%eax
  800421307c:	74 07                	je     8004213085 <dwarf_init_eh_section+0x75>
		return (DW_DLV_ERROR);
  800421307e:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213083:	eb 27                	jmp    80042130ac <dwarf_init_eh_section+0x9c>

	dbg->dbg_eh_size = debug_frame_sec.ds_size;
  8004213085:	48 b8 a0 a6 22 04 80 	movabs $0x800422a6a0,%rax
  800421308c:	00 00 00 
  800421308f:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004213093:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213097:	48 89 50 38          	mov    %rdx,0x38(%rax)
	dbg->dbg_eh_offset = 0;
  800421309b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421309f:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  80042130a6:	00 

    return (DW_DLV_OK);
  80042130a7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042130ac:	c9                   	leaveq 
  80042130ad:	c3                   	retq   
	...

00000080042130b0 <_dwarf_lineno_run_program>:


static int
_dwarf_lineno_run_program(Dwarf_CU *cu, Dwarf_LineInfo li, uint8_t *p,
    uint8_t *pe, Dwarf_Addr pc, Dwarf_Error *error)
{
  80042130b0:	55                   	push   %rbp
  80042130b1:	48 89 e5             	mov    %rsp,%rbp
  80042130b4:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  80042130bb:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  80042130bf:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  80042130c3:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  80042130c7:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  80042130cb:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  80042130d2:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
    uint64_t address, file, line, column, isa, opsize;
    int is_stmt, basic_block, end_sequence;
    int prologue_end, epilogue_begin;
    int ret;

	ln = &li->li_line;
  80042130d9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042130dd:	48 83 c0 48          	add    $0x48,%rax
  80042130e1:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

    /*
     *   ln->ln_li     = li;             \
     * Set registers to their default values.
     */
    RESET_REGISTERS;
  80042130e5:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042130ec:	00 
  80042130ed:	48 c7 45 f0 01 00 00 	movq   $0x1,-0x10(%rbp)
  80042130f4:	00 
  80042130f5:	48 c7 45 e8 01 00 00 	movq   $0x1,-0x18(%rbp)
  80042130fc:	00 
  80042130fd:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004213104:	00 
  8004213105:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213109:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  800421310d:	0f b6 c0             	movzbl %al,%eax
  8004213110:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004213113:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
  800421311a:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  8004213121:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  8004213128:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)

    /*
     * Start line number program.
     */
    while (p < pe) {
  800421312f:	e9 cf 04 00 00       	jmpq   8004213603 <_dwarf_lineno_run_program+0x553>
        if (*p == 0) {
  8004213134:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004213138:	0f b6 00             	movzbl (%rax),%eax
  800421313b:	84 c0                	test   %al,%al
  800421313d:	0f 85 47 01 00 00    	jne    800421328a <_dwarf_lineno_run_program+0x1da>

            /*
             * Extended Opcodes.
             */

            p++;
  8004213143:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004213147:	48 83 c0 01          	add    $0x1,%rax
  800421314b:	48 89 45 88          	mov    %rax,-0x78(%rbp)
            opsize = _dwarf_decode_uleb128(&p);
  800421314f:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  8004213153:	48 89 c7             	mov    %rax,%rdi
  8004213156:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  800421315d:	00 00 00 
  8004213160:	ff d0                	callq  *%rax
  8004213162:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
            switch (*p) {
  8004213166:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421316a:	0f b6 00             	movzbl (%rax),%eax
  800421316d:	0f b6 c0             	movzbl %al,%eax
  8004213170:	83 f8 02             	cmp    $0x2,%eax
  8004213173:	74 74                	je     80042131e9 <_dwarf_lineno_run_program+0x139>
  8004213175:	83 f8 03             	cmp    $0x3,%eax
  8004213178:	0f 84 a7 00 00 00    	je     8004213225 <_dwarf_lineno_run_program+0x175>
  800421317e:	83 f8 01             	cmp    $0x1,%eax
  8004213181:	0f 85 f2 00 00 00    	jne    8004213279 <_dwarf_lineno_run_program+0x1c9>
            case DW_LNE_end_sequence:
                p++;
  8004213187:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421318b:	48 83 c0 01          	add    $0x1,%rax
  800421318f:	48 89 45 88          	mov    %rax,-0x78(%rbp)
                end_sequence = 1;
  8004213193:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
                RESET_REGISTERS;
  800421319a:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042131a1:	00 
  80042131a2:	48 c7 45 f0 01 00 00 	movq   $0x1,-0x10(%rbp)
  80042131a9:	00 
  80042131aa:	48 c7 45 e8 01 00 00 	movq   $0x1,-0x18(%rbp)
  80042131b1:	00 
  80042131b2:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  80042131b9:	00 
  80042131ba:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042131be:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  80042131c2:	0f b6 c0             	movzbl %al,%eax
  80042131c5:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042131c8:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
  80042131cf:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
  80042131d6:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  80042131dd:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)
                break;
  80042131e4:	e9 1a 04 00 00       	jmpq   8004213603 <_dwarf_lineno_run_program+0x553>
            case DW_LNE_set_address:
                p++;
  80042131e9:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042131ed:	48 83 c0 01          	add    $0x1,%rax
  80042131f1:	48 89 45 88          	mov    %rax,-0x78(%rbp)
                address = dbg->decode(&p, cu->addr_size);
  80042131f5:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  80042131fc:	00 00 00 
  80042131ff:	48 8b 00             	mov    (%rax),%rax
  8004213202:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213206:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421320a:	0f b6 40 0a          	movzbl 0xa(%rax),%eax
  800421320e:	0f b6 d0             	movzbl %al,%edx
  8004213211:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  8004213215:	89 d6                	mov    %edx,%esi
  8004213217:	48 89 c7             	mov    %rax,%rdi
  800421321a:	ff d1                	callq  *%rcx
  800421321c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                break;
  8004213220:	e9 de 03 00 00       	jmpq   8004213603 <_dwarf_lineno_run_program+0x553>
            case DW_LNE_define_file:
                p++;
  8004213225:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004213229:	48 83 c0 01          	add    $0x1,%rax
  800421322d:	48 89 45 88          	mov    %rax,-0x78(%rbp)
                ret = _dwarf_lineno_add_file(li, &p, NULL,
  8004213231:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  8004213238:	00 00 00 
  800421323b:	48 8b 08             	mov    (%rax),%rcx
  800421323e:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004213245:	48 8d 75 88          	lea    -0x78(%rbp),%rsi
  8004213249:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421324d:	49 89 c8             	mov    %rcx,%r8
  8004213250:	48 89 d1             	mov    %rdx,%rcx
  8004213253:	ba 00 00 00 00       	mov    $0x0,%edx
  8004213258:	48 89 c7             	mov    %rax,%rdi
  800421325b:	48 b8 1d 36 21 04 80 	movabs $0x800421361d,%rax
  8004213262:	00 00 00 
  8004213265:	ff d0                	callq  *%rax
  8004213267:	89 45 b4             	mov    %eax,-0x4c(%rbp)
                    error, dbg);
                if (ret != DW_DLE_NONE)
  800421326a:	83 7d b4 00          	cmpl   $0x0,-0x4c(%rbp)
  800421326e:	0f 84 8e 03 00 00    	je     8004213602 <_dwarf_lineno_run_program+0x552>
                    goto prog_fail;
  8004213274:	e9 9f 03 00 00       	jmpq   8004213618 <_dwarf_lineno_run_program+0x568>
                break;
            default:
                /* Unrecognized extened opcodes. */
                p += opsize;
  8004213279:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421327d:	48 03 45 b8          	add    -0x48(%rbp),%rax
  8004213281:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004213285:	e9 79 03 00 00       	jmpq   8004213603 <_dwarf_lineno_run_program+0x553>
            }

        } else if (*p > 0 && *p < li->li_opbase) {
  800421328a:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421328e:	0f b6 00             	movzbl (%rax),%eax
  8004213291:	84 c0                	test   %al,%al
  8004213293:	0f 84 2f 02 00 00    	je     80042134c8 <_dwarf_lineno_run_program+0x418>
  8004213299:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421329d:	0f b6 10             	movzbl (%rax),%edx
  80042132a0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042132a4:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042132a8:	38 c2                	cmp    %al,%dl
  80042132aa:	0f 83 18 02 00 00    	jae    80042134c8 <_dwarf_lineno_run_program+0x418>

            /*
             * Standard Opcodes.
             */

            switch (*p++) {
  80042132b0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042132b4:	0f b6 10             	movzbl (%rax),%edx
  80042132b7:	0f b6 d2             	movzbl %dl,%edx
  80042132ba:	48 83 c0 01          	add    $0x1,%rax
  80042132be:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  80042132c2:	83 fa 0c             	cmp    $0xc,%edx
  80042132c5:	0f 87 f7 01 00 00    	ja     80042134c2 <_dwarf_lineno_run_program+0x412>
  80042132cb:	89 d0                	mov    %edx,%eax
  80042132cd:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042132d4:	00 
  80042132d5:	48 b8 88 94 21 04 80 	movabs $0x8004219488,%rax
  80042132dc:	00 00 00 
  80042132df:	48 01 d0             	add    %rdx,%rax
  80042132e2:	48 8b 00             	mov    (%rax),%rax
  80042132e5:	ff e0                	jmpq   *%rax
            case DW_LNS_copy:
                APPEND_ROW;
  80042132e7:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042132ee:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042132f2:	73 0a                	jae    80042132fe <_dwarf_lineno_run_program+0x24e>
  80042132f4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042132f9:	e9 1d 03 00 00       	jmpq   800421361b <_dwarf_lineno_run_program+0x56b>
  80042132fe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213302:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213306:	48 89 10             	mov    %rdx,(%rax)
  8004213309:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421330d:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004213314:	00 
  8004213315:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213319:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421331d:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004213321:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213325:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213329:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800421332d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213331:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213335:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004213339:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421333d:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8004213340:	89 50 28             	mov    %edx,0x28(%rax)
  8004213343:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213347:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800421334a:	89 50 2c             	mov    %edx,0x2c(%rax)
  800421334d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213351:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004213354:	89 50 30             	mov    %edx,0x30(%rax)
  8004213357:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421335b:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004213362:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004213366:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421336a:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
                basic_block = 0;
  8004213371:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
                prologue_end = 0;
  8004213378:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
                epilogue_begin = 0;
  800421337f:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)
                break;
  8004213386:	e9 38 01 00 00       	jmpq   80042134c3 <_dwarf_lineno_run_program+0x413>
            case DW_LNS_advance_pc:
                address += _dwarf_decode_uleb128(&p) *
  800421338b:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  800421338f:	48 89 c7             	mov    %rax,%rdi
  8004213392:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  8004213399:	00 00 00 
  800421339c:	ff d0                	callq  *%rax
                    li->li_minlen;
  800421339e:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80042133a2:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
                basic_block = 0;
                prologue_end = 0;
                epilogue_begin = 0;
                break;
            case DW_LNS_advance_pc:
                address += _dwarf_decode_uleb128(&p) *
  80042133a6:	0f b6 d2             	movzbl %dl,%edx
  80042133a9:	48 0f af c2          	imul   %rdx,%rax
  80042133ad:	48 01 45 f8          	add    %rax,-0x8(%rbp)
                    li->li_minlen;
                break;
  80042133b1:	e9 0d 01 00 00       	jmpq   80042134c3 <_dwarf_lineno_run_program+0x413>
            case DW_LNS_advance_line:
                line += _dwarf_decode_sleb128(&p);
  80042133b6:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  80042133ba:	48 89 c7             	mov    %rax,%rdi
  80042133bd:	48 b8 e1 f1 20 04 80 	movabs $0x800420f1e1,%rax
  80042133c4:	00 00 00 
  80042133c7:	ff d0                	callq  *%rax
  80042133c9:	48 01 45 e8          	add    %rax,-0x18(%rbp)
                break;
  80042133cd:	e9 f1 00 00 00       	jmpq   80042134c3 <_dwarf_lineno_run_program+0x413>
            case DW_LNS_set_file:
                file = _dwarf_decode_uleb128(&p);
  80042133d2:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  80042133d6:	48 89 c7             	mov    %rax,%rdi
  80042133d9:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  80042133e0:	00 00 00 
  80042133e3:	ff d0                	callq  *%rax
  80042133e5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
                break;
  80042133e9:	e9 d5 00 00 00       	jmpq   80042134c3 <_dwarf_lineno_run_program+0x413>
            case DW_LNS_set_column:
                column = _dwarf_decode_uleb128(&p);
  80042133ee:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  80042133f2:	48 89 c7             	mov    %rax,%rdi
  80042133f5:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  80042133fc:	00 00 00 
  80042133ff:	ff d0                	callq  *%rax
  8004213401:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
                break;
  8004213405:	e9 b9 00 00 00       	jmpq   80042134c3 <_dwarf_lineno_run_program+0x413>
            case DW_LNS_negate_stmt:
                is_stmt = !is_stmt;
  800421340a:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800421340e:	0f 94 c0             	sete   %al
  8004213411:	0f b6 c0             	movzbl %al,%eax
  8004213414:	89 45 dc             	mov    %eax,-0x24(%rbp)
                break;
  8004213417:	e9 a7 00 00 00       	jmpq   80042134c3 <_dwarf_lineno_run_program+0x413>
            case DW_LNS_set_basic_block:
                basic_block = 1;
  800421341c:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%rbp)
                break;
  8004213423:	e9 9b 00 00 00       	jmpq   80042134c3 <_dwarf_lineno_run_program+0x413>
            case DW_LNS_const_add_pc:
                address += ADDRESS(255);
  8004213428:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421342c:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004213430:	0f b6 c0             	movzbl %al,%eax
  8004213433:	ba ff 00 00 00       	mov    $0xff,%edx
  8004213438:	89 d1                	mov    %edx,%ecx
  800421343a:	29 c1                	sub    %eax,%ecx
  800421343c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213440:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004213444:	0f b6 c0             	movzbl %al,%eax
  8004213447:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
  800421344d:	89 c8                	mov    %ecx,%eax
  800421344f:	89 c2                	mov    %eax,%edx
  8004213451:	c1 fa 1f             	sar    $0x1f,%edx
  8004213454:	f7 bd 6c ff ff ff    	idivl  -0x94(%rbp)
  800421345a:	89 c2                	mov    %eax,%edx
  800421345c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213460:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8004213464:	0f b6 c0             	movzbl %al,%eax
  8004213467:	0f af c2             	imul   %edx,%eax
  800421346a:	48 98                	cltq   
  800421346c:	48 01 45 f8          	add    %rax,-0x8(%rbp)
                break;
  8004213470:	eb 51                	jmp    80042134c3 <_dwarf_lineno_run_program+0x413>
            case DW_LNS_fixed_advance_pc:
                address += dbg->decode(&p, 2);
  8004213472:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  8004213479:	00 00 00 
  800421347c:	48 8b 00             	mov    (%rax),%rax
  800421347f:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004213483:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  8004213487:	be 02 00 00 00       	mov    $0x2,%esi
  800421348c:	48 89 c7             	mov    %rax,%rdi
  800421348f:	ff d2                	callq  *%rdx
  8004213491:	48 01 45 f8          	add    %rax,-0x8(%rbp)
                break;
  8004213495:	eb 2c                	jmp    80042134c3 <_dwarf_lineno_run_program+0x413>
            case DW_LNS_set_prologue_end:
                prologue_end = 1;
  8004213497:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%rbp)
                break;
  800421349e:	eb 23                	jmp    80042134c3 <_dwarf_lineno_run_program+0x413>
            case DW_LNS_set_epilogue_begin:
                epilogue_begin = 1;
  80042134a0:	c7 45 c0 01 00 00 00 	movl   $0x1,-0x40(%rbp)
                break;
  80042134a7:	eb 1a                	jmp    80042134c3 <_dwarf_lineno_run_program+0x413>
            case DW_LNS_set_isa:
                isa = _dwarf_decode_uleb128(&p);
  80042134a9:	48 8d 45 88          	lea    -0x78(%rbp),%rax
  80042134ad:	48 89 c7             	mov    %rax,%rdi
  80042134b0:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  80042134b7:	00 00 00 
  80042134ba:	ff d0                	callq  *%rax
  80042134bc:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                break;
  80042134c0:	eb 01                	jmp    80042134c3 <_dwarf_lineno_run_program+0x413>
            default:
                /* Unrecognized extened opcodes. What to do? */
                break;
  80042134c2:	90                   	nop
            }

        } else {
  80042134c3:	e9 3b 01 00 00       	jmpq   8004213603 <_dwarf_lineno_run_program+0x553>

            /*
             * Special Opcodes.
             */

            line += LINE(*p);
  80042134c8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042134cc:	0f b6 40 1a          	movzbl 0x1a(%rax),%eax
  80042134d0:	0f be c8             	movsbl %al,%ecx
  80042134d3:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042134d7:	0f b6 00             	movzbl (%rax),%eax
  80042134da:	0f b6 d0             	movzbl %al,%edx
  80042134dd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042134e1:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042134e5:	0f b6 c0             	movzbl %al,%eax
  80042134e8:	29 c2                	sub    %eax,%edx
  80042134ea:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042134ee:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  80042134f2:	0f b6 f0             	movzbl %al,%esi
  80042134f5:	89 d0                	mov    %edx,%eax
  80042134f7:	89 c2                	mov    %eax,%edx
  80042134f9:	c1 fa 1f             	sar    $0x1f,%edx
  80042134fc:	f7 fe                	idiv   %esi
  80042134fe:	89 d0                	mov    %edx,%eax
  8004213500:	01 c8                	add    %ecx,%eax
  8004213502:	48 98                	cltq   
  8004213504:	48 01 45 e8          	add    %rax,-0x18(%rbp)
            address += ADDRESS(*p);
  8004213508:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421350c:	0f b6 00             	movzbl (%rax),%eax
  800421350f:	0f b6 d0             	movzbl %al,%edx
  8004213512:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213516:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  800421351a:	0f b6 c0             	movzbl %al,%eax
  800421351d:	89 d1                	mov    %edx,%ecx
  800421351f:	29 c1                	sub    %eax,%ecx
  8004213521:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213525:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  8004213529:	0f b6 c0             	movzbl %al,%eax
  800421352c:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
  8004213532:	89 c8                	mov    %ecx,%eax
  8004213534:	89 c2                	mov    %eax,%edx
  8004213536:	c1 fa 1f             	sar    $0x1f,%edx
  8004213539:	f7 bd 6c ff ff ff    	idivl  -0x94(%rbp)
  800421353f:	89 c2                	mov    %eax,%edx
  8004213541:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213545:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8004213549:	0f b6 c0             	movzbl %al,%eax
  800421354c:	0f af c2             	imul   %edx,%eax
  800421354f:	48 98                	cltq   
  8004213551:	48 01 45 f8          	add    %rax,-0x8(%rbp)
            APPEND_ROW;
  8004213555:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421355c:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004213560:	73 0a                	jae    800421356c <_dwarf_lineno_run_program+0x4bc>
  8004213562:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213567:	e9 af 00 00 00       	jmpq   800421361b <_dwarf_lineno_run_program+0x56b>
  800421356c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213570:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213574:	48 89 10             	mov    %rdx,(%rax)
  8004213577:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421357b:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004213582:	00 
  8004213583:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213587:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421358b:	48 89 50 10          	mov    %rdx,0x10(%rax)
  800421358f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213593:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213597:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800421359b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421359f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042135a3:	48 89 50 20          	mov    %rdx,0x20(%rax)
  80042135a7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042135ab:	8b 55 d8             	mov    -0x28(%rbp),%edx
  80042135ae:	89 50 28             	mov    %edx,0x28(%rax)
  80042135b1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042135b5:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042135b8:	89 50 2c             	mov    %edx,0x2c(%rax)
  80042135bb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042135bf:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042135c2:	89 50 30             	mov    %edx,0x30(%rax)
  80042135c5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042135c9:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  80042135d0:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042135d4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042135d8:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
            basic_block = 0;
  80042135df:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
            prologue_end = 0;
  80042135e6:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
            epilogue_begin = 0;
  80042135ed:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)
            p++;
  80042135f4:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042135f8:	48 83 c0 01          	add    $0x1,%rax
  80042135fc:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004213600:	eb 01                	jmp    8004213603 <_dwarf_lineno_run_program+0x553>
                p++;
                ret = _dwarf_lineno_add_file(li, &p, NULL,
                    error, dbg);
                if (ret != DW_DLE_NONE)
                    goto prog_fail;
                break;
  8004213602:	90                   	nop
    RESET_REGISTERS;

    /*
     * Start line number program.
     */
    while (p < pe) {
  8004213603:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004213607:	48 3b 45 80          	cmp    -0x80(%rbp),%rax
  800421360b:	0f 82 23 fb ff ff    	jb     8004213134 <_dwarf_lineno_run_program+0x84>
            epilogue_begin = 0;
            p++;
        }
    }

    return (DW_DLE_NONE);
  8004213611:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213616:	eb 03                	jmp    800421361b <_dwarf_lineno_run_program+0x56b>

prog_fail:

    return (ret);
  8004213618:	8b 45 b4             	mov    -0x4c(%rbp),%eax

#undef  RESET_REGISTERS
#undef  APPEND_ROW
#undef  LINE
#undef  ADDRESS
}
  800421361b:	c9                   	leaveq 
  800421361c:	c3                   	retq   

000000800421361d <_dwarf_lineno_add_file>:

static int
_dwarf_lineno_add_file(Dwarf_LineInfo li, uint8_t **p, const char *compdir,
    Dwarf_Error *error, Dwarf_Debug dbg)
{
  800421361d:	55                   	push   %rbp
  800421361e:	48 89 e5             	mov    %rsp,%rbp
  8004213621:	53                   	push   %rbx
  8004213622:	48 83 ec 48          	sub    $0x48,%rsp
  8004213626:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800421362a:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800421362e:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004213632:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8004213636:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
    char *fname;
    //const char *dirname;
    uint8_t *src;
    int slen;

    src = *p;
  800421363a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421363e:	48 8b 00             	mov    (%rax),%rax
  8004213641:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
        return (DW_DLE_MEMORY);
    }
*/  
    //lf->lf_fullpath = NULL;
    fname = (char *) src;
  8004213645:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213649:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    src += strlen(fname) + 1;
  800421364d:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  8004213651:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213655:	48 89 c7             	mov    %rax,%rdi
  8004213658:	48 b8 50 e3 20 04 80 	movabs $0x800420e350,%rax
  800421365f:	00 00 00 
  8004213662:	ff d0                	callq  *%rax
  8004213664:	48 98                	cltq   
  8004213666:	48 83 c0 01          	add    $0x1,%rax
  800421366a:	48 01 d8             	add    %rbx,%rax
  800421366d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    _dwarf_decode_uleb128(&src);
  8004213671:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004213675:	48 89 c7             	mov    %rax,%rdi
  8004213678:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  800421367f:	00 00 00 
  8004213682:	ff d0                	callq  *%rax
            snprintf(lf->lf_fullpath, slen, "%s/%s", dirname,
                lf->lf_fname);
        }
    }
*/
    _dwarf_decode_uleb128(&src);
  8004213684:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004213688:	48 89 c7             	mov    %rax,%rdi
  800421368b:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  8004213692:	00 00 00 
  8004213695:	ff d0                	callq  *%rax
    _dwarf_decode_uleb128(&src);
  8004213697:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800421369b:	48 89 c7             	mov    %rax,%rdi
  800421369e:	48 b8 7a f2 20 04 80 	movabs $0x800420f27a,%rax
  80042136a5:	00 00 00 
  80042136a8:	ff d0                	callq  *%rax
    //STAILQ_INSERT_TAIL(&li->li_lflist, lf, lf_next);
    //li->li_lflen++;

    *p = src;
  80042136aa:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042136ae:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042136b2:	48 89 10             	mov    %rdx,(%rax)

    return (DW_DLE_NONE);
  80042136b5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042136ba:	48 83 c4 48          	add    $0x48,%rsp
  80042136be:	5b                   	pop    %rbx
  80042136bf:	5d                   	pop    %rbp
  80042136c0:	c3                   	retq   

00000080042136c1 <_dwarf_lineno_init>:

int     
_dwarf_lineno_init(Dwarf_Die *die, uint64_t offset, Dwarf_LineInfo linfo, Dwarf_Addr pc, Dwarf_Error *error)
{   
  80042136c1:	55                   	push   %rbp
  80042136c2:	48 89 e5             	mov    %rsp,%rbp
  80042136c5:	53                   	push   %rbx
  80042136c6:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
  80042136cd:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  80042136d4:	48 89 b5 10 ff ff ff 	mov    %rsi,-0xf0(%rbp)
  80042136db:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
  80042136e2:	48 89 8d 00 ff ff ff 	mov    %rcx,-0x100(%rbp)
  80042136e9:	4c 89 85 f8 fe ff ff 	mov    %r8,-0x108(%rbp)
    Dwarf_Section myds = {.ds_name = ".debug_line"};
  80042136f0:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  80042136f7:	00 
  80042136f8:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
  80042136ff:	00 
  8004213700:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  8004213707:	00 
  8004213708:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  800421370f:	00 
  8004213710:	48 b8 f0 94 21 04 80 	movabs $0x80042194f0,%rax
  8004213717:	00 00 00 
  800421371a:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	Dwarf_Section *ds = &myds;
  800421371e:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  8004213722:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    //Dwarf_LineFile lf, tlf;
    uint64_t length, hdroff, endoff;
    uint8_t *p;
    int dwarf_size, i, ret;
            
    cu = die->cu_header;
  8004213726:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  800421372d:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  8004213734:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    assert(cu != NULL); 
  8004213738:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800421373d:	75 35                	jne    8004213774 <_dwarf_lineno_init+0xb3>
  800421373f:	48 b9 fc 94 21 04 80 	movabs $0x80042194fc,%rcx
  8004213746:	00 00 00 
  8004213749:	48 ba 07 95 21 04 80 	movabs $0x8004219507,%rdx
  8004213750:	00 00 00 
  8004213753:	be 17 01 00 00       	mov    $0x117,%esi
  8004213758:	48 bf 1c 95 21 04 80 	movabs $0x800421951c,%rdi
  800421375f:	00 00 00 
  8004213762:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213767:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800421376e:	00 00 00 
  8004213771:	41 ff d0             	callq  *%r8
    assert(dbg != NULL);
  8004213774:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  800421377b:	00 00 00 
  800421377e:	48 8b 00             	mov    (%rax),%rax
  8004213781:	48 85 c0             	test   %rax,%rax
  8004213784:	75 35                	jne    80042137bb <_dwarf_lineno_init+0xfa>
  8004213786:	48 b9 33 95 21 04 80 	movabs $0x8004219533,%rcx
  800421378d:	00 00 00 
  8004213790:	48 ba 07 95 21 04 80 	movabs $0x8004219507,%rdx
  8004213797:	00 00 00 
  800421379a:	be 18 01 00 00       	mov    $0x118,%esi
  800421379f:	48 bf 1c 95 21 04 80 	movabs $0x800421951c,%rdi
  80042137a6:	00 00 00 
  80042137a9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042137ae:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042137b5:	00 00 00 
  80042137b8:	41 ff d0             	callq  *%r8

    if ((_dwarf_find_section_enhanced(ds)) != 0)
  80042137bb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042137bf:	48 89 c7             	mov    %rax,%rdi
  80042137c2:	48 b8 3f 0a 21 04 80 	movabs $0x8004210a3f,%rax
  80042137c9:	00 00 00 
  80042137cc:	ff d0                	callq  *%rax
  80042137ce:	85 c0                	test   %eax,%eax
  80042137d0:	74 0a                	je     80042137dc <_dwarf_lineno_init+0x11b>
        return (DW_DLE_NONE);
  80042137d2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042137d7:	e9 7d 04 00 00       	jmpq   8004213c59 <_dwarf_lineno_init+0x598>

	li = linfo;
  80042137dc:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  80042137e3:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
            break;
        }
    }
     */

    length = dbg->read(ds->ds_data, &offset, 4);
  80042137e7:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  80042137ee:	00 00 00 
  80042137f1:	48 8b 00             	mov    (%rax),%rax
  80042137f4:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042137f8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042137fc:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213800:	48 8d 8d 10 ff ff ff 	lea    -0xf0(%rbp),%rcx
  8004213807:	ba 04 00 00 00       	mov    $0x4,%edx
  800421380c:	48 89 ce             	mov    %rcx,%rsi
  800421380f:	48 89 c7             	mov    %rax,%rdi
  8004213812:	41 ff d0             	callq  *%r8
  8004213815:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if (length == 0xffffffff) {
  8004213819:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421381e:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004213822:	75 3b                	jne    800421385f <_dwarf_lineno_init+0x19e>
        dwarf_size = 8;
  8004213824:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
        length = dbg->read(ds->ds_data, &offset, 8);
  800421382b:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  8004213832:	00 00 00 
  8004213835:	48 8b 00             	mov    (%rax),%rax
  8004213838:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800421383c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213840:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213844:	48 8d 8d 10 ff ff ff 	lea    -0xf0(%rbp),%rcx
  800421384b:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213850:	48 89 ce             	mov    %rcx,%rsi
  8004213853:	48 89 c7             	mov    %rax,%rdi
  8004213856:	41 ff d0             	callq  *%r8
  8004213859:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800421385d:	eb 07                	jmp    8004213866 <_dwarf_lineno_init+0x1a5>
    } else
        dwarf_size = 4;
  800421385f:	c7 45 e4 04 00 00 00 	movl   $0x4,-0x1c(%rbp)

    if (length > ds->ds_size - offset) {
  8004213866:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421386a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421386e:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004213875:	48 89 d1             	mov    %rdx,%rcx
  8004213878:	48 29 c1             	sub    %rax,%rcx
  800421387b:	48 89 c8             	mov    %rcx,%rax
  800421387e:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004213882:	73 0a                	jae    800421388e <_dwarf_lineno_init+0x1cd>
        DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_LINE_LENGTH_BAD);
        return (DW_DLE_DEBUG_LINE_LENGTH_BAD);
  8004213884:	b8 0f 00 00 00       	mov    $0xf,%eax
  8004213889:	e9 cb 03 00 00       	jmpq   8004213c59 <_dwarf_lineno_init+0x598>
    }
    /*
     * Read in line number program header.
     */
    li->li_length = length;
  800421388e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213892:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213896:	48 89 10             	mov    %rdx,(%rax)
    endoff = offset + length;
  8004213899:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042138a0:	48 03 45 e8          	add    -0x18(%rbp),%rax
  80042138a4:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    li->li_version = dbg->read(ds->ds_data, &offset, 2); /* FIXME: verify version */
  80042138a8:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  80042138af:	00 00 00 
  80042138b2:	48 8b 00             	mov    (%rax),%rax
  80042138b5:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042138b9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042138bd:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042138c1:	48 8d 8d 10 ff ff ff 	lea    -0xf0(%rbp),%rcx
  80042138c8:	ba 02 00 00 00       	mov    $0x2,%edx
  80042138cd:	48 89 ce             	mov    %rcx,%rsi
  80042138d0:	48 89 c7             	mov    %rax,%rdi
  80042138d3:	41 ff d0             	callq  *%r8
  80042138d6:	89 c2                	mov    %eax,%edx
  80042138d8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042138dc:	66 89 50 08          	mov    %dx,0x8(%rax)
    li->li_hdrlen = dbg->read(ds->ds_data, &offset, dwarf_size);
  80042138e0:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  80042138e7:	00 00 00 
  80042138ea:	48 8b 00             	mov    (%rax),%rax
  80042138ed:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042138f1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042138f5:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042138f9:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042138fc:	48 8d 8d 10 ff ff ff 	lea    -0xf0(%rbp),%rcx
  8004213903:	48 89 ce             	mov    %rcx,%rsi
  8004213906:	48 89 c7             	mov    %rax,%rdi
  8004213909:	41 ff d0             	callq  *%r8
  800421390c:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213910:	48 89 42 10          	mov    %rax,0x10(%rdx)
    hdroff = offset;
  8004213914:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  800421391b:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    li->li_minlen = dbg->read(ds->ds_data, &offset, 1);
  800421391f:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  8004213926:	00 00 00 
  8004213929:	48 8b 00             	mov    (%rax),%rax
  800421392c:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004213930:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213934:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213938:	48 8d 8d 10 ff ff ff 	lea    -0xf0(%rbp),%rcx
  800421393f:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213944:	48 89 ce             	mov    %rcx,%rsi
  8004213947:	48 89 c7             	mov    %rax,%rdi
  800421394a:	41 ff d0             	callq  *%r8
  800421394d:	89 c2                	mov    %eax,%edx
  800421394f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213953:	88 50 18             	mov    %dl,0x18(%rax)
    li->li_defstmt = dbg->read(ds->ds_data, &offset, 1);
  8004213956:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  800421395d:	00 00 00 
  8004213960:	48 8b 00             	mov    (%rax),%rax
  8004213963:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004213967:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421396b:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421396f:	48 8d 8d 10 ff ff ff 	lea    -0xf0(%rbp),%rcx
  8004213976:	ba 01 00 00 00       	mov    $0x1,%edx
  800421397b:	48 89 ce             	mov    %rcx,%rsi
  800421397e:	48 89 c7             	mov    %rax,%rdi
  8004213981:	41 ff d0             	callq  *%r8
  8004213984:	89 c2                	mov    %eax,%edx
  8004213986:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421398a:	88 50 19             	mov    %dl,0x19(%rax)
    li->li_lbase = dbg->read(ds->ds_data, &offset, 1);
  800421398d:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  8004213994:	00 00 00 
  8004213997:	48 8b 00             	mov    (%rax),%rax
  800421399a:	4c 8b 40 18          	mov    0x18(%rax),%r8
  800421399e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042139a2:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042139a6:	48 8d 8d 10 ff ff ff 	lea    -0xf0(%rbp),%rcx
  80042139ad:	ba 01 00 00 00       	mov    $0x1,%edx
  80042139b2:	48 89 ce             	mov    %rcx,%rsi
  80042139b5:	48 89 c7             	mov    %rax,%rdi
  80042139b8:	41 ff d0             	callq  *%r8
  80042139bb:	89 c2                	mov    %eax,%edx
  80042139bd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042139c1:	88 50 1a             	mov    %dl,0x1a(%rax)
    li->li_lrange = dbg->read(ds->ds_data, &offset, 1);
  80042139c4:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  80042139cb:	00 00 00 
  80042139ce:	48 8b 00             	mov    (%rax),%rax
  80042139d1:	4c 8b 40 18          	mov    0x18(%rax),%r8
  80042139d5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042139d9:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042139dd:	48 8d 8d 10 ff ff ff 	lea    -0xf0(%rbp),%rcx
  80042139e4:	ba 01 00 00 00       	mov    $0x1,%edx
  80042139e9:	48 89 ce             	mov    %rcx,%rsi
  80042139ec:	48 89 c7             	mov    %rax,%rdi
  80042139ef:	41 ff d0             	callq  *%r8
  80042139f2:	89 c2                	mov    %eax,%edx
  80042139f4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042139f8:	88 50 1b             	mov    %dl,0x1b(%rax)
    li->li_opbase = dbg->read(ds->ds_data, &offset, 1);
  80042139fb:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  8004213a02:	00 00 00 
  8004213a05:	48 8b 00             	mov    (%rax),%rax
  8004213a08:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004213a0c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213a10:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213a14:	48 8d 8d 10 ff ff ff 	lea    -0xf0(%rbp),%rcx
  8004213a1b:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213a20:	48 89 ce             	mov    %rcx,%rsi
  8004213a23:	48 89 c7             	mov    %rax,%rdi
  8004213a26:	41 ff d0             	callq  *%r8
  8004213a29:	89 c2                	mov    %eax,%edx
  8004213a2b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213a2f:	88 50 1c             	mov    %dl,0x1c(%rax)
    //STAILQ_INIT(&li->li_lflist);
    //STAILQ_INIT(&li->li_lnlist);

    if ((int)li->li_hdrlen - 5 < li->li_opbase - 1) {
  8004213a32:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213a36:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004213a3a:	8d 50 fb             	lea    -0x5(%rax),%edx
  8004213a3d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213a41:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004213a45:	0f b6 c0             	movzbl %al,%eax
  8004213a48:	83 e8 01             	sub    $0x1,%eax
  8004213a4b:	39 c2                	cmp    %eax,%edx
  8004213a4d:	7d 0c                	jge    8004213a5b <_dwarf_lineno_init+0x39a>
        ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004213a4f:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
        DWARF_SET_ERROR(dbg, error, ret);
        goto fail_cleanup;
  8004213a56:	e9 fb 01 00 00       	jmpq   8004213c56 <_dwarf_lineno_init+0x595>
    }

    li->li_oplen = global_std_op;
  8004213a5b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213a5f:	48 ba e0 dc 67 04 80 	movabs $0x800467dce0,%rdx
  8004213a66:	00 00 00 
  8004213a69:	48 89 50 20          	mov    %rdx,0x20(%rax)

    /*
     * Read in std opcode arg length list. Note that the first
     * element is not used.
     */
    for (i = 1; i < li->li_opbase; i++)
  8004213a6d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%rbp)
  8004213a74:	eb 45                	jmp    8004213abb <_dwarf_lineno_init+0x3fa>
        li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);
  8004213a76:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213a7a:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004213a7e:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004213a81:	48 98                	cltq   
  8004213a83:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004213a87:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  8004213a8e:	00 00 00 
  8004213a91:	48 8b 00             	mov    (%rax),%rax
  8004213a94:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004213a98:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213a9c:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213aa0:	48 8d 8d 10 ff ff ff 	lea    -0xf0(%rbp),%rcx
  8004213aa7:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213aac:	48 89 ce             	mov    %rcx,%rsi
  8004213aaf:	48 89 c7             	mov    %rax,%rdi
  8004213ab2:	41 ff d0             	callq  *%r8
  8004213ab5:	88 03                	mov    %al,(%rbx)

    /*
     * Read in std opcode arg length list. Note that the first
     * element is not used.
     */
    for (i = 1; i < li->li_opbase; i++)
  8004213ab7:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
  8004213abb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213abf:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004213ac3:	0f b6 c0             	movzbl %al,%eax
  8004213ac6:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  8004213ac9:	7f ab                	jg     8004213a76 <_dwarf_lineno_init+0x3b5>
        li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);

    /*
     * Check how many strings in the include dir string array.
     */
    length = 0;
  8004213acb:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004213ad2:	00 
    p = ds->ds_data + offset;
  8004213ad3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213ad7:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004213adb:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004213ae2:	48 01 d0             	add    %rdx,%rax
  8004213ae5:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
    while (*p != '\0') {
  8004213aec:	eb 24                	jmp    8004213b12 <_dwarf_lineno_init+0x451>
        while (*p++ != '\0')
  8004213aee:	90                   	nop
  8004213aef:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004213af6:	0f b6 10             	movzbl (%rax),%edx
  8004213af9:	84 d2                	test   %dl,%dl
  8004213afb:	0f 95 c2             	setne  %dl
  8004213afe:	48 83 c0 01          	add    $0x1,%rax
  8004213b02:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  8004213b09:	84 d2                	test   %dl,%dl
  8004213b0b:	75 e2                	jne    8004213aef <_dwarf_lineno_init+0x42e>
            ;
        length++;
  8004213b0d:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
    /*
     * Check how many strings in the include dir string array.
     */
    length = 0;
    p = ds->ds_data + offset;
    while (*p != '\0') {
  8004213b12:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004213b19:	0f b6 00             	movzbl (%rax),%eax
  8004213b1c:	84 c0                	test   %al,%al
  8004213b1e:	75 ce                	jne    8004213aee <_dwarf_lineno_init+0x42d>
        while (*p++ != '\0')
            ;
        length++;
    }
    li->li_inclen = length;
  8004213b20:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213b24:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213b28:	48 89 50 30          	mov    %rdx,0x30(%rax)

    /* Sanity check. */
    if (p - ds->ds_data > (int) ds->ds_size) {
  8004213b2c:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004213b33:	48 89 c2             	mov    %rax,%rdx
  8004213b36:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213b3a:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213b3e:	48 29 c2             	sub    %rax,%rdx
  8004213b41:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213b45:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213b49:	48 98                	cltq   
  8004213b4b:	48 39 c2             	cmp    %rax,%rdx
  8004213b4e:	7e 0c                	jle    8004213b5c <_dwarf_lineno_init+0x49b>
        ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004213b50:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
        DWARF_SET_ERROR(dbg, error, ret);
        goto fail_cleanup;
  8004213b57:	e9 fa 00 00 00       	jmpq   8004213c56 <_dwarf_lineno_init+0x595>
        li->li_incdirs[i++] = (char *) p;
        while (*p++ != '\0')
            ;
    }
*/
    p++;
  8004213b5c:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004213b63:	48 83 c0 01          	add    $0x1,%rax
  8004213b67:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)

    /*
     * Process file list.
     */
    while (*p != '\0') {
  8004213b6e:	eb 3c                	jmp    8004213bac <_dwarf_lineno_init+0x4eb>
        ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
  8004213b70:	48 b8 98 a6 22 04 80 	movabs $0x800422a698,%rax
  8004213b77:	00 00 00 
  8004213b7a:	48 8b 08             	mov    (%rax),%rcx
  8004213b7d:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004213b84:	48 8d b5 28 ff ff ff 	lea    -0xd8(%rbp),%rsi
  8004213b8b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213b8f:	49 89 c8             	mov    %rcx,%r8
  8004213b92:	48 89 d1             	mov    %rdx,%rcx
  8004213b95:	ba 00 00 00 00       	mov    $0x0,%edx
  8004213b9a:	48 89 c7             	mov    %rax,%rdi
  8004213b9d:	48 b8 1d 36 21 04 80 	movabs $0x800421361d,%rax
  8004213ba4:	00 00 00 
  8004213ba7:	ff d0                	callq  *%rax
  8004213ba9:	89 45 dc             	mov    %eax,-0x24(%rbp)
    p++;

    /*
     * Process file list.
     */
    while (*p != '\0') {
  8004213bac:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004213bb3:	0f b6 00             	movzbl (%rax),%eax
  8004213bb6:	84 c0                	test   %al,%al
  8004213bb8:	75 b6                	jne    8004213b70 <_dwarf_lineno_init+0x4af>
        ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
		//p++;
    }

    p++;
  8004213bba:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004213bc1:	48 83 c0 01          	add    $0x1,%rax
  8004213bc5:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
    /* Sanity check. */
    if (p - ds->ds_data - hdroff != li->li_hdrlen) {
  8004213bcc:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004213bd3:	48 89 c2             	mov    %rax,%rdx
  8004213bd6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213bda:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213bde:	48 89 d1             	mov    %rdx,%rcx
  8004213be1:	48 29 c1             	sub    %rax,%rcx
  8004213be4:	48 89 c8             	mov    %rcx,%rax
  8004213be7:	48 89 c2             	mov    %rax,%rdx
  8004213bea:	48 2b 55 b0          	sub    -0x50(%rbp),%rdx
  8004213bee:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213bf2:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004213bf6:	48 39 c2             	cmp    %rax,%rdx
  8004213bf9:	74 09                	je     8004213c04 <_dwarf_lineno_init+0x543>
        ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004213bfb:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
        DWARF_SET_ERROR(dbg, error, ret);
        goto fail_cleanup;
  8004213c02:	eb 52                	jmp    8004213c56 <_dwarf_lineno_init+0x595>
    }

    /*
     * Process line number program.
     */
    ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
  8004213c04:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213c08:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213c0c:	48 89 c1             	mov    %rax,%rcx
  8004213c0f:	48 03 4d b8          	add    -0x48(%rbp),%rcx
  8004213c13:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  8004213c1a:	4c 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%r8
  8004213c21:	48 8b bd 00 ff ff ff 	mov    -0x100(%rbp),%rdi
  8004213c28:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004213c2c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213c30:	4d 89 c1             	mov    %r8,%r9
  8004213c33:	49 89 f8             	mov    %rdi,%r8
  8004213c36:	48 89 c7             	mov    %rax,%rdi
  8004213c39:	48 b8 b0 30 21 04 80 	movabs $0x80042130b0,%rax
  8004213c40:	00 00 00 
  8004213c43:	ff d0                	callq  *%rax
  8004213c45:	89 45 dc             	mov    %eax,-0x24(%rbp)
        error);
    if (ret != DW_DLE_NONE)
  8004213c48:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004213c4c:	75 07                	jne    8004213c55 <_dwarf_lineno_init+0x594>
        goto fail_cleanup;

    //cu->cu_lineinfo = li;

    return (DW_DLE_NONE);
  8004213c4e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213c53:	eb 04                	jmp    8004213c59 <_dwarf_lineno_init+0x598>
     * Process line number program.
     */
    ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
        error);
    if (ret != DW_DLE_NONE)
        goto fail_cleanup;
  8004213c55:	90                   	nop
fail_cleanup:

    /*if (li->li_oplen)
        free(li->li_oplen);*/

    return (ret);
  8004213c56:	8b 45 dc             	mov    -0x24(%rbp),%eax
}
  8004213c59:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  8004213c60:	5b                   	pop    %rbx
  8004213c61:	5d                   	pop    %rbp
  8004213c62:	c3                   	retq   

0000008004213c63 <dwarf_srclines>:

int
dwarf_srclines(Dwarf_Die *die, Dwarf_Line linebuf, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004213c63:	55                   	push   %rbp
  8004213c64:	48 89 e5             	mov    %rsp,%rbp
  8004213c67:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  8004213c6e:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004213c75:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  8004213c7c:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004213c83:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
    _Dwarf_LineInfo li;
    Dwarf_Attribute *at;

	assert(die);
  8004213c8a:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  8004213c91:	00 
  8004213c92:	75 35                	jne    8004213cc9 <dwarf_srclines+0x66>
  8004213c94:	48 b9 3f 95 21 04 80 	movabs $0x800421953f,%rcx
  8004213c9b:	00 00 00 
  8004213c9e:	48 ba 07 95 21 04 80 	movabs $0x8004219507,%rdx
  8004213ca5:	00 00 00 
  8004213ca8:	be ae 01 00 00       	mov    $0x1ae,%esi
  8004213cad:	48 bf 1c 95 21 04 80 	movabs $0x800421951c,%rdi
  8004213cb4:	00 00 00 
  8004213cb7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213cbc:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004213cc3:	00 00 00 
  8004213cc6:	41 ff d0             	callq  *%r8
	assert(linebuf);
  8004213cc9:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  8004213cd0:	00 
  8004213cd1:	75 35                	jne    8004213d08 <dwarf_srclines+0xa5>
  8004213cd3:	48 b9 43 95 21 04 80 	movabs $0x8004219543,%rcx
  8004213cda:	00 00 00 
  8004213cdd:	48 ba 07 95 21 04 80 	movabs $0x8004219507,%rdx
  8004213ce4:	00 00 00 
  8004213ce7:	be af 01 00 00       	mov    $0x1af,%esi
  8004213cec:	48 bf 1c 95 21 04 80 	movabs $0x800421951c,%rdi
  8004213cf3:	00 00 00 
  8004213cf6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213cfb:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004213d02:	00 00 00 
  8004213d05:	41 ff d0             	callq  *%r8

	memset(&li, 0, sizeof(_Dwarf_LineInfo));
  8004213d08:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  8004213d0f:	ba 88 00 00 00       	mov    $0x88,%edx
  8004213d14:	be 00 00 00 00       	mov    $0x0,%esi
  8004213d19:	48 89 c7             	mov    %rax,%rdi
  8004213d1c:	48 b8 53 e6 20 04 80 	movabs $0x800420e653,%rax
  8004213d23:	00 00 00 
  8004213d26:	ff d0                	callq  *%rax

    if ((at = _dwarf_attr_find(die, DW_AT_stmt_list)) == NULL) {
  8004213d28:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004213d2f:	be 10 00 00 00       	mov    $0x10,%esi
  8004213d34:	48 89 c7             	mov    %rax,%rdi
  8004213d37:	48 b8 c4 05 21 04 80 	movabs $0x80042105c4,%rax
  8004213d3e:	00 00 00 
  8004213d41:	ff d0                	callq  *%rax
  8004213d43:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004213d47:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004213d4c:	75 0a                	jne    8004213d58 <dwarf_srclines+0xf5>
        DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
        return (DW_DLV_NO_ENTRY);
  8004213d4e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213d53:	e9 84 00 00 00       	jmpq   8004213ddc <dwarf_srclines+0x179>
    }

    if (_dwarf_lineno_init(die, at->u[0].u64, &li, pc, error) !=
  8004213d58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213d5c:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004213d60:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  8004213d67:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
  8004213d6e:	48 8d 95 70 ff ff ff 	lea    -0x90(%rbp),%rdx
  8004213d75:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004213d7c:	49 89 f8             	mov    %rdi,%r8
  8004213d7f:	48 89 c7             	mov    %rax,%rdi
  8004213d82:	48 b8 c1 36 21 04 80 	movabs $0x80042136c1,%rax
  8004213d89:	00 00 00 
  8004213d8c:	ff d0                	callq  *%rax
  8004213d8e:	85 c0                	test   %eax,%eax
  8004213d90:	74 07                	je     8004213d99 <dwarf_srclines+0x136>
        DW_DLE_NONE)
	{
          return (DW_DLV_ERROR);
  8004213d92:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213d97:	eb 43                	jmp    8004213ddc <dwarf_srclines+0x179>
	}
    *linebuf = li.li_line;
  8004213d99:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004213da0:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213da4:	48 89 10             	mov    %rdx,(%rax)
  8004213da7:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213dab:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8004213daf:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213db3:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004213db7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213dbb:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004213dbf:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004213dc3:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004213dc7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213dcb:	48 89 50 28          	mov    %rdx,0x28(%rax)
  8004213dcf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213dd3:	48 89 50 30          	mov    %rdx,0x30(%rax)

    return (DW_DLV_OK);
  8004213dd7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213ddc:	c9                   	leaveq 
  8004213ddd:	c3                   	retq   
	...

0000008004213de0 <_dwarf_find_section>:
uintptr_t
read_section_headers(uintptr_t, uintptr_t);

Dwarf_Section *
_dwarf_find_section(const char *name)
{
  8004213de0:	55                   	push   %rbp
  8004213de1:	48 89 e5             	mov    %rsp,%rbp
  8004213de4:	48 83 ec 20          	sub    $0x20,%rsp
  8004213de8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    Dwarf_Section *ret=NULL;
  8004213dec:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004213df3:	00 
    int i;

    for(i=0; i < NDEBUG_SECT; i++) {
  8004213df4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004213dfb:	eb 57                	jmp    8004213e54 <_dwarf_find_section+0x74>
        if(!strcmp(section_info[i].ds_name, name)) {
  8004213dfd:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  8004213e04:	00 00 00 
  8004213e07:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004213e0a:	48 63 d2             	movslq %edx,%rdx
  8004213e0d:	48 c1 e2 05          	shl    $0x5,%rdx
  8004213e11:	48 01 d0             	add    %rdx,%rax
  8004213e14:	48 8b 00             	mov    (%rax),%rax
  8004213e17:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213e1b:	48 89 d6             	mov    %rdx,%rsi
  8004213e1e:	48 89 c7             	mov    %rax,%rdi
  8004213e21:	48 b8 17 e5 20 04 80 	movabs $0x800420e517,%rax
  8004213e28:	00 00 00 
  8004213e2b:	ff d0                	callq  *%rax
  8004213e2d:	85 c0                	test   %eax,%eax
  8004213e2f:	75 1f                	jne    8004213e50 <_dwarf_find_section+0x70>
            ret = (section_info + i);
  8004213e31:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004213e34:	48 98                	cltq   
  8004213e36:	48 89 c2             	mov    %rax,%rdx
  8004213e39:	48 c1 e2 05          	shl    $0x5,%rdx
  8004213e3d:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  8004213e44:	00 00 00 
  8004213e47:	48 01 d0             	add    %rdx,%rax
  8004213e4a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
            break;
  8004213e4e:	eb 0a                	jmp    8004213e5a <_dwarf_find_section+0x7a>
_dwarf_find_section(const char *name)
{
    Dwarf_Section *ret=NULL;
    int i;

    for(i=0; i < NDEBUG_SECT; i++) {
  8004213e50:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004213e54:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004213e58:	7e a3                	jle    8004213dfd <_dwarf_find_section+0x1d>
            ret = (section_info + i);
            break;
        }
    }

    return ret;
  8004213e5a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004213e5e:	c9                   	leaveq 
  8004213e5f:	c3                   	retq   

0000008004213e60 <find_debug_sections>:

void find_debug_sections(uintptr_t elf) 
{
  8004213e60:	55                   	push   %rbp
  8004213e61:	48 89 e5             	mov    %rsp,%rbp
  8004213e64:	48 83 ec 40          	sub    $0x40,%rsp
  8004213e68:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
    Elf *ehdr = (Elf *)elf;
  8004213e6c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213e70:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    uintptr_t debug_address = USTABDATA;
  8004213e74:	48 c7 45 f8 00 00 20 	movq   $0x200000,-0x8(%rbp)
  8004213e7b:	00 
    Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
  8004213e7c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213e80:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213e84:	48 03 45 e8          	add    -0x18(%rbp),%rax
  8004213e88:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
  8004213e8c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213e90:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004213e94:	0f b7 c0             	movzwl %ax,%eax
  8004213e97:	48 c1 e0 06          	shl    $0x6,%rax
  8004213e9b:	48 03 45 f0          	add    -0x10(%rbp),%rax
  8004213e9f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    Secthdr* esh = sh + ehdr->e_shnum;
  8004213ea3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ea7:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004213eab:	0f b7 c0             	movzwl %ax,%eax
  8004213eae:	48 c1 e0 06          	shl    $0x6,%rax
  8004213eb2:	48 03 45 f0          	add    -0x10(%rbp),%rax
  8004213eb6:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    for(;sh < esh; sh++) {
  8004213eba:	e9 48 02 00 00       	jmpq   8004214107 <find_debug_sections+0x2a7>
        char* name = (char*)((uint8_t*)elf + shstr_tab->sh_offset) + sh->sh_name;
  8004213ebf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213ec3:	8b 00                	mov    (%rax),%eax
  8004213ec5:	89 c2                	mov    %eax,%edx
  8004213ec7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213ecb:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213ecf:	48 03 45 c8          	add    -0x38(%rbp),%rax
  8004213ed3:	48 01 d0             	add    %rdx,%rax
  8004213ed6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!strcmp(name, ".debug_info")) {
  8004213eda:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213ede:	48 be 4b 95 21 04 80 	movabs $0x800421954b,%rsi
  8004213ee5:	00 00 00 
  8004213ee8:	48 89 c7             	mov    %rax,%rdi
  8004213eeb:	48 b8 17 e5 20 04 80 	movabs $0x800420e517,%rax
  8004213ef2:	00 00 00 
  8004213ef5:	ff d0                	callq  *%rax
  8004213ef7:	85 c0                	test   %eax,%eax
  8004213ef9:	75 4b                	jne    8004213f46 <find_debug_sections+0xe6>
            section_info[DEBUG_INFO].ds_data = (uint8_t*)debug_address;
  8004213efb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213eff:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  8004213f06:	00 00 00 
  8004213f09:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = debug_address;
  8004213f0d:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  8004213f14:	00 00 00 
  8004213f17:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213f1b:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = sh->sh_size;
  8004213f1f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213f23:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004213f27:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  8004213f2e:	00 00 00 
  8004213f31:	48 89 50 18          	mov    %rdx,0x18(%rax)
            debug_address += sh->sh_size;
  8004213f35:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213f39:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004213f3d:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004213f41:	e9 bc 01 00 00       	jmpq   8004214102 <find_debug_sections+0x2a2>
        } else if(!strcmp(name, ".debug_abbrev")) {
  8004213f46:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213f4a:	48 be 57 95 21 04 80 	movabs $0x8004219557,%rsi
  8004213f51:	00 00 00 
  8004213f54:	48 89 c7             	mov    %rax,%rdi
  8004213f57:	48 b8 17 e5 20 04 80 	movabs $0x800420e517,%rax
  8004213f5e:	00 00 00 
  8004213f61:	ff d0                	callq  *%rax
  8004213f63:	85 c0                	test   %eax,%eax
  8004213f65:	75 4b                	jne    8004213fb2 <find_debug_sections+0x152>
            section_info[DEBUG_ABBREV].ds_data = (uint8_t*)debug_address;
  8004213f67:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213f6b:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  8004213f72:	00 00 00 
  8004213f75:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = debug_address;
  8004213f79:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  8004213f80:	00 00 00 
  8004213f83:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213f87:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = sh->sh_size;
  8004213f8b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213f8f:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004213f93:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  8004213f9a:	00 00 00 
  8004213f9d:	48 89 50 38          	mov    %rdx,0x38(%rax)
            debug_address += sh->sh_size;
  8004213fa1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213fa5:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004213fa9:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004213fad:	e9 50 01 00 00       	jmpq   8004214102 <find_debug_sections+0x2a2>
        } else if(!strcmp(name, ".debug_line")){
  8004213fb2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213fb6:	48 be 6f 95 21 04 80 	movabs $0x800421956f,%rsi
  8004213fbd:	00 00 00 
  8004213fc0:	48 89 c7             	mov    %rax,%rdi
  8004213fc3:	48 b8 17 e5 20 04 80 	movabs $0x800420e517,%rax
  8004213fca:	00 00 00 
  8004213fcd:	ff d0                	callq  *%rax
  8004213fcf:	85 c0                	test   %eax,%eax
  8004213fd1:	75 4b                	jne    800421401e <find_debug_sections+0x1be>
            section_info[DEBUG_LINE].ds_data = (uint8_t*)debug_address;
  8004213fd3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213fd7:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  8004213fde:	00 00 00 
  8004213fe1:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = debug_address;
  8004213fe5:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  8004213fec:	00 00 00 
  8004213fef:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213ff3:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = sh->sh_size;
  8004213ff7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213ffb:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004213fff:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  8004214006:	00 00 00 
  8004214009:	48 89 50 78          	mov    %rdx,0x78(%rax)
            debug_address += sh->sh_size;
  800421400d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214011:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004214015:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004214019:	e9 e4 00 00 00       	jmpq   8004214102 <find_debug_sections+0x2a2>
        } else if(!strcmp(name, ".eh_frame")){
  800421401e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214022:	48 be 65 95 21 04 80 	movabs $0x8004219565,%rsi
  8004214029:	00 00 00 
  800421402c:	48 89 c7             	mov    %rax,%rdi
  800421402f:	48 b8 17 e5 20 04 80 	movabs $0x800420e517,%rax
  8004214036:	00 00 00 
  8004214039:	ff d0                	callq  *%rax
  800421403b:	85 c0                	test   %eax,%eax
  800421403d:	75 53                	jne    8004214092 <find_debug_sections+0x232>
            section_info[DEBUG_FRAME].ds_data = (uint8_t*)sh->sh_addr;
  800421403f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214043:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004214047:	48 89 c2             	mov    %rax,%rdx
  800421404a:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  8004214051:	00 00 00 
  8004214054:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = sh->sh_addr;
  8004214058:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421405c:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004214060:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  8004214067:	00 00 00 
  800421406a:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = sh->sh_size;
  800421406e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214072:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214076:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  800421407d:	00 00 00 
  8004214080:	48 89 50 58          	mov    %rdx,0x58(%rax)
            debug_address += sh->sh_size;
  8004214084:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214088:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421408c:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004214090:	eb 70                	jmp    8004214102 <find_debug_sections+0x2a2>
        } else if(!strcmp(name, ".debug_str")) {
  8004214092:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214096:	48 be 7b 95 21 04 80 	movabs $0x800421957b,%rsi
  800421409d:	00 00 00 
  80042140a0:	48 89 c7             	mov    %rax,%rdi
  80042140a3:	48 b8 17 e5 20 04 80 	movabs $0x800420e517,%rax
  80042140aa:	00 00 00 
  80042140ad:	ff d0                	callq  *%rax
  80042140af:	85 c0                	test   %eax,%eax
  80042140b1:	75 4f                	jne    8004214102 <find_debug_sections+0x2a2>
            section_info[DEBUG_STR].ds_data = (uint8_t*)debug_address;
  80042140b3:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042140b7:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  80042140be:	00 00 00 
  80042140c1:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = debug_address;
  80042140c8:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  80042140cf:	00 00 00 
  80042140d2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042140d6:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = sh->sh_size;
  80042140dd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042140e1:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042140e5:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  80042140ec:	00 00 00 
  80042140ef:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
            debug_address += sh->sh_size;
  80042140f6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042140fa:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042140fe:	48 01 45 f8          	add    %rax,-0x8(%rbp)
    Elf *ehdr = (Elf *)elf;
    uintptr_t debug_address = USTABDATA;
    Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
    Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
    Secthdr* esh = sh + ehdr->e_shnum;
    for(;sh < esh; sh++) {
  8004214102:	48 83 45 f0 40       	addq   $0x40,-0x10(%rbp)
  8004214107:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421410b:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800421410f:	0f 82 aa fd ff ff    	jb     8004213ebf <find_debug_sections+0x5f>
			section_info[DEBUG_STR].ds_size = sh->sh_size;
            debug_address += sh->sh_size;
        }
    }

}
  8004214115:	c9                   	leaveq 
  8004214116:	c3                   	retq   

0000008004214117 <read_section_headers>:

uint64_t
read_section_headers(uintptr_t elfhdr, uintptr_t to_va)
{
  8004214117:	55                   	push   %rbp
  8004214118:	48 89 e5             	mov    %rsp,%rbp
  800421411b:	48 81 ec 60 01 00 00 	sub    $0x160,%rsp
  8004214122:	48 89 bd a8 fe ff ff 	mov    %rdi,-0x158(%rbp)
  8004214129:	48 89 b5 a0 fe ff ff 	mov    %rsi,-0x160(%rbp)
    Secthdr* secthdr_ptr[20] = {0};
  8004214130:	48 8d b5 c0 fe ff ff 	lea    -0x140(%rbp),%rsi
  8004214137:	b8 00 00 00 00       	mov    $0x0,%eax
  800421413c:	ba 14 00 00 00       	mov    $0x14,%edx
  8004214141:	48 89 f7             	mov    %rsi,%rdi
  8004214144:	48 89 d1             	mov    %rdx,%rcx
  8004214147:	f3 48 ab             	rep stos %rax,%es:(%rdi)
    char* kvbase = ROUNDUP((char*)to_va, SECTSIZE);
  800421414a:	48 c7 45 e8 00 02 00 	movq   $0x200,-0x18(%rbp)
  8004214151:	00 
  8004214152:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214156:	48 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%rdx
  800421415d:	48 01 d0             	add    %rdx,%rax
  8004214160:	48 83 e8 01          	sub    $0x1,%rax
  8004214164:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004214168:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421416c:	ba 00 00 00 00       	mov    $0x0,%edx
  8004214171:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004214175:	48 89 d0             	mov    %rdx,%rax
  8004214178:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421417c:	48 89 d1             	mov    %rdx,%rcx
  800421417f:	48 29 c1             	sub    %rax,%rcx
  8004214182:	48 89 c8             	mov    %rcx,%rax
  8004214185:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    uint64_t kvoffset = 0;
  8004214189:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  8004214190:	00 00 00 00 
	char *orig_secthdr = (char*)kvbase;
  8004214194:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214198:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    char * secthdr = NULL;
  800421419c:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  80042141a3:	00 
    uint64_t offset;
    if(elfhdr == KELFHDR)
  80042141a4:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  80042141ab:	00 00 00 
  80042141ae:	48 39 85 a8 fe ff ff 	cmp    %rax,-0x158(%rbp)
  80042141b5:	75 11                	jne    80042141c8 <read_section_headers+0xb1>
        offset = ((Elf*)elfhdr)->e_shoff;
  80042141b7:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042141be:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042141c2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042141c6:	eb 26                	jmp    80042141ee <read_section_headers+0xd7>
    else
        offset = ((Elf*)elfhdr)->e_shoff + (elfhdr - KERNBASE);
  80042141c8:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042141cf:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042141d3:	48 89 c2             	mov    %rax,%rdx
  80042141d6:	48 03 95 a8 fe ff ff 	add    -0x158(%rbp),%rdx
  80042141dd:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  80042141e4:	ff ff ff 
  80042141e7:	48 01 d0             	add    %rdx,%rax
  80042141ea:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    int numSectionHeaders = ((Elf*)elfhdr)->e_shnum;
  80042141ee:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042141f5:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  80042141f9:	0f b7 c0             	movzwl %ax,%eax
  80042141fc:	89 45 c4             	mov    %eax,-0x3c(%rbp)
	int sizeSections = ((Elf*)elfhdr)->e_shentsize;
  80042141ff:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004214206:	0f b7 40 3a          	movzwl 0x3a(%rax),%eax
  800421420a:	0f b7 c0             	movzwl %ax,%eax
  800421420d:	89 45 c0             	mov    %eax,-0x40(%rbp)
	char *nametab;
	int i;
	uint64_t temp;
	char *name;

	Elf *ehdr = (Elf *)elfhdr;
  8004214210:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004214217:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
  800421421b:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421421e:	0f af 45 c0          	imul   -0x40(%rbp),%eax
  8004214222:	48 63 f0             	movslq %eax,%rsi
  8004214225:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214229:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004214230:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004214234:	48 89 c7             	mov    %rax,%rdi
  8004214237:	48 b8 4b 48 21 04 80 	movabs $0x800421484b,%rax
  800421423e:	00 00 00 
  8004214241:	ff d0                	callq  *%rax
             offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
  8004214243:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214247:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  800421424b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421424f:	48 89 c2             	mov    %rax,%rdx
  8004214252:	48 81 e2 00 fe ff ff 	and    $0xfffffffffffffe00,%rdx
  8004214259:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421425d:	48 29 d0             	sub    %rdx,%rax
  8004214260:	48 03 45 d0          	add    -0x30(%rbp),%rax
  8004214264:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < numSectionHeaders; i++)
  8004214268:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  800421426f:	eb 21                	jmp    8004214292 <read_section_headers+0x17b>
	{
		 secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
  8004214271:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214274:	48 98                	cltq   
  8004214276:	48 c1 e0 06          	shl    $0x6,%rax
  800421427a:	48 89 c2             	mov    %rax,%rdx
  800421427d:	48 03 55 c8          	add    -0x38(%rbp),%rdx
  8004214281:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214284:	48 98                	cltq   
  8004214286:	48 89 94 c5 c0 fe ff 	mov    %rdx,-0x140(%rbp,%rax,8)
  800421428d:	ff 
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
             offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
	for (i = 0; i < numSectionHeaders; i++)
  800421428e:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004214292:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214295:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004214298:	7c d7                	jl     8004214271 <read_section_headers+0x15a>
	{
		 secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
	}
	
	sec_name = secthdr_ptr[ehdr->e_shstrndx]; 
  800421429a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421429e:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  80042142a2:	0f b7 c0             	movzwl %ax,%eax
  80042142a5:	48 98                	cltq   
  80042142a7:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042142ae:	ff 
  80042142af:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	temp = kvoffset;
  80042142b3:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  80042142ba:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
            sec_name->sh_offset, &kvoffset);
  80042142be:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
		 secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
	}
	
	sec_name = secthdr_ptr[ehdr->e_shstrndx]; 
	temp = kvoffset;
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
  80042142c2:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042142c6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042142ca:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042142ce:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  80042142d5:	48 03 45 d8          	add    -0x28(%rbp),%rax
  80042142d9:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042142e0:	48 89 c7             	mov    %rax,%rdi
  80042142e3:	48 b8 4b 48 21 04 80 	movabs $0x800421484b,%rax
  80042142ea:	00 00 00 
  80042142ed:	ff d0                	callq  *%rax
            sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	
  80042142ef:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042142f3:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042142f7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042142fb:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042142ff:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  8004214303:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004214307:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  800421430d:	48 89 d7             	mov    %rdx,%rdi
  8004214310:	48 29 c7             	sub    %rax,%rdi
  8004214313:	48 89 f8             	mov    %rdi,%rax
  8004214316:	48 03 45 a0          	add    -0x60(%rbp),%rax
  800421431a:	48 03 45 d8          	add    -0x28(%rbp),%rax
  800421431e:	48 89 45 90          	mov    %rax,-0x70(%rbp)

    
	for (i = 0; i < numSectionHeaders; i++)
  8004214322:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004214329:	e9 01 05 00 00       	jmpq   800421482f <read_section_headers+0x718>
    {
		name = (char *)(nametab + secthdr_ptr[i]->sh_name);
  800421432e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214331:	48 98                	cltq   
  8004214333:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421433a:	ff 
  800421433b:	8b 00                	mov    (%rax),%eax
  800421433d:	89 c0                	mov    %eax,%eax
  800421433f:	48 03 45 90          	add    -0x70(%rbp),%rax
  8004214343:	48 89 45 88          	mov    %rax,-0x78(%rbp)
        assert(kvoffset % SECTSIZE == 0);
  8004214347:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  800421434e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004214353:	48 85 c0             	test   %rax,%rax
  8004214356:	74 35                	je     800421438d <read_section_headers+0x276>
  8004214358:	48 b9 86 95 21 04 80 	movabs $0x8004219586,%rcx
  800421435f:	00 00 00 
  8004214362:	48 ba 9f 95 21 04 80 	movabs $0x800421959f,%rdx
  8004214369:	00 00 00 
  800421436c:	be 87 00 00 00       	mov    $0x87,%esi
  8004214371:	48 bf b4 95 21 04 80 	movabs $0x80042195b4,%rdi
  8004214378:	00 00 00 
  800421437b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214380:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004214387:	00 00 00 
  800421438a:	41 ff d0             	callq  *%r8
        temp = kvoffset;
  800421438d:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004214394:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef DWARF_DEBUG
        cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
  8004214398:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421439c:	48 be 4b 95 21 04 80 	movabs $0x800421954b,%rsi
  80042143a3:	00 00 00 
  80042143a6:	48 89 c7             	mov    %rax,%rdi
  80042143a9:	48 b8 17 e5 20 04 80 	movabs $0x800420e517,%rax
  80042143b0:	00 00 00 
  80042143b3:	ff d0                	callq  *%rax
  80042143b5:	85 c0                	test   %eax,%eax
  80042143b7:	0f 85 d8 00 00 00    	jne    8004214495 <read_section_headers+0x37e>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
  80042143bd:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042143c0:	48 98                	cltq   
  80042143c2:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042143c9:	ff 
#ifdef DWARF_DEBUG
        cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  80042143ca:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042143ce:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042143d1:	48 98                	cltq   
  80042143d3:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042143da:	ff 
  80042143db:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042143df:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  80042143e6:	48 03 45 d8          	add    -0x28(%rbp),%rax
  80042143ea:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042143f1:	48 89 c7             	mov    %rax,%rdi
  80042143f4:	48 b8 4b 48 21 04 80 	movabs $0x800421484b,%rax
  80042143fb:	00 00 00 
  80042143fe:	ff d0                	callq  *%rax
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_INFO].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004214400:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214403:	48 98                	cltq   
  8004214405:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421440c:	ff 
  800421440d:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214411:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214414:	48 98                	cltq   
  8004214416:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421441d:	ff 
  800421441e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214422:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  8004214426:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421442a:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004214430:	48 89 d1             	mov    %rdx,%rcx
  8004214433:	48 29 c1             	sub    %rax,%rcx
  8004214436:	48 89 c8             	mov    %rcx,%rax
  8004214439:	48 03 45 a0          	add    -0x60(%rbp),%rax
  800421443d:	48 89 c2             	mov    %rax,%rdx
  8004214440:	48 03 55 d8          	add    -0x28(%rbp),%rdx
  8004214444:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  800421444b:	00 00 00 
  800421444e:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
  8004214452:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  8004214459:	00 00 00 
  800421445c:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214460:	48 89 c2             	mov    %rax,%rdx
  8004214463:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  800421446a:	00 00 00 
  800421446d:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
  8004214471:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214474:	48 98                	cltq   
  8004214476:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421447d:	ff 
  800421447e:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214482:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  8004214489:	00 00 00 
  800421448c:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004214490:	e9 96 03 00 00       	jmpq   800421482b <read_section_headers+0x714>
		}
		else if(!strcmp(name, ".debug_abbrev"))
  8004214495:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214499:	48 be 57 95 21 04 80 	movabs $0x8004219557,%rsi
  80042144a0:	00 00 00 
  80042144a3:	48 89 c7             	mov    %rax,%rdi
  80042144a6:	48 b8 17 e5 20 04 80 	movabs $0x800420e517,%rax
  80042144ad:	00 00 00 
  80042144b0:	ff d0                	callq  *%rax
  80042144b2:	85 c0                	test   %eax,%eax
  80042144b4:	0f 85 de 00 00 00    	jne    8004214598 <read_section_headers+0x481>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
  80042144ba:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042144bd:	48 98                	cltq   
  80042144bf:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042144c6:	ff 
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_abbrev"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  80042144c7:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042144cb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042144ce:	48 98                	cltq   
  80042144d0:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042144d7:	ff 
  80042144d8:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042144dc:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  80042144e3:	48 03 45 d8          	add    -0x28(%rbp),%rax
  80042144e7:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042144ee:	48 89 c7             	mov    %rax,%rdi
  80042144f1:	48 b8 4b 48 21 04 80 	movabs $0x800421484b,%rax
  80042144f8:	00 00 00 
  80042144fb:	ff d0                	callq  *%rax
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_ABBREV].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  80042144fd:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214500:	48 98                	cltq   
  8004214502:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214509:	ff 
  800421450a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421450e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214511:	48 98                	cltq   
  8004214513:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421451a:	ff 
  800421451b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421451f:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004214526:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421452d:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004214533:	48 89 d7             	mov    %rdx,%rdi
  8004214536:	48 29 c7             	sub    %rax,%rdi
  8004214539:	48 89 f8             	mov    %rdi,%rax
  800421453c:	48 03 45 a0          	add    -0x60(%rbp),%rax
  8004214540:	48 89 c2             	mov    %rax,%rdx
  8004214543:	48 03 55 d8          	add    -0x28(%rbp),%rdx
  8004214547:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  800421454e:	00 00 00 
  8004214551:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
  8004214555:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  800421455c:	00 00 00 
  800421455f:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214563:	48 89 c2             	mov    %rax,%rdx
  8004214566:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  800421456d:	00 00 00 
  8004214570:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
  8004214574:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214577:	48 98                	cltq   
  8004214579:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214580:	ff 
  8004214581:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214585:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  800421458c:	00 00 00 
  800421458f:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004214593:	e9 93 02 00 00       	jmpq   800421482b <read_section_headers+0x714>
		}
		else if(!strcmp(name, ".debug_line"))
  8004214598:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421459c:	48 be 6f 95 21 04 80 	movabs $0x800421956f,%rsi
  80042145a3:	00 00 00 
  80042145a6:	48 89 c7             	mov    %rax,%rdi
  80042145a9:	48 b8 17 e5 20 04 80 	movabs $0x800420e517,%rax
  80042145b0:	00 00 00 
  80042145b3:	ff d0                	callq  *%rax
  80042145b5:	85 c0                	test   %eax,%eax
  80042145b7:	0f 85 de 00 00 00    	jne    800421469b <read_section_headers+0x584>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
  80042145bd:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042145c0:	48 98                	cltq   
  80042145c2:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042145c9:	ff 
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_line"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  80042145ca:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042145ce:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042145d1:	48 98                	cltq   
  80042145d3:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042145da:	ff 
  80042145db:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042145df:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  80042145e6:	48 03 45 d8          	add    -0x28(%rbp),%rax
  80042145ea:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042145f1:	48 89 c7             	mov    %rax,%rdi
  80042145f4:	48 b8 4b 48 21 04 80 	movabs $0x800421484b,%rax
  80042145fb:	00 00 00 
  80042145fe:	ff d0                	callq  *%rax
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_LINE].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004214600:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214603:	48 98                	cltq   
  8004214605:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421460c:	ff 
  800421460d:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214611:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214614:	48 98                	cltq   
  8004214616:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421461d:	ff 
  800421461e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214622:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  8004214629:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004214630:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004214636:	48 89 d1             	mov    %rdx,%rcx
  8004214639:	48 29 c1             	sub    %rax,%rcx
  800421463c:	48 89 c8             	mov    %rcx,%rax
  800421463f:	48 03 45 a0          	add    -0x60(%rbp),%rax
  8004214643:	48 89 c2             	mov    %rax,%rdx
  8004214646:	48 03 55 d8          	add    -0x28(%rbp),%rdx
  800421464a:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  8004214651:	00 00 00 
  8004214654:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = (uintptr_t)section_info[DEBUG_LINE].ds_data;
  8004214658:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  800421465f:	00 00 00 
  8004214662:	48 8b 40 68          	mov    0x68(%rax),%rax
  8004214666:	48 89 c2             	mov    %rax,%rdx
  8004214669:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  8004214670:	00 00 00 
  8004214673:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = secthdr_ptr[i]->sh_size;
  8004214677:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421467a:	48 98                	cltq   
  800421467c:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214683:	ff 
  8004214684:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214688:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  800421468f:	00 00 00 
  8004214692:	48 89 50 78          	mov    %rdx,0x78(%rax)
  8004214696:	e9 90 01 00 00       	jmpq   800421482b <read_section_headers+0x714>
		}
		else if(!strcmp(name, ".eh_frame"))
  800421469b:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421469f:	48 be 65 95 21 04 80 	movabs $0x8004219565,%rsi
  80042146a6:	00 00 00 
  80042146a9:	48 89 c7             	mov    %rax,%rdi
  80042146ac:	48 b8 17 e5 20 04 80 	movabs $0x800420e517,%rax
  80042146b3:	00 00 00 
  80042146b6:	ff d0                	callq  *%rax
  80042146b8:	85 c0                	test   %eax,%eax
  80042146ba:	75 65                	jne    8004214721 <read_section_headers+0x60a>
		{
			section_info[DEBUG_FRAME].ds_data = (uint8_t *)secthdr_ptr[i]->sh_addr;
  80042146bc:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042146bf:	48 98                	cltq   
  80042146c1:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042146c8:	ff 
  80042146c9:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042146cd:	48 89 c2             	mov    %rax,%rdx
  80042146d0:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  80042146d7:	00 00 00 
  80042146da:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
  80042146de:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  80042146e5:	00 00 00 
  80042146e8:	48 8b 40 48          	mov    0x48(%rax),%rax
  80042146ec:	48 89 c2             	mov    %rax,%rdx
  80042146ef:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  80042146f6:	00 00 00 
  80042146f9:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
  80042146fd:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214700:	48 98                	cltq   
  8004214702:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214709:	ff 
  800421470a:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421470e:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  8004214715:	00 00 00 
  8004214718:	48 89 50 58          	mov    %rdx,0x58(%rax)
  800421471c:	e9 0a 01 00 00       	jmpq   800421482b <read_section_headers+0x714>
		}
		else if(!strcmp(name, ".debug_str"))
  8004214721:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004214725:	48 be 7b 95 21 04 80 	movabs $0x800421957b,%rsi
  800421472c:	00 00 00 
  800421472f:	48 89 c7             	mov    %rax,%rdi
  8004214732:	48 b8 17 e5 20 04 80 	movabs $0x800420e517,%rax
  8004214739:	00 00 00 
  800421473c:	ff d0                	callq  *%rax
  800421473e:	85 c0                	test   %eax,%eax
  8004214740:	0f 85 e5 00 00 00    	jne    800421482b <read_section_headers+0x714>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004214746:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214749:	48 98                	cltq   
  800421474b:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214752:	ff 
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_str"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004214753:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214757:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421475a:	48 98                	cltq   
  800421475c:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214763:	ff 
  8004214764:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004214768:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  800421476f:	48 03 45 d8          	add    -0x28(%rbp),%rax
  8004214773:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  800421477a:	48 89 c7             	mov    %rax,%rdi
  800421477d:	48 b8 4b 48 21 04 80 	movabs $0x800421484b,%rax
  8004214784:	00 00 00 
  8004214787:	ff d0                	callq  *%rax
                    secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_STR].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004214789:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421478c:	48 98                	cltq   
  800421478e:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214795:	ff 
  8004214796:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421479a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421479d:	48 98                	cltq   
  800421479f:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042147a6:	ff 
  80042147a7:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042147ab:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  80042147b2:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042147b9:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042147bf:	48 89 d7             	mov    %rdx,%rdi
  80042147c2:	48 29 c7             	sub    %rax,%rdi
  80042147c5:	48 89 f8             	mov    %rdi,%rax
  80042147c8:	48 03 45 a0          	add    -0x60(%rbp),%rax
  80042147cc:	48 89 c2             	mov    %rax,%rdx
  80042147cf:	48 03 55 d8          	add    -0x28(%rbp),%rdx
  80042147d3:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  80042147da:	00 00 00 
  80042147dd:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
  80042147e4:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  80042147eb:	00 00 00 
  80042147ee:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  80042147f5:	48 89 c2             	mov    %rax,%rdx
  80042147f8:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  80042147ff:	00 00 00 
  8004214802:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
  8004214809:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421480c:	48 98                	cltq   
  800421480e:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004214815:	ff 
  8004214816:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421481a:	48 b8 e0 a6 22 04 80 	movabs $0x800422a6e0,%rax
  8004214821:	00 00 00 
  8004214824:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
            sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	

    
	for (i = 0; i < numSectionHeaders; i++)
  800421482b:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800421482f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004214832:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004214835:	0f 8c f3 fa ff ff    	jl     800421432e <read_section_headers+0x217>
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
		}
    }
	
    return ((uintptr_t)kvbase + kvoffset);
  800421483b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421483f:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004214846:	48 01 d0             	add    %rdx,%rax
}
  8004214849:	c9                   	leaveq 
  800421484a:	c3                   	retq   

000000800421484b <readseg>:

// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
// Might copy more than asked
void
readseg(uint64_t pa, uint64_t count, uint64_t offset, uint64_t* kvoffset)
{
  800421484b:	55                   	push   %rbp
  800421484c:	48 89 e5             	mov    %rsp,%rbp
  800421484f:	48 83 ec 30          	sub    $0x30,%rsp
  8004214853:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004214857:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421485b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800421485f:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	uint64_t end_pa;
	uint64_t orgoff = offset;
  8004214863:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214867:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	end_pa = pa + count;
  800421486b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421486f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214873:	48 01 d0             	add    %rdx,%rax
  8004214876:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	assert(pa % SECTSIZE == 0);	
  800421487a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421487e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004214883:	48 85 c0             	test   %rax,%rax
  8004214886:	74 35                	je     80042148bd <readseg+0x72>
  8004214888:	48 b9 c2 95 21 04 80 	movabs $0x80042195c2,%rcx
  800421488f:	00 00 00 
  8004214892:	48 ba 9f 95 21 04 80 	movabs $0x800421959f,%rdx
  8004214899:	00 00 00 
  800421489c:	be c1 00 00 00       	mov    $0xc1,%esi
  80042148a1:	48 bf b4 95 21 04 80 	movabs $0x80042195b4,%rdi
  80042148a8:	00 00 00 
  80042148ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80042148b0:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042148b7:	00 00 00 
  80042148ba:	41 ff d0             	callq  *%r8
	// round down to sector boundary
	pa &= ~(SECTSIZE - 1);
  80042148bd:	48 81 65 e8 00 fe ff 	andq   $0xfffffffffffffe00,-0x18(%rbp)
  80042148c4:	ff 

	// translate from bytes to sectors, and kernel starts at sector 1
	offset = (offset / SECTSIZE) + 1;
  80042148c5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042148c9:	48 c1 e8 09          	shr    $0x9,%rax
  80042148cd:	48 83 c0 01          	add    $0x1,%rax
  80042148d1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  80042148d5:	eb 3c                	jmp    8004214913 <readseg+0xc8>
		readsect((uint8_t*) pa, offset);
  80042148d7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042148db:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042148df:	48 89 d6             	mov    %rdx,%rsi
  80042148e2:	48 89 c7             	mov    %rax,%rdi
  80042148e5:	48 b8 e0 49 21 04 80 	movabs $0x80042149e0,%rax
  80042148ec:	00 00 00 
  80042148ef:	ff d0                	callq  *%rax
		pa += SECTSIZE;
  80042148f1:	48 81 45 e8 00 02 00 	addq   $0x200,-0x18(%rbp)
  80042148f8:	00 
		*kvoffset += SECTSIZE;
  80042148f9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042148fd:	48 8b 00             	mov    (%rax),%rax
  8004214900:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004214907:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421490b:	48 89 10             	mov    %rdx,(%rax)
		offset++;
  800421490e:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
	offset = (offset / SECTSIZE) + 1;

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004214913:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214917:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800421491b:	72 ba                	jb     80042148d7 <readseg+0x8c>
		pa += SECTSIZE;
		*kvoffset += SECTSIZE;
		offset++;
	}

	if(((orgoff % SECTSIZE) + count) > SECTSIZE)
  800421491d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214921:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004214926:	48 03 45 e0          	add    -0x20(%rbp),%rax
  800421492a:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  8004214930:	76 2f                	jbe    8004214961 <readseg+0x116>
	{
		readsect((uint8_t*) pa, offset);
  8004214932:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214936:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421493a:	48 89 d6             	mov    %rdx,%rsi
  800421493d:	48 89 c7             	mov    %rax,%rdi
  8004214940:	48 b8 e0 49 21 04 80 	movabs $0x80042149e0,%rax
  8004214947:	00 00 00 
  800421494a:	ff d0                	callq  *%rax
		*kvoffset += SECTSIZE;
  800421494c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214950:	48 8b 00             	mov    (%rax),%rax
  8004214953:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  800421495a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421495e:	48 89 10             	mov    %rdx,(%rax)
	}
	assert(*kvoffset % SECTSIZE == 0);
  8004214961:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214965:	48 8b 00             	mov    (%rax),%rax
  8004214968:	25 ff 01 00 00       	and    $0x1ff,%eax
  800421496d:	48 85 c0             	test   %rax,%rax
  8004214970:	74 35                	je     80042149a7 <readseg+0x15c>
  8004214972:	48 b9 d5 95 21 04 80 	movabs $0x80042195d5,%rcx
  8004214979:	00 00 00 
  800421497c:	48 ba 9f 95 21 04 80 	movabs $0x800421959f,%rdx
  8004214983:	00 00 00 
  8004214986:	be d7 00 00 00       	mov    $0xd7,%esi
  800421498b:	48 bf b4 95 21 04 80 	movabs $0x80042195b4,%rdi
  8004214992:	00 00 00 
  8004214995:	b8 00 00 00 00       	mov    $0x0,%eax
  800421499a:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042149a1:	00 00 00 
  80042149a4:	41 ff d0             	callq  *%r8
}
  80042149a7:	c9                   	leaveq 
  80042149a8:	c3                   	retq   

00000080042149a9 <waitdisk>:

void
waitdisk(void)
{
  80042149a9:	55                   	push   %rbp
  80042149aa:	48 89 e5             	mov    %rsp,%rbp
  80042149ad:	53                   	push   %rbx
  80042149ae:	48 83 ec 18          	sub    $0x18,%rsp
	// wait for disk reaady
	while ((inb(0x1F7) & 0xC0) != 0x40)
  80042149b2:	c7 45 f4 f7 01 00 00 	movl   $0x1f7,-0xc(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042149b9:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042149bc:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  80042149bf:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042149c2:	ec                   	in     (%dx),%al
  80042149c3:	89 c3                	mov    %eax,%ebx
  80042149c5:	88 5d f3             	mov    %bl,-0xd(%rbp)
	return data;
  80042149c8:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  80042149cc:	0f b6 c0             	movzbl %al,%eax
  80042149cf:	25 c0 00 00 00       	and    $0xc0,%eax
  80042149d4:	83 f8 40             	cmp    $0x40,%eax
  80042149d7:	75 d9                	jne    80042149b2 <waitdisk+0x9>
		/* do nothing */;
}
  80042149d9:	48 83 c4 18          	add    $0x18,%rsp
  80042149dd:	5b                   	pop    %rbx
  80042149de:	5d                   	pop    %rbp
  80042149df:	c3                   	retq   

00000080042149e0 <readsect>:

void
readsect(void *dst, uint64_t offset)
{
  80042149e0:	55                   	push   %rbp
  80042149e1:	48 89 e5             	mov    %rsp,%rbp
  80042149e4:	41 54                	push   %r12
  80042149e6:	53                   	push   %rbx
  80042149e7:	48 83 ec 60          	sub    $0x60,%rsp
  80042149eb:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  80042149ef:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
	// wait for disk to be ready
	waitdisk();
  80042149f3:	48 b8 a9 49 21 04 80 	movabs $0x80042149a9,%rax
  80042149fa:	00 00 00 
  80042149fd:	ff d0                	callq  *%rax
  80042149ff:	c7 45 ec f2 01 00 00 	movl   $0x1f2,-0x14(%rbp)
  8004214a06:	c6 45 eb 01          	movb   $0x1,-0x15(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004214a0a:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004214a0e:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004214a11:	ee                   	out    %al,(%dx)

	outb(0x1F2, 1);		// count = 1
	outb(0x1F3, offset);
  8004214a12:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214a16:	0f b6 c0             	movzbl %al,%eax
  8004214a19:	c7 45 e4 f3 01 00 00 	movl   $0x1f3,-0x1c(%rbp)
  8004214a20:	88 45 e3             	mov    %al,-0x1d(%rbp)
  8004214a23:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004214a27:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004214a2a:	ee                   	out    %al,(%dx)
	outb(0x1F4, offset >> 8);
  8004214a2b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214a2f:	48 c1 e8 08          	shr    $0x8,%rax
  8004214a33:	0f b6 c0             	movzbl %al,%eax
  8004214a36:	c7 45 dc f4 01 00 00 	movl   $0x1f4,-0x24(%rbp)
  8004214a3d:	88 45 db             	mov    %al,-0x25(%rbp)
  8004214a40:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004214a44:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004214a47:	ee                   	out    %al,(%dx)
	outb(0x1F5, offset >> 16);
  8004214a48:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214a4c:	48 c1 e8 10          	shr    $0x10,%rax
  8004214a50:	0f b6 c0             	movzbl %al,%eax
  8004214a53:	c7 45 d4 f5 01 00 00 	movl   $0x1f5,-0x2c(%rbp)
  8004214a5a:	88 45 d3             	mov    %al,-0x2d(%rbp)
  8004214a5d:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004214a61:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004214a64:	ee                   	out    %al,(%dx)
	outb(0x1F6, (offset >> 24) | 0xE0);
  8004214a65:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214a69:	48 c1 e8 18          	shr    $0x18,%rax
  8004214a6d:	83 c8 e0             	or     $0xffffffe0,%eax
  8004214a70:	0f b6 c0             	movzbl %al,%eax
  8004214a73:	c7 45 cc f6 01 00 00 	movl   $0x1f6,-0x34(%rbp)
  8004214a7a:	88 45 cb             	mov    %al,-0x35(%rbp)
  8004214a7d:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004214a81:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004214a84:	ee                   	out    %al,(%dx)
  8004214a85:	c7 45 c4 f7 01 00 00 	movl   $0x1f7,-0x3c(%rbp)
  8004214a8c:	c6 45 c3 20          	movb   $0x20,-0x3d(%rbp)
  8004214a90:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
  8004214a94:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004214a97:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// cmd 0x20 - read sectors

	// wait for disk to be ready
	waitdisk();
  8004214a98:	48 b8 a9 49 21 04 80 	movabs $0x80042149a9,%rax
  8004214a9f:	00 00 00 
  8004214aa2:	ff d0                	callq  *%rax
  8004214aa4:	c7 45 bc f0 01 00 00 	movl   $0x1f0,-0x44(%rbp)
  8004214aab:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004214aaf:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004214ab3:	c7 45 ac 80 00 00 00 	movl   $0x80,-0x54(%rbp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
  8004214aba:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8004214abd:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004214ac1:	8b 55 ac             	mov    -0x54(%rbp),%edx
  8004214ac4:	49 89 cc             	mov    %rcx,%r12
  8004214ac7:	89 d3                	mov    %edx,%ebx
  8004214ac9:	4c 89 e7             	mov    %r12,%rdi
  8004214acc:	89 d9                	mov    %ebx,%ecx
  8004214ace:	89 c2                	mov    %eax,%edx
  8004214ad0:	fc                   	cld    
  8004214ad1:	f2 6d                	repnz insl (%dx),%es:(%rdi)
  8004214ad3:	89 cb                	mov    %ecx,%ebx
  8004214ad5:	49 89 fc             	mov    %rdi,%r12
  8004214ad8:	4c 89 65 b0          	mov    %r12,-0x50(%rbp)
  8004214adc:	89 5d ac             	mov    %ebx,-0x54(%rbp)

	// read a sector
	insl(0x1F0, dst, SECTSIZE/4);
}
  8004214adf:	48 83 c4 60          	add    $0x60,%rsp
  8004214ae3:	5b                   	pop    %rbx
  8004214ae4:	41 5c                	pop    %r12
  8004214ae6:	5d                   	pop    %rbp
  8004214ae7:	c3                   	retq   

0000008004214ae8 <mpentry_start>:
.set pml4, pml4phys

.code16           
.globl mpentry_start
mpentry_start:
	cli
  8004214ae8:	fa                   	cli    
	xorw    %ax, %ax
  8004214ae9:	31 c0                	xor    %eax,%eax
	movw    %ax, %ds
  8004214aeb:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004214aed:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004214aef:	8e d0                	mov    %eax,%ss
	
	
	lgdt    MPBOOTPHYS(gdt32desc)   // load 32 bit global descritor table
  8004214af1:	0f 01 16             	lgdt   (%rsi)
  8004214af4:	e0 70                	loopne 8004214b66 <start64+0x10>
	movl    %cr0, %eax
  8004214af6:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004214af9:	66 83 c8 01          	or     $0x1,%ax
	movl    %eax, %cr0
  8004214afd:	0f 22 c0             	mov    %rax,%cr0
	ljmp	$(PROT_MODE_CSEG),$(MPBOOTPHYS(start32))
  8004214b00:	ea                   	(bad)  
  8004214b01:	1d 70 08 00 66       	sbb    $0x66000870,%eax

0000008004214b05 <start32>:

.code32
start32:
	
	movw    $(PROT_MODE_DSEG), %ax
  8004214b05:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004214b09:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004214b0b:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004214b0d:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004214b0f:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004214b13:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004214b15:	8e e8                	mov    %eax,%gs

	movl $CR4_PAE,%eax
  8004214b17:	b8 20 00 00 00       	mov    $0x20,%eax
	movl %eax,%cr4
  8004214b1c:	0f 22 e0             	mov    %rax,%cr4
	
	lgdt    MPBOOTPHYS(gdtdesc)
  8004214b1f:	0f 01 15 c0 70 00 00 	lgdt   0x70c0(%rip)        # 800421bbe6 <bootstack+0x1be6>
	movl    %cr0, %eax
  8004214b26:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004214b29:	83 c8 01             	or     $0x1,%eax
	movl    %eax, %cr0
  8004214b2c:	0f 22 c0             	mov    %rax,%cr0
	
	# Set up initial page table. We cannot use kern_pgdir yet because
	# we are still running at a low EIP.
	movl    $pml4, %eax
  8004214b2f:	b8 00 20 10 00       	mov    $0x102000,%eax
	movl    %eax, %cr3
  8004214b34:	0f 22 d8             	mov    %rax,%cr3
	
	# enable the long mode in MSR
	movl $EFER_MSR,%ecx
  8004214b37:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
	rdmsr
  8004214b3c:	0f 32                	rdmsr  
	btsl $EFER_LME,%eax
  8004214b3e:	0f ba e8 08          	bts    $0x8,%eax
	wrmsr
  8004214b42:	0f 30                	wrmsr  
	
	# Turn on paging.
	movl    %cr0, %eax
  8004214b44:	0f 20 c0             	mov    %cr0,%rax
	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
  8004214b47:	0d 01 00 01 80       	or     $0x80010001,%eax
	movl    %eax, %cr0
  8004214b4c:	0f 22 c0             	mov    %rax,%cr0
	

	ljmpl   $(LONG_MODE_CSEG), $(MPBOOTPHYS(start64))
  8004214b4f:	ea                   	(bad)  
  8004214b50:	6e                   	outsb  %ds:(%rsi),(%dx)
  8004214b51:	70 00                	jo     8004214b53 <start32+0x4e>
  8004214b53:	00 08                	add    %cl,(%rax)
	...

0000008004214b56 <start64>:

.code64
start64:
	movw    $(LONG_MODE_DSEG), %ax
  8004214b56:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004214b5a:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004214b5c:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004214b5e:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004214b60:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004214b64:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004214b66:	8e e8                	mov    %eax,%gs

	# Switch to the per-cpu stack allocated in boot_aps()
	movabs    mpentry_kstack, %rax
  8004214b68:	48 a1 c8 c7 63 04 80 	movabs 0x800463c7c8,%rax
  8004214b6f:	00 00 00 
	movq    %rax,%rsp
  8004214b72:	48 89 c4             	mov    %rax,%rsp
	movq    $0x0, %rbp       # nuke frame pointer
  8004214b75:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Call mp_main().  (Exercise for the reader: why the indirect call?)
	movabs    $mp_main, %rax
  8004214b7c:	48 b8 2c 04 20 04 80 	movabs $0x800420042c,%rax
  8004214b83:	00 00 00 
	call    *%rax
  8004214b86:	ff d0                	callq  *%rax

0000008004214b88 <spin>:

	# If mp_main returns (it shouldn't), loop.
spin:
	jmp     spin
  8004214b88:	eb fe                	jmp    8004214b88 <spin>
  8004214b8a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000008004214b90 <gdt>:
	...
  8004214b98:	ff                   	(bad)  
  8004214b99:	ff 00                	incl   (%rax)
  8004214b9b:	00 00                	add    %al,(%rax)
  8004214b9d:	9a                   	(bad)  
  8004214b9e:	af                   	scas   %es:(%rdi),%eax
  8004214b9f:	00 ff                	add    %bh,%bh
  8004214ba1:	ff 00                	incl   (%rax)
  8004214ba3:	00 00                	add    %al,(%rax)
  8004214ba5:	92                   	xchg   %eax,%edx
  8004214ba6:	af                   	scas   %es:(%rdi),%eax
	...

0000008004214ba8 <gdtdesc>:
  8004214ba8:	17                   	(bad)  
  8004214ba9:	00 a8 70 00 00 66    	add    %ch,0x66000070(%rax)
  8004214baf:	90                   	nop

0000008004214bb0 <gdt32>:
	...
  8004214bb8:	ff                   	(bad)  
  8004214bb9:	ff 00                	incl   (%rax)
  8004214bbb:	00 00                	add    %al,(%rax)
  8004214bbd:	9a                   	(bad)  
  8004214bbe:	cf                   	iret   
  8004214bbf:	00 ff                	add    %bh,%bh
  8004214bc1:	ff 00                	incl   (%rax)
  8004214bc3:	00 00                	add    %al,(%rax)
  8004214bc5:	92                   	xchg   %eax,%edx
  8004214bc6:	cf                   	iret   
	...

0000008004214bc8 <gdt32desc>:
  8004214bc8:	17                   	(bad)  
  8004214bc9:	00 c8                	add    %cl,%al
  8004214bcb:	70 00                	jo     8004214bcd <gdt32desc+0x5>
	...

0000008004214bce <mpentry_end>:
	.long   MPBOOTPHYS(gdt32)			# address gdt


.globl mpentry_end
mpentry_end:
	nop
  8004214bce:	90                   	nop
	...

0000008004214bd0 <sum>:
#define MPIOINTR  0x03  // One per bus interrupt source
#define MPLINTR   0x04  // One per system interrupt source

static uint8_t
sum(void *addr, int len)
{
  8004214bd0:	55                   	push   %rbp
  8004214bd1:	48 89 e5             	mov    %rsp,%rbp
  8004214bd4:	48 83 ec 20          	sub    $0x20,%rsp
  8004214bd8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004214bdc:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	int i, sum;

	sum = 0;
  8004214bdf:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < len; i++)
  8004214be6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004214bed:	eb 16                	jmp    8004214c05 <sum+0x35>
		sum += ((uint8_t *)addr)[i];
  8004214bef:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004214bf2:	48 98                	cltq   
  8004214bf4:	48 03 45 e8          	add    -0x18(%rbp),%rax
  8004214bf8:	0f b6 00             	movzbl (%rax),%eax
  8004214bfb:	0f b6 c0             	movzbl %al,%eax
  8004214bfe:	01 45 f8             	add    %eax,-0x8(%rbp)
sum(void *addr, int len)
{
	int i, sum;

	sum = 0;
	for (i = 0; i < len; i++)
  8004214c01:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004214c05:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004214c08:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  8004214c0b:	7c e2                	jl     8004214bef <sum+0x1f>
		sum += ((uint8_t *)addr)[i];
	return sum;
  8004214c0d:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  8004214c10:	c9                   	leaveq 
  8004214c11:	c3                   	retq   

0000008004214c12 <mpsearch1>:

// Look for an MP structure in the len bytes at physical address addr.
static struct mp *
mpsearch1(physaddr_t a, int len)
{
  8004214c12:	55                   	push   %rbp
  8004214c13:	48 89 e5             	mov    %rsp,%rbp
  8004214c16:	48 83 ec 40          	sub    $0x40,%rsp
  8004214c1a:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004214c1e:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	struct mp *mp = KADDR(a), *end = KADDR(a + len);
  8004214c21:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214c25:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004214c29:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214c2d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004214c31:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004214c34:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004214c37:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004214c3e:	00 00 00 
  8004214c41:	48 8b 00             	mov    (%rax),%rax
  8004214c44:	48 39 c2             	cmp    %rax,%rdx
  8004214c47:	72 32                	jb     8004214c7b <mpsearch1+0x69>
  8004214c49:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214c4d:	48 89 c1             	mov    %rax,%rcx
  8004214c50:	48 ba f0 95 21 04 80 	movabs $0x80042195f0,%rdx
  8004214c57:	00 00 00 
  8004214c5a:	be 57 00 00 00       	mov    $0x57,%esi
  8004214c5f:	48 bf 13 96 21 04 80 	movabs $0x8004219613,%rdi
  8004214c66:	00 00 00 
  8004214c69:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214c6e:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004214c75:	00 00 00 
  8004214c78:	41 ff d0             	callq  *%r8
  8004214c7b:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004214c82:	00 00 00 
  8004214c85:	48 03 45 f0          	add    -0x10(%rbp),%rax
  8004214c89:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004214c8d:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004214c90:	48 98                	cltq   
  8004214c92:	48 03 45 c8          	add    -0x38(%rbp),%rax
  8004214c96:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004214c9a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214c9e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004214ca2:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004214ca5:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004214ca8:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004214caf:	00 00 00 
  8004214cb2:	48 8b 00             	mov    (%rax),%rax
  8004214cb5:	48 39 c2             	cmp    %rax,%rdx
  8004214cb8:	72 32                	jb     8004214cec <mpsearch1+0xda>
  8004214cba:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214cbe:	48 89 c1             	mov    %rax,%rcx
  8004214cc1:	48 ba f0 95 21 04 80 	movabs $0x80042195f0,%rdx
  8004214cc8:	00 00 00 
  8004214ccb:	be 57 00 00 00       	mov    $0x57,%esi
  8004214cd0:	48 bf 13 96 21 04 80 	movabs $0x8004219613,%rdi
  8004214cd7:	00 00 00 
  8004214cda:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214cdf:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004214ce6:	00 00 00 
  8004214ce9:	41 ff d0             	callq  *%r8
  8004214cec:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004214cf3:	00 00 00 
  8004214cf6:	48 03 45 e0          	add    -0x20(%rbp),%rax
  8004214cfa:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	for (; mp < end; mp++)
  8004214cfe:	eb 4d                	jmp    8004214d4d <mpsearch1+0x13b>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  8004214d00:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214d04:	ba 04 00 00 00       	mov    $0x4,%edx
  8004214d09:	48 be 23 96 21 04 80 	movabs $0x8004219623,%rsi
  8004214d10:	00 00 00 
  8004214d13:	48 89 c7             	mov    %rax,%rdi
  8004214d16:	48 b8 29 e8 20 04 80 	movabs $0x800420e829,%rax
  8004214d1d:	00 00 00 
  8004214d20:	ff d0                	callq  *%rax
  8004214d22:	85 c0                	test   %eax,%eax
  8004214d24:	75 22                	jne    8004214d48 <mpsearch1+0x136>
		    sum(mp, sizeof(*mp)) == 0)
  8004214d26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214d2a:	be 10 00 00 00       	mov    $0x10,%esi
  8004214d2f:	48 89 c7             	mov    %rax,%rdi
  8004214d32:	48 b8 d0 4b 21 04 80 	movabs $0x8004214bd0,%rax
  8004214d39:	00 00 00 
  8004214d3c:	ff d0                	callq  *%rax
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  8004214d3e:	84 c0                	test   %al,%al
  8004214d40:	75 06                	jne    8004214d48 <mpsearch1+0x136>
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
  8004214d42:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214d46:	eb 14                	jmp    8004214d5c <mpsearch1+0x14a>
static struct mp *
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
  8004214d48:	48 83 45 f8 10       	addq   $0x10,-0x8(%rbp)
  8004214d4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214d51:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004214d55:	72 a9                	jb     8004214d00 <mpsearch1+0xee>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
	return NULL;
  8004214d57:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214d5c:	c9                   	leaveq 
  8004214d5d:	c3                   	retq   

0000008004214d5e <mpsearch>:
// 1) in the first KB of the EBDA;
// 2) if there is no EBDA, in the last KB of system base memory;
// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
static struct mp *
mpsearch(void)
{
  8004214d5e:	55                   	push   %rbp
  8004214d5f:	48 89 e5             	mov    %rsp,%rbp
  8004214d62:	48 83 ec 30          	sub    $0x30,%rsp
	struct mp *mp;

	//static_assert(sizeof(*mp) == 32);

	// The BIOS data area lives in 16-bit segment 0x40.
	bda = (uint8_t *) KADDR(0x40 << 4);
  8004214d66:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  8004214d6d:	00 
  8004214d6e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214d72:	48 c1 e8 0c          	shr    $0xc,%rax
  8004214d76:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004214d79:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004214d7c:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004214d83:	00 00 00 
  8004214d86:	48 8b 00             	mov    (%rax),%rax
  8004214d89:	48 39 c2             	cmp    %rax,%rdx
  8004214d8c:	72 32                	jb     8004214dc0 <mpsearch+0x62>
  8004214d8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214d92:	48 89 c1             	mov    %rax,%rcx
  8004214d95:	48 ba f0 95 21 04 80 	movabs $0x80042195f0,%rdx
  8004214d9c:	00 00 00 
  8004214d9f:	be 6f 00 00 00       	mov    $0x6f,%esi
  8004214da4:	48 bf 13 96 21 04 80 	movabs $0x8004219613,%rdi
  8004214dab:	00 00 00 
  8004214dae:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214db3:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004214dba:	00 00 00 
  8004214dbd:	41 ff d0             	callq  *%r8
  8004214dc0:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004214dc7:	00 00 00 
  8004214dca:	48 03 45 f8          	add    -0x8(%rbp),%rax
  8004214dce:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// [MP 4] The 16-bit segment of the EBDA is in the two bytes
	// starting at byte 0x0E of the BDA.  0 if not present.
	if ((p = *(uint16_t *) (bda + 0x0E))) {
  8004214dd2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214dd6:	48 83 c0 0e          	add    $0xe,%rax
  8004214dda:	0f b7 00             	movzwl (%rax),%eax
  8004214ddd:	0f b7 c0             	movzwl %ax,%eax
  8004214de0:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004214de3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004214de7:	74 2c                	je     8004214e15 <mpsearch+0xb7>
		p <<= 4;	// Translate from segment to PA
  8004214de9:	c1 65 e4 04          	shll   $0x4,-0x1c(%rbp)
		if ((mp = mpsearch1(p, 1024)))
  8004214ded:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004214df0:	be 00 04 00 00       	mov    $0x400,%esi
  8004214df5:	48 89 c7             	mov    %rax,%rdi
  8004214df8:	48 b8 12 4c 21 04 80 	movabs $0x8004214c12,%rax
  8004214dff:	00 00 00 
  8004214e02:	ff d0                	callq  *%rax
  8004214e04:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004214e08:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004214e0d:	74 49                	je     8004214e58 <mpsearch+0xfa>
			return mp;
  8004214e0f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214e13:	eb 59                	jmp    8004214e6e <mpsearch+0x110>
	} else {
		// The size of base memory, in KB is in the two bytes
		// starting at 0x13 of the BDA.
		p = *(uint16_t *) (bda + 0x13) * 1024;
  8004214e15:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214e19:	48 83 c0 13          	add    $0x13,%rax
  8004214e1d:	0f b7 00             	movzwl (%rax),%eax
  8004214e20:	0f b7 c0             	movzwl %ax,%eax
  8004214e23:	c1 e0 0a             	shl    $0xa,%eax
  8004214e26:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if ((mp = mpsearch1(p - 1024, 1024)))
  8004214e29:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004214e2c:	2d 00 04 00 00       	sub    $0x400,%eax
  8004214e31:	89 c0                	mov    %eax,%eax
  8004214e33:	be 00 04 00 00       	mov    $0x400,%esi
  8004214e38:	48 89 c7             	mov    %rax,%rdi
  8004214e3b:	48 b8 12 4c 21 04 80 	movabs $0x8004214c12,%rax
  8004214e42:	00 00 00 
  8004214e45:	ff d0                	callq  *%rax
  8004214e47:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004214e4b:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004214e50:	74 06                	je     8004214e58 <mpsearch+0xfa>
			return mp;
  8004214e52:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214e56:	eb 16                	jmp    8004214e6e <mpsearch+0x110>
	}
	return mpsearch1(0xF0000, 0x10000);
  8004214e58:	be 00 00 01 00       	mov    $0x10000,%esi
  8004214e5d:	bf 00 00 0f 00       	mov    $0xf0000,%edi
  8004214e62:	48 b8 12 4c 21 04 80 	movabs $0x8004214c12,%rax
  8004214e69:	00 00 00 
  8004214e6c:	ff d0                	callq  *%rax
}
  8004214e6e:	c9                   	leaveq 
  8004214e6f:	c3                   	retq   

0000008004214e70 <mpconfig>:
// Search for an MP configuration table.  For now, don't accept the
// default configurations (physaddr == 0).
// Check for the correct signature, checksum, and version.
static struct mpconf *
mpconfig(struct mp **pmp)
{
  8004214e70:	55                   	push   %rbp
  8004214e71:	48 89 e5             	mov    %rsp,%rbp
  8004214e74:	48 83 ec 30          	sub    $0x30,%rsp
  8004214e78:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	struct mpconf *conf;
	struct mp *mp;

	if ((mp = mpsearch()) == 0)
  8004214e7c:	48 b8 5e 4d 21 04 80 	movabs $0x8004214d5e,%rax
  8004214e83:	00 00 00 
  8004214e86:	ff d0                	callq  *%rax
  8004214e88:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004214e8c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004214e91:	75 0a                	jne    8004214e9d <mpconfig+0x2d>
		return NULL;
  8004214e93:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214e98:	e9 f0 01 00 00       	jmpq   800421508d <mpconfig+0x21d>
	if (mp->physaddr == 0 || mp->type != 0) {
  8004214e9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214ea1:	8b 40 04             	mov    0x4(%rax),%eax
  8004214ea4:	85 c0                	test   %eax,%eax
  8004214ea6:	74 0c                	je     8004214eb4 <mpconfig+0x44>
  8004214ea8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214eac:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8004214eb0:	84 c0                	test   %al,%al
  8004214eb2:	74 25                	je     8004214ed9 <mpconfig+0x69>
		cprintf("SMP: Default configurations not implemented\n");
  8004214eb4:	48 bf 28 96 21 04 80 	movabs $0x8004219628,%rdi
  8004214ebb:	00 00 00 
  8004214ebe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214ec3:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  8004214eca:	00 00 00 
  8004214ecd:	ff d2                	callq  *%rdx
		return NULL;
  8004214ecf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214ed4:	e9 b4 01 00 00       	jmpq   800421508d <mpconfig+0x21d>
	}
	conf = (struct mpconf *) KADDR(mp->physaddr);
  8004214ed9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214edd:	8b 40 04             	mov    0x4(%rax),%eax
  8004214ee0:	89 c0                	mov    %eax,%eax
  8004214ee2:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004214ee6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214eea:	48 c1 e8 0c          	shr    $0xc,%rax
  8004214eee:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004214ef1:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004214ef4:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004214efb:	00 00 00 
  8004214efe:	48 8b 00             	mov    (%rax),%rax
  8004214f01:	48 39 c2             	cmp    %rax,%rdx
  8004214f04:	72 32                	jb     8004214f38 <mpconfig+0xc8>
  8004214f06:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214f0a:	48 89 c1             	mov    %rax,%rcx
  8004214f0d:	48 ba f0 95 21 04 80 	movabs $0x80042195f0,%rdx
  8004214f14:	00 00 00 
  8004214f17:	be 90 00 00 00       	mov    $0x90,%esi
  8004214f1c:	48 bf 13 96 21 04 80 	movabs $0x8004219613,%rdi
  8004214f23:	00 00 00 
  8004214f26:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214f2b:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004214f32:	00 00 00 
  8004214f35:	41 ff d0             	callq  *%r8
  8004214f38:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004214f3f:	00 00 00 
  8004214f42:	48 03 45 f0          	add    -0x10(%rbp),%rax
  8004214f46:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (memcmp(conf, "PCMP", 4) != 0) {
  8004214f4a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214f4e:	ba 04 00 00 00       	mov    $0x4,%edx
  8004214f53:	48 be 55 96 21 04 80 	movabs $0x8004219655,%rsi
  8004214f5a:	00 00 00 
  8004214f5d:	48 89 c7             	mov    %rax,%rdi
  8004214f60:	48 b8 29 e8 20 04 80 	movabs $0x800420e829,%rax
  8004214f67:	00 00 00 
  8004214f6a:	ff d0                	callq  *%rax
  8004214f6c:	85 c0                	test   %eax,%eax
  8004214f6e:	74 25                	je     8004214f95 <mpconfig+0x125>
		cprintf("SMP: Incorrect MP configuration table signature\n");
  8004214f70:	48 bf 60 96 21 04 80 	movabs $0x8004219660,%rdi
  8004214f77:	00 00 00 
  8004214f7a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214f7f:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  8004214f86:	00 00 00 
  8004214f89:	ff d2                	callq  *%rdx
		return NULL;
  8004214f8b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214f90:	e9 f8 00 00 00       	jmpq   800421508d <mpconfig+0x21d>
	}
	if (sum(conf, conf->length) != 0) {
  8004214f95:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214f99:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  8004214f9d:	0f b7 d0             	movzwl %ax,%edx
  8004214fa0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214fa4:	89 d6                	mov    %edx,%esi
  8004214fa6:	48 89 c7             	mov    %rax,%rdi
  8004214fa9:	48 b8 d0 4b 21 04 80 	movabs $0x8004214bd0,%rax
  8004214fb0:	00 00 00 
  8004214fb3:	ff d0                	callq  *%rax
  8004214fb5:	84 c0                	test   %al,%al
  8004214fb7:	74 25                	je     8004214fde <mpconfig+0x16e>
		cprintf("SMP: Bad MP configuration checksum\n");
  8004214fb9:	48 bf 98 96 21 04 80 	movabs $0x8004219698,%rdi
  8004214fc0:	00 00 00 
  8004214fc3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214fc8:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  8004214fcf:	00 00 00 
  8004214fd2:	ff d2                	callq  *%rdx
		return NULL;
  8004214fd4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214fd9:	e9 af 00 00 00       	jmpq   800421508d <mpconfig+0x21d>
	}
	if (conf->version != 1 && conf->version != 4) {
  8004214fde:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214fe2:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004214fe6:	3c 01                	cmp    $0x1,%al
  8004214fe8:	74 3b                	je     8004215025 <mpconfig+0x1b5>
  8004214fea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214fee:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004214ff2:	3c 04                	cmp    $0x4,%al
  8004214ff4:	74 2f                	je     8004215025 <mpconfig+0x1b5>
		cprintf("SMP: Unsupported MP version %d\n", conf->version);
  8004214ff6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214ffa:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004214ffe:	0f b6 c0             	movzbl %al,%eax
  8004215001:	89 c6                	mov    %eax,%esi
  8004215003:	48 bf c0 96 21 04 80 	movabs $0x80042196c0,%rdi
  800421500a:	00 00 00 
  800421500d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215012:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  8004215019:	00 00 00 
  800421501c:	ff d2                	callq  *%rdx
		return NULL;
  800421501e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215023:	eb 68                	jmp    800421508d <mpconfig+0x21d>
	}
	if (sum((uint8_t *)conf + conf->length, conf->xlength) != conf->xchecksum) {
  8004215025:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215029:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  800421502d:	0f b7 d0             	movzwl %ax,%edx
  8004215030:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215034:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  8004215038:	0f b7 c0             	movzwl %ax,%eax
  800421503b:	48 03 45 e0          	add    -0x20(%rbp),%rax
  800421503f:	89 d6                	mov    %edx,%esi
  8004215041:	48 89 c7             	mov    %rax,%rdi
  8004215044:	48 b8 d0 4b 21 04 80 	movabs $0x8004214bd0,%rax
  800421504b:	00 00 00 
  800421504e:	ff d0                	callq  *%rax
  8004215050:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215054:	0f b6 52 2a          	movzbl 0x2a(%rdx),%edx
  8004215058:	38 d0                	cmp    %dl,%al
  800421505a:	74 22                	je     800421507e <mpconfig+0x20e>
		cprintf("SMP: Bad MP configuration extended checksum\n");
  800421505c:	48 bf e0 96 21 04 80 	movabs $0x80042196e0,%rdi
  8004215063:	00 00 00 
  8004215066:	b8 00 00 00 00       	mov    $0x0,%eax
  800421506b:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  8004215072:	00 00 00 
  8004215075:	ff d2                	callq  *%rdx
		return NULL;
  8004215077:	b8 00 00 00 00       	mov    $0x0,%eax
  800421507c:	eb 0f                	jmp    800421508d <mpconfig+0x21d>
	}
	*pmp = mp;
  800421507e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215082:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215086:	48 89 10             	mov    %rdx,(%rax)
	return conf;
  8004215089:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  800421508d:	c9                   	leaveq 
  800421508e:	c3                   	retq   

000000800421508f <mp_init>:

void
mp_init(void)
{
  800421508f:	55                   	push   %rbp
  8004215090:	48 89 e5             	mov    %rsp,%rbp
  8004215093:	53                   	push   %rbx
  8004215094:	48 83 ec 58          	sub    $0x58,%rsp
	struct mpconf *conf;
	struct mpproc *proc;
	uint8_t *p;
	unsigned int i;

	bootcpu = &cpus[0];
  8004215098:	48 b8 e0 e3 67 04 80 	movabs $0x800467e3e0,%rax
  800421509f:	00 00 00 
  80042150a2:	48 ba 20 e0 67 04 80 	movabs $0x800467e020,%rdx
  80042150a9:	00 00 00 
  80042150ac:	48 89 10             	mov    %rdx,(%rax)
	if ((conf = mpconfig(&mp)) == 0)
  80042150af:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  80042150b3:	48 89 c7             	mov    %rax,%rdi
  80042150b6:	48 b8 70 4e 21 04 80 	movabs $0x8004214e70,%rax
  80042150bd:	00 00 00 
  80042150c0:	ff d0                	callq  *%rax
  80042150c2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042150c6:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042150cb:	0f 84 bd 02 00 00    	je     800421538e <mp_init+0x2ff>
		return;
	ismp = 1;
  80042150d1:	48 b8 00 e0 67 04 80 	movabs $0x800467e000,%rax
  80042150d8:	00 00 00 
  80042150db:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	lapicaddr = conf->lapicaddr;
  80042150e1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042150e5:	8b 40 24             	mov    0x24(%rax),%eax
  80042150e8:	89 c2                	mov    %eax,%edx
  80042150ea:	48 b8 00 f0 6f 04 80 	movabs $0x80046ff000,%rax
  80042150f1:	00 00 00 
  80042150f4:	48 89 10             	mov    %rdx,(%rax)

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  80042150f7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042150fb:	48 83 c0 2c          	add    $0x2c,%rax
  80042150ff:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004215103:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  800421510a:	e9 5c 01 00 00       	jmpq   800421526b <mp_init+0x1dc>
		switch (*p) {
  800421510f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215113:	0f b6 00             	movzbl (%rax),%eax
  8004215116:	0f b6 c0             	movzbl %al,%eax
  8004215119:	85 c0                	test   %eax,%eax
  800421511b:	74 16                	je     8004215133 <mp_init+0xa4>
  800421511d:	85 c0                	test   %eax,%eax
  800421511f:	0f 88 fd 00 00 00    	js     8004215222 <mp_init+0x193>
  8004215125:	83 f8 04             	cmp    $0x4,%eax
  8004215128:	0f 8f f4 00 00 00    	jg     8004215222 <mp_init+0x193>
  800421512e:	e9 e8 00 00 00       	jmpq   800421521b <mp_init+0x18c>
		case MPPROC:
			proc = (struct mpproc *)p;
  8004215133:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215137:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			if (proc->flags & MPPROC_BOOT)
  800421513b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421513f:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  8004215143:	0f b6 c0             	movzbl %al,%eax
  8004215146:	83 e0 02             	and    $0x2,%eax
  8004215149:	85 c0                	test   %eax,%eax
  800421514b:	74 36                	je     8004215183 <mp_init+0xf4>
				bootcpu = &cpus[ncpu];
  800421514d:	48 b8 e8 e3 67 04 80 	movabs $0x800467e3e8,%rax
  8004215154:	00 00 00 
  8004215157:	8b 00                	mov    (%rax),%eax
  8004215159:	48 98                	cltq   
  800421515b:	48 c1 e0 03          	shl    $0x3,%rax
  800421515f:	48 89 c2             	mov    %rax,%rdx
  8004215162:	48 c1 e2 04          	shl    $0x4,%rdx
  8004215166:	48 29 c2             	sub    %rax,%rdx
  8004215169:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  8004215170:	00 00 00 
  8004215173:	48 01 c2             	add    %rax,%rdx
  8004215176:	48 b8 e0 e3 67 04 80 	movabs $0x800467e3e0,%rax
  800421517d:	00 00 00 
  8004215180:	48 89 10             	mov    %rdx,(%rax)
			if (ncpu < NCPU) {
  8004215183:	48 b8 e8 e3 67 04 80 	movabs $0x800467e3e8,%rax
  800421518a:	00 00 00 
  800421518d:	8b 00                	mov    (%rax),%eax
  800421518f:	83 f8 07             	cmp    $0x7,%eax
  8004215192:	7f 58                	jg     80042151ec <mp_init+0x15d>
				cpus[ncpu].cpu_id = ncpu;
  8004215194:	48 b8 e8 e3 67 04 80 	movabs $0x800467e3e8,%rax
  800421519b:	00 00 00 
  800421519e:	8b 10                	mov    (%rax),%edx
  80042151a0:	48 b8 e8 e3 67 04 80 	movabs $0x800467e3e8,%rax
  80042151a7:	00 00 00 
  80042151aa:	8b 00                	mov    (%rax),%eax
  80042151ac:	89 c1                	mov    %eax,%ecx
  80042151ae:	48 be 20 e0 67 04 80 	movabs $0x800467e020,%rsi
  80042151b5:	00 00 00 
  80042151b8:	48 63 c2             	movslq %edx,%rax
  80042151bb:	48 c1 e0 03          	shl    $0x3,%rax
  80042151bf:	48 89 c2             	mov    %rax,%rdx
  80042151c2:	48 c1 e2 04          	shl    $0x4,%rdx
  80042151c6:	48 29 c2             	sub    %rax,%rdx
  80042151c9:	48 8d 04 16          	lea    (%rsi,%rdx,1),%rax
  80042151cd:	88 08                	mov    %cl,(%rax)
				ncpu++;
  80042151cf:	48 b8 e8 e3 67 04 80 	movabs $0x800467e3e8,%rax
  80042151d6:	00 00 00 
  80042151d9:	8b 00                	mov    (%rax),%eax
  80042151db:	8d 50 01             	lea    0x1(%rax),%edx
  80042151de:	48 b8 e8 e3 67 04 80 	movabs $0x800467e3e8,%rax
  80042151e5:	00 00 00 
  80042151e8:	89 10                	mov    %edx,(%rax)
  80042151ea:	eb 28                	jmp    8004215214 <mp_init+0x185>
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
					proc->apicid);
  80042151ec:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042151f0:	0f b6 40 01          	movzbl 0x1(%rax),%eax
				bootcpu = &cpus[ncpu];
			if (ncpu < NCPU) {
				cpus[ncpu].cpu_id = ncpu;
				ncpu++;
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
  80042151f4:	0f b6 c0             	movzbl %al,%eax
  80042151f7:	89 c6                	mov    %eax,%esi
  80042151f9:	48 bf 10 97 21 04 80 	movabs $0x8004219710,%rdi
  8004215200:	00 00 00 
  8004215203:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215208:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  800421520f:	00 00 00 
  8004215212:	ff d2                	callq  *%rdx
					proc->apicid);
			}
			p += sizeof(struct mpproc);
  8004215214:	48 83 45 e8 14       	addq   $0x14,-0x18(%rbp)
			continue;
  8004215219:	eb 4c                	jmp    8004215267 <mp_init+0x1d8>
		case MPBUS:
		case MPIOAPIC:
		case MPIOINTR:
		case MPLINTR:
			p += 8;
  800421521b:	48 83 45 e8 08       	addq   $0x8,-0x18(%rbp)
			continue;
  8004215220:	eb 45                	jmp    8004215267 <mp_init+0x1d8>
		default:
			cprintf("mpinit: unknown config type %x\n", *p);
  8004215222:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215226:	0f b6 00             	movzbl (%rax),%eax
  8004215229:	0f b6 c0             	movzbl %al,%eax
  800421522c:	89 c6                	mov    %eax,%esi
  800421522e:	48 bf 38 97 21 04 80 	movabs $0x8004219738,%rdi
  8004215235:	00 00 00 
  8004215238:	b8 00 00 00 00       	mov    $0x0,%eax
  800421523d:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  8004215244:	00 00 00 
  8004215247:	ff d2                	callq  *%rdx
			ismp = 0;
  8004215249:	48 b8 00 e0 67 04 80 	movabs $0x800467e000,%rax
  8004215250:	00 00 00 
  8004215253:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
			i = conf->entry;
  8004215259:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421525d:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  8004215261:	0f b7 c0             	movzwl %ax,%eax
  8004215264:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	if ((conf = mpconfig(&mp)) == 0)
		return;
	ismp = 1;
	lapicaddr = conf->lapicaddr;

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  8004215267:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
  800421526b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421526f:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  8004215273:	0f b7 c0             	movzwl %ax,%eax
  8004215276:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  8004215279:	0f 87 90 fe ff ff    	ja     800421510f <mp_init+0x80>
			ismp = 0;
			i = conf->entry;
		}
	}

	bootcpu->cpu_status = CPU_STARTED;
  800421527f:	48 b8 e0 e3 67 04 80 	movabs $0x800467e3e0,%rax
  8004215286:	00 00 00 
  8004215289:	48 8b 00             	mov    (%rax),%rax
  800421528c:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
	if (!ismp) {
  8004215293:	48 b8 00 e0 67 04 80 	movabs $0x800467e000,%rax
  800421529a:	00 00 00 
  800421529d:	8b 00                	mov    (%rax),%eax
  800421529f:	85 c0                	test   %eax,%eax
  80042152a1:	75 41                	jne    80042152e4 <mp_init+0x255>
		// Didn't like what we found; fall back to no MP.
		ncpu = 1;
  80042152a3:	48 b8 e8 e3 67 04 80 	movabs $0x800467e3e8,%rax
  80042152aa:	00 00 00 
  80042152ad:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
		lapicaddr = 0;
  80042152b3:	48 b8 00 f0 6f 04 80 	movabs $0x80046ff000,%rax
  80042152ba:	00 00 00 
  80042152bd:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		cprintf("SMP: configuration not found, SMP disabled\n");
  80042152c4:	48 bf 58 97 21 04 80 	movabs $0x8004219758,%rdi
  80042152cb:	00 00 00 
  80042152ce:	b8 00 00 00 00       	mov    $0x0,%eax
  80042152d3:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  80042152da:	00 00 00 
  80042152dd:	ff d2                	callq  *%rdx
		return;
  80042152df:	e9 ab 00 00 00       	jmpq   800421538f <mp_init+0x300>
	}
	cprintf("SMP: CPU %d found %d CPU(s)\n", bootcpu->cpu_id,  ncpu);
  80042152e4:	48 b8 e8 e3 67 04 80 	movabs $0x800467e3e8,%rax
  80042152eb:	00 00 00 
  80042152ee:	8b 10                	mov    (%rax),%edx
  80042152f0:	48 b8 e0 e3 67 04 80 	movabs $0x800467e3e0,%rax
  80042152f7:	00 00 00 
  80042152fa:	48 8b 00             	mov    (%rax),%rax
  80042152fd:	0f b6 00             	movzbl (%rax),%eax
  8004215300:	0f b6 c0             	movzbl %al,%eax
  8004215303:	89 c6                	mov    %eax,%esi
  8004215305:	48 bf 84 97 21 04 80 	movabs $0x8004219784,%rdi
  800421530c:	00 00 00 
  800421530f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215314:	48 b9 f2 89 20 04 80 	movabs $0x80042089f2,%rcx
  800421531b:	00 00 00 
  800421531e:	ff d1                	callq  *%rcx

	if (mp->imcrp) {
  8004215320:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004215324:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  8004215328:	84 c0                	test   %al,%al
  800421532a:	74 63                	je     800421538f <mp_init+0x300>
		// [MP 3.2.6.1] If the hardware implements PIC mode,
		// switch to getting interrupts from the LAPIC.
		cprintf("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");
  800421532c:	48 bf a8 97 21 04 80 	movabs $0x80042197a8,%rdi
  8004215333:	00 00 00 
  8004215336:	b8 00 00 00 00       	mov    $0x0,%eax
  800421533b:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  8004215342:	00 00 00 
  8004215345:	ff d2                	callq  *%rdx
  8004215347:	c7 45 cc 22 00 00 00 	movl   $0x22,-0x34(%rbp)
  800421534e:	c6 45 cb 70          	movb   $0x70,-0x35(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004215352:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004215356:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004215359:	ee                   	out    %al,(%dx)
  800421535a:	c7 45 c4 23 00 00 00 	movl   $0x23,-0x3c(%rbp)

static __inline uint8_t
inb(int port)
{
	uint8_t data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004215361:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004215364:	89 55 ac             	mov    %edx,-0x54(%rbp)
  8004215367:	8b 55 ac             	mov    -0x54(%rbp),%edx
  800421536a:	ec                   	in     (%dx),%al
  800421536b:	89 c3                	mov    %eax,%ebx
  800421536d:	88 5d c3             	mov    %bl,-0x3d(%rbp)
	return data;
  8004215370:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
		outb(0x22, 0x70);   // Select IMCR
		outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
  8004215374:	83 c8 01             	or     $0x1,%eax
  8004215377:	0f b6 c0             	movzbl %al,%eax
  800421537a:	c7 45 bc 23 00 00 00 	movl   $0x23,-0x44(%rbp)
  8004215381:	88 45 bb             	mov    %al,-0x45(%rbp)
}

static __inline void
outb(int port, uint8_t data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004215384:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  8004215388:	8b 55 bc             	mov    -0x44(%rbp),%edx
  800421538b:	ee                   	out    %al,(%dx)
  800421538c:	eb 01                	jmp    800421538f <mp_init+0x300>
	uint8_t *p;
	unsigned int i;

	bootcpu = &cpus[0];
	if ((conf = mpconfig(&mp)) == 0)
		return;
  800421538e:	90                   	nop
		// switch to getting interrupts from the LAPIC.
		cprintf("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");
		outb(0x22, 0x70);   // Select IMCR
		outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
	}
}
  800421538f:	48 83 c4 58          	add    $0x58,%rsp
  8004215393:	5b                   	pop    %rbx
  8004215394:	5d                   	pop    %rbp
  8004215395:	c3                   	retq   
	...

0000008004215398 <lapicw>:
physaddr_t lapicaddr;        // Initialized in mpconfig.c
volatile uint32_t *lapic;

static void
lapicw(int index, int value)
{
  8004215398:	55                   	push   %rbp
  8004215399:	48 89 e5             	mov    %rsp,%rbp
  800421539c:	48 83 ec 08          	sub    $0x8,%rsp
  80042153a0:	89 7d fc             	mov    %edi,-0x4(%rbp)
  80042153a3:	89 75 f8             	mov    %esi,-0x8(%rbp)
	lapic[index] = value;
  80042153a6:	48 b8 08 f0 6f 04 80 	movabs $0x80046ff008,%rax
  80042153ad:	00 00 00 
  80042153b0:	48 8b 00             	mov    (%rax),%rax
  80042153b3:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042153b6:	48 63 d2             	movslq %edx,%rdx
  80042153b9:	48 c1 e2 02          	shl    $0x2,%rdx
  80042153bd:	48 01 c2             	add    %rax,%rdx
  80042153c0:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042153c3:	89 02                	mov    %eax,(%rdx)
	lapic[ID];  // wait for write to finish, by reading
  80042153c5:	48 b8 08 f0 6f 04 80 	movabs $0x80046ff008,%rax
  80042153cc:	00 00 00 
  80042153cf:	48 8b 00             	mov    (%rax),%rax
  80042153d2:	48 83 c0 20          	add    $0x20,%rax
  80042153d6:	8b 00                	mov    (%rax),%eax
}
  80042153d8:	c9                   	leaveq 
  80042153d9:	c3                   	retq   

00000080042153da <lapic_init>:

void
lapic_init(void)
{
  80042153da:	55                   	push   %rbp
  80042153db:	48 89 e5             	mov    %rsp,%rbp
	if (!lapicaddr)
  80042153de:	48 b8 00 f0 6f 04 80 	movabs $0x80046ff000,%rax
  80042153e5:	00 00 00 
  80042153e8:	48 8b 00             	mov    (%rax),%rax
  80042153eb:	48 85 c0             	test   %rax,%rax
  80042153ee:	0f 84 de 01 00 00    	je     80042155d2 <lapic_init+0x1f8>
		return;

	// lapicaddr is the physical address of the LAPIC's 4K MMIO
	// region.  Map it in to virtual memory so we can access it.
	lapic = mmio_map_region(lapicaddr, 4096);
  80042153f4:	48 b8 00 f0 6f 04 80 	movabs $0x80046ff000,%rax
  80042153fb:	00 00 00 
  80042153fe:	48 8b 00             	mov    (%rax),%rax
  8004215401:	be 00 10 00 00       	mov    $0x1000,%esi
  8004215406:	48 89 c7             	mov    %rax,%rdi
  8004215409:	48 b8 42 38 20 04 80 	movabs $0x8004203842,%rax
  8004215410:	00 00 00 
  8004215413:	ff d0                	callq  *%rax
  8004215415:	48 ba 08 f0 6f 04 80 	movabs $0x80046ff008,%rdx
  800421541c:	00 00 00 
  800421541f:	48 89 02             	mov    %rax,(%rdx)

	// Enable local APIC; set spurious interrupt vector.
	lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS));
  8004215422:	be 27 01 00 00       	mov    $0x127,%esi
  8004215427:	bf 3c 00 00 00       	mov    $0x3c,%edi
  800421542c:	48 b8 98 53 21 04 80 	movabs $0x8004215398,%rax
  8004215433:	00 00 00 
  8004215436:	ff d0                	callq  *%rax

	// The timer repeatedly counts down at bus frequency
	// from lapic[TICR] and then issues an interrupt.  
	// If we cared more about precise timekeeping,
	// TICR would be calibrated using an external time source.
	lapicw(TDCR, X1);
  8004215438:	be 0b 00 00 00       	mov    $0xb,%esi
  800421543d:	bf f8 00 00 00       	mov    $0xf8,%edi
  8004215442:	48 b8 98 53 21 04 80 	movabs $0x8004215398,%rax
  8004215449:	00 00 00 
  800421544c:	ff d0                	callq  *%rax
	lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER));
  800421544e:	be 20 00 02 00       	mov    $0x20020,%esi
  8004215453:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004215458:	48 b8 98 53 21 04 80 	movabs $0x8004215398,%rax
  800421545f:	00 00 00 
  8004215462:	ff d0                	callq  *%rax
	lapicw(TICR, 10000000); 
  8004215464:	be 80 96 98 00       	mov    $0x989680,%esi
  8004215469:	bf e0 00 00 00       	mov    $0xe0,%edi
  800421546e:	48 b8 98 53 21 04 80 	movabs $0x8004215398,%rax
  8004215475:	00 00 00 
  8004215478:	ff d0                	callq  *%rax
	//
	// According to Intel MP Specification, the BIOS should initialize
	// BSP's local APIC in Virtual Wire Mode, in which 8259A's
	// INTR is virtually connected to BSP's LINTIN0. In this mode,
	// we do not need to program the IOAPIC.
	if (thiscpu != bootcpu)
  800421547a:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  8004215481:	00 00 00 
  8004215484:	ff d0                	callq  *%rax
  8004215486:	48 98                	cltq   
  8004215488:	48 c1 e0 03          	shl    $0x3,%rax
  800421548c:	48 89 c2             	mov    %rax,%rdx
  800421548f:	48 c1 e2 04          	shl    $0x4,%rdx
  8004215493:	48 29 c2             	sub    %rax,%rdx
  8004215496:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800421549d:	00 00 00 
  80042154a0:	48 01 c2             	add    %rax,%rdx
  80042154a3:	48 b8 e0 e3 67 04 80 	movabs $0x800467e3e0,%rax
  80042154aa:	00 00 00 
  80042154ad:	48 8b 00             	mov    (%rax),%rax
  80042154b0:	48 39 c2             	cmp    %rax,%rdx
  80042154b3:	74 16                	je     80042154cb <lapic_init+0xf1>
		lapicw(LINT0, MASKED);
  80042154b5:	be 00 00 01 00       	mov    $0x10000,%esi
  80042154ba:	bf d4 00 00 00       	mov    $0xd4,%edi
  80042154bf:	48 b8 98 53 21 04 80 	movabs $0x8004215398,%rax
  80042154c6:	00 00 00 
  80042154c9:	ff d0                	callq  *%rax

	// Disable NMI (LINT1) on all CPUs
	lapicw(LINT1, MASKED);
  80042154cb:	be 00 00 01 00       	mov    $0x10000,%esi
  80042154d0:	bf d8 00 00 00       	mov    $0xd8,%edi
  80042154d5:	48 b8 98 53 21 04 80 	movabs $0x8004215398,%rax
  80042154dc:	00 00 00 
  80042154df:	ff d0                	callq  *%rax

	// Disable performance counter overflow interrupts
	// on machines that provide that interrupt entry.
	if (((lapic[VER]>>16) & 0xFF) >= 4)
  80042154e1:	48 b8 08 f0 6f 04 80 	movabs $0x80046ff008,%rax
  80042154e8:	00 00 00 
  80042154eb:	48 8b 00             	mov    (%rax),%rax
  80042154ee:	48 83 c0 30          	add    $0x30,%rax
  80042154f2:	8b 00                	mov    (%rax),%eax
  80042154f4:	c1 e8 10             	shr    $0x10,%eax
  80042154f7:	25 ff 00 00 00       	and    $0xff,%eax
  80042154fc:	83 f8 03             	cmp    $0x3,%eax
  80042154ff:	76 16                	jbe    8004215517 <lapic_init+0x13d>
		lapicw(PCINT, MASKED);
  8004215501:	be 00 00 01 00       	mov    $0x10000,%esi
  8004215506:	bf d0 00 00 00       	mov    $0xd0,%edi
  800421550b:	48 b8 98 53 21 04 80 	movabs $0x8004215398,%rax
  8004215512:	00 00 00 
  8004215515:	ff d0                	callq  *%rax

	// Map error interrupt to IRQ_ERROR.
	lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR);
  8004215517:	be 33 00 00 00       	mov    $0x33,%esi
  800421551c:	bf dc 00 00 00       	mov    $0xdc,%edi
  8004215521:	48 b8 98 53 21 04 80 	movabs $0x8004215398,%rax
  8004215528:	00 00 00 
  800421552b:	ff d0                	callq  *%rax

	// Clear error status register (requires back-to-back writes).
	lapicw(ESR, 0);
  800421552d:	be 00 00 00 00       	mov    $0x0,%esi
  8004215532:	bf a0 00 00 00       	mov    $0xa0,%edi
  8004215537:	48 b8 98 53 21 04 80 	movabs $0x8004215398,%rax
  800421553e:	00 00 00 
  8004215541:	ff d0                	callq  *%rax
	lapicw(ESR, 0);
  8004215543:	be 00 00 00 00       	mov    $0x0,%esi
  8004215548:	bf a0 00 00 00       	mov    $0xa0,%edi
  800421554d:	48 b8 98 53 21 04 80 	movabs $0x8004215398,%rax
  8004215554:	00 00 00 
  8004215557:	ff d0                	callq  *%rax

	// Ack any outstanding interrupts.
	lapicw(EOI, 0);
  8004215559:	be 00 00 00 00       	mov    $0x0,%esi
  800421555e:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004215563:	48 b8 98 53 21 04 80 	movabs $0x8004215398,%rax
  800421556a:	00 00 00 
  800421556d:	ff d0                	callq  *%rax

	// Send an Init Level De-Assert to synchronize arbitration ID's.
	lapicw(ICRHI, 0);
  800421556f:	be 00 00 00 00       	mov    $0x0,%esi
  8004215574:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004215579:	48 b8 98 53 21 04 80 	movabs $0x8004215398,%rax
  8004215580:	00 00 00 
  8004215583:	ff d0                	callq  *%rax
	lapicw(ICRLO, BCAST | INIT | LEVEL);
  8004215585:	be 00 85 08 00       	mov    $0x88500,%esi
  800421558a:	bf c0 00 00 00       	mov    $0xc0,%edi
  800421558f:	48 b8 98 53 21 04 80 	movabs $0x8004215398,%rax
  8004215596:	00 00 00 
  8004215599:	ff d0                	callq  *%rax
	while(lapic[ICRLO] & DELIVS)
  800421559b:	90                   	nop
  800421559c:	48 b8 08 f0 6f 04 80 	movabs $0x80046ff008,%rax
  80042155a3:	00 00 00 
  80042155a6:	48 8b 00             	mov    (%rax),%rax
  80042155a9:	48 05 00 03 00 00    	add    $0x300,%rax
  80042155af:	8b 00                	mov    (%rax),%eax
  80042155b1:	25 00 10 00 00       	and    $0x1000,%eax
  80042155b6:	85 c0                	test   %eax,%eax
  80042155b8:	75 e2                	jne    800421559c <lapic_init+0x1c2>
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
  80042155ba:	be 00 00 00 00       	mov    $0x0,%esi
  80042155bf:	bf 20 00 00 00       	mov    $0x20,%edi
  80042155c4:	48 b8 98 53 21 04 80 	movabs $0x8004215398,%rax
  80042155cb:	00 00 00 
  80042155ce:	ff d0                	callq  *%rax
  80042155d0:	eb 01                	jmp    80042155d3 <lapic_init+0x1f9>

void
lapic_init(void)
{
	if (!lapicaddr)
		return;
  80042155d2:	90                   	nop
	while(lapic[ICRLO] & DELIVS)
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
}
  80042155d3:	5d                   	pop    %rbp
  80042155d4:	c3                   	retq   

00000080042155d5 <cpunum>:

int
cpunum(void)
{
  80042155d5:	55                   	push   %rbp
  80042155d6:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  80042155d9:	48 b8 08 f0 6f 04 80 	movabs $0x80046ff008,%rax
  80042155e0:	00 00 00 
  80042155e3:	48 8b 00             	mov    (%rax),%rax
  80042155e6:	48 85 c0             	test   %rax,%rax
  80042155e9:	74 18                	je     8004215603 <cpunum+0x2e>
		return lapic[ID] >> 24;
  80042155eb:	48 b8 08 f0 6f 04 80 	movabs $0x80046ff008,%rax
  80042155f2:	00 00 00 
  80042155f5:	48 8b 00             	mov    (%rax),%rax
  80042155f8:	48 83 c0 20          	add    $0x20,%rax
  80042155fc:	8b 00                	mov    (%rax),%eax
  80042155fe:	c1 e8 18             	shr    $0x18,%eax
  8004215601:	eb 05                	jmp    8004215608 <cpunum+0x33>
	return 0;
  8004215603:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215608:	5d                   	pop    %rbp
  8004215609:	c3                   	retq   

000000800421560a <lapic_eoi>:

// Acknowledge interrupt.
void
lapic_eoi(void)
{
  800421560a:	55                   	push   %rbp
  800421560b:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  800421560e:	48 b8 08 f0 6f 04 80 	movabs $0x80046ff008,%rax
  8004215615:	00 00 00 
  8004215618:	48 8b 00             	mov    (%rax),%rax
  800421561b:	48 85 c0             	test   %rax,%rax
  800421561e:	74 16                	je     8004215636 <lapic_eoi+0x2c>
		lapicw(EOI, 0);
  8004215620:	be 00 00 00 00       	mov    $0x0,%esi
  8004215625:	bf 2c 00 00 00       	mov    $0x2c,%edi
  800421562a:	48 b8 98 53 21 04 80 	movabs $0x8004215398,%rax
  8004215631:	00 00 00 
  8004215634:	ff d0                	callq  *%rax
}
  8004215636:	5d                   	pop    %rbp
  8004215637:	c3                   	retq   

0000008004215638 <microdelay>:

// Spin for a given number of microseconds.
// On real hardware would want to tune this dynamically.
static void
microdelay(int us)
{
  8004215638:	55                   	push   %rbp
  8004215639:	48 89 e5             	mov    %rsp,%rbp
  800421563c:	48 83 ec 08          	sub    $0x8,%rsp
  8004215640:	89 7d fc             	mov    %edi,-0x4(%rbp)
}
  8004215643:	c9                   	leaveq 
  8004215644:	c3                   	retq   

0000008004215645 <lapic_startap>:

// Start additional processor running entry code at addr.
// See Appendix B of MultiProcessor Specification.
void
lapic_startap(uint8_t apicid, uint32_t addr)
{
  8004215645:	55                   	push   %rbp
  8004215646:	48 89 e5             	mov    %rsp,%rbp
  8004215649:	48 83 ec 40          	sub    $0x40,%rsp
  800421564d:	89 f8                	mov    %edi,%eax
  800421564f:	89 75 c8             	mov    %esi,-0x38(%rbp)
  8004215652:	88 45 cc             	mov    %al,-0x34(%rbp)
  8004215655:	c7 45 dc 70 00 00 00 	movl   $0x70,-0x24(%rbp)
  800421565c:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
  8004215660:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004215664:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004215667:	ee                   	out    %al,(%dx)
  8004215668:	c7 45 d4 71 00 00 00 	movl   $0x71,-0x2c(%rbp)
  800421566f:	c6 45 d3 0a          	movb   $0xa,-0x2d(%rbp)
  8004215673:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004215677:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800421567a:	ee                   	out    %al,(%dx)
	// "The BSP must initialize CMOS shutdown code to 0AH
	// and the warm reset vector (DWORD based at 40:67) to point at
	// the AP startup code prior to the [universal startup algorithm]."
	outb(IO_RTC, 0xF);  // offset 0xF is shutdown code
	outb(IO_RTC+1, 0x0A);
	wrv = (uint16_t *)KADDR((0x40 << 4 | 0x67));  // Warm reset vector
  800421567b:	48 c7 45 f0 67 04 00 	movq   $0x467,-0x10(%rbp)
  8004215682:	00 
  8004215683:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215687:	48 c1 e8 0c          	shr    $0xc,%rax
  800421568b:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800421568e:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004215691:	48 b8 e0 c7 63 04 80 	movabs $0x800463c7e0,%rax
  8004215698:	00 00 00 
  800421569b:	48 8b 00             	mov    (%rax),%rax
  800421569e:	48 39 c2             	cmp    %rax,%rdx
  80042156a1:	72 32                	jb     80042156d5 <lapic_startap+0x90>
  80042156a3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042156a7:	48 89 c1             	mov    %rax,%rcx
  80042156aa:	48 ba f0 97 21 04 80 	movabs $0x80042197f0,%rdx
  80042156b1:	00 00 00 
  80042156b4:	be 98 00 00 00       	mov    $0x98,%esi
  80042156b9:	48 bf 13 98 21 04 80 	movabs $0x8004219813,%rdi
  80042156c0:	00 00 00 
  80042156c3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042156c8:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042156cf:	00 00 00 
  80042156d2:	41 ff d0             	callq  *%r8
  80042156d5:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  80042156dc:	00 00 00 
  80042156df:	48 03 45 f0          	add    -0x10(%rbp),%rax
  80042156e3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	wrv[0] = 0;
  80042156e7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042156eb:	66 c7 00 00 00       	movw   $0x0,(%rax)
	wrv[1] = addr >> 4;
  80042156f0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042156f4:	48 8d 50 02          	lea    0x2(%rax),%rdx
  80042156f8:	8b 45 c8             	mov    -0x38(%rbp),%eax
  80042156fb:	c1 e8 04             	shr    $0x4,%eax
  80042156fe:	66 89 02             	mov    %ax,(%rdx)

	// "Universal startup algorithm."
	// Send INIT (level-triggered) interrupt to reset other CPU.
	lapicw(ICRHI, apicid << 24);
  8004215701:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004215705:	c1 e0 18             	shl    $0x18,%eax
  8004215708:	89 c6                	mov    %eax,%esi
  800421570a:	bf c4 00 00 00       	mov    $0xc4,%edi
  800421570f:	48 b8 98 53 21 04 80 	movabs $0x8004215398,%rax
  8004215716:	00 00 00 
  8004215719:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL | ASSERT);
  800421571b:	be 00 c5 00 00       	mov    $0xc500,%esi
  8004215720:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004215725:	48 b8 98 53 21 04 80 	movabs $0x8004215398,%rax
  800421572c:	00 00 00 
  800421572f:	ff d0                	callq  *%rax
	microdelay(200);
  8004215731:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004215736:	48 b8 38 56 21 04 80 	movabs $0x8004215638,%rax
  800421573d:	00 00 00 
  8004215740:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL);
  8004215742:	be 00 85 00 00       	mov    $0x8500,%esi
  8004215747:	bf c0 00 00 00       	mov    $0xc0,%edi
  800421574c:	48 b8 98 53 21 04 80 	movabs $0x8004215398,%rax
  8004215753:	00 00 00 
  8004215756:	ff d0                	callq  *%rax
	microdelay(100);    // should be 10ms, but too slow in Bochs!
  8004215758:	bf 64 00 00 00       	mov    $0x64,%edi
  800421575d:	48 b8 38 56 21 04 80 	movabs $0x8004215638,%rax
  8004215764:	00 00 00 
  8004215767:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004215769:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004215770:	eb 4b                	jmp    80042157bd <lapic_startap+0x178>
		lapicw(ICRHI, apicid << 24);
  8004215772:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004215776:	c1 e0 18             	shl    $0x18,%eax
  8004215779:	89 c6                	mov    %eax,%esi
  800421577b:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004215780:	48 b8 98 53 21 04 80 	movabs $0x8004215398,%rax
  8004215787:	00 00 00 
  800421578a:	ff d0                	callq  *%rax
		lapicw(ICRLO, STARTUP | (addr >> 12));
  800421578c:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421578f:	c1 e8 0c             	shr    $0xc,%eax
  8004215792:	80 cc 06             	or     $0x6,%ah
  8004215795:	89 c6                	mov    %eax,%esi
  8004215797:	bf c0 00 00 00       	mov    $0xc0,%edi
  800421579c:	48 b8 98 53 21 04 80 	movabs $0x8004215398,%rax
  80042157a3:	00 00 00 
  80042157a6:	ff d0                	callq  *%rax
		microdelay(200);
  80042157a8:	bf c8 00 00 00       	mov    $0xc8,%edi
  80042157ad:	48 b8 38 56 21 04 80 	movabs $0x8004215638,%rax
  80042157b4:	00 00 00 
  80042157b7:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  80042157b9:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042157bd:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  80042157c1:	7e af                	jle    8004215772 <lapic_startap+0x12d>
		lapicw(ICRHI, apicid << 24);
		lapicw(ICRLO, STARTUP | (addr >> 12));
		microdelay(200);
	}
}
  80042157c3:	c9                   	leaveq 
  80042157c4:	c3                   	retq   

00000080042157c5 <lapic_ipi>:

void
lapic_ipi(int vector)
{
  80042157c5:	55                   	push   %rbp
  80042157c6:	48 89 e5             	mov    %rsp,%rbp
  80042157c9:	48 83 ec 08          	sub    $0x8,%rsp
  80042157cd:	89 7d fc             	mov    %edi,-0x4(%rbp)
	lapicw(ICRLO, OTHERS | FIXED | vector);
  80042157d0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042157d3:	0d 00 00 0c 00       	or     $0xc0000,%eax
  80042157d8:	89 c6                	mov    %eax,%esi
  80042157da:	bf c0 00 00 00       	mov    $0xc0,%edi
  80042157df:	48 b8 98 53 21 04 80 	movabs $0x8004215398,%rax
  80042157e6:	00 00 00 
  80042157e9:	ff d0                	callq  *%rax
	while (lapic[ICRLO] & DELIVS)
  80042157eb:	90                   	nop
  80042157ec:	48 b8 08 f0 6f 04 80 	movabs $0x80046ff008,%rax
  80042157f3:	00 00 00 
  80042157f6:	48 8b 00             	mov    (%rax),%rax
  80042157f9:	48 05 00 03 00 00    	add    $0x300,%rax
  80042157ff:	8b 00                	mov    (%rax),%eax
  8004215801:	25 00 10 00 00       	and    $0x1000,%eax
  8004215806:	85 c0                	test   %eax,%eax
  8004215808:	75 e2                	jne    80042157ec <lapic_ipi+0x27>
		;
}
  800421580a:	c9                   	leaveq 
  800421580b:	c3                   	retq   

000000800421580c <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  800421580c:	55                   	push   %rbp
  800421580d:	48 89 e5             	mov    %rsp,%rbp
  8004215810:	53                   	push   %rbx
  8004215811:	48 83 ec 20          	sub    $0x20,%rsp
  8004215815:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
  8004215819:	89 75 dc             	mov    %esi,-0x24(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
	"+m" (*addr), "=a" (result):
  800421581c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004215820:	8b 45 dc             	mov    -0x24(%rbp),%eax
	"+m" (*addr), "=a" (result):
  8004215823:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004215827:	89 c3                	mov    %eax,%ebx
  8004215829:	89 d8                	mov    %ebx,%eax
  800421582b:	f0 87 02             	lock xchg %eax,(%rdx)
  800421582e:	89 c3                	mov    %eax,%ebx
  8004215830:	89 5d f4             	mov    %ebx,-0xc(%rbp)
	"+m" (*addr), "=a" (result):
	"1"(newval):
	"cc");
	return result;
  8004215833:	8b 45 f4             	mov    -0xc(%rbp),%eax
}
  8004215836:	48 83 c4 20          	add    $0x20,%rsp
  800421583a:	5b                   	pop    %rbx
  800421583b:	5d                   	pop    %rbp
  800421583c:	c3                   	retq   

000000800421583d <get_caller_pcs>:

#ifdef DEBUG_SPINLOCK
// Record the current call stack in pcs[] by following the %ebp chain.
static void
get_caller_pcs(uint64_t pcs[])
{
  800421583d:	55                   	push   %rbp
  800421583e:	48 89 e5             	mov    %rsp,%rbp
  8004215841:	53                   	push   %rbx
  8004215842:	48 83 ec 28          	sub    $0x28,%rsp
  8004215846:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)

static __inline uint64_t
read_rbp(void)
{
        uint64_t rbp;
        __asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  800421584a:	48 89 eb             	mov    %rbp,%rbx
  800421584d:	48 89 5d e0          	mov    %rbx,-0x20(%rbp)
        return rbp;
  8004215851:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
  8004215855:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < 10; i++){
  8004215859:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004215860:	eb 3e                	jmp    80042158a0 <get_caller_pcs+0x63>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
  8004215862:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004215867:	74 57                	je     80042158c0 <get_caller_pcs+0x83>
  8004215869:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004215870:	00 00 00 
  8004215873:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  8004215877:	76 47                	jbe    80042158c0 <get_caller_pcs+0x83>
			break;
		pcs[i] = rbp[1];          // saved %rip
  8004215879:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421587c:	48 98                	cltq   
  800421587e:	48 c1 e0 03          	shl    $0x3,%rax
  8004215882:	48 03 45 d0          	add    -0x30(%rbp),%rax
  8004215886:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421588a:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800421588e:	48 89 10             	mov    %rdx,(%rax)
		rbp = (uint64_t *)rbp[0]; // saved %rbp
  8004215891:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215895:	48 8b 00             	mov    (%rax),%rax
  8004215898:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
{
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
	for (i = 0; i < 10; i++){
  800421589c:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042158a0:	83 7d ec 09          	cmpl   $0x9,-0x14(%rbp)
  80042158a4:	7e bc                	jle    8004215862 <get_caller_pcs+0x25>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  80042158a6:	eb 18                	jmp    80042158c0 <get_caller_pcs+0x83>
		pcs[i] = 0;
  80042158a8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042158ab:	48 98                	cltq   
  80042158ad:	48 c1 e0 03          	shl    $0x3,%rax
  80042158b1:	48 03 45 d0          	add    -0x30(%rbp),%rax
  80042158b5:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  80042158bc:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042158c0:	83 7d ec 09          	cmpl   $0x9,-0x14(%rbp)
  80042158c4:	7e e2                	jle    80042158a8 <get_caller_pcs+0x6b>
		pcs[i] = 0;
}
  80042158c6:	48 83 c4 28          	add    $0x28,%rsp
  80042158ca:	5b                   	pop    %rbx
  80042158cb:	5d                   	pop    %rbp
  80042158cc:	c3                   	retq   

00000080042158cd <holding>:

// Check whether this CPU is holding the lock.
static int
holding(struct spinlock *lock)
{
  80042158cd:	55                   	push   %rbp
  80042158ce:	48 89 e5             	mov    %rsp,%rbp
  80042158d1:	53                   	push   %rbx
  80042158d2:	48 83 ec 18          	sub    $0x18,%rsp
  80042158d6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return lock->locked && lock->cpu == thiscpu;
  80042158da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042158de:	8b 00                	mov    (%rax),%eax
  80042158e0:	85 c0                	test   %eax,%eax
  80042158e2:	74 3d                	je     8004215921 <holding+0x54>
  80042158e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042158e8:	48 8b 58 10          	mov    0x10(%rax),%rbx
  80042158ec:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  80042158f3:	00 00 00 
  80042158f6:	ff d0                	callq  *%rax
  80042158f8:	48 98                	cltq   
  80042158fa:	48 c1 e0 03          	shl    $0x3,%rax
  80042158fe:	48 89 c2             	mov    %rax,%rdx
  8004215901:	48 c1 e2 04          	shl    $0x4,%rdx
  8004215905:	48 29 c2             	sub    %rax,%rdx
  8004215908:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  800421590f:	00 00 00 
  8004215912:	48 01 d0             	add    %rdx,%rax
  8004215915:	48 39 c3             	cmp    %rax,%rbx
  8004215918:	75 07                	jne    8004215921 <holding+0x54>
  800421591a:	b8 01 00 00 00       	mov    $0x1,%eax
  800421591f:	eb 05                	jmp    8004215926 <holding+0x59>
  8004215921:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215926:	48 83 c4 18          	add    $0x18,%rsp
  800421592a:	5b                   	pop    %rbx
  800421592b:	5d                   	pop    %rbp
  800421592c:	c3                   	retq   

000000800421592d <__spin_initlock>:
#endif

void
__spin_initlock(struct spinlock *lk, char *name)
{
  800421592d:	55                   	push   %rbp
  800421592e:	48 89 e5             	mov    %rsp,%rbp
  8004215931:	48 83 ec 10          	sub    $0x10,%rsp
  8004215935:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004215939:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	lk->locked = 0;
  800421593d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215941:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
#ifdef DEBUG_SPINLOCK
	lk->name = name;
  8004215947:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421594b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421594f:	48 89 50 08          	mov    %rdx,0x8(%rax)
	lk->cpu = 0;
  8004215953:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215957:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  800421595e:	00 
#endif
}
  800421595f:	c9                   	leaveq 
  8004215960:	c3                   	retq   

0000008004215961 <spin_lock>:
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void
spin_lock(struct spinlock *lk)
{
  8004215961:	55                   	push   %rbp
  8004215962:	48 89 e5             	mov    %rsp,%rbp
  8004215965:	53                   	push   %rbx
  8004215966:	48 83 ec 18          	sub    $0x18,%rsp
  800421596a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#ifdef DEBUG_SPINLOCK
	if (holding(lk))
  800421596e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215972:	48 89 c7             	mov    %rax,%rdi
  8004215975:	48 b8 cd 58 21 04 80 	movabs $0x80042158cd,%rax
  800421597c:	00 00 00 
  800421597f:	ff d0                	callq  *%rax
  8004215981:	85 c0                	test   %eax,%eax
  8004215983:	74 48                	je     80042159cd <spin_lock+0x6c>
		panic("CPU %d cannot acquire %s: already holding", cpunum(), lk->name);
  8004215985:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215989:	48 8b 58 08          	mov    0x8(%rax),%rbx
  800421598d:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  8004215994:	00 00 00 
  8004215997:	ff d0                	callq  *%rax
  8004215999:	49 89 d8             	mov    %rbx,%r8
  800421599c:	89 c1                	mov    %eax,%ecx
  800421599e:	48 ba 30 98 21 04 80 	movabs $0x8004219830,%rdx
  80042159a5:	00 00 00 
  80042159a8:	be 41 00 00 00       	mov    $0x41,%esi
  80042159ad:	48 bf 5a 98 21 04 80 	movabs $0x800421985a,%rdi
  80042159b4:	00 00 00 
  80042159b7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042159bc:	49 b9 f2 04 20 04 80 	movabs $0x80042004f2,%r9
  80042159c3:	00 00 00 
  80042159c6:	41 ff d1             	callq  *%r9

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
		asm volatile ("pause");
  80042159c9:	f3 90                	pause  
  80042159cb:	eb 01                	jmp    80042159ce <spin_lock+0x6d>
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  80042159cd:	90                   	nop
  80042159ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042159d2:	be 01 00 00 00       	mov    $0x1,%esi
  80042159d7:	48 89 c7             	mov    %rax,%rdi
  80042159da:	48 b8 0c 58 21 04 80 	movabs $0x800421580c,%rax
  80042159e1:	00 00 00 
  80042159e4:	ff d0                	callq  *%rax
  80042159e6:	85 c0                	test   %eax,%eax
  80042159e8:	75 df                	jne    80042159c9 <spin_lock+0x68>
		asm volatile ("pause");

	// Record info about lock acquisition for debugging.
#ifdef DEBUG_SPINLOCK
	lk->cpu = thiscpu;
  80042159ea:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  80042159f1:	00 00 00 
  80042159f4:	ff d0                	callq  *%rax
  80042159f6:	48 98                	cltq   
  80042159f8:	48 c1 e0 03          	shl    $0x3,%rax
  80042159fc:	48 89 c2             	mov    %rax,%rdx
  80042159ff:	48 c1 e2 04          	shl    $0x4,%rdx
  8004215a03:	48 29 c2             	sub    %rax,%rdx
  8004215a06:	48 b8 20 e0 67 04 80 	movabs $0x800467e020,%rax
  8004215a0d:	00 00 00 
  8004215a10:	48 01 c2             	add    %rax,%rdx
  8004215a13:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215a17:	48 89 50 10          	mov    %rdx,0x10(%rax)
	get_caller_pcs(lk->pcs);
  8004215a1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215a1f:	48 83 c0 18          	add    $0x18,%rax
  8004215a23:	48 89 c7             	mov    %rax,%rdi
  8004215a26:	48 b8 3d 58 21 04 80 	movabs $0x800421583d,%rax
  8004215a2d:	00 00 00 
  8004215a30:	ff d0                	callq  *%rax
#endif
}
  8004215a32:	48 83 c4 18          	add    $0x18,%rsp
  8004215a36:	5b                   	pop    %rbx
  8004215a37:	5d                   	pop    %rbp
  8004215a38:	c3                   	retq   

0000008004215a39 <spin_unlock>:

// Release the lock.
void
spin_unlock(struct spinlock *lk)
{
  8004215a39:	55                   	push   %rbp
  8004215a3a:	48 89 e5             	mov    %rsp,%rbp
  8004215a3d:	41 54                	push   %r12
  8004215a3f:	53                   	push   %rbx
  8004215a40:	48 81 ec d0 04 00 00 	sub    $0x4d0,%rsp
  8004215a47:	48 89 bd 38 fb ff ff 	mov    %rdi,-0x4c8(%rbp)
#ifdef DEBUG_SPINLOCK
	if (!holding(lk)) {
  8004215a4e:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  8004215a55:	48 89 c7             	mov    %rax,%rdi
  8004215a58:	48 b8 cd 58 21 04 80 	movabs $0x80042158cd,%rax
  8004215a5f:	00 00 00 
  8004215a62:	ff d0                	callq  *%rax
  8004215a64:	85 c0                	test   %eax,%eax
  8004215a66:	0f 85 c0 01 00 00    	jne    8004215c2c <spin_unlock+0x1f3>
		int i;
		uint32_t pcs[10];
		// Nab the acquiring EIP chain before it gets released
		memmove(pcs, lk->pcs, sizeof pcs);
  8004215a6c:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  8004215a73:	48 8d 48 18          	lea    0x18(%rax),%rcx
  8004215a77:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
  8004215a7b:	ba 28 00 00 00       	mov    $0x28,%edx
  8004215a80:	48 89 ce             	mov    %rcx,%rsi
  8004215a83:	48 89 c7             	mov    %rax,%rdi
  8004215a86:	48 b8 de e6 20 04 80 	movabs $0x800420e6de,%rax
  8004215a8d:	00 00 00 
  8004215a90:	ff d0                	callq  *%rax
		if (!lk->cpu) 
  8004215a92:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  8004215a99:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004215a9d:	48 85 c0             	test   %rax,%rax
  8004215aa0:	75 39                	jne    8004215adb <spin_unlock+0xa2>
			cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
				cpunum(), lk->name);
  8004215aa2:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
		int i;
		uint32_t pcs[10];
		// Nab the acquiring EIP chain before it gets released
		memmove(pcs, lk->pcs, sizeof pcs);
		if (!lk->cpu) 
			cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
  8004215aa9:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004215aad:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  8004215ab4:	00 00 00 
  8004215ab7:	ff d0                	callq  *%rax
  8004215ab9:	48 89 da             	mov    %rbx,%rdx
  8004215abc:	89 c6                	mov    %eax,%esi
  8004215abe:	48 bf 70 98 21 04 80 	movabs $0x8004219870,%rdi
  8004215ac5:	00 00 00 
  8004215ac8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215acd:	48 b9 f2 89 20 04 80 	movabs $0x80042089f2,%rcx
  8004215ad4:	00 00 00 
  8004215ad7:	ff d1                	callq  *%rcx
  8004215ad9:	eb 4d                	jmp    8004215b28 <spin_unlock+0xef>
				cpunum(), lk->name);
		else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
  8004215adb:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  8004215ae2:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004215ae6:	0f b6 00             	movzbl (%rax),%eax
		memmove(pcs, lk->pcs, sizeof pcs);
		if (!lk->cpu) 
			cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
				cpunum(), lk->name);
		else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
  8004215ae9:	44 0f b6 e0          	movzbl %al,%r12d
				cpunum(), lk->name, lk->cpu->cpu_id);
  8004215aed:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
		memmove(pcs, lk->pcs, sizeof pcs);
		if (!lk->cpu) 
			cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
				cpunum(), lk->name);
		else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
  8004215af4:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004215af8:	48 b8 d5 55 21 04 80 	movabs $0x80042155d5,%rax
  8004215aff:	00 00 00 
  8004215b02:	ff d0                	callq  *%rax
  8004215b04:	44 89 e1             	mov    %r12d,%ecx
  8004215b07:	48 89 da             	mov    %rbx,%rdx
  8004215b0a:	89 c6                	mov    %eax,%esi
  8004215b0c:	48 bf b0 98 21 04 80 	movabs $0x80042198b0,%rdi
  8004215b13:	00 00 00 
  8004215b16:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215b1b:	49 b8 f2 89 20 04 80 	movabs $0x80042089f2,%r8
  8004215b22:	00 00 00 
  8004215b25:	41 ff d0             	callq  *%r8
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  8004215b28:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004215b2f:	e9 b7 00 00 00       	jmpq   8004215beb <spin_unlock+0x1b2>
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
  8004215b34:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004215b37:	48 98                	cltq   
  8004215b39:	8b 44 85 c0          	mov    -0x40(%rbp,%rax,4),%eax
  8004215b3d:	89 c0                	mov    %eax,%eax
  8004215b3f:	48 8d 95 40 fb ff ff 	lea    -0x4c0(%rbp),%rdx
  8004215b46:	48 89 d6             	mov    %rdx,%rsi
  8004215b49:	48 89 c7             	mov    %rax,%rdi
  8004215b4c:	48 b8 8f d3 20 04 80 	movabs $0x800420d38f,%rax
  8004215b53:	00 00 00 
  8004215b56:	ff d0                	callq  *%rax
  8004215b58:	85 c0                	test   %eax,%eax
  8004215b5a:	78 65                	js     8004215bc1 <spin_unlock+0x188>
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  8004215b5c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004215b5f:	48 98                	cltq   
  8004215b61:	8b 44 85 c0          	mov    -0x40(%rbp,%rax,4),%eax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004215b65:	89 c2                	mov    %eax,%edx
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  8004215b67:	48 8b 85 60 fb ff ff 	mov    -0x4a0(%rbp),%rax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004215b6e:	49 89 d0             	mov    %rdx,%r8
  8004215b71:	49 29 c0             	sub    %rax,%r8
  8004215b74:	48 8b bd 50 fb ff ff 	mov    -0x4b0(%rbp),%rdi
  8004215b7b:	8b b5 58 fb ff ff    	mov    -0x4a8(%rbp),%esi
  8004215b81:	8b 8d 48 fb ff ff    	mov    -0x4b8(%rbp),%ecx
  8004215b87:	48 8b 95 40 fb ff ff 	mov    -0x4c0(%rbp),%rdx
  8004215b8e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004215b91:	48 98                	cltq   
  8004215b93:	8b 44 85 c0          	mov    -0x40(%rbp,%rax,4),%eax
  8004215b97:	4c 89 04 24          	mov    %r8,(%rsp)
  8004215b9b:	49 89 f9             	mov    %rdi,%r9
  8004215b9e:	41 89 f0             	mov    %esi,%r8d
  8004215ba1:	89 c6                	mov    %eax,%esi
  8004215ba3:	48 bf e6 98 21 04 80 	movabs $0x80042198e6,%rdi
  8004215baa:	00 00 00 
  8004215bad:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215bb2:	49 ba f2 89 20 04 80 	movabs $0x80042089f2,%r10
  8004215bb9:	00 00 00 
  8004215bbc:	41 ff d2             	callq  *%r10
  8004215bbf:	eb 26                	jmp    8004215be7 <spin_unlock+0x1ae>
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
  8004215bc1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004215bc4:	48 98                	cltq   
  8004215bc6:	8b 44 85 c0          	mov    -0x40(%rbp,%rax,4),%eax
  8004215bca:	89 c6                	mov    %eax,%esi
  8004215bcc:	48 bf fd 98 21 04 80 	movabs $0x80042198fd,%rdi
  8004215bd3:	00 00 00 
  8004215bd6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215bdb:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  8004215be2:	00 00 00 
  8004215be5:	ff d2                	callq  *%rdx
			cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
				cpunum(), lk->name);
		else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  8004215be7:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004215beb:	83 7d ec 09          	cmpl   $0x9,-0x14(%rbp)
  8004215bef:	7f 11                	jg     8004215c02 <spin_unlock+0x1c9>
  8004215bf1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004215bf4:	48 98                	cltq   
  8004215bf6:	8b 44 85 c0          	mov    -0x40(%rbp,%rax,4),%eax
  8004215bfa:	85 c0                	test   %eax,%eax
  8004215bfc:	0f 85 32 ff ff ff    	jne    8004215b34 <spin_unlock+0xfb>
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
		}
		panic("spin_unlock");
  8004215c02:	48 ba 05 99 21 04 80 	movabs $0x8004219905,%rdx
  8004215c09:	00 00 00 
  8004215c0c:	be 6b 00 00 00       	mov    $0x6b,%esi
  8004215c11:	48 bf 5a 98 21 04 80 	movabs $0x800421985a,%rdi
  8004215c18:	00 00 00 
  8004215c1b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215c20:	48 b9 f2 04 20 04 80 	movabs $0x80042004f2,%rcx
  8004215c27:	00 00 00 
  8004215c2a:	ff d1                	callq  *%rcx
	}

	lk->pcs[0] = 0;
  8004215c2c:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  8004215c33:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  8004215c3a:	00 
	lk->cpu = 0;
  8004215c3b:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  8004215c42:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004215c49:	00 
	// But the 2007 Intel 64 Architecture Memory Ordering White
	// Paper says that Intel 64 and IA-32 will not move a load
	// after a store. So lock->locked = 0 would work here.
	// The xchg being asm volatile ensures gcc emits it after
	// the above assignments (and after the critical section).
	xchg(&lk->locked, 0);
  8004215c4a:	48 8b 85 38 fb ff ff 	mov    -0x4c8(%rbp),%rax
  8004215c51:	be 00 00 00 00       	mov    $0x0,%esi
  8004215c56:	48 89 c7             	mov    %rax,%rdi
  8004215c59:	48 b8 0c 58 21 04 80 	movabs $0x800421580c,%rax
  8004215c60:	00 00 00 
  8004215c63:	ff d0                	callq  *%rax
}
  8004215c65:	48 81 c4 d0 04 00 00 	add    $0x4d0,%rsp
  8004215c6c:	5b                   	pop    %rbx
  8004215c6d:	41 5c                	pop    %r12
  8004215c6f:	5d                   	pop    %rbp
  8004215c70:	c3                   	retq   
  8004215c71:	00 00                	add    %al,(%rax)
	...

0000008004215c74 <descriptors_init>:
volatile uint32_t *pci_mmio_base;

uint32_t e1000_mac_address[2] = {0x12005452, 0x5634};

static void descriptors_init()
{
  8004215c74:	55                   	push   %rbp
  8004215c75:	48 89 e5             	mov    %rsp,%rbp
  8004215c78:	48 83 ec 20          	sub    $0x20,%rsp
	int a;
	//Initialize the transmit descriptor ring
	for(a=0;a<NUM_TX_DESC;a++)
  8004215c7c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004215c83:	e9 31 01 00 00       	jmpq   8004215db9 <descriptors_init+0x145>
	{
		tranDescRing[a].addr = PADDR(&tranBuf[a]);
  8004215c88:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215c8b:	48 98                	cltq   
  8004215c8d:	48 89 c2             	mov    %rax,%rdx
  8004215c90:	48 c1 e2 0b          	shl    $0xb,%rdx
  8004215c94:	48 b8 00 cc 65 04 80 	movabs $0x800465cc00,%rax
  8004215c9b:	00 00 00 
  8004215c9e:	48 01 d0             	add    %rdx,%rax
  8004215ca1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004215ca5:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004215cac:	00 00 00 
  8004215caf:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  8004215cb3:	77 32                	ja     8004215ce7 <descriptors_init+0x73>
  8004215cb5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215cb9:	48 89 c1             	mov    %rax,%rcx
  8004215cbc:	48 ba 18 99 21 04 80 	movabs $0x8004219918,%rdx
  8004215cc3:	00 00 00 
  8004215cc6:	be 10 00 00 00       	mov    $0x10,%esi
  8004215ccb:	48 bf 3c 99 21 04 80 	movabs $0x800421993c,%rdi
  8004215cd2:	00 00 00 
  8004215cd5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215cda:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004215ce1:	00 00 00 
  8004215ce4:	41 ff d0             	callq  *%r8
  8004215ce7:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004215cee:	ff ff ff 
  8004215cf1:	48 03 45 f0          	add    -0x10(%rbp),%rax
  8004215cf5:	48 ba 00 c8 65 04 80 	movabs $0x800465c800,%rdx
  8004215cfc:	00 00 00 
  8004215cff:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004215d02:	48 63 c9             	movslq %ecx,%rcx
  8004215d05:	48 c1 e1 04          	shl    $0x4,%rcx
  8004215d09:	48 01 ca             	add    %rcx,%rdx
  8004215d0c:	48 89 02             	mov    %rax,(%rdx)
		tranDescRing[a].length = 0;
  8004215d0f:	48 b8 00 c8 65 04 80 	movabs $0x800465c800,%rax
  8004215d16:	00 00 00 
  8004215d19:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004215d1c:	48 63 d2             	movslq %edx,%rdx
  8004215d1f:	48 c1 e2 04          	shl    $0x4,%rdx
  8004215d23:	48 01 d0             	add    %rdx,%rax
  8004215d26:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
		tranDescRing[a].cso = 0;		
  8004215d2c:	48 b8 00 c8 65 04 80 	movabs $0x800465c800,%rax
  8004215d33:	00 00 00 
  8004215d36:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004215d39:	48 63 d2             	movslq %edx,%rdx
  8004215d3c:	48 c1 e2 04          	shl    $0x4,%rdx
  8004215d40:	48 01 d0             	add    %rdx,%rax
  8004215d43:	c6 40 0a 00          	movb   $0x0,0xa(%rax)
		tranDescRing[a].status = TXD_STAT_DD;
  8004215d47:	48 b8 00 c8 65 04 80 	movabs $0x800465c800,%rax
  8004215d4e:	00 00 00 
  8004215d51:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004215d54:	48 63 d2             	movslq %edx,%rdx
  8004215d57:	48 c1 e2 04          	shl    $0x4,%rdx
  8004215d5b:	48 01 d0             	add    %rdx,%rax
  8004215d5e:	c6 40 0c 01          	movb   $0x1,0xc(%rax)
		tranDescRing[a].cmd = TXD_CMD_EOP | TXD_CMD_RS;
  8004215d62:	48 b8 00 c8 65 04 80 	movabs $0x800465c800,%rax
  8004215d69:	00 00 00 
  8004215d6c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004215d6f:	48 63 d2             	movslq %edx,%rdx
  8004215d72:	48 c1 e2 04          	shl    $0x4,%rdx
  8004215d76:	48 01 d0             	add    %rdx,%rax
  8004215d79:	c6 40 0b 09          	movb   $0x9,0xb(%rax)
		tranDescRing[a].css = 0;
  8004215d7d:	48 b8 00 c8 65 04 80 	movabs $0x800465c800,%rax
  8004215d84:	00 00 00 
  8004215d87:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004215d8a:	48 63 d2             	movslq %edx,%rdx
  8004215d8d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004215d91:	48 01 d0             	add    %rdx,%rax
  8004215d94:	c6 40 0d 00          	movb   $0x0,0xd(%rax)
		tranDescRing[a].special = 0;
  8004215d98:	48 b8 00 c8 65 04 80 	movabs $0x800465c800,%rax
  8004215d9f:	00 00 00 
  8004215da2:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004215da5:	48 63 d2             	movslq %edx,%rdx
  8004215da8:	48 c1 e2 04          	shl    $0x4,%rdx
  8004215dac:	48 01 d0             	add    %rdx,%rax
  8004215daf:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%rax)

static void descriptors_init()
{
	int a;
	//Initialize the transmit descriptor ring
	for(a=0;a<NUM_TX_DESC;a++)
  8004215db5:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004215db9:	83 7d fc 3f          	cmpl   $0x3f,-0x4(%rbp)
  8004215dbd:	0f 8e c5 fe ff ff    	jle    8004215c88 <descriptors_init+0x14>
		tranDescRing[a].cmd = TXD_CMD_EOP | TXD_CMD_RS;
		tranDescRing[a].css = 0;
		tranDescRing[a].special = 0;
	}
	//Initialize the receive descriptor ring
	for(a=0;a<NUM_RX_DESC;a++)
  8004215dc3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004215dca:	e9 18 01 00 00       	jmpq   8004215ee7 <descriptors_init+0x273>
	{
		recvDescRing[a].addr = PADDR(&recvBuf[a]);
  8004215dcf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215dd2:	48 98                	cltq   
  8004215dd4:	48 89 c2             	mov    %rax,%rdx
  8004215dd7:	48 c1 e2 0b          	shl    $0xb,%rdx
  8004215ddb:	48 b8 00 c8 63 04 80 	movabs $0x800463c800,%rax
  8004215de2:	00 00 00 
  8004215de5:	48 01 d0             	add    %rdx,%rax
  8004215de8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004215dec:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004215df3:	00 00 00 
  8004215df6:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004215dfa:	77 32                	ja     8004215e2e <descriptors_init+0x1ba>
  8004215dfc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215e00:	48 89 c1             	mov    %rax,%rcx
  8004215e03:	48 ba 18 99 21 04 80 	movabs $0x8004219918,%rdx
  8004215e0a:	00 00 00 
  8004215e0d:	be 1b 00 00 00       	mov    $0x1b,%esi
  8004215e12:	48 bf 3c 99 21 04 80 	movabs $0x800421993c,%rdi
  8004215e19:	00 00 00 
  8004215e1c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215e21:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004215e28:	00 00 00 
  8004215e2b:	41 ff d0             	callq  *%r8
  8004215e2e:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004215e35:	ff ff ff 
  8004215e38:	48 03 45 e8          	add    -0x18(%rbp),%rax
  8004215e3c:	48 ba 00 cc 67 04 80 	movabs $0x800467cc00,%rdx
  8004215e43:	00 00 00 
  8004215e46:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004215e49:	48 63 c9             	movslq %ecx,%rcx
  8004215e4c:	48 c1 e1 04          	shl    $0x4,%rcx
  8004215e50:	48 01 ca             	add    %rcx,%rdx
  8004215e53:	48 89 02             	mov    %rax,(%rdx)
		recvDescRing[a].length = 0;
  8004215e56:	48 b8 00 cc 67 04 80 	movabs $0x800467cc00,%rax
  8004215e5d:	00 00 00 
  8004215e60:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004215e63:	48 63 d2             	movslq %edx,%rdx
  8004215e66:	48 c1 e2 04          	shl    $0x4,%rdx
  8004215e6a:	48 01 d0             	add    %rdx,%rax
  8004215e6d:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
		recvDescRing[a].cs = 0;
  8004215e73:	48 b8 00 cc 67 04 80 	movabs $0x800467cc00,%rax
  8004215e7a:	00 00 00 
  8004215e7d:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004215e80:	48 63 d2             	movslq %edx,%rdx
  8004215e83:	48 c1 e2 04          	shl    $0x4,%rdx
  8004215e87:	48 01 d0             	add    %rdx,%rax
  8004215e8a:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%rax)
		//Zero the status indicating it is available for hardware to use
		recvDescRing[a].status = 0;
  8004215e90:	48 b8 00 cc 67 04 80 	movabs $0x800467cc00,%rax
  8004215e97:	00 00 00 
  8004215e9a:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004215e9d:	48 63 d2             	movslq %edx,%rdx
  8004215ea0:	48 c1 e2 04          	shl    $0x4,%rdx
  8004215ea4:	48 01 d0             	add    %rdx,%rax
  8004215ea7:	c6 40 0c 00          	movb   $0x0,0xc(%rax)
		recvDescRing[a].errors = 0;
  8004215eab:	48 b8 00 cc 67 04 80 	movabs $0x800467cc00,%rax
  8004215eb2:	00 00 00 
  8004215eb5:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004215eb8:	48 63 d2             	movslq %edx,%rdx
  8004215ebb:	48 c1 e2 04          	shl    $0x4,%rdx
  8004215ebf:	48 01 d0             	add    %rdx,%rax
  8004215ec2:	c6 40 0d 00          	movb   $0x0,0xd(%rax)
		recvDescRing[a].special = 0;
  8004215ec6:	48 b8 00 cc 67 04 80 	movabs $0x800467cc00,%rax
  8004215ecd:	00 00 00 
  8004215ed0:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004215ed3:	48 63 d2             	movslq %edx,%rdx
  8004215ed6:	48 c1 e2 04          	shl    $0x4,%rdx
  8004215eda:	48 01 d0             	add    %rdx,%rax
  8004215edd:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%rax)
		tranDescRing[a].cmd = TXD_CMD_EOP | TXD_CMD_RS;
		tranDescRing[a].css = 0;
		tranDescRing[a].special = 0;
	}
	//Initialize the receive descriptor ring
	for(a=0;a<NUM_RX_DESC;a++)
  8004215ee3:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004215ee7:	83 7d fc 3f          	cmpl   $0x3f,-0x4(%rbp)
  8004215eeb:	0f 8e de fe ff ff    	jle    8004215dcf <descriptors_init+0x15b>
		//Zero the status indicating it is available for hardware to use
		recvDescRing[a].status = 0;
		recvDescRing[a].errors = 0;
		recvDescRing[a].special = 0;
	}
}
  8004215ef1:	c9                   	leaveq 
  8004215ef2:	c3                   	retq   

0000008004215ef3 <transmit_packet_e1000>:

int transmit_packet_e1000(void *addr, size_t len)
{
  8004215ef3:	55                   	push   %rbp
  8004215ef4:	48 89 e5             	mov    %rsp,%rbp
  8004215ef7:	48 83 ec 20          	sub    $0x20,%rsp
  8004215efb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004215eff:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint32_t tail = pci_mmio_base[E1000_TDT/4];
  8004215f03:	48 b8 10 f0 6f 04 80 	movabs $0x80046ff010,%rax
  8004215f0a:	00 00 00 
  8004215f0d:	48 8b 00             	mov    (%rax),%rax
  8004215f10:	8b 80 18 38 00 00    	mov    0x3818(%rax),%eax
  8004215f16:	89 45 fc             	mov    %eax,-0x4(%rbp)
	struct tx_desc *t = &tranDescRing[tail];
  8004215f19:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215f1c:	48 89 c2             	mov    %rax,%rdx
  8004215f1f:	48 c1 e2 04          	shl    $0x4,%rdx
  8004215f23:	48 b8 00 c8 65 04 80 	movabs $0x800465c800,%rax
  8004215f2a:	00 00 00 
  8004215f2d:	48 01 d0             	add    %rdx,%rax
  8004215f30:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	//Check if the transmit descriptor ring is full
	if((t->status & TXD_STAT_DD) == 0)
  8004215f34:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215f38:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  8004215f3c:	0f b6 c0             	movzbl %al,%eax
  8004215f3f:	83 e0 01             	and    $0x1,%eax
  8004215f42:	85 c0                	test   %eax,%eax
  8004215f44:	75 0a                	jne    8004215f50 <transmit_packet_e1000+0x5d>
	{
		//cprintf("transmit descriptor ring full...dropping packet...\n");
		return -1;
  8004215f46:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004215f4b:	e9 84 00 00 00       	jmpq   8004215fd4 <transmit_packet_e1000+0xe1>
	}
	
	//Truncate the packet length if >TBUFFERSIZE
	if(len > TBUFFERSIZE)
  8004215f50:	48 81 7d e0 ee 05 00 	cmpq   $0x5ee,-0x20(%rbp)
  8004215f57:	00 
  8004215f58:	76 08                	jbe    8004215f62 <transmit_packet_e1000+0x6f>
		len = TBUFFERSIZE;
  8004215f5a:	48 c7 45 e0 ee 05 00 	movq   $0x5ee,-0x20(%rbp)
  8004215f61:	00 

	//Copy the data to the packet header and update the descriptor length and status
	memmove(&tranBuf[tail], addr, len);
  8004215f62:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215f65:	48 89 c2             	mov    %rax,%rdx
  8004215f68:	48 c1 e2 0b          	shl    $0xb,%rdx
  8004215f6c:	48 b8 00 cc 65 04 80 	movabs $0x800465cc00,%rax
  8004215f73:	00 00 00 
  8004215f76:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8004215f7a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215f7e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215f82:	48 89 c6             	mov    %rax,%rsi
  8004215f85:	48 89 cf             	mov    %rcx,%rdi
  8004215f88:	48 b8 de e6 20 04 80 	movabs $0x800420e6de,%rax
  8004215f8f:	00 00 00 
  8004215f92:	ff d0                	callq  *%rax
	t->length = (uint16_t)len;
  8004215f94:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215f98:	89 c2                	mov    %eax,%edx
  8004215f9a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215f9e:	66 89 50 08          	mov    %dx,0x8(%rax)
	t->status = t->status & (!TXD_STAT_DD);
  8004215fa2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215fa6:	c6 40 0c 00          	movb   $0x0,0xc(%rax)

	//Update tail pointer
	tail = (tail+1)%NUM_TX_DESC;
  8004215faa:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215fad:	83 c0 01             	add    $0x1,%eax
  8004215fb0:	83 e0 3f             	and    $0x3f,%eax
  8004215fb3:	89 45 fc             	mov    %eax,-0x4(%rbp)

	//Update TDT register	
	pci_mmio_base[E1000_TDT/4] = tail;
  8004215fb6:	48 b8 10 f0 6f 04 80 	movabs $0x80046ff010,%rax
  8004215fbd:	00 00 00 
  8004215fc0:	48 8b 00             	mov    (%rax),%rax
  8004215fc3:	48 8d 90 18 38 00 00 	lea    0x3818(%rax),%rdx
  8004215fca:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215fcd:	89 02                	mov    %eax,(%rdx)
	return 0;
  8004215fcf:	b8 00 00 00 00       	mov    $0x0,%eax
} 
  8004215fd4:	c9                   	leaveq 
  8004215fd5:	c3                   	retq   

0000008004215fd6 <receive_packet_e1000>:

int receive_packet_e1000(void *addr, size_t len)
{
  8004215fd6:	55                   	push   %rbp
  8004215fd7:	48 89 e5             	mov    %rsp,%rbp
  8004215fda:	48 83 ec 20          	sub    $0x20,%rsp
  8004215fde:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004215fe2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint32_t tail = pci_mmio_base[E1000_RDT/4];
  8004215fe6:	48 b8 10 f0 6f 04 80 	movabs $0x80046ff010,%rax
  8004215fed:	00 00 00 
  8004215ff0:	48 8b 00             	mov    (%rax),%rax
  8004215ff3:	8b 80 18 28 00 00    	mov    0x2818(%rax),%eax
  8004215ff9:	89 45 fc             	mov    %eax,-0x4(%rbp)
	struct rx_desc *r = &recvDescRing[tail];
  8004215ffc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215fff:	48 89 c2             	mov    %rax,%rdx
  8004216002:	48 c1 e2 04          	shl    $0x4,%rdx
  8004216006:	48 b8 00 cc 67 04 80 	movabs $0x800467cc00,%rax
  800421600d:	00 00 00 
  8004216010:	48 01 d0             	add    %rdx,%rax
  8004216013:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	
	//Check if the receive descriptor ring is empty
	if((r->status & E1000_RXD_STAT_DD) == 0)
  8004216017:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421601b:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  800421601f:	0f b6 c0             	movzbl %al,%eax
  8004216022:	83 e0 01             	and    $0x1,%eax
  8004216025:	85 c0                	test   %eax,%eax
  8004216027:	75 0a                	jne    8004216033 <receive_packet_e1000+0x5d>
	{
		//cprintf("receive descriptor ring empty...dropping packet...\n");		
		return -1;
  8004216029:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421602e:	e9 83 00 00 00       	jmpq   80042160b6 <receive_packet_e1000+0xe0>
	}
	
	//Truncate the received packet if packet buffer length is lesser-sized
	if(r->length < len)
  8004216033:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216037:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800421603b:	0f b7 c0             	movzwl %ax,%eax
  800421603e:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004216042:	73 0f                	jae    8004216053 <receive_packet_e1000+0x7d>
		len = r->length;
  8004216044:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216048:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800421604c:	0f b7 c0             	movzwl %ax,%eax
  800421604f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

	//Copy the data from packet buffer to the address argument and update the descriptor status
	memmove(addr, &recvBuf[tail], len);
  8004216053:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004216056:	48 89 c2             	mov    %rax,%rdx
  8004216059:	48 c1 e2 0b          	shl    $0xb,%rdx
  800421605d:	48 b8 00 c8 63 04 80 	movabs $0x800463c800,%rax
  8004216064:	00 00 00 
  8004216067:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  800421606b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421606f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216073:	48 89 ce             	mov    %rcx,%rsi
  8004216076:	48 89 c7             	mov    %rax,%rdi
  8004216079:	48 b8 de e6 20 04 80 	movabs $0x800420e6de,%rax
  8004216080:	00 00 00 
  8004216083:	ff d0                	callq  *%rax
	r->status = r->status & (!E1000_RXD_STAT_DD);
  8004216085:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216089:	c6 40 0c 00          	movb   $0x0,0xc(%rax)
	
	//Update tail pointer
	tail = (tail+1)%NUM_RX_DESC;
  800421608d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004216090:	83 c0 01             	add    $0x1,%eax
  8004216093:	83 e0 3f             	and    $0x3f,%eax
  8004216096:	89 45 fc             	mov    %eax,-0x4(%rbp)

	//Update TDT register
	pci_mmio_base[E1000_RDT/4] = tail;
  8004216099:	48 b8 10 f0 6f 04 80 	movabs $0x80046ff010,%rax
  80042160a0:	00 00 00 
  80042160a3:	48 8b 00             	mov    (%rax),%rax
  80042160a6:	48 8d 90 18 28 00 00 	lea    0x2818(%rax),%rdx
  80042160ad:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042160b0:	89 02                	mov    %eax,(%rdx)
	return len;
  80042160b2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  80042160b6:	c9                   	leaveq 
  80042160b7:	c3                   	retq   

00000080042160b8 <attach_e1000>:

int attach_e1000(struct pci_func *pcif)
{
  80042160b8:	55                   	push   %rbp
  80042160b9:	48 89 e5             	mov    %rsp,%rbp
  80042160bc:	48 83 ec 30          	sub    $0x30,%rsp
  80042160c0:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	//uint32_t *devStatusReg,*TDBAH,*TDBAL,*TDLEN,*TDH,*TDT,*TCTL_EN,*TCTL_PSP,*TCTL_CT,*TCTL_COLD,*TIPG;
	//int i;
	
	pci_func_enable(pcif);
  80042160c4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042160c8:	48 89 c7             	mov    %rax,%rdi
  80042160cb:	48 b8 36 6c 21 04 80 	movabs $0x8004216c36,%rax
  80042160d2:	00 00 00 
  80042160d5:	ff d0                	callq  *%rax
	descriptors_init();
  80042160d7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042160dc:	48 ba 74 5c 21 04 80 	movabs $0x8004215c74,%rdx
  80042160e3:	00 00 00 
  80042160e6:	ff d2                	callq  *%rdx

	physaddr_t bar0_base = (physaddr_t)pcif->reg_base[0];
  80042160e8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042160ec:	8b 40 18             	mov    0x18(%rax),%eax
  80042160ef:	89 c0                	mov    %eax,%eax
  80042160f1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	size_t bar0_size = (size_t)pcif->reg_size[0];
  80042160f5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042160f9:	8b 40 30             	mov    0x30(%rax),%eax
  80042160fc:	89 c0                	mov    %eax,%eax
  80042160fe:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	pci_mmio_base = mmio_map_region(bar0_base, bar0_size);
  8004216102:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004216106:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421610a:	48 89 d6             	mov    %rdx,%rsi
  800421610d:	48 89 c7             	mov    %rax,%rdi
  8004216110:	48 b8 42 38 20 04 80 	movabs $0x8004203842,%rax
  8004216117:	00 00 00 
  800421611a:	ff d0                	callq  *%rax
  800421611c:	48 ba 10 f0 6f 04 80 	movabs $0x80046ff010,%rdx
  8004216123:	00 00 00 
  8004216126:	48 89 02             	mov    %rax,(%rdx)

	//Device status register
	cprintf("e1000 device status register:%x\n", pci_mmio_base[E1000_STATUS/4]);
  8004216129:	48 b8 10 f0 6f 04 80 	movabs $0x80046ff010,%rax
  8004216130:	00 00 00 
  8004216133:	48 8b 00             	mov    (%rax),%rax
  8004216136:	48 83 c0 08          	add    $0x8,%rax
  800421613a:	8b 00                	mov    (%rax),%eax
  800421613c:	89 c6                	mov    %eax,%esi
  800421613e:	48 bf 50 99 21 04 80 	movabs $0x8004219950,%rdi
  8004216145:	00 00 00 
  8004216148:	b8 00 00 00 00       	mov    $0x0,%eax
  800421614d:	48 ba f2 89 20 04 80 	movabs $0x80042089f2,%rdx
  8004216154:	00 00 00 
  8004216157:	ff d2                	callq  *%rdx
	
	//Initialize the card to transmit. Set the necessary registers
	pci_mmio_base[E1000_TDBAL/4] = PADDR(tranDescRing);
  8004216159:	48 b8 10 f0 6f 04 80 	movabs $0x80046ff010,%rax
  8004216160:	00 00 00 
  8004216163:	48 8b 00             	mov    (%rax),%rax
  8004216166:	48 8d 90 00 38 00 00 	lea    0x3800(%rax),%rdx
  800421616d:	48 b8 00 c8 65 04 80 	movabs $0x800465c800,%rax
  8004216174:	00 00 00 
  8004216177:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800421617b:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004216182:	00 00 00 
  8004216185:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004216189:	77 32                	ja     80042161bd <attach_e1000+0x105>
  800421618b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421618f:	48 89 c1             	mov    %rax,%rcx
  8004216192:	48 ba 18 99 21 04 80 	movabs $0x8004219918,%rdx
  8004216199:	00 00 00 
  800421619c:	be 6e 00 00 00       	mov    $0x6e,%esi
  80042161a1:	48 bf 3c 99 21 04 80 	movabs $0x800421993c,%rdi
  80042161a8:	00 00 00 
  80042161ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80042161b0:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042161b7:	00 00 00 
  80042161ba:	41 ff d0             	callq  *%r8
  80042161bd:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  80042161c4:	ff ff ff 
  80042161c7:	48 03 45 e8          	add    -0x18(%rbp),%rax
  80042161cb:	89 02                	mov    %eax,(%rdx)
	pci_mmio_base[E1000_TDBAH/4] = 0;
  80042161cd:	48 b8 10 f0 6f 04 80 	movabs $0x80046ff010,%rax
  80042161d4:	00 00 00 
  80042161d7:	48 8b 00             	mov    (%rax),%rax
  80042161da:	48 05 04 38 00 00    	add    $0x3804,%rax
  80042161e0:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	pci_mmio_base[E1000_TDLEN/4] = NUM_TX_DESC * sizeof(struct tx_desc);
  80042161e6:	48 b8 10 f0 6f 04 80 	movabs $0x80046ff010,%rax
  80042161ed:	00 00 00 
  80042161f0:	48 8b 00             	mov    (%rax),%rax
  80042161f3:	48 05 08 38 00 00    	add    $0x3808,%rax
  80042161f9:	c7 00 00 04 00 00    	movl   $0x400,(%rax)
	pci_mmio_base[E1000_TDH/4] = 0;
  80042161ff:	48 b8 10 f0 6f 04 80 	movabs $0x80046ff010,%rax
  8004216206:	00 00 00 
  8004216209:	48 8b 00             	mov    (%rax),%rax
  800421620c:	48 05 10 38 00 00    	add    $0x3810,%rax
  8004216212:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	pci_mmio_base[E1000_TDT/4] = 0;
  8004216218:	48 b8 10 f0 6f 04 80 	movabs $0x80046ff010,%rax
  800421621f:	00 00 00 
  8004216222:	48 8b 00             	mov    (%rax),%rax
  8004216225:	48 05 18 38 00 00    	add    $0x3818,%rax
  800421622b:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	pci_mmio_base[E1000_TCTL/4] = E1000_TCTL_EN|E1000_TCTL_PSP|(E1000_TCTL_CT & (0x10<<4))|(E1000_TCTL_COLD & (0x40<<12));
  8004216231:	48 b8 10 f0 6f 04 80 	movabs $0x80046ff010,%rax
  8004216238:	00 00 00 
  800421623b:	48 8b 00             	mov    (%rax),%rax
  800421623e:	48 05 00 04 00 00    	add    $0x400,%rax
  8004216244:	c7 00 0a 01 04 00    	movl   $0x4010a,(%rax)
	pci_mmio_base[E1000_TIPG/4] = 10|(8<<10)|(6<<20);
  800421624a:	48 b8 10 f0 6f 04 80 	movabs $0x80046ff010,%rax
  8004216251:	00 00 00 
  8004216254:	48 8b 00             	mov    (%rax),%rax
  8004216257:	48 05 10 04 00 00    	add    $0x410,%rax
  800421625d:	c7 00 0a 20 60 00    	movl   $0x60200a,(%rax)
                panic("panic in attach_e1000:transmit_packet_e1000:%e",res);
	*/

	//Initialize the card to receive. Set necessary registers
	//Set RAH and  RAL to filter out only packets destined for E1000's MACID
	pci_mmio_base[E1000_RA/4] = e1000_mac_address[0];
  8004216263:	48 b8 10 f0 6f 04 80 	movabs $0x80046ff010,%rax
  800421626a:	00 00 00 
  800421626d:	48 8b 00             	mov    (%rax),%rax
  8004216270:	48 8d 90 00 54 00 00 	lea    0x5400(%rax),%rdx
  8004216277:	48 b8 e8 a7 22 04 80 	movabs $0x800422a7e8,%rax
  800421627e:	00 00 00 
  8004216281:	8b 00                	mov    (%rax),%eax
  8004216283:	89 02                	mov    %eax,(%rdx)
	pci_mmio_base[E1000_RA/4+1] = e1000_mac_address[1];
  8004216285:	48 b8 10 f0 6f 04 80 	movabs $0x80046ff010,%rax
  800421628c:	00 00 00 
  800421628f:	48 8b 00             	mov    (%rax),%rax
  8004216292:	48 8d 90 04 54 00 00 	lea    0x5404(%rax),%rdx
  8004216299:	48 b8 e8 a7 22 04 80 	movabs $0x800422a7e8,%rax
  80042162a0:	00 00 00 
  80042162a3:	8b 40 04             	mov    0x4(%rax),%eax
  80042162a6:	89 02                	mov    %eax,(%rdx)
	pci_mmio_base[E1000_RA/4+1] |= E1000_RAH_AV;
  80042162a8:	48 b8 10 f0 6f 04 80 	movabs $0x80046ff010,%rax
  80042162af:	00 00 00 
  80042162b2:	48 8b 00             	mov    (%rax),%rax
  80042162b5:	48 8d 90 04 54 00 00 	lea    0x5404(%rax),%rdx
  80042162bc:	48 b8 10 f0 6f 04 80 	movabs $0x80046ff010,%rax
  80042162c3:	00 00 00 
  80042162c6:	48 8b 00             	mov    (%rax),%rax
  80042162c9:	48 05 04 54 00 00    	add    $0x5404,%rax
  80042162cf:	8b 00                	mov    (%rax),%eax
  80042162d1:	0d 00 00 00 80       	or     $0x80000000,%eax
  80042162d6:	89 02                	mov    %eax,(%rdx)
	cprintf("e1000 mac_address:%x:%x\n",e1000_mac_address[1],e1000_mac_address[0]);
  80042162d8:	48 b8 e8 a7 22 04 80 	movabs $0x800422a7e8,%rax
  80042162df:	00 00 00 
  80042162e2:	8b 10                	mov    (%rax),%edx
  80042162e4:	48 b8 e8 a7 22 04 80 	movabs $0x800422a7e8,%rax
  80042162eb:	00 00 00 
  80042162ee:	8b 40 04             	mov    0x4(%rax),%eax
  80042162f1:	89 c6                	mov    %eax,%esi
  80042162f3:	48 bf 71 99 21 04 80 	movabs $0x8004219971,%rdi
  80042162fa:	00 00 00 
  80042162fd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216302:	48 b9 f2 89 20 04 80 	movabs $0x80042089f2,%rcx
  8004216309:	00 00 00 
  800421630c:	ff d1                	callq  *%rcx
	
	pci_mmio_base[E1000_RDBAL/4] = PADDR(recvDescRing);
  800421630e:	48 b8 10 f0 6f 04 80 	movabs $0x80046ff010,%rax
  8004216315:	00 00 00 
  8004216318:	48 8b 00             	mov    (%rax),%rax
  800421631b:	48 8d 90 00 28 00 00 	lea    0x2800(%rax),%rdx
  8004216322:	48 b8 00 cc 67 04 80 	movabs $0x800467cc00,%rax
  8004216329:	00 00 00 
  800421632c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004216330:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004216337:	00 00 00 
  800421633a:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  800421633e:	77 32                	ja     8004216372 <attach_e1000+0x2ba>
  8004216340:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216344:	48 89 c1             	mov    %rax,%rcx
  8004216347:	48 ba 18 99 21 04 80 	movabs $0x8004219918,%rdx
  800421634e:	00 00 00 
  8004216351:	be 89 00 00 00       	mov    $0x89,%esi
  8004216356:	48 bf 3c 99 21 04 80 	movabs $0x800421993c,%rdi
  800421635d:	00 00 00 
  8004216360:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216365:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800421636c:	00 00 00 
  800421636f:	41 ff d0             	callq  *%r8
  8004216372:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004216379:	ff ff ff 
  800421637c:	48 03 45 e0          	add    -0x20(%rbp),%rax
  8004216380:	89 02                	mov    %eax,(%rdx)
	pci_mmio_base[E1000_RDBAH/4] = 0;
  8004216382:	48 b8 10 f0 6f 04 80 	movabs $0x80046ff010,%rax
  8004216389:	00 00 00 
  800421638c:	48 8b 00             	mov    (%rax),%rax
  800421638f:	48 05 04 28 00 00    	add    $0x2804,%rax
  8004216395:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	pci_mmio_base[E1000_RDLEN/4] = NUM_RX_DESC * sizeof(struct rx_desc);
  800421639b:	48 b8 10 f0 6f 04 80 	movabs $0x80046ff010,%rax
  80042163a2:	00 00 00 
  80042163a5:	48 8b 00             	mov    (%rax),%rax
  80042163a8:	48 05 08 28 00 00    	add    $0x2808,%rax
  80042163ae:	c7 00 00 04 00 00    	movl   $0x400,(%rax)
	pci_mmio_base[E1000_RDH/4] = 0;
  80042163b4:	48 b8 10 f0 6f 04 80 	movabs $0x80046ff010,%rax
  80042163bb:	00 00 00 
  80042163be:	48 8b 00             	mov    (%rax),%rax
  80042163c1:	48 05 10 28 00 00    	add    $0x2810,%rax
  80042163c7:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	pci_mmio_base[E1000_RDT/4] = 0;
  80042163cd:	48 b8 10 f0 6f 04 80 	movabs $0x80046ff010,%rax
  80042163d4:	00 00 00 
  80042163d7:	48 8b 00             	mov    (%rax),%rax
  80042163da:	48 05 18 28 00 00    	add    $0x2818,%rax
  80042163e0:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
	pci_mmio_base[E1000_RCTL/4] = E1000_RCTL_EN | E1000_RCTL_SZ_2048 | E1000_RCTL_SECRC;
  80042163e6:	48 b8 10 f0 6f 04 80 	movabs $0x80046ff010,%rax
  80042163ed:	00 00 00 
  80042163f0:	48 8b 00             	mov    (%rax),%rax
  80042163f3:	48 05 00 01 00 00    	add    $0x100,%rax
  80042163f9:	c7 00 02 00 00 04    	movl   $0x4000002,(%rax)
	
	return 0;	
  80042163ff:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004216404:	c9                   	leaveq 
  8004216405:	c3                   	retq   
	...

0000008004216408 <pci_conf1_set_addr>:
static void
pci_conf1_set_addr(uint32_t bus,
		   uint32_t dev,
		   uint32_t func,
		   uint32_t offset)
{
  8004216408:	55                   	push   %rbp
  8004216409:	48 89 e5             	mov    %rsp,%rbp
  800421640c:	48 83 ec 20          	sub    $0x20,%rsp
  8004216410:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004216413:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8004216416:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  8004216419:	89 4d e0             	mov    %ecx,-0x20(%rbp)
	assert(bus < 256);
  800421641c:	81 7d ec ff 00 00 00 	cmpl   $0xff,-0x14(%rbp)
  8004216423:	76 35                	jbe    800421645a <pci_conf1_set_addr+0x52>
  8004216425:	48 b9 90 99 21 04 80 	movabs $0x8004219990,%rcx
  800421642c:	00 00 00 
  800421642f:	48 ba 9a 99 21 04 80 	movabs $0x800421999a,%rdx
  8004216436:	00 00 00 
  8004216439:	be 2b 00 00 00       	mov    $0x2b,%esi
  800421643e:	48 bf af 99 21 04 80 	movabs $0x80042199af,%rdi
  8004216445:	00 00 00 
  8004216448:	b8 00 00 00 00       	mov    $0x0,%eax
  800421644d:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004216454:	00 00 00 
  8004216457:	41 ff d0             	callq  *%r8
	assert(dev < 32);
  800421645a:	83 7d e8 1f          	cmpl   $0x1f,-0x18(%rbp)
  800421645e:	76 35                	jbe    8004216495 <pci_conf1_set_addr+0x8d>
  8004216460:	48 b9 ba 99 21 04 80 	movabs $0x80042199ba,%rcx
  8004216467:	00 00 00 
  800421646a:	48 ba 9a 99 21 04 80 	movabs $0x800421999a,%rdx
  8004216471:	00 00 00 
  8004216474:	be 2c 00 00 00       	mov    $0x2c,%esi
  8004216479:	48 bf af 99 21 04 80 	movabs $0x80042199af,%rdi
  8004216480:	00 00 00 
  8004216483:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216488:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  800421648f:	00 00 00 
  8004216492:	41 ff d0             	callq  *%r8
	assert(func < 8);
  8004216495:	83 7d e4 07          	cmpl   $0x7,-0x1c(%rbp)
  8004216499:	76 35                	jbe    80042164d0 <pci_conf1_set_addr+0xc8>
  800421649b:	48 b9 c3 99 21 04 80 	movabs $0x80042199c3,%rcx
  80042164a2:	00 00 00 
  80042164a5:	48 ba 9a 99 21 04 80 	movabs $0x800421999a,%rdx
  80042164ac:	00 00 00 
  80042164af:	be 2d 00 00 00       	mov    $0x2d,%esi
  80042164b4:	48 bf af 99 21 04 80 	movabs $0x80042199af,%rdi
  80042164bb:	00 00 00 
  80042164be:	b8 00 00 00 00       	mov    $0x0,%eax
  80042164c3:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  80042164ca:	00 00 00 
  80042164cd:	41 ff d0             	callq  *%r8
	assert(offset < 256);
  80042164d0:	81 7d e0 ff 00 00 00 	cmpl   $0xff,-0x20(%rbp)
  80042164d7:	76 35                	jbe    800421650e <pci_conf1_set_addr+0x106>
  80042164d9:	48 b9 cc 99 21 04 80 	movabs $0x80042199cc,%rcx
  80042164e0:	00 00 00 
  80042164e3:	48 ba 9a 99 21 04 80 	movabs $0x800421999a,%rdx
  80042164ea:	00 00 00 
  80042164ed:	be 2e 00 00 00       	mov    $0x2e,%esi
  80042164f2:	48 bf af 99 21 04 80 	movabs $0x80042199af,%rdi
  80042164f9:	00 00 00 
  80042164fc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216501:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004216508:	00 00 00 
  800421650b:	41 ff d0             	callq  *%r8
	assert((offset & 0x3) == 0);
  800421650e:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004216511:	83 e0 03             	and    $0x3,%eax
  8004216514:	85 c0                	test   %eax,%eax
  8004216516:	74 35                	je     800421654d <pci_conf1_set_addr+0x145>
  8004216518:	48 b9 d9 99 21 04 80 	movabs $0x80042199d9,%rcx
  800421651f:	00 00 00 
  8004216522:	48 ba 9a 99 21 04 80 	movabs $0x800421999a,%rdx
  8004216529:	00 00 00 
  800421652c:	be 2f 00 00 00       	mov    $0x2f,%esi
  8004216531:	48 bf af 99 21 04 80 	movabs $0x80042199af,%rdi
  8004216538:	00 00 00 
  800421653b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216540:	49 b8 f2 04 20 04 80 	movabs $0x80042004f2,%r8
  8004216547:	00 00 00 
  800421654a:	41 ff d0             	callq  *%r8

	uint32_t v = (1 << 31) |		// config-space
		(bus << 16) | (dev << 11) | (func << 8) | (offset);
  800421654d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216550:	89 c2                	mov    %eax,%edx
  8004216552:	c1 e2 10             	shl    $0x10,%edx
  8004216555:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004216558:	c1 e0 0b             	shl    $0xb,%eax
  800421655b:	09 c2                	or     %eax,%edx
  800421655d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004216560:	c1 e0 08             	shl    $0x8,%eax
  8004216563:	09 d0                	or     %edx,%eax
  8004216565:	0b 45 e0             	or     -0x20(%rbp),%eax
	assert(dev < 32);
	assert(func < 8);
	assert(offset < 256);
	assert((offset & 0x3) == 0);

	uint32_t v = (1 << 31) |		// config-space
  8004216568:	0d 00 00 00 80       	or     $0x80000000,%eax
  800421656d:	89 45 fc             	mov    %eax,-0x4(%rbp)
		(bus << 16) | (dev << 11) | (func << 8) | (offset);
	outl(pci_conf1_addr_ioport, v);
  8004216570:	48 b8 04 a8 22 04 80 	movabs $0x800422a804,%rax
  8004216577:	00 00 00 
  800421657a:	8b 00                	mov    (%rax),%eax
  800421657c:	89 45 f8             	mov    %eax,-0x8(%rbp)
  800421657f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004216582:	89 45 f4             	mov    %eax,-0xc(%rbp)
}

static __inline void
outl(int port, uint32_t data)
{
	__asm __volatile("outl %0,%w1" : : "a" (data), "d" (port));
  8004216585:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216588:	8b 55 f8             	mov    -0x8(%rbp),%edx
  800421658b:	ef                   	out    %eax,(%dx)
}
  800421658c:	c9                   	leaveq 
  800421658d:	c3                   	retq   

000000800421658e <pci_conf_read>:

static uint32_t
pci_conf_read(struct pci_func *f, uint32_t off)
{
  800421658e:	55                   	push   %rbp
  800421658f:	48 89 e5             	mov    %rsp,%rbp
  8004216592:	53                   	push   %rbx
  8004216593:	48 83 ec 28          	sub    $0x28,%rsp
  8004216597:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800421659b:	89 75 d4             	mov    %esi,-0x2c(%rbp)
	pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  800421659e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042165a2:	8b 50 0c             	mov    0xc(%rax),%edx
  80042165a5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042165a9:	8b 70 08             	mov    0x8(%rax),%esi
  80042165ac:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042165b0:	48 8b 00             	mov    (%rax),%rax
  80042165b3:	8b 40 08             	mov    0x8(%rax),%eax
  80042165b6:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  80042165b9:	89 c7                	mov    %eax,%edi
  80042165bb:	48 b8 08 64 21 04 80 	movabs $0x8004216408,%rax
  80042165c2:	00 00 00 
  80042165c5:	ff d0                	callq  *%rax
	return inl(pci_conf1_data_ioport);
  80042165c7:	48 b8 08 a8 22 04 80 	movabs $0x800422a808,%rax
  80042165ce:	00 00 00 
  80042165d1:	8b 00                	mov    (%rax),%eax
  80042165d3:	89 45 ec             	mov    %eax,-0x14(%rbp)

static __inline uint32_t
inl(int port)
{
	uint32_t data;
	__asm __volatile("inl %w1,%0" : "=a" (data) : "d" (port));
  80042165d6:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042165d9:	89 55 d0             	mov    %edx,-0x30(%rbp)
  80042165dc:	8b 55 d0             	mov    -0x30(%rbp),%edx
  80042165df:	ed                   	in     (%dx),%eax
  80042165e0:	89 c3                	mov    %eax,%ebx
  80042165e2:	89 5d e8             	mov    %ebx,-0x18(%rbp)
	return data;
  80042165e5:	8b 45 e8             	mov    -0x18(%rbp),%eax
}
  80042165e8:	48 83 c4 28          	add    $0x28,%rsp
  80042165ec:	5b                   	pop    %rbx
  80042165ed:	5d                   	pop    %rbp
  80042165ee:	c3                   	retq   

00000080042165ef <pci_conf_write>:

static void
pci_conf_write(struct pci_func *f, uint32_t off, uint32_t v)
{
  80042165ef:	55                   	push   %rbp
  80042165f0:	48 89 e5             	mov    %rsp,%rbp
  80042165f3:	48 83 ec 20          	sub    $0x20,%rsp
  80042165f7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042165fb:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  80042165fe:	89 55 e0             	mov    %edx,-0x20(%rbp)
	pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  8004216601:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216605:	8b 50 0c             	mov    0xc(%rax),%edx
  8004216608:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421660c:	8b 70 08             	mov    0x8(%rax),%esi
  800421660f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216613:	48 8b 00             	mov    (%rax),%rax
  8004216616:	8b 40 08             	mov    0x8(%rax),%eax
  8004216619:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800421661c:	89 c7                	mov    %eax,%edi
  800421661e:	48 b8 08 64 21 04 80 	movabs $0x8004216408,%rax
  8004216625:	00 00 00 
  8004216628:	ff d0                	callq  *%rax
	outl(pci_conf1_data_ioport, v);
  800421662a:	48 b8 08 a8 22 04 80 	movabs $0x800422a808,%rax
  8004216631:	00 00 00 
  8004216634:	8b 00                	mov    (%rax),%eax
  8004216636:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004216639:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421663c:	89 45 f8             	mov    %eax,-0x8(%rbp)
}

static __inline void
outl(int port, uint32_t data)
{
	__asm __volatile("outl %0,%w1" : : "a" (data), "d" (port));
  800421663f:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004216642:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004216645:	ef                   	out    %eax,(%dx)
}
  8004216646:	c9                   	leaveq 
  8004216647:	c3                   	retq   

0000008004216648 <pci_attach_match>:

static int __attribute__((warn_unused_result))
pci_attach_match(uint32_t key1, uint32_t key2,
		 struct pci_driver *list, struct pci_func *pcif)
{
  8004216648:	55                   	push   %rbp
  8004216649:	48 89 e5             	mov    %rsp,%rbp
  800421664c:	48 83 ec 30          	sub    $0x30,%rsp
  8004216650:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004216653:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8004216656:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  800421665a:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
	uint32_t i;

	for (i = 0; list[i].attachfn; i++) {
  800421665e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004216665:	e9 8e 00 00 00       	jmpq   80042166f8 <pci_attach_match+0xb0>
		if (list[i].key1 == key1 && list[i].key2 == key2) {
  800421666a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421666d:	48 c1 e0 04          	shl    $0x4,%rax
  8004216671:	48 03 45 e0          	add    -0x20(%rbp),%rax
  8004216675:	8b 00                	mov    (%rax),%eax
  8004216677:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800421667a:	75 78                	jne    80042166f4 <pci_attach_match+0xac>
  800421667c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421667f:	48 c1 e0 04          	shl    $0x4,%rax
  8004216683:	48 03 45 e0          	add    -0x20(%rbp),%rax
  8004216687:	8b 40 04             	mov    0x4(%rax),%eax
  800421668a:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  800421668d:	75 65                	jne    80042166f4 <pci_attach_match+0xac>
			int r = list[i].attachfn(pcif);
  800421668f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004216692:	48 c1 e0 04          	shl    $0x4,%rax
  8004216696:	48 03 45 e0          	add    -0x20(%rbp),%rax
  800421669a:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800421669e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042166a2:	48 89 c7             	mov    %rax,%rdi
  80042166a5:	ff d2                	callq  *%rdx
  80042166a7:	89 45 f8             	mov    %eax,-0x8(%rbp)
			if (r > 0)
  80042166aa:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80042166ae:	7e 05                	jle    80042166b5 <pci_attach_match+0x6d>
				return r;
  80042166b0:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042166b3:	eb 60                	jmp    8004216715 <pci_attach_match+0xcd>
			if (r < 0)
  80042166b5:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80042166b9:	79 39                	jns    80042166f4 <pci_attach_match+0xac>
				cprintf("pci_attach_match: attaching "
					"%x.%x (%p): e\n",
					key1, key2, list[i].attachfn, r);
  80042166bb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042166be:	48 c1 e0 04          	shl    $0x4,%rax
  80042166c2:	48 03 45 e0          	add    -0x20(%rbp),%rax
		if (list[i].key1 == key1 && list[i].key2 == key2) {
			int r = list[i].attachfn(pcif);
			if (r > 0)
				return r;
			if (r < 0)
				cprintf("pci_attach_match: attaching "
  80042166c6:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042166ca:	8b 75 f8             	mov    -0x8(%rbp),%esi
  80042166cd:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80042166d0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042166d3:	41 89 f0             	mov    %esi,%r8d
  80042166d6:	89 c6                	mov    %eax,%esi
  80042166d8:	48 bf f0 99 21 04 80 	movabs $0x80042199f0,%rdi
  80042166df:	00 00 00 
  80042166e2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042166e7:	49 b9 f2 89 20 04 80 	movabs $0x80042089f2,%r9
  80042166ee:	00 00 00 
  80042166f1:	41 ff d1             	callq  *%r9
pci_attach_match(uint32_t key1, uint32_t key2,
		 struct pci_driver *list, struct pci_func *pcif)
{
	uint32_t i;

	for (i = 0; list[i].attachfn; i++) {
  80042166f4:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042166f8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042166fb:	48 c1 e0 04          	shl    $0x4,%rax
  80042166ff:	48 03 45 e0          	add    -0x20(%rbp),%rax
  8004216703:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004216707:	48 85 c0             	test   %rax,%rax
  800421670a:	0f 85 5a ff ff ff    	jne    800421666a <pci_attach_match+0x22>
				cprintf("pci_attach_match: attaching "
					"%x.%x (%p): e\n",
					key1, key2, list[i].attachfn, r);
		}
	}
	return 0;
  8004216710:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004216715:	c9                   	leaveq 
  8004216716:	c3                   	retq   

0000008004216717 <pci_attach>:

static int
pci_attach(struct pci_func *f)
{
  8004216717:	55                   	push   %rbp
  8004216718:	48 89 e5             	mov    %rsp,%rbp
  800421671b:	48 83 ec 10          	sub    $0x10,%rsp
  800421671f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
  8004216723:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216727:	8b 40 14             	mov    0x14(%rax),%eax
  800421672a:	c1 e8 10             	shr    $0x10,%eax

static int
pci_attach(struct pci_func *f)
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
  800421672d:	0f b6 f0             	movzbl %al,%esi
  8004216730:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216734:	8b 40 14             	mov    0x14(%rax),%eax
  8004216737:	89 c7                	mov    %eax,%edi
  8004216739:	c1 ef 18             	shr    $0x18,%edi
  800421673c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216740:	48 89 c1             	mov    %rax,%rcx
  8004216743:	48 ba 20 a8 22 04 80 	movabs $0x800422a820,%rdx
  800421674a:	00 00 00 
  800421674d:	48 b8 48 66 21 04 80 	movabs $0x8004216648,%rax
  8004216754:	00 00 00 
  8004216757:	ff d0                	callq  *%rax
}

static int
pci_attach(struct pci_func *f)
{
	return
  8004216759:	85 c0                	test   %eax,%eax
  800421675b:	75 37                	jne    8004216794 <pci_attach+0x7d>
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
		pci_attach_match(PCI_VENDOR(f->dev_id),
				 PCI_PRODUCT(f->dev_id),
  800421675d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216761:	8b 40 10             	mov    0x10(%rax),%eax
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
		pci_attach_match(PCI_VENDOR(f->dev_id),
  8004216764:	89 c6                	mov    %eax,%esi
  8004216766:	c1 ee 10             	shr    $0x10,%esi
  8004216769:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421676d:	8b 40 10             	mov    0x10(%rax),%eax
  8004216770:	0f b7 f8             	movzwl %ax,%edi
  8004216773:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216777:	48 89 c1             	mov    %rax,%rcx
  800421677a:	48 ba 40 a8 22 04 80 	movabs $0x800422a840,%rdx
  8004216781:	00 00 00 
  8004216784:	48 b8 48 66 21 04 80 	movabs $0x8004216648,%rax
  800421678b:	00 00 00 
  800421678e:	ff d0                	callq  *%rax
pci_attach(struct pci_func *f)
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
  8004216790:	85 c0                	test   %eax,%eax
  8004216792:	74 07                	je     800421679b <pci_attach+0x84>
}

static int
pci_attach(struct pci_func *f)
{
	return
  8004216794:	b8 01 00 00 00       	mov    $0x1,%eax
  8004216799:	eb 05                	jmp    80042167a0 <pci_attach+0x89>
  800421679b:	b8 00 00 00 00       	mov    $0x0,%eax
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
		pci_attach_match(PCI_VENDOR(f->dev_id),
				 PCI_PRODUCT(f->dev_id),
				 &pci_attach_vendor[0], f);
}
  80042167a0:	c9                   	leaveq 
  80042167a1:	c3                   	retq   

00000080042167a2 <pci_print_func>:
	[0x6] = "Bridge device",
};

static void
pci_print_func(struct pci_func *f)
{
  80042167a2:	55                   	push   %rbp
  80042167a3:	48 89 e5             	mov    %rsp,%rbp
  80042167a6:	48 83 ec 40          	sub    $0x40,%rsp
  80042167aa:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	const char *class = pci_class[0];
  80042167ae:	48 b8 60 a8 22 04 80 	movabs $0x800422a860,%rax
  80042167b5:	00 00 00 
  80042167b8:	48 8b 00             	mov    (%rax),%rax
  80042167bb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
  80042167bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042167c3:	8b 40 14             	mov    0x14(%rax),%eax
  80042167c6:	c1 e8 18             	shr    $0x18,%eax
  80042167c9:	83 f8 06             	cmp    $0x6,%eax
  80042167cc:	77 20                	ja     80042167ee <pci_print_func+0x4c>
		class = pci_class[PCI_CLASS(f->dev_class)];
  80042167ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042167d2:	8b 40 14             	mov    0x14(%rax),%eax
  80042167d5:	89 c2                	mov    %eax,%edx
  80042167d7:	c1 ea 18             	shr    $0x18,%edx
  80042167da:	48 b8 60 a8 22 04 80 	movabs $0x800422a860,%rax
  80042167e1:	00 00 00 
  80042167e4:	89 d2                	mov    %edx,%edx
  80042167e6:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80042167ea:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
		f->irq_line);
  80042167ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042167f2:	0f b6 40 48          	movzbl 0x48(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  80042167f6:	0f b6 f0             	movzbl %al,%esi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
  80042167f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042167fd:	8b 40 14             	mov    0x14(%rax),%eax
  8004216800:	c1 e8 10             	shr    $0x10,%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004216803:	44 0f b6 c0          	movzbl %al,%r8d
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
  8004216807:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421680b:	8b 40 14             	mov    0x14(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  800421680e:	89 c7                	mov    %eax,%edi
  8004216810:	c1 ef 18             	shr    $0x18,%edi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004216813:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216817:	8b 40 10             	mov    0x10(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  800421681a:	41 89 c1             	mov    %eax,%r9d
  800421681d:	41 c1 e9 10          	shr    $0x10,%r9d
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004216821:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216825:	8b 40 10             	mov    0x10(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004216828:	44 0f b7 d0          	movzwl %ax,%r10d
		f->bus->busno, f->dev, f->func,
  800421682c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004216830:	8b 48 0c             	mov    0xc(%rax),%ecx
		f->bus->busno, f->dev, f->func,
  8004216833:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004216837:	8b 50 08             	mov    0x8(%rax),%edx
		f->bus->busno, f->dev, f->func,
  800421683a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421683e:	48 8b 00             	mov    (%rax),%rax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004216841:	8b 40 08             	mov    0x8(%rax),%eax
  8004216844:	89 74 24 18          	mov    %esi,0x18(%rsp)
  8004216848:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800421684c:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  8004216851:	44 89 44 24 08       	mov    %r8d,0x8(%rsp)
  8004216856:	89 3c 24             	mov    %edi,(%rsp)
  8004216859:	45 89 d0             	mov    %r10d,%r8d
  800421685c:	89 c6                	mov    %eax,%esi
  800421685e:	48 bf 90 9a 21 04 80 	movabs $0x8004219a90,%rdi
  8004216865:	00 00 00 
  8004216868:	b8 00 00 00 00       	mov    $0x0,%eax
  800421686d:	49 ba f2 89 20 04 80 	movabs $0x80042089f2,%r10
  8004216874:	00 00 00 
  8004216877:	41 ff d2             	callq  *%r10
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
		f->irq_line);
}
  800421687a:	c9                   	leaveq 
  800421687b:	c3                   	retq   

000000800421687c <pci_scan_bus>:

static int
pci_scan_bus(struct pci_bus *bus)
{
  800421687c:	55                   	push   %rbp
  800421687d:	48 89 e5             	mov    %rsp,%rbp
  8004216880:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  8004216887:	48 89 bd f8 fe ff ff 	mov    %rdi,-0x108(%rbp)
	int totaldev = 0;
  800421688e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct pci_func df;
	memset(&df, 0, sizeof(df));
  8004216895:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004216899:	ba 50 00 00 00       	mov    $0x50,%edx
  800421689e:	be 00 00 00 00       	mov    $0x0,%esi
  80042168a3:	48 89 c7             	mov    %rax,%rdi
  80042168a6:	48 b8 53 e6 20 04 80 	movabs $0x800420e653,%rax
  80042168ad:	00 00 00 
  80042168b0:	ff d0                	callq  *%rax
	df.bus = bus;
  80042168b2:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  80042168b9:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

	for (df.dev = 0; df.dev < 32; df.dev++) {
  80042168bd:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%rbp)
  80042168c4:	e9 2a 02 00 00       	jmpq   8004216af3 <pci_scan_bus+0x277>
		uint32_t bhlc = pci_conf_read(&df, PCI_BHLC_REG);
  80042168c9:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042168cd:	be 0c 00 00 00       	mov    $0xc,%esi
  80042168d2:	48 89 c7             	mov    %rax,%rdi
  80042168d5:	48 b8 8e 65 21 04 80 	movabs $0x800421658e,%rax
  80042168dc:	00 00 00 
  80042168df:	ff d0                	callq  *%rax
  80042168e1:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (PCI_HDRTYPE_TYPE(bhlc) > 1)	    // Unsupported or no device
  80042168e4:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042168e7:	c1 e8 10             	shr    $0x10,%eax
  80042168ea:	83 e0 7f             	and    $0x7f,%eax
  80042168ed:	83 f8 01             	cmp    $0x1,%eax
  80042168f0:	0f 87 f3 01 00 00    	ja     8004216ae9 <pci_scan_bus+0x26d>
			continue;

		totaldev++;
  80042168f6:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)

		struct pci_func f = df;
  80042168fa:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042168fe:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
  8004216905:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004216909:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
  8004216910:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004216914:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
  800421691b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421691f:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
  8004216926:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421692a:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  8004216931:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004216935:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  800421693c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216940:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  8004216947:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421694b:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004216952:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216956:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800421695d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216961:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  8004216968:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%rbp)
  800421696f:	00 00 00 
  8004216972:	e9 4a 01 00 00       	jmpq   8004216ac1 <pci_scan_bus+0x245>
		     f.func++) {
			struct pci_func af = f;
  8004216977:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  800421697e:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
  8004216985:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800421698c:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  8004216993:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  800421699a:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  80042169a1:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042169a8:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  80042169af:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  80042169b6:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  80042169bd:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042169c4:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  80042169cb:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  80042169d2:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  80042169d6:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  80042169dd:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  80042169e1:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  80042169e8:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  80042169ec:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042169f3:	48 89 45 98          	mov    %rax,-0x68(%rbp)

			af.dev_id = pci_conf_read(&f, PCI_ID_REG);
  80042169f7:	48 8d 85 00 ff ff ff 	lea    -0x100(%rbp),%rax
  80042169fe:	be 00 00 00 00       	mov    $0x0,%esi
  8004216a03:	48 89 c7             	mov    %rax,%rdi
  8004216a06:	48 b8 8e 65 21 04 80 	movabs $0x800421658e,%rax
  8004216a0d:	00 00 00 
  8004216a10:	ff d0                	callq  *%rax
  8004216a12:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%rbp)
			if (PCI_VENDOR(af.dev_id) == 0xffff)
  8004216a18:	8b 85 60 ff ff ff    	mov    -0xa0(%rbp),%eax
  8004216a1e:	25 ff ff 00 00       	and    $0xffff,%eax
  8004216a23:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004216a28:	0f 84 83 00 00 00    	je     8004216ab1 <pci_scan_bus+0x235>
				continue;

			uint32_t intr = pci_conf_read(&af, PCI_INTERRUPT_REG);
  8004216a2e:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004216a35:	be 3c 00 00 00       	mov    $0x3c,%esi
  8004216a3a:	48 89 c7             	mov    %rax,%rdi
  8004216a3d:	48 b8 8e 65 21 04 80 	movabs $0x800421658e,%rax
  8004216a44:	00 00 00 
  8004216a47:	ff d0                	callq  *%rax
  8004216a49:	89 45 f4             	mov    %eax,-0xc(%rbp)
			af.irq_line = PCI_INTERRUPT_LINE(intr);
  8004216a4c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216a4f:	88 45 98             	mov    %al,-0x68(%rbp)

			af.dev_class = pci_conf_read(&af, PCI_CLASS_REG);
  8004216a52:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004216a59:	be 08 00 00 00       	mov    $0x8,%esi
  8004216a5e:	48 89 c7             	mov    %rax,%rdi
  8004216a61:	48 b8 8e 65 21 04 80 	movabs $0x800421658e,%rax
  8004216a68:	00 00 00 
  8004216a6b:	ff d0                	callq  *%rax
  8004216a6d:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%rbp)
			if (pci_show_devs)
  8004216a73:	48 b8 00 a8 22 04 80 	movabs $0x800422a800,%rax
  8004216a7a:	00 00 00 
  8004216a7d:	8b 00                	mov    (%rax),%eax
  8004216a7f:	85 c0                	test   %eax,%eax
  8004216a81:	74 16                	je     8004216a99 <pci_scan_bus+0x21d>
				pci_print_func(&af);
  8004216a83:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004216a8a:	48 89 c7             	mov    %rax,%rdi
  8004216a8d:	48 b8 a2 67 21 04 80 	movabs $0x80042167a2,%rax
  8004216a94:	00 00 00 
  8004216a97:	ff d0                	callq  *%rax
			pci_attach(&af);
  8004216a99:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004216aa0:	48 89 c7             	mov    %rax,%rdi
  8004216aa3:	48 b8 17 67 21 04 80 	movabs $0x8004216717,%rax
  8004216aaa:	00 00 00 
  8004216aad:	ff d0                	callq  *%rax
  8004216aaf:	eb 01                	jmp    8004216ab2 <pci_scan_bus+0x236>
		     f.func++) {
			struct pci_func af = f;

			af.dev_id = pci_conf_read(&f, PCI_ID_REG);
			if (PCI_VENDOR(af.dev_id) == 0xffff)
				continue;
  8004216ab1:	90                   	nop

		totaldev++;

		struct pci_func f = df;
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
		     f.func++) {
  8004216ab2:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  8004216ab8:	83 c0 01             	add    $0x1,%eax
  8004216abb:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
			continue;

		totaldev++;

		struct pci_func f = df;
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  8004216ac1:	8b 95 0c ff ff ff    	mov    -0xf4(%rbp),%edx
  8004216ac7:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004216aca:	25 00 00 80 00       	and    $0x800000,%eax
  8004216acf:	85 c0                	test   %eax,%eax
  8004216ad1:	74 07                	je     8004216ada <pci_scan_bus+0x25e>
  8004216ad3:	b8 08 00 00 00       	mov    $0x8,%eax
  8004216ad8:	eb 05                	jmp    8004216adf <pci_scan_bus+0x263>
  8004216ada:	b8 01 00 00 00       	mov    $0x1,%eax
  8004216adf:	39 c2                	cmp    %eax,%edx
  8004216ae1:	0f 82 90 fe ff ff    	jb     8004216977 <pci_scan_bus+0xfb>
  8004216ae7:	eb 01                	jmp    8004216aea <pci_scan_bus+0x26e>
	df.bus = bus;

	for (df.dev = 0; df.dev < 32; df.dev++) {
		uint32_t bhlc = pci_conf_read(&df, PCI_BHLC_REG);
		if (PCI_HDRTYPE_TYPE(bhlc) > 1)	    // Unsupported or no device
			continue;
  8004216ae9:	90                   	nop
	int totaldev = 0;
	struct pci_func df;
	memset(&df, 0, sizeof(df));
	df.bus = bus;

	for (df.dev = 0; df.dev < 32; df.dev++) {
  8004216aea:	8b 45 a8             	mov    -0x58(%rbp),%eax
  8004216aed:	83 c0 01             	add    $0x1,%eax
  8004216af0:	89 45 a8             	mov    %eax,-0x58(%rbp)
  8004216af3:	8b 45 a8             	mov    -0x58(%rbp),%eax
  8004216af6:	83 f8 1f             	cmp    $0x1f,%eax
  8004216af9:	0f 86 ca fd ff ff    	jbe    80042168c9 <pci_scan_bus+0x4d>
				pci_print_func(&af);
			pci_attach(&af);
		}
	}

	return totaldev;
  8004216aff:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004216b02:	c9                   	leaveq 
  8004216b03:	c3                   	retq   

0000008004216b04 <pci_bridge_attach>:

static int
pci_bridge_attach(struct pci_func *pcif)
{
  8004216b04:	55                   	push   %rbp
  8004216b05:	48 89 e5             	mov    %rsp,%rbp
  8004216b08:	48 83 ec 30          	sub    $0x30,%rsp
  8004216b0c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
  8004216b10:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216b14:	be 1c 00 00 00       	mov    $0x1c,%esi
  8004216b19:	48 89 c7             	mov    %rax,%rdi
  8004216b1c:	48 b8 8e 65 21 04 80 	movabs $0x800421658e,%rax
  8004216b23:	00 00 00 
  8004216b26:	ff d0                	callq  *%rax
  8004216b28:	89 45 fc             	mov    %eax,-0x4(%rbp)
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);
  8004216b2b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216b2f:	be 18 00 00 00       	mov    $0x18,%esi
  8004216b34:	48 89 c7             	mov    %rax,%rdi
  8004216b37:	48 b8 8e 65 21 04 80 	movabs $0x800421658e,%rax
  8004216b3e:	00 00 00 
  8004216b41:	ff d0                	callq  *%rax
  8004216b43:	89 45 f8             	mov    %eax,-0x8(%rbp)

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
  8004216b46:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004216b49:	83 e0 0f             	and    $0xf,%eax
  8004216b4c:	83 f8 01             	cmp    $0x1,%eax
  8004216b4f:	75 40                	jne    8004216b91 <pci_bridge_attach+0x8d>
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
			pcif->bus->busno, pcif->dev, pcif->func);
  8004216b51:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
{
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  8004216b55:	8b 48 0c             	mov    0xc(%rax),%ecx
			pcif->bus->busno, pcif->dev, pcif->func);
  8004216b58:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
{
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  8004216b5c:	8b 50 08             	mov    0x8(%rax),%edx
			pcif->bus->busno, pcif->dev, pcif->func);
  8004216b5f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216b63:	48 8b 00             	mov    (%rax),%rax
{
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  8004216b66:	8b 40 08             	mov    0x8(%rax),%eax
  8004216b69:	89 c6                	mov    %eax,%esi
  8004216b6b:	48 bf d0 9a 21 04 80 	movabs $0x8004219ad0,%rdi
  8004216b72:	00 00 00 
  8004216b75:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216b7a:	49 b8 f2 89 20 04 80 	movabs $0x80042089f2,%r8
  8004216b81:	00 00 00 
  8004216b84:	41 ff d0             	callq  *%r8
			pcif->bus->busno, pcif->dev, pcif->func);
		return 0;
  8004216b87:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216b8c:	e9 a3 00 00 00       	jmpq   8004216c34 <pci_bridge_attach+0x130>
	}

	struct pci_bus nbus;
	memset(&nbus, 0, sizeof(nbus));
  8004216b91:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004216b95:	ba 10 00 00 00       	mov    $0x10,%edx
  8004216b9a:	be 00 00 00 00       	mov    $0x0,%esi
  8004216b9f:	48 89 c7             	mov    %rax,%rdi
  8004216ba2:	48 b8 53 e6 20 04 80 	movabs $0x800420e653,%rax
  8004216ba9:	00 00 00 
  8004216bac:	ff d0                	callq  *%rax
	nbus.parent_bridge = pcif;
  8004216bae:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216bb2:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;
  8004216bb6:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004216bb9:	c1 e8 08             	shr    $0x8,%eax
  8004216bbc:	25 ff 00 00 00       	and    $0xff,%eax
  8004216bc1:	89 45 e8             	mov    %eax,-0x18(%rbp)

	if (pci_show_devs)
  8004216bc4:	48 b8 00 a8 22 04 80 	movabs $0x800422a800,%rax
  8004216bcb:	00 00 00 
  8004216bce:	8b 00                	mov    (%rax),%eax
  8004216bd0:	85 c0                	test   %eax,%eax
  8004216bd2:	74 48                	je     8004216c1c <pci_bridge_attach+0x118>
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
			pcif->bus->busno, pcif->dev, pcif->func,
			nbus.busno,
			(busreg >> PCI_BRIDGE_BUS_SUBORDINATE_SHIFT) & 0xff);
  8004216bd4:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004216bd7:	c1 e8 10             	shr    $0x10,%eax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  8004216bda:	0f b6 f8             	movzbl %al,%edi
  8004216bdd:	8b 75 e8             	mov    -0x18(%rbp),%esi
			pcif->bus->busno, pcif->dev, pcif->func,
  8004216be0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  8004216be4:	8b 48 0c             	mov    0xc(%rax),%ecx
			pcif->bus->busno, pcif->dev, pcif->func,
  8004216be7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  8004216beb:	8b 50 08             	mov    0x8(%rax),%edx
			pcif->bus->busno, pcif->dev, pcif->func,
  8004216bee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216bf2:	48 8b 00             	mov    (%rax),%rax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  8004216bf5:	8b 40 08             	mov    0x8(%rax),%eax
  8004216bf8:	41 89 f9             	mov    %edi,%r9d
  8004216bfb:	41 89 f0             	mov    %esi,%r8d
  8004216bfe:	89 c6                	mov    %eax,%esi
  8004216c00:	48 bf 08 9b 21 04 80 	movabs $0x8004219b08,%rdi
  8004216c07:	00 00 00 
  8004216c0a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216c0f:	49 ba f2 89 20 04 80 	movabs $0x80042089f2,%r10
  8004216c16:	00 00 00 
  8004216c19:	41 ff d2             	callq  *%r10
			pcif->bus->busno, pcif->dev, pcif->func,
			nbus.busno,
			(busreg >> PCI_BRIDGE_BUS_SUBORDINATE_SHIFT) & 0xff);

	pci_scan_bus(&nbus);
  8004216c1c:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004216c20:	48 89 c7             	mov    %rax,%rdi
  8004216c23:	48 b8 7c 68 21 04 80 	movabs $0x800421687c,%rax
  8004216c2a:	00 00 00 
  8004216c2d:	ff d0                	callq  *%rax
	return 1;
  8004216c2f:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004216c34:	c9                   	leaveq 
  8004216c35:	c3                   	retq   

0000008004216c36 <pci_func_enable>:

// External PCI subsystem interface

void
pci_func_enable(struct pci_func *f)
{
  8004216c36:	55                   	push   %rbp
  8004216c37:	48 89 e5             	mov    %rsp,%rbp
  8004216c3a:	48 83 ec 50          	sub    $0x50,%rsp
  8004216c3e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	pci_conf_write(f, PCI_COMMAND_STATUS_REG,
  8004216c42:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216c46:	ba 07 00 00 00       	mov    $0x7,%edx
  8004216c4b:	be 04 00 00 00       	mov    $0x4,%esi
  8004216c50:	48 89 c7             	mov    %rax,%rdi
  8004216c53:	48 b8 ef 65 21 04 80 	movabs $0x80042165ef,%rax
  8004216c5a:	00 00 00 
  8004216c5d:	ff d0                	callq  *%rax
		       PCI_COMMAND_MEM_ENABLE |
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  8004216c5f:	c7 45 f8 10 00 00 00 	movl   $0x10,-0x8(%rbp)
  8004216c66:	e9 f1 01 00 00       	jmpq   8004216e5c <pci_func_enable+0x226>
	     bar += bar_width)
	{
		uint32_t oldv = pci_conf_read(f, bar);
  8004216c6b:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004216c6e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216c72:	89 d6                	mov    %edx,%esi
  8004216c74:	48 89 c7             	mov    %rax,%rdi
  8004216c77:	48 b8 8e 65 21 04 80 	movabs $0x800421658e,%rax
  8004216c7e:	00 00 00 
  8004216c81:	ff d0                	callq  *%rax
  8004216c83:	89 45 ec             	mov    %eax,-0x14(%rbp)

		bar_width = 4;
  8004216c86:	c7 45 fc 04 00 00 00 	movl   $0x4,-0x4(%rbp)
		pci_conf_write(f, bar, 0xffffffff);
  8004216c8d:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  8004216c90:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216c94:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8004216c99:	89 ce                	mov    %ecx,%esi
  8004216c9b:	48 89 c7             	mov    %rax,%rdi
  8004216c9e:	48 b8 ef 65 21 04 80 	movabs $0x80042165ef,%rax
  8004216ca5:	00 00 00 
  8004216ca8:	ff d0                	callq  *%rax
		uint32_t rv = pci_conf_read(f, bar);
  8004216caa:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004216cad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216cb1:	89 d6                	mov    %edx,%esi
  8004216cb3:	48 89 c7             	mov    %rax,%rdi
  8004216cb6:	48 b8 8e 65 21 04 80 	movabs $0x800421658e,%rax
  8004216cbd:	00 00 00 
  8004216cc0:	ff d0                	callq  *%rax
  8004216cc2:	89 45 e8             	mov    %eax,-0x18(%rbp)

		if (rv == 0)
  8004216cc5:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  8004216cc9:	0f 84 86 01 00 00    	je     8004216e55 <pci_func_enable+0x21f>
			continue;

		int regnum = PCI_MAPREG_NUM(bar);
  8004216ccf:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004216cd2:	83 e8 10             	sub    $0x10,%eax
  8004216cd5:	c1 e8 02             	shr    $0x2,%eax
  8004216cd8:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		uint32_t base, size;
		if (PCI_MAPREG_TYPE(rv) == PCI_MAPREG_TYPE_MEM) {
  8004216cdb:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004216cde:	83 e0 01             	and    $0x1,%eax
  8004216ce1:	85 c0                	test   %eax,%eax
  8004216ce3:	75 65                	jne    8004216d4a <pci_func_enable+0x114>
			if (PCI_MAPREG_MEM_TYPE(rv) == PCI_MAPREG_MEM_TYPE_64BIT)
  8004216ce5:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004216ce8:	83 e0 06             	and    $0x6,%eax
  8004216ceb:	83 f8 04             	cmp    $0x4,%eax
  8004216cee:	75 07                	jne    8004216cf7 <pci_func_enable+0xc1>
				bar_width = 8;
  8004216cf0:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%rbp)

			size = PCI_MAPREG_MEM_SIZE(rv);
  8004216cf7:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004216cfa:	83 e0 f0             	and    $0xfffffff0,%eax
  8004216cfd:	f7 d8                	neg    %eax
  8004216cff:	23 45 e8             	and    -0x18(%rbp),%eax
  8004216d02:	83 e0 f0             	and    $0xfffffff0,%eax
  8004216d05:	89 45 f0             	mov    %eax,-0x10(%rbp)
			base = PCI_MAPREG_MEM_ADDR(oldv);
  8004216d08:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216d0b:	83 e0 f0             	and    $0xfffffff0,%eax
  8004216d0e:	89 45 f4             	mov    %eax,-0xc(%rbp)
			if (pci_show_addrs)
  8004216d11:	48 b8 90 c7 63 04 80 	movabs $0x800463c790,%rax
  8004216d18:	00 00 00 
  8004216d1b:	8b 00                	mov    (%rax),%eax
  8004216d1d:	85 c0                	test   %eax,%eax
  8004216d1f:	74 7a                	je     8004216d9b <pci_func_enable+0x165>
				cprintf("  mem region %d: %d bytes at 0x%x\n",
  8004216d21:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004216d24:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004216d27:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004216d2a:	89 c6                	mov    %eax,%esi
  8004216d2c:	48 bf 38 9b 21 04 80 	movabs $0x8004219b38,%rdi
  8004216d33:	00 00 00 
  8004216d36:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216d3b:	49 b8 f2 89 20 04 80 	movabs $0x80042089f2,%r8
  8004216d42:	00 00 00 
  8004216d45:	41 ff d0             	callq  *%r8
  8004216d48:	eb 51                	jmp    8004216d9b <pci_func_enable+0x165>
					regnum, size, base);
		} else {
			size = PCI_MAPREG_IO_SIZE(rv);
  8004216d4a:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004216d4d:	83 e0 fc             	and    $0xfffffffc,%eax
  8004216d50:	f7 d8                	neg    %eax
  8004216d52:	23 45 e8             	and    -0x18(%rbp),%eax
  8004216d55:	83 e0 fc             	and    $0xfffffffc,%eax
  8004216d58:	89 45 f0             	mov    %eax,-0x10(%rbp)
			base = PCI_MAPREG_IO_ADDR(oldv);
  8004216d5b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216d5e:	83 e0 fc             	and    $0xfffffffc,%eax
  8004216d61:	89 45 f4             	mov    %eax,-0xc(%rbp)
			if (pci_show_addrs)
  8004216d64:	48 b8 90 c7 63 04 80 	movabs $0x800463c790,%rax
  8004216d6b:	00 00 00 
  8004216d6e:	8b 00                	mov    (%rax),%eax
  8004216d70:	85 c0                	test   %eax,%eax
  8004216d72:	74 27                	je     8004216d9b <pci_func_enable+0x165>
				cprintf("  io region %d: %d bytes at 0x%x\n",
  8004216d74:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004216d77:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004216d7a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004216d7d:	89 c6                	mov    %eax,%esi
  8004216d7f:	48 bf 60 9b 21 04 80 	movabs $0x8004219b60,%rdi
  8004216d86:	00 00 00 
  8004216d89:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216d8e:	49 b8 f2 89 20 04 80 	movabs $0x80042089f2,%r8
  8004216d95:	00 00 00 
  8004216d98:	41 ff d0             	callq  *%r8
					regnum, size, base);
		}

		pci_conf_write(f, bar, oldv);
  8004216d9b:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004216d9e:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  8004216da1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216da5:	89 ce                	mov    %ecx,%esi
  8004216da7:	48 89 c7             	mov    %rax,%rdi
  8004216daa:	48 b8 ef 65 21 04 80 	movabs $0x80042165ef,%rax
  8004216db1:	00 00 00 
  8004216db4:	ff d0                	callq  *%rax
		f->reg_base[regnum] = base;
  8004216db6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216dba:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004216dbd:	48 63 d2             	movslq %edx,%rdx
  8004216dc0:	48 8d 4a 04          	lea    0x4(%rdx),%rcx
  8004216dc4:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004216dc7:	89 54 88 08          	mov    %edx,0x8(%rax,%rcx,4)
		f->reg_size[regnum] = size;
  8004216dcb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216dcf:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004216dd2:	48 63 d2             	movslq %edx,%rdx
  8004216dd5:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  8004216dd9:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004216ddc:	89 14 88             	mov    %edx,(%rax,%rcx,4)

		if (size && !base)
  8004216ddf:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  8004216de3:	74 71                	je     8004216e56 <pci_func_enable+0x220>
  8004216de5:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004216de9:	75 6b                	jne    8004216e56 <pci_func_enable+0x220>
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004216deb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216def:	8b 40 10             	mov    0x10(%rax),%eax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  8004216df2:	41 89 c0             	mov    %eax,%r8d
  8004216df5:	41 c1 e8 10          	shr    $0x10,%r8d
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004216df9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216dfd:	8b 40 10             	mov    0x10(%rax),%eax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  8004216e00:	0f b7 f8             	movzwl %ax,%edi
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
  8004216e03:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  8004216e07:	8b 48 0c             	mov    0xc(%rax),%ecx
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
  8004216e0a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  8004216e0e:	8b 50 08             	mov    0x8(%rax),%edx
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
  8004216e11:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216e15:	48 8b 00             	mov    (%rax),%rax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  8004216e18:	8b 40 08             	mov    0x8(%rax),%eax
  8004216e1b:	8b 75 f0             	mov    -0x10(%rbp),%esi
  8004216e1e:	89 74 24 10          	mov    %esi,0x10(%rsp)
  8004216e22:	8b 75 f4             	mov    -0xc(%rbp),%esi
  8004216e25:	89 74 24 08          	mov    %esi,0x8(%rsp)
  8004216e29:	8b 75 e4             	mov    -0x1c(%rbp),%esi
  8004216e2c:	89 34 24             	mov    %esi,(%rsp)
  8004216e2f:	45 89 c1             	mov    %r8d,%r9d
  8004216e32:	41 89 f8             	mov    %edi,%r8d
  8004216e35:	89 c6                	mov    %eax,%esi
  8004216e37:	48 bf 88 9b 21 04 80 	movabs $0x8004219b88,%rdi
  8004216e3e:	00 00 00 
  8004216e41:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216e46:	49 ba f2 89 20 04 80 	movabs $0x80042089f2,%r10
  8004216e4d:	00 00 00 
  8004216e50:	41 ff d2             	callq  *%r10
  8004216e53:	eb 01                	jmp    8004216e56 <pci_func_enable+0x220>
		bar_width = 4;
		pci_conf_write(f, bar, 0xffffffff);
		uint32_t rv = pci_conf_read(f, bar);

		if (rv == 0)
			continue;
  8004216e55:	90                   	nop
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
	     bar += bar_width)
  8004216e56:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004216e59:	01 45 f8             	add    %eax,-0x8(%rbp)
		       PCI_COMMAND_MEM_ENABLE |
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  8004216e5c:	83 7d f8 27          	cmpl   $0x27,-0x8(%rbp)
  8004216e60:	0f 86 05 fe ff ff    	jbe    8004216c6b <pci_func_enable+0x35>
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
  8004216e66:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216e6a:	8b 40 10             	mov    0x10(%rax),%eax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004216e6d:	89 c7                	mov    %eax,%edi
  8004216e6f:	c1 ef 10             	shr    $0x10,%edi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
  8004216e72:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216e76:	8b 40 10             	mov    0x10(%rax),%eax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004216e79:	0f b7 f0             	movzwl %ax,%esi
		f->bus->busno, f->dev, f->func,
  8004216e7c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004216e80:	8b 48 0c             	mov    0xc(%rax),%ecx
		f->bus->busno, f->dev, f->func,
  8004216e83:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004216e87:	8b 50 08             	mov    0x8(%rax),%edx
		f->bus->busno, f->dev, f->func,
  8004216e8a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216e8e:	48 8b 00             	mov    (%rax),%rax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004216e91:	8b 40 08             	mov    0x8(%rax),%eax
  8004216e94:	41 89 f9             	mov    %edi,%r9d
  8004216e97:	41 89 f0             	mov    %esi,%r8d
  8004216e9a:	89 c6                	mov    %eax,%esi
  8004216e9c:	48 bf e8 9b 21 04 80 	movabs $0x8004219be8,%rdi
  8004216ea3:	00 00 00 
  8004216ea6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216eab:	49 ba f2 89 20 04 80 	movabs $0x80042089f2,%r10
  8004216eb2:	00 00 00 
  8004216eb5:	41 ff d2             	callq  *%r10
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
}
  8004216eb8:	c9                   	leaveq 
  8004216eb9:	c3                   	retq   

0000008004216eba <pci_init>:

int
pci_init(void)
{
  8004216eba:	55                   	push   %rbp
  8004216ebb:	48 89 e5             	mov    %rsp,%rbp
	static struct pci_bus root_bus;
	memset(&root_bus, 0, sizeof(root_bus));
  8004216ebe:	ba 10 00 00 00       	mov    $0x10,%edx
  8004216ec3:	be 00 00 00 00       	mov    $0x0,%esi
  8004216ec8:	48 bf a0 c7 63 04 80 	movabs $0x800463c7a0,%rdi
  8004216ecf:	00 00 00 
  8004216ed2:	48 b8 53 e6 20 04 80 	movabs $0x800420e653,%rax
  8004216ed9:	00 00 00 
  8004216edc:	ff d0                	callq  *%rax

	return pci_scan_bus(&root_bus);
  8004216ede:	48 bf a0 c7 63 04 80 	movabs $0x800463c7a0,%rdi
  8004216ee5:	00 00 00 
  8004216ee8:	48 b8 7c 68 21 04 80 	movabs $0x800421687c,%rax
  8004216eef:	00 00 00 
  8004216ef2:	ff d0                	callq  *%rax
}
  8004216ef4:	5d                   	pop    %rbp
  8004216ef5:	c3                   	retq   
	...

0000008004216ef8 <time_init>:

static unsigned int ticks;

void
time_init(void)
{
  8004216ef8:	55                   	push   %rbp
  8004216ef9:	48 89 e5             	mov    %rsp,%rbp
	ticks = 0;
  8004216efc:	48 b8 b0 c7 63 04 80 	movabs $0x800463c7b0,%rax
  8004216f03:	00 00 00 
  8004216f06:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
}
  8004216f0c:	5d                   	pop    %rbp
  8004216f0d:	c3                   	retq   

0000008004216f0e <time_tick>:

// This should be called once per timer interrupt.  A timer interrupt
// fires every 10 ms.
void
time_tick(void)
{
  8004216f0e:	55                   	push   %rbp
  8004216f0f:	48 89 e5             	mov    %rsp,%rbp
	ticks++;
  8004216f12:	48 b8 b0 c7 63 04 80 	movabs $0x800463c7b0,%rax
  8004216f19:	00 00 00 
  8004216f1c:	8b 00                	mov    (%rax),%eax
  8004216f1e:	8d 50 01             	lea    0x1(%rax),%edx
  8004216f21:	48 b8 b0 c7 63 04 80 	movabs $0x800463c7b0,%rax
  8004216f28:	00 00 00 
  8004216f2b:	89 10                	mov    %edx,(%rax)
	if (ticks * 10 < ticks)
  8004216f2d:	48 b8 b0 c7 63 04 80 	movabs $0x800463c7b0,%rax
  8004216f34:	00 00 00 
  8004216f37:	8b 10                	mov    (%rax),%edx
  8004216f39:	89 d0                	mov    %edx,%eax
  8004216f3b:	c1 e0 02             	shl    $0x2,%eax
  8004216f3e:	01 d0                	add    %edx,%eax
  8004216f40:	01 c0                	add    %eax,%eax
  8004216f42:	89 c2                	mov    %eax,%edx
  8004216f44:	48 b8 b0 c7 63 04 80 	movabs $0x800463c7b0,%rax
  8004216f4b:	00 00 00 
  8004216f4e:	8b 00                	mov    (%rax),%eax
  8004216f50:	39 c2                	cmp    %eax,%edx
  8004216f52:	73 2a                	jae    8004216f7e <time_tick+0x70>
		panic("time_tick: time overflowed");
  8004216f54:	48 ba 17 9c 21 04 80 	movabs $0x8004219c17,%rdx
  8004216f5b:	00 00 00 
  8004216f5e:	be 13 00 00 00       	mov    $0x13,%esi
  8004216f63:	48 bf 32 9c 21 04 80 	movabs $0x8004219c32,%rdi
  8004216f6a:	00 00 00 
  8004216f6d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216f72:	48 b9 f2 04 20 04 80 	movabs $0x80042004f2,%rcx
  8004216f79:	00 00 00 
  8004216f7c:	ff d1                	callq  *%rcx
}
  8004216f7e:	5d                   	pop    %rbp
  8004216f7f:	c3                   	retq   

0000008004216f80 <time_msec>:

unsigned int
time_msec(void)
{
  8004216f80:	55                   	push   %rbp
  8004216f81:	48 89 e5             	mov    %rsp,%rbp
	return ticks * 10;
  8004216f84:	48 b8 b0 c7 63 04 80 	movabs $0x800463c7b0,%rax
  8004216f8b:	00 00 00 
  8004216f8e:	8b 10                	mov    (%rax),%edx
  8004216f90:	89 d0                	mov    %edx,%eax
  8004216f92:	c1 e0 02             	shl    $0x2,%eax
  8004216f95:	01 d0                	add    %edx,%eax
  8004216f97:	01 c0                	add    %eax,%eax
}
  8004216f99:	5d                   	pop    %rbp
  8004216f9a:	c3                   	retq   
